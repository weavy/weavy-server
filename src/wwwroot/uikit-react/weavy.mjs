"use client";
var KD = Object.defineProperty;
var c = (n, t) => KD(n, "name", { value: t, configurable: !0 });
import N, { createContext as JD, useState as b3, useMemo as $3, useEffect as Zx, useRef as tW } from "react";
var eW = Object.defineProperty, m = /* @__PURE__ */ c((n, t) => eW(n, "name", { value: t, configurable: !0 }), "c$1");
const uS = /* @__PURE__ */ m((n) => {
  n && requestAnimationFrame(() => n?.focus?.());
}, "autofocusRef");
async function gr(n, t = "wy-") {
  const e = [];
  for (let i = n; i = i.parentElement; )
    i.matches(":not(:defined)") && i.localName.startsWith(t) && e.push(customElements.whenDefined(i.localName));
  await Promise.all(e);
}
c(gr, "nx$1");
m(gr, "whenParentsDefined");
const L9 = /* @__PURE__ */ m((n, t) => {
  let e;
  const i = new ResizeObserver(() => {
    const { isConnected: r } = n;
    r !== e && (e = r, t(r, n));
  });
  return i.observe(n), i;
}, "observeConnected");
async function pS(n, t = !0) {
  if (n.isConnected === t)
    return t;
  {
    let e;
    const i = new Promise((s) => e = s), r = L9(n, (s) => {
      s === t && e?.(t);
    });
    return await i, r.disconnect(), t;
  }
}
c(pS, "sx$1");
m(pS, "whenConnected");
async function I9() {
  we(), document.hidden && await new Promise((n) => {
    window.addEventListener(
      "visibilitychange",
      () => {
        document.hidden || n(!0);
      },
      { once: !0 }
    );
  });
}
c(I9, "ox$1");
m(I9, "whenDocumentVisible");
const fS = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  /* @ts-ignore */
  opacityProperty: !0,
  visibilityProperty: !0,
  // Legacy compatibility
  checkOpacity: !0,
  checkVisibilityCSS: !0
};
function mS(n, t = !0, e = fS, i) {
  n.checkVisibility(e) === t ? i(t) : requestAnimationFrame(() => mS(n, t, e, i));
}
c(mS, "XO");
m(mS, "untilVisibility");
async function Gv(n, t = !0, e = fS) {
  n.checkVisibility(e) !== t && await new Promise((i) => {
    mS(n, t, e, i);
  });
}
c(Gv, "lx$1");
m(Gv, "whenElementVisible");
function Gw(n) {
  return n.ctrlKey || n.metaKey || n.button === 1;
}
c(Gw, "ax$1");
m(Gw, "isModifiedClick");
function Xx(n) {
  return n.getRootNode() instanceof ShadowRoot;
}
c(Xx, "hx$1");
m(Xx, "isInShadowDom");
function Kv() {
  return !!(document.body?.showPopover && !/native code/i.test(document.body.showPopover.toString()));
}
c(Kv, "fx$1");
m(Kv, "isPopoverPolyfilled");
function g0() {
  return typeof window < "u";
}
c(g0, "cx$1");
m(g0, "isDomAvailable");
function we() {
  if (typeof window > "u")
    throw Error("DOM not available");
}
c(we, "eh$1");
m(we, "throwOnDomNotAvailable");
function V9(n, t) {
  if (we(), n) {
    for (let e = n; e = e.parentElement || e.parentNode || e.host; )
      if (e instanceof Element && t(e))
        return e;
  }
}
c(V9, "xg$1");
m(V9, "getParent");
function D9(n) {
  return V9(n, (t) => {
    const e = getComputedStyle(t);
    return !!(t instanceof HTMLElement && (t.localName === "wy-overlay" || t.popover || e.position === "fixed" || // @ts-expect-error overlay not in CSSStyleDeclaration
    e.overlay === "auto"));
  });
}
c(D9, "ux$1");
m(D9, "inOverlay");
let Nx = [], W9 = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, e = 0; t < n.length; t++)
    (t % 2 ? W9 : Nx).push(e = e + n[t]);
})();
function q9(n) {
  if (n < 768) return !1;
  for (let t = 0, e = Nx.length; ; ) {
    let i = t + e >> 1;
    if (n < Nx[i]) e = i;
    else if (n >= W9[i]) t = i + 1;
    else return !0;
    if (t == e) return !1;
  }
}
c(q9, "Pg$1");
m(q9, "isExtendingChar");
function jx(n) {
  return n >= 127462 && n <= 127487;
}
c(jx, "Lc$1");
m(jx, "isRegionalIndicator");
const x3 = 8205;
function F9(n, t, e = !0, i = !0) {
  return (e ? yS : Z9)(n, t, i);
}
c(F9, "kg$1");
m(F9, "findClusterBreak$1");
function yS(n, t, e) {
  if (t == n.length) return t;
  t && gS(n.charCodeAt(t)) && wS(n.charCodeAt(t - 1)) && t--;
  let i = sv(n, t);
  for (t += Bx(i); t < n.length; ) {
    let r = sv(n, t);
    if (i == x3 || r == x3 || e && q9(r))
      t += Bx(r), i = r;
    else if (jx(r)) {
      let s = 0, a = t - 2;
      for (; a >= 0 && jx(sv(n, a)); )
        s++, a -= 2;
      if (s % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
c(yS, "YO");
m(yS, "nextClusterBreak");
function Z9(n, t, e) {
  for (; t > 0; ) {
    let i = yS(n, t - 2, e);
    if (i < t) return i;
    t--;
  }
  return 0;
}
c(Z9, "$g$1");
m(Z9, "prevClusterBreak");
function sv(n, t) {
  let e = n.charCodeAt(t);
  if (!wS(e) || t + 1 == n.length) return e;
  let i = n.charCodeAt(t + 1);
  return gS(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
c(sv, "$o$1");
m(sv, "codePointAt$1");
function gS(n) {
  return n >= 56320 && n < 57344;
}
c(gS, "VO");
m(gS, "surrogateLow$1");
function wS(n) {
  return n >= 55296 && n < 56320;
}
c(wS, "WO");
m(wS, "surrogateHigh$1");
function Bx(n) {
  return n < 65536 ? 1 : 2;
}
c(Bx, "Mc$1");
m(Bx, "codePointSize$1");
var fo;
const X9 = (fo = class {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, e, i) {
    [t, e] = Go(this, t, e);
    let r = [];
    return this.decompose(
      0,
      t,
      r,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      e,
      this.length,
      r,
      1
      /* Open.From */
    ), av.from(r, this.length - (e - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, e = this.length) {
    [t, e] = Go(this, t, e);
    let i = [];
    return this.decompose(t, e, i, 0), av.from(i, e - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), r = new Ug(this), s = new Ug(t);
    for (let a = e, o = e; ; ) {
      if (r.next(a), s.next(a), a = 0, r.lineBreak != s.lineBreak || r.done != s.done || r.value != s.value)
        return !1;
      if (o += r.value.length, r.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new Ug(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, e = this.length) {
    return new Y9(this, t, e);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let r = this.line(t).from;
      i = this.iterRange(r, Math.max(r, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new K9(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? fo.empty : t.length <= 32 ? new xn(t) : av.from(xn.split(t, []));
  }
}, c(fo, "Ws"), fo);
m(X9, "Text");
let Dt = X9;
var yi;
const N9 = (yi = class extends Dt {
  constructor(t, e = B9(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, r) {
    for (let s = 0; ; s++) {
      let a = this.text[s], o = r + a.length;
      if ((e ? i : o) >= t)
        return new iW(r, o, i, a);
      r = o + 1, i++;
    }
  }
  decompose(t, e, i, r) {
    let s = t <= 0 && e >= this.length ? this : new yi(Ux(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (r & 1) {
      let a = i.pop(), o = Bg(s.text, a.text.slice(), 0, s.length);
      if (o.length <= 32)
        i.push(new yi(o, a.length + s.length));
      else {
        let l = o.length >> 1;
        i.push(new yi(o.slice(0, l)), new yi(o.slice(l)));
      }
    } else
      i.push(s);
  }
  replace(t, e, i) {
    if (!(i instanceof yi))
      return super.replace(t, e, i);
    [t, e] = Go(this, t, e);
    let r = Bg(this.text, Bg(i.text, Ux(this.text, 0, t)), e), s = this.length + i.length - (e - t);
    return r.length <= 32 ? new yi(r, s) : av.from(yi.split(r, []), s);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Go(this, t, e);
    let r = "";
    for (let s = 0, a = 0; s <= e && a < this.text.length; a++) {
      let o = this.text[a], l = s + o.length;
      s > t && a && (r += i), t < l && e > s && (r += o.slice(Math.max(0, t - s), e - s)), s = l + 1;
    }
    return r;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], r = -1;
    for (let s of t)
      i.push(s), r += s.length + 1, i.length == 32 && (e.push(new yi(i, r)), i = [], r = -1);
    return r > -1 && e.push(new yi(i, r)), e;
  }
}, c(yi, "Le"), yi);
m(N9, "TextLeaf");
let xn = N9;
var bn;
const j9 = (bn = class extends Dt {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, r) {
    for (let s = 0; ; s++) {
      let a = this.children[s], o = r + a.length, l = i + a.lines - 1;
      if ((e ? l : o) >= t)
        return a.lineInner(t, e, i, r);
      r = o + 1, i = l + 1;
    }
  }
  decompose(t, e, i, r) {
    for (let s = 0, a = 0; a <= e && s < this.children.length; s++) {
      let o = this.children[s], l = a + o.length;
      if (t <= l && e >= a) {
        let d = r & ((a <= t ? 1 : 0) | (l >= e ? 2 : 0));
        a >= t && l <= e && !d ? i.push(o) : o.decompose(t - a, e - a, i, d);
      }
      a = l + 1;
    }
  }
  replace(t, e, i) {
    if ([t, e] = Go(this, t, e), i.lines < this.lines)
      for (let r = 0, s = 0; r < this.children.length; r++) {
        let a = this.children[r], o = s + a.length;
        if (t >= s && e <= o) {
          let l = a.replace(t - s, e - s, i), d = this.lines - a.lines + l.lines;
          if (l.lines < d >> 4 && l.lines > d >> 6) {
            let u = this.children.slice();
            return u[r] = l, new bn(u, this.length - (e - t) + i.length);
          }
          return super.replace(s, o, l);
        }
        s = o + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Go(this, t, e);
    let r = "";
    for (let s = 0, a = 0; s < this.children.length && a <= e; s++) {
      let o = this.children[s], l = a + o.length;
      a > t && s && (r += i), t < l && e > a && (r += o.sliceString(t - a, e - a, i)), a = l + 1;
    }
    return r;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof bn))
      return 0;
    let i = 0, [r, s, a, o] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; r += e, s += e) {
      if (r == a || s == o)
        return i;
      let l = this.children[r], d = t.children[s];
      if (l != d)
        return i + l.scanIdentical(d, e);
      i += l.length + 1;
    }
  }
  static from(t, e = t.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let y of t)
      i += y.lines;
    if (i < 32) {
      let y = [];
      for (let g of t)
        g.flatten(y);
      return new xn(y, e);
    }
    let r = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), s = r << 1, a = r >> 1, o = [], l = 0, d = -1, u = [];
    function p(y) {
      let g;
      if (y.lines > s && y instanceof bn)
        for (let b of y.children)
          p(b);
      else y.lines > a && (l > a || !l) ? (f(), o.push(y)) : y instanceof xn && l && (g = u[u.length - 1]) instanceof xn && y.lines + g.lines <= 32 ? (l += y.lines, d += y.length + 1, u[u.length - 1] = new xn(g.text.concat(y.text), g.length + 1 + y.length)) : (l + y.lines > r && f(), l += y.lines, d += y.length + 1, u.push(y));
    }
    c(p, "u"), m(p, "add");
    function f() {
      l != 0 && (o.push(u.length == 1 ? u[0] : bn.from(u, d)), d = -1, l = u.length = 0);
    }
    c(f, "O"), m(f, "flush");
    for (let y of t)
      p(y);
    return f(), o.length == 1 ? o[0] : new bn(o, e);
  }
}, c(bn, "Qt"), bn);
m(j9, "TextNode");
let av = j9;
Dt.empty = /* @__PURE__ */ new xn([""], 0);
function B9(n) {
  let t = -1;
  for (let e of n)
    t += e.length + 1;
  return t;
}
c(B9, "Rg$1");
m(B9, "textLength");
function Bg(n, t, e = 0, i = 1e9) {
  for (let r = 0, s = 0, a = !0; s < n.length && r <= i; s++) {
    let o = n[s], l = r + o.length;
    l >= e && (l > i && (o = o.slice(0, i - r)), r < e && (o = o.slice(e - r)), a ? (t[t.length - 1] += o, a = !1) : t.push(o)), r = l + 1;
  }
  return t;
}
c(Bg, "Gn$1");
m(Bg, "appendText");
function Ux(n, t, e) {
  return Bg(n, [""], t, e);
}
c(Ux, "Zc");
m(Ux, "sliceText");
var gh;
const U9 = (gh = class {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof xn ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], s = this.offsets[i], a = s >> 1, o = r instanceof xn ? r.text.length : r.children.length;
      if (a == (e > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (r instanceof xn) {
        let l = r.text[a + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : e > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = r.children[a + (e < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(e > 0 ? 1 : (l instanceof xn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}, c(gh, "Eh"), gh);
m(U9, "RawTextCursor");
let Ug = U9;
var wh;
const H9 = (wh = class {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new Ug(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: r } = this.cursor.next(t);
    return this.pos += (r.length + t) * e, this.value = r.length <= i ? r : e < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}, c(wh, "Yh"), wh);
m(H9, "PartialTextCursor");
let Y9 = H9;
var vh;
const G9 = (vh = class {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: r } = this.inner.next(t);
    return e && this.afterBreak ? (this.value = "", this.afterBreak = !1) : e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}, c(vh, "Vh"), vh);
m(G9, "LineCursor");
let K9 = G9;
typeof Symbol < "u" && (Dt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ug.prototype[Symbol.iterator] = Y9.prototype[Symbol.iterator] = K9.prototype[Symbol.iterator] = function() {
  return this;
});
var _b, Oh;
let iW = (_b = (Oh = class {
  /**
  @internal
  */
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.number = i, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}, c(Oh, "Ti$1"), Oh), m(_b, "Line"), _b);
function Go(n, t, e) {
  return t = Math.max(0, Math.min(n.length, t)), [t, Math.max(t, Math.min(n.length, e))];
}
c(Go, "Ei");
m(Go, "clip");
function kn(n, t, e = !0, i = !0) {
  return F9(n, t, e, i);
}
c(kn, "me$2");
m(kn, "findClusterBreak");
function J9(n) {
  return n >= 56320 && n < 57344;
}
c(J9, "Tg$1");
m(J9, "surrogateLow");
function t8(n) {
  return n >= 55296 && n < 56320;
}
c(t8, "Ag$1");
m(t8, "surrogateHigh");
function bs(n, t) {
  let e = n.charCodeAt(t);
  if (!t8(e) || t + 1 == n.length)
    return e;
  let i = n.charCodeAt(t + 1);
  return J9(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
c(bs, "Vt$2");
m(bs, "codePointAt");
function e8(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
c(e8, "Lg$1");
m(e8, "fromCodePoint");
function Ja(n) {
  return n < 65536 ? 1 : 2;
}
c(Ja, "Oi$1");
m(Ja, "codePointSize");
const Hx = /\r\n?|\n/;
var vi = /* @__PURE__ */ (function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
})(vi || (vi = {})), Vr;
const i8 = (Vr = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let e = 0, i = 0, r = 0; e < this.sections.length; ) {
      let s = this.sections[e++], a = this.sections[e++];
      a < 0 ? (t(i, r, s), r += s) : r += a, i += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, e = !1) {
    Jv(this, t, e);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], r = this.sections[e++];
      r < 0 ? t.push(i, r) : t.push(r, i);
    }
    return new Vr(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : vS(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, e = !1) {
    return t.empty ? this : tO(this, t, e);
  }
  mapPos(t, e = -1, i = vi.Simple) {
    let r = 0, s = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], l = this.sections[a++], d = r + o;
      if (l < 0) {
        if (d > t)
          return s + (t - r);
        s += o;
      } else {
        if (i != vi.Simple && d >= t && (i == vi.TrackDel && r < t && d > t || i == vi.TrackBefore && r < t || i == vi.TrackAfter && d > t))
          return null;
        if (d > t || d == t && e < 0 && !o)
          return t == r || e < 0 ? s : s + l;
        s += l;
      }
      r = d;
    }
    if (t > r)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${r}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, e = t) {
    for (let i = 0, r = 0; i < this.sections.length && r <= e; ) {
      let s = this.sections[i++], a = this.sections[i++], o = r + s;
      if (a >= 0 && r <= e && o >= t)
        return r < t && o > e ? "cover" : !0;
      r = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], r = this.sections[e++];
      t += (t ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Vr(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new Vr(t);
  }
}, c(Vr, "Qi"), Vr);
m(i8, "ChangeDesc");
let ah = i8;
var ji;
const n8 = (ji = class extends ah {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Jv(this, (e, i, r, s, a) => t = t.replace(r, r + (i - e), a), !1), t;
  }
  mapDesc(t, e = !1) {
    return tO(this, t, e, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let r = 0, s = 0; r < e.length; r += 2) {
      let a = e[r], o = e[r + 1];
      if (o >= 0) {
        e[r] = o, e[r + 1] = a;
        let l = r >> 1;
        for (; i.length < l; )
          i.push(Dt.empty);
        i.push(a ? t.slice(s, s + a) : Dt.empty);
      }
      s += a;
    }
    return new ji(e, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : vS(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, e = !1) {
    return t.empty ? this : tO(this, t, e, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, e = !1) {
    Jv(this, t, e);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ah.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let e = [], i = [], r = [], s = new sw(this);
    t: for (let a = 0, o = 0; ; ) {
      let l = a == t.length ? 1e9 : t[a++];
      for (; o < l || o == l && s.len == 0; ) {
        if (s.done)
          break t;
        let u = Math.min(s.len, l - o);
        Je(r, u, -1);
        let p = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        Je(e, u, p), p > 0 && Er(i, e, s.text), s.forward(u), o += u;
      }
      let d = t[a++];
      for (; o < d; ) {
        if (s.done)
          break t;
        let u = Math.min(s.len, d - o);
        Je(e, u, -1), Je(r, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), o += u;
      }
    }
    return {
      changes: new ji(e, i),
      filtered: ah.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], r = this.sections[e + 1];
      r < 0 ? t.push(i) : r == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, e, i) {
    let r = [], s = [], a = 0, o = null;
    function l(u = !1) {
      if (!u && !r.length)
        return;
      a < e && Je(r, e - a, -1);
      let p = new ji(r, s);
      o = o ? o.compose(p.map(o)) : p, r = [], s = [], a = 0;
    }
    c(l, "a"), m(l, "flush");
    function d(u) {
      if (Array.isArray(u))
        for (let p of u)
          d(p);
      else if (u instanceof ji) {
        if (u.length != e)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${e})`);
        l(), o = o ? o.compose(u.map(o)) : u;
      } else {
        let { from: p, to: f = p, insert: y } = u;
        if (p > f || p < 0 || f > e)
          throw new RangeError(`Invalid change range ${p} to ${f} (in doc of length ${e})`);
        let g = y ? typeof y == "string" ? Dt.of(y.split(i || Hx)) : y : Dt.empty, b = g.length;
        if (p == f && b == 0)
          return;
        p < a && l(), p > a && Je(r, p - a, -1), Je(r, f - p, b), Er(s, r, g), a = f;
      }
    }
    return c(d, "h"), m(d, "process"), d(t), l(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new ji(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let r = 0; r < t.length; r++) {
      let s = t[r];
      if (typeof s == "number")
        e.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          e.push(s[0], 0);
        else {
          for (; i.length < r; )
            i.push(Dt.empty);
          i[r] = Dt.of(s.slice(1)), e.push(s[0], i[r].length);
        }
      }
    }
    return new ji(e, i);
  }
  /**
  @internal
  */
  static createSet(t, e) {
    return new ji(t, e);
  }
}, c(ji, "Ke"), ji);
m(n8, "ChangeSet");
let Tn = n8;
function Je(n, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let r = n.length - 2;
  r >= 0 && e <= 0 && e == n[r + 1] ? n[r] += t : r >= 0 && t == 0 && n[r] == 0 ? n[r + 1] += e : i ? (n[r] += t, n[r + 1] += e) : n.push(t, e);
}
c(Je, "ae$2");
m(Je, "addSection");
function Er(n, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(e);
  else {
    for (; n.length < i; )
      n.push(Dt.empty);
    n.push(e);
  }
}
c(Er, "St$1");
m(Er, "addInsert");
function Jv(n, t, e) {
  let i = n.inserted;
  for (let r = 0, s = 0, a = 0; a < n.sections.length; ) {
    let o = n.sections[a++], l = n.sections[a++];
    if (l < 0)
      r += o, s += o;
    else {
      let d = r, u = s, p = Dt.empty;
      for (; d += o, u += l, l && i && (p = p.append(i[a - 2 >> 1])), !(e || a == n.sections.length || n.sections[a + 1] < 0); )
        o = n.sections[a++], l = n.sections[a++];
      t(r, d, s, u, p), r = d, s = u;
    }
  }
}
c(Jv, "sl$1");
m(Jv, "iterChanges");
function tO(n, t, e, i = !1) {
  let r = [], s = i ? [] : null, a = new sw(n), o = new sw(t);
  for (let l = -1; ; ) {
    if (a.done && o.len || o.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && o.ins == -1) {
      let d = Math.min(a.len, o.len);
      Je(r, d, -1), a.forward(d), o.forward(d);
    } else if (o.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !e))) {
      let d = o.len;
      for (Je(r, o.ins, -1); d; ) {
        let u = Math.min(a.len, d);
        a.ins >= 0 && l < a.i && a.len <= u && (Je(r, 0, a.ins), s && Er(s, r, a.text), l = a.i), a.forward(u), d -= u;
      }
      o.next();
    } else if (a.ins >= 0) {
      let d = 0, u = a.len;
      for (; u; )
        if (o.ins == -1) {
          let p = Math.min(u, o.len);
          d += p, u -= p, o.forward(p);
        } else if (o.ins == 0 && o.len < u)
          u -= o.len, o.next();
        else
          break;
      Je(r, d, l < a.i ? a.ins : 0), s && l < a.i && Er(s, r, a.text), l = a.i, a.forward(a.len - u);
    } else {
      if (a.done && o.done)
        return s ? Tn.createSet(r, s) : ah.create(r);
      throw new Error("Mismatched change set lengths");
    }
  }
}
c(tO, "ol$1");
m(tO, "mapSet");
function vS(n, t, e = !1) {
  let i = [], r = e ? [] : null, s = new sw(n), a = new sw(t);
  for (let o = !1; ; ) {
    if (s.done && a.done)
      return r ? Tn.createSet(i, r) : ah.create(i);
    if (s.ins == 0)
      Je(i, s.len, 0, o), s.next();
    else if (a.len == 0 && !a.done)
      Je(i, 0, a.ins, o), r && Er(r, i, a.text), a.next();
    else {
      if (s.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, a.len), d = i.length;
        if (s.ins == -1) {
          let u = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Je(i, l, u, o), r && u && Er(r, i, a.text);
        } else a.ins == -1 ? (Je(i, s.off ? 0 : s.len, l, o), r && Er(r, i, s.textBit(l))) : (Je(i, s.off ? 0 : s.len, a.off ? 0 : a.ins, o), r && !a.off && Er(r, i, a.text));
        o = (s.ins > l || a.ins >= 0 && a.len > l) && (o || i.length > d), s.forward2(l), a.forward(l);
      }
    }
  }
}
c(vS, "UO");
m(vS, "composeSets");
var bh;
const r8 = (bh = class {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? Dt.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? Dt.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}, c(bh, "Wh"), bh);
m(r8, "SectionIter");
let sw = r8;
var Is;
const s8 = (Is = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, e = -1) {
    let i, r;
    return this.empty ? i = r = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), r = t.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new Is(i, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return it.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return it.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, e = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!e || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return it.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Is(t, e, i);
  }
}, c(Is, "$r"), Is);
m(s8, "SelectionRange");
let R1 = s8;
var Fe;
const a8 = (Fe = class {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, e = -1) {
    return t.empty ? this : Fe.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, e = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], e))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Fe([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, e = !0) {
    return Fe.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, Fe.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Fe(t.ranges.map((e) => R1.fromJSON(e)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, e = t) {
    return new Fe([Fe.range(t, e)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < t.length; r++) {
      let s = t[r];
      if (s.empty ? s.from <= i : s.from < i)
        return Fe.normalized(t.slice(), e);
      i = s.to;
    }
    return new Fe(t, e);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, e = 0, i, r) {
    return R1.create(t, t, (e == 0 ? 0 : e < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, e, i, r) {
    let s = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return e < t ? R1.create(e, t, 48 | s) : R1.create(t, e, (e > t ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((r, s) => r.from - s.from), e = t.indexOf(i);
    for (let r = 1; r < t.length; r++) {
      let s = t[r], a = t[r - 1];
      if (s.empty ? s.from <= a.to : s.from < a.to) {
        let o = a.from, l = Math.max(s.to, a.to);
        r <= e && e--, t.splice(--r, 2, s.anchor > s.head ? Fe.range(l, o) : Fe.range(o, l));
      }
    }
    return new Fe(t, e);
  }
}, c(Fe, "fe"), Fe);
m(a8, "EditorSelection");
let it = a8;
function OS(n, t) {
  for (let e of n.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
c(OS, "IO");
m(OS, "checkSelection");
let bS = 0;
var mo;
const o8 = (mo = class {
  constructor(t, e, i, r, s) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = r, this.id = bS++, this.default = t([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new mo(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : w0), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new ov([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new ov(t, this, 1, e);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new ov(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = /* @__PURE__ */ m((i) => i, "get")), this.compute([t], (i) => e(i.field(t)));
  }
}, c(mo, "Us"), mo);
m(o8, "Facet");
let $t = o8;
function w0(n, t) {
  return n == t || n.length == t.length && n.every((e, i) => e === t[i]);
}
c(w0, "ih$1");
m(w0, "sameArray$1");
var $h;
const l8 = ($h = class {
  constructor(t, e, i, r) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = r, this.id = bS++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, r = this.facet.compareInput, s = this.id, a = t[s] >> 1, o = this.type == 2, l = !1, d = !1, u = [];
    for (let p of this.dependencies)
      p == "doc" ? l = !0 : p == "selection" ? d = !0 : (((e = t[p.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && u.push(t[p.id]);
    return {
      create(p) {
        return p.values[a] = i(p), 1;
      },
      update(p, f) {
        if (l && f.docChanged || d && (f.docChanged || f.selection) || eO(p, u)) {
          let y = i(p);
          if (o ? !Yx(y, p.values[a], r) : !r(y, p.values[a]))
            return p.values[a] = y, 1;
        }
        return 0;
      },
      reconfigure: /* @__PURE__ */ m((p, f) => {
        let y, g = f.config.address[s];
        if (g != null) {
          let b = aw(f, g);
          if (this.dependencies.every((S) => S instanceof $t ? f.facet(S) === p.facet(S) : S instanceof ss ? f.field(S, !1) == p.field(S, !1) : !0) || (o ? Yx(y = i(p), b, r) : r(y = i(p), b)))
            return p.values[a] = b, 0;
        } else
          y = i(p);
        return p.values[a] = y, 1;
      }, "reconfigure")
    };
  }
}, c($h, "Uh"), $h);
m(l8, "FacetProvider");
let ov = l8;
function Yx(n, t, e) {
  if (n.length != t.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!e(n[i], t[i]))
      return !1;
  return !0;
}
c(Yx, "Cc$1");
m(Yx, "compareArray");
function eO(n, t) {
  let e = !1;
  for (let i of t)
    oh(n, i) & 1 && (e = !0);
  return e;
}
c(eO, "ll$1");
m(eO, "ensureAll");
function c8(n, t, e) {
  let i = e.map((l) => n[l.id]), r = e.map((l) => l.type), s = i.filter((l) => !(l & 1)), a = n[t.id] >> 1;
  function o(l) {
    let d = [];
    for (let u = 0; u < i.length; u++) {
      let p = aw(l, i[u]);
      if (r[u] == 2)
        for (let f of p)
          d.push(f);
      else
        d.push(p);
    }
    return t.combine(d);
  }
  return c(o, "l"), m(o, "get"), {
    create(l) {
      for (let d of i)
        oh(l, d);
      return l.values[a] = o(l), 1;
    },
    update(l, d) {
      if (!eO(l, s))
        return 0;
      let u = o(l);
      return t.compare(u, l.values[a]) ? 0 : (l.values[a] = u, 1);
    },
    reconfigure(l, d) {
      let u = eO(l, i), p = d.config.facets[t.id], f = d.facet(t);
      if (p && !u && w0(e, p))
        return l.values[a] = f, 0;
      let y = o(l);
      return t.compare(y, f) ? (l.values[a] = f, 0) : (l.values[a] = y, 1);
    }
  };
}
c(c8, "_g$1");
m(c8, "dynamicFacetSlot");
const E1 = /* @__PURE__ */ $t.define({ static: !0 });
var yo;
const h8 = (yo = class {
  constructor(t, e, i, r, s) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = r, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let e = new yo(bS++, t.create, t.update, t.compare || ((i, r) => i === r), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    return (t.facet(E1).find((i) => i.field == this)?.create || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: /* @__PURE__ */ m((i) => (i.values[e] = this.create(i), 1), "create"),
      update: /* @__PURE__ */ m((i, r) => {
        let s = i.values[e], a = this.updateF(s, r);
        return this.compareF(s, a) ? 0 : (i.values[e] = a, 1);
      }, "update"),
      reconfigure: /* @__PURE__ */ m((i, r) => {
        let s = i.facet(E1), a = r.facet(E1), o;
        return (o = s.find((l) => l.field == this)) && o != a.find((l) => l.field == this) ? (i.values[e] = o.create(i), 1) : r.config.address[this.id] != null ? (i.values[e] = r.field(this), 0) : (i.values[e] = this.create(i), 1);
      }, "reconfigure")
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, E1.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}, c(yo, "Is"), yo);
m(h8, "StateField");
let ss = h8;
const to = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Lc(n) {
  return (t) => new u8(t, n);
}
c(Lc, "rr$1");
m(Lc, "prec");
const Cl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Lc(to.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Lc(to.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Lc(to.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Lc(to.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Lc(to.lowest)
};
var xh;
const d8 = (xh = class {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}, c(xh, "Ih"), xh);
m(d8, "PrecExtension");
let u8 = d8;
var go;
const p8 = (go = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new Gx(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return go.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}, c(go, "zs"), go);
m(p8, "Compartment");
let f8 = p8;
var kh;
const m8 = (kh = class {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}, c(kh, "zh"), kh);
m(m8, "CompartmentInstance");
let Gx = m8;
var wo;
const y8 = (wo = class {
  constructor(t, e, i, r, s, a) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = r, this.staticValues = s, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let r = [], s = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let f of g8(t, e, a))
      f instanceof ss ? r.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let o = /* @__PURE__ */ Object.create(null), l = [], d = [];
    for (let f of r)
      o[f.id] = d.length << 1, d.push((y) => f.slot(y));
    let u = i?.config.facets;
    for (let f in s) {
      let y = s[f], g = y[0].facet, b = u && u[f] || [];
      if (y.every(
        (S) => S.type == 0
        /* Provider.Static */
      ))
        if (o[g.id] = l.length << 1 | 1, w0(b, y))
          l.push(i.facet(g));
        else {
          let S = g.combine(y.map(($) => $.value));
          l.push(i && g.compare(S, i.facet(g)) ? i.facet(g) : S);
        }
      else {
        for (let S of y)
          S.type == 0 ? (o[S.id] = l.length << 1 | 1, l.push(S.value)) : (o[S.id] = d.length << 1, d.push(($) => S.dynamicSlot($)));
        o[g.id] = d.length << 1, d.push((S) => c8(S, g, y));
      }
    }
    let p = d.map((f) => f(o));
    return new wo(t, a, p, o, l, s);
  }
}, c(wo, "js"), wo);
m(y8, "Configuration");
let k3 = y8;
function g8(n, t, e) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function s(a, o) {
    let l = r.get(a);
    if (l != null) {
      if (l <= o)
        return;
      let d = i[l].indexOf(a);
      d > -1 && i[l].splice(d, 1), a instanceof Gx && e.delete(a.compartment);
    }
    if (r.set(a, o), Array.isArray(a))
      for (let d of a)
        s(d, o);
    else if (a instanceof Gx) {
      if (e.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let d = t.get(a.compartment) || a.inner;
      e.set(a.compartment, d), s(d, o);
    } else if (a instanceof u8)
      s(a.inner, a.prec);
    else if (a instanceof ss)
      i[o].push(a), a.provides && s(a.provides, o);
    else if (a instanceof ov)
      i[o].push(a), a.facet.extensions && s(a.facet.extensions, to.default);
    else {
      let d = a.extension;
      if (!d)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(d, o);
    }
  }
  return c(s, "s"), m(s, "inner"), s(n, to.default), i.reduce((a, o) => a.concat(o));
}
c(g8, "Mg$1");
m(g8, "flatten");
function oh(n, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = n.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[e] = 4;
  let r = n.computeSlot(n, n.config.dynamicSlots[e]);
  return n.status[e] = 2 | r;
}
c(oh, "pr$1");
m(oh, "ensureAddr");
function aw(n, t) {
  return t & 1 ? n.config.staticValues[t >> 1] : n.values[t >> 1];
}
c(aw, "os$2");
m(aw, "getAddr");
const w8 = /* @__PURE__ */ $t.define(), Kx = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => n.some((t) => t), "combine"),
  static: !0
}), v8 = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => n.length ? n[0] : void 0, "combine"),
  static: !0
}), O8 = /* @__PURE__ */ $t.define(), b8 = /* @__PURE__ */ $t.define(), $8 = /* @__PURE__ */ $t.define(), x8 = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => n.length ? n[0] : !1, "combine")
});
var Sh;
const k8 = (Sh = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new nW();
  }
}, c(Sh, "jh"), Sh);
m(k8, "Annotation");
let as = k8;
var Ch;
const S8 = (Ch = class {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new as(this, t);
  }
}, c(Ch, "qh"), Ch);
m(S8, "AnnotationType");
let nW = S8;
var Ph;
const C8 = (Ph = class {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new jt(this, t);
  }
}, c(Ph, "Dh"), Ph);
m(C8, "StateEffectType");
let rW = C8;
var vo;
const P8 = (vo = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new vo(this.type, e);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new rW(t.map || ((e) => e));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let r of t) {
      let s = r.map(e);
      s && i.push(s);
    }
    return i;
  }
}, c(vo, "qs"), vo);
m(P8, "StateEffect");
let jt = P8;
jt.reconfigure = /* @__PURE__ */ jt.define();
jt.appendConfig = /* @__PURE__ */ jt.define();
var Hn;
const Q8 = (Hn = class {
  constructor(t, e, i, r, s, a) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = r, this.annotations = s, this.scrollIntoView = a, this._doc = null, this._state = null, i && OS(i, e.newLength), s.some((o) => o.type == Hn.time) || (this.annotations = s.concat(Hn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, e, i, r, s, a) {
    return new Hn(t, e, i, r, s, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let e = this.annotation(Hn.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}, c(Hn, "jt"), Hn);
m(Q8, "Transaction");
let Oi = Q8;
Oi.time = /* @__PURE__ */ as.define();
Oi.userEvent = /* @__PURE__ */ as.define();
Oi.addToHistory = /* @__PURE__ */ as.define();
Oi.remote = /* @__PURE__ */ as.define();
function T8(n, t) {
  let e = [];
  for (let i = 0, r = 0; ; ) {
    let s, a;
    if (i < n.length && (r == t.length || t[r] >= n[i]))
      s = n[i++], a = n[i++];
    else if (r < t.length)
      s = t[r++], a = t[r++];
    else
      return e;
    !e.length || e[e.length - 1] < s ? e.push(s, a) : e[e.length - 1] < a && (e[e.length - 1] = a);
  }
}
c(T8, "Zg$1");
m(T8, "joinRanges");
function $S(n, t, e) {
  var i;
  let r, s, a;
  return e ? (r = t.changes, s = Tn.empty(t.changes.length), a = n.changes.compose(t.changes)) : (r = t.changes.map(n.changes), s = n.changes.mapDesc(t.changes, !0), a = n.changes.compose(r)), {
    changes: a,
    selection: t.selection ? t.selection.map(s) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: jt.mapEffects(n.effects, r).concat(jt.mapEffects(t.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: n.scrollIntoView || t.scrollIntoView
  };
}
c($S, "GO");
m($S, "mergeTransaction");
function iO(n, t, e) {
  let i = t.selection, r = so(t.annotations);
  return t.userEvent && (r = r.concat(Oi.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Tn ? t.changes : Tn.of(t.changes || [], e, n.facet(v8)),
    selection: i && (i instanceof it ? i : it.single(i.anchor, i.head)),
    effects: so(t.effects),
    annotations: r,
    scrollIntoView: !!t.scrollIntoView
  };
}
c(iO, "cl$1");
m(iO, "resolveTransactionInner");
function xS(n, t, e) {
  let i = iO(n, t.length ? t[0] : {}, n.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let s = 1; s < t.length; s++) {
    t[s].filter === !1 && (e = !1);
    let a = !!t[s].sequential;
    i = $S(i, iO(n, t[s], a ? i.changes.newLength : n.doc.length), a);
  }
  let r = Oi.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return A8(e ? M8(r) : r);
}
c(xS, "FO");
m(xS, "resolveTransaction");
function M8(n) {
  let t = n.startState, e = !0;
  for (let r of t.facet(O8)) {
    let s = r(n);
    if (s === !1) {
      e = !1;
      break;
    }
    Array.isArray(s) && (e = e === !0 ? s : T8(e, s));
  }
  if (e !== !0) {
    let r, s;
    if (e === !1)
      s = n.changes.invertedDesc, r = Tn.empty(t.doc.length);
    else {
      let a = n.changes.filter(e);
      r = a.changes, s = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    n = Oi.create(t, r, n.selection && n.selection.map(s), jt.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let i = t.facet(b8);
  for (let r = i.length - 1; r >= 0; r--) {
    let s = i[r](n);
    s instanceof Oi ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Oi ? n = s[0] : n = xS(t, so(s), !1);
  }
  return n;
}
c(M8, "Cg$1");
m(M8, "filterTransaction");
function A8(n) {
  let t = n.startState, e = t.facet($8), i = n;
  for (let r = e.length - 1; r >= 0; r--) {
    let s = e[r](n);
    s && Object.keys(s).length && (i = $S(i, iO(t, s, n.changes.newLength), !0));
  }
  return i == n ? n : Oi.create(t, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
c(A8, "Xg$1");
m(A8, "extendTransaction");
const sW = [];
function so(n) {
  return n == null ? sW : Array.isArray(n) ? n : [n];
}
c(so, "$i$1");
m(so, "asArray");
var _r = /* @__PURE__ */ (function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
})(_r || (_r = {}));
const aW = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Jx;
try {
  Jx = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function R8(n) {
  if (Jx)
    return Jx.test(n);
  for (let t = 0; t < n.length; t++) {
    let e = n[t];
    if (/\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || aW.test(e)))
      return !0;
  }
  return !1;
}
c(R8, "Vg$1");
m(R8, "hasWordChar");
function E8(n) {
  return (t) => {
    if (!/\S/.test(t))
      return _r.Space;
    if (R8(t))
      return _r.Word;
    for (let e = 0; e < n.length; e++)
      if (t.indexOf(n[e]) > -1)
        return _r.Word;
    return _r.Other;
  };
}
c(E8, "Wg$1");
m(E8, "makeCategorizer");
var ai;
const _8 = (ai = class {
  constructor(t, e, i, r, s, a) {
    this.config = t, this.doc = e, this.selection = i, this.values = r, this.status = t.statusTemplate.slice(), this.computeSlot = s, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      oh(this, o << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return oh(this, i), aw(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return xS(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: r } = e;
    for (let o of t.effects)
      o.is(f8.reconfigure) ? (e && (r = /* @__PURE__ */ new Map(), e.compartments.forEach((l, d) => r.set(d, l)), e = null), r.set(o.value.compartment, o.value.extension)) : o.is(jt.reconfigure) ? (e = null, i = o.value) : o.is(jt.appendConfig) && (e = null, i = so(i).concat(o.value));
    let s;
    e ? s = t.startState.values.slice() : (e = k3.resolve(i, r, this), s = new ai(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (o, l) => l.reconfigure(o, this), null).values);
    let a = t.startState.facet(Kx) ? t.newSelection : t.newSelection.asSingle();
    new ai(e, t.newDoc, a, s, (o, l) => l.update(o, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: it.cursor(e.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), r = this.changes(i.changes), s = [i.range], a = so(i.effects);
    for (let o = 1; o < e.ranges.length; o++) {
      let l = t(e.ranges[o]), d = this.changes(l.changes), u = d.map(r);
      for (let f = 0; f < o; f++)
        s[f] = s[f].map(u);
      let p = r.mapDesc(d, !0);
      s.push(l.range.map(p)), r = r.compose(u), a = jt.mapEffects(a, u).concat(jt.mapEffects(so(l.effects), p));
    }
    return {
      changes: r,
      selection: it.create(s, e.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof Tn ? t : Tn.of(t, this.doc.length, this.facet(ai.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Dt.of(t.split(this.facet(ai.lineSeparator) || Hx));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (oh(this, e), aw(this, e));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let r = t[i];
        r instanceof ss && this.config.address[r.id] != null && (e[i] = r.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(t, s)) {
          let a = i[s], o = t[s];
          r.push(a.init((l) => a.spec.fromJSON(o, l)));
        }
    }
    return ai.create({
      doc: t.doc,
      selection: it.fromJSON(t.selection),
      extensions: e.extensions ? r.concat([e.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let e = k3.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Dt ? t.doc : Dt.of((t.doc || "").split(e.staticFacet(ai.lineSeparator) || Hx)), r = t.selection ? t.selection instanceof it ? t.selection : it.single(t.selection.anchor, t.selection.head) : it.single(0);
    return OS(r, i.length), e.staticFacet(Kx) || (r = r.asSingle()), new ai(e, i, r, e.dynamicSlots.map(() => null), (s, a) => a.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ai.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ai.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(x8);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...e) {
    for (let i of this.facet(ai.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let s = +(r || 1);
      return !s || s > e.length ? i : e[s - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, e, i = -1) {
    let r = [];
    for (let s of this.facet(w8))
      for (let a of s(this, e, i))
        Object.prototype.hasOwnProperty.call(a, t) && r.push(a[t]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return E8(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: e, from: i, length: r } = this.doc.lineAt(t), s = this.charCategorizer(t), a = t - i, o = t - i;
    for (; a > 0; ) {
      let l = kn(e, a, !1);
      if (s(e.slice(l, a)) != _r.Word)
        break;
      a = l;
    }
    for (; o < r; ) {
      let l = kn(e, o);
      if (s(e.slice(o, l)) != _r.Word)
        break;
      o = l;
    }
    return a == o ? null : it.range(a + i, o + i);
  }
}, c(ai, "Pe"), ai);
m(_8, "EditorState");
let Le = _8;
Le.allowMultipleSelections = Kx;
Le.tabSize = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => n.length ? n[0] : 4, "combine")
});
Le.lineSeparator = v8;
Le.readOnly = x8;
Le.phrases = /* @__PURE__ */ $t.define({
  compare(n, t) {
    let e = Object.keys(n), i = Object.keys(t);
    return e.length == i.length && e.every((r) => n[r] == t[r]);
  }
});
Le.languageData = w8;
Le.changeFilter = O8;
Le.transactionFilter = b8;
Le.transactionExtender = $8;
f8.reconfigure = /* @__PURE__ */ jt.define();
function kS(n, t, e = {}) {
  let i = {};
  for (let r of n)
    for (let s of Object.keys(r)) {
      let a = r[s], o = i[s];
      if (o === void 0)
        i[s] = a;
      else if (!(o === a || a === void 0)) if (Object.hasOwnProperty.call(e, s))
        i[s] = e[s](o, a);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let r in t)
    i[r] === void 0 && (i[r] = t[r]);
  return i;
}
c(kS, "HO");
m(kS, "combineConfig");
var Qh;
const z8 = (Qh = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, e = t) {
    return tk.create(t, e, this);
  }
}, c(Qh, "Bh"), Qh);
m(z8, "RangeValue");
let Ko = z8;
Ko.prototype.startSide = Ko.prototype.endSide = 0;
Ko.prototype.point = !1;
Ko.prototype.mapMode = vi.TrackDel;
var _1, Th;
let tk = (_1 = (Th = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new _1(t, e, i);
  }
}, c(Th, "ii$1"), Th), m(_1, "Range"), _1);
function nO(n, t) {
  return n.from - t.from || n.value.startSide - t.value.startSide;
}
c(nO, "dl$1");
m(nO, "cmpRange");
var Oo;
const L8 = (Oo = class {
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, e, i, r = 0) {
    let s = i ? this.to : this.from;
    for (let a = r, o = s.length; ; ) {
      if (a == o)
        return a;
      let l = a + o >> 1, d = s[l] - t || (i ? this.value[l].endSide : this.value[l].startSide) - e;
      if (l == a)
        return d >= 0 ? a : o;
      d >= 0 ? o = l : a = l + 1;
    }
  }
  between(t, e, i, r) {
    for (let s = this.findIndex(e, -1e9, !0), a = this.findIndex(i, 1e9, !1, s); s < a; s++)
      if (r(this.from[s] + t, this.to[s] + t, this.value[s]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], r = [], s = [], a = -1, o = -1;
    for (let l = 0; l < this.value.length; l++) {
      let d = this.value[l], u = this.from[l] + t, p = this.to[l] + t, f, y;
      if (u == p) {
        let g = e.mapPos(u, d.startSide, d.mapMode);
        if (g == null || (f = y = g, d.startSide != d.endSide && (y = e.mapPos(u, d.endSide), y < f)))
          continue;
      } else if (f = e.mapPos(u, d.startSide), y = e.mapPos(p, d.endSide), f > y || f == y && d.startSide > 0 && d.endSide <= 0)
        continue;
      (y - f || d.endSide - d.startSide) < 0 || (a < 0 && (a = f), d.point && (o = Math.max(o, y - f)), i.push(d), r.push(f - a), s.push(y - a));
    }
    return { mapped: i.length ? new Oo(r, s, i, o) : null, pos: a };
  }
}, c(Oo, "Ds"), Oo);
m(L8, "Chunk");
let oW = L8;
var Pi;
const I8 = (Pi = class {
  constructor(t, e, i, r) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(t, e, i, r) {
    return new Pi(t, e, i, r);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: r = 0, filterTo: s = this.length } = t, a = t.filter;
    if (e.length == 0 && !a)
      return this;
    if (i && (e = e.slice().sort(nO)), this.isEmpty)
      return e.length ? Pi.of(e) : this;
    let o = new q8(this, null, -1).goto(0), l = 0, d = [], u = new rO();
    for (; o.value || l < e.length; )
      if (l < e.length && (o.from - e[l].from || o.startSide - e[l].value.startSide) >= 0) {
        let p = e[l++];
        u.addInner(p.from, p.to, p.value) || d.push(p);
      } else o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (l == e.length || this.chunkEnd(o.chunkIndex) < e[l].from) && (!a || r > this.chunkEnd(o.chunkIndex) || s < this.chunkPos[o.chunkIndex]) && u.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || r > o.to || s < o.from || a(o.from, o.to, o.value)) && (u.addInner(o.from, o.to, o.value) || d.push(tk.create(o.from, o.to, o.value))), o.next());
    return u.finishInner(this.nextLayer.isEmpty && !d.length ? Pi.empty : this.nextLayer.update({ add: d, filter: a, filterFrom: r, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], r = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], l = this.chunk[a], d = t.touchesRange(o, o + l.length);
      if (d === !1)
        r = Math.max(r, l.maxPoint), e.push(l), i.push(t.mapPos(o));
      else if (d === !0) {
        let { mapped: u, pos: p } = l.map(o, t);
        u && (r = Math.max(r, u.maxPoint), e.push(u), i.push(p));
      }
    }
    let s = this.nextLayer.map(t);
    return e.length == 0 ? s : new Pi(i, e, s || Pi.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let s = this.chunkPos[r], a = this.chunk[r];
        if (e >= s && t <= s + a.length && a.between(s, t - s, e - s, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return ik.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, e = 0) {
    return ik.from(t).goto(e);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, e, i, r, s = -1) {
    let a = t.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= s), o = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= s), l = ek(a, o, i), d = new Ay(a, l, s), u = new Ay(o, l, s);
    i.iterGaps((p, f, y) => nk(d, p, u, f, y, r)), i.empty && i.length == 0 && nk(d, 0, u, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, e, i = 0, r) {
    r == null && (r = 999999999);
    let s = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0), a = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0);
    if (s.length != a.length)
      return !1;
    if (!s.length)
      return !0;
    let o = ek(s, a), l = new Ay(s, o, 0).goto(i), d = new Ay(a, o, 0).goto(i);
    for (; ; ) {
      if (l.to != d.to || !sO(l.active, d.active) || l.point && (!d.point || !l.point.eq(d.point)))
        return !1;
      if (l.to > r)
        return !0;
      l.next(), d.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, e, i, r, s = -1) {
    let a = new Ay(t, null, s).goto(e), o = e, l = a.openStart;
    for (; ; ) {
      let d = Math.min(a.to, i);
      if (a.point) {
        let u = a.activeForPoint(a.to), p = a.pointFrom < e ? u.length + 1 : a.point.startSide < 0 ? u.length : Math.min(u.length, l);
        r.point(o, d, a.point, u, p, a.pointRank), l = Math.min(a.openEnd(d), u.length);
      } else d > o && (r.span(o, d, a.active, l), l = a.openEnd(d));
      if (a.to > i)
        return l + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, e = !1) {
    let i = new rO();
    for (let r of t instanceof tk ? [t] : e ? V8(t) : t)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return Pi.empty;
    let e = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let r = t[i]; r != Pi.empty; r = r.nextLayer)
        e = new Pi(r.chunkPos, r.chunk, e, Math.max(r.maxPoint, e.maxPoint));
    return e;
  }
}, c(Pi, "Ve"), Pi);
m(I8, "RangeSet");
let hi = I8;
hi.empty = /* @__PURE__ */ new hi([], [], null, -1);
function V8(n) {
  if (n.length > 1)
    for (let t = n[0], e = 1; e < n.length; e++) {
      let i = n[e];
      if (nO(t, i) > 0)
        return n.slice().sort(nO);
      t = i;
    }
  return n;
}
c(V8, "Ug$1");
m(V8, "lazySort");
hi.empty.nextLayer = hi.empty;
var bo;
const D8 = (bo = class {
  finishChunk(t) {
    this.chunks.push(new oW(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new bo())).add(t, e, i);
  }
  /**
  @internal
  */
  addInner(t, e, i) {
    let r = t - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(hi.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = hi.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}, c(bo, "Bs"), bo);
m(D8, "RangeSetBuilder");
let rO = D8;
function ek(n, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let a = 0; a < s.chunk.length; a++)
      s.chunk[a].maxPoint <= 0 && i.set(s.chunk[a], s.chunkPos[a]);
  let r = /* @__PURE__ */ new Set();
  for (let s of t)
    for (let a = 0; a < s.chunk.length; a++) {
      let o = i.get(s.chunk[a]);
      o != null && (e ? e.mapPos(o) : o) == s.chunkPos[a] && !e?.touchesRange(o, o + s.chunk[a].length) && r.add(s.chunk[a]);
    }
  return r;
}
c(ek, "Xc$1");
m(ek, "findSharedChunks");
var Mh;
const W8 = (Mh = class {
  constructor(t, e, i, r = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < t || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}, c(Mh, "Nh"), Mh);
m(W8, "LayerCursor");
let q8 = W8;
var $o;
const F8 = ($o = class {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let r = [];
    for (let s = 0; s < t.length; s++)
      for (let a = t[s]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && r.push(new q8(a, e, i, s));
    return r.length == 1 ? r[0] : new $o(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      lv(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      lv(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), lv(this.heap, 0);
    }
  }
}, c($o, "Ns"), $o);
m(F8, "HeapCursor");
let ik = F8;
function lv(n, t) {
  for (let e = n[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= n.length)
      break;
    let r = n[i];
    if (i + 1 < n.length && r.compare(n[i + 1]) >= 0 && (r = n[i + 1], i++), e.compare(r) < 0)
      break;
    n[i] = e, n[t] = r, t = i;
  }
}
c(lv, "Ro$1");
m(lv, "heapBubble");
var Ah;
const Z8 = (Ah = class {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = ik.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    ig(this.active, t), ig(this.activeTo, t), ig(this.activeRank, t), this.minActive = rk(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: r, rank: s } = this.cursor;
    for (; e < this.activeRank.length && (s - this.activeRank[e] || r - this.activeTo[e]) > 0; )
      e++;
    ng(this.active, e, i), ng(this.activeTo, e, r), ng(this.activeRank, e, s), t && ng(t, e, this.cursor.from), this.minActive = rk(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > t) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && ig(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < t; r--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}, c(Ah, "Gh"), Ah);
m(Z8, "SpanCursor");
let Ay = Z8;
function nk(n, t, e, i, r, s) {
  n.goto(t), e.goto(i);
  let a = i + r, o = i, l = i - t;
  for (; ; ) {
    let d = n.to + l - e.to, u = d || n.endSide - e.endSide, p = u < 0 ? n.to + l : e.to, f = Math.min(p, a);
    if (n.point || e.point ? n.point && e.point && (n.point == e.point || n.point.eq(e.point)) && sO(n.activeForPoint(n.to), e.activeForPoint(e.to)) || s.comparePoint(o, f, n.point, e.point) : f > o && !sO(n.active, e.active) && s.compareRange(o, f, n.active, e.active), p > a)
      break;
    (d || n.openEnd != e.openEnd) && s.boundChange && s.boundChange(p), o = p, u <= 0 && n.next(), u >= 0 && e.next();
  }
}
c(nk, "Ec$1");
m(nk, "compare");
function sO(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] != t[e] && !n[e].eq(t[e]))
      return !1;
  return !0;
}
c(sO, "ml$1");
m(sO, "sameValues");
function ig(n, t) {
  for (let e = t, i = n.length - 1; e < i; e++)
    n[e] = n[e + 1];
  n.pop();
}
c(ig, "Tn$1");
m(ig, "remove");
function ng(n, t, e) {
  for (let i = n.length - 1; i >= t; i--)
    n[i + 1] = n[i];
  n[t] = e;
}
c(ng, "An$1");
m(ng, "insert");
function rk(n, t) {
  let e = -1, i = 1e9;
  for (let r = 0; r < t.length; r++)
    (t[r] - i || n[r].endSide - n[e].endSide) < 0 && (e = r, i = t[r]);
  return e;
}
c(rk, "Yc$1");
m(rk, "findMinIndex");
function ra(n, t, e = n.length) {
  let i = 0;
  for (let r = 0; r < e && r < n.length; )
    n.charCodeAt(r) == 9 ? (i += t - i % t, r++) : (i++, r = kn(n, r));
  return i;
}
c(ra, "Ot$2");
m(ra, "countColumn");
function X8(n, t, e, i) {
  for (let r = 0, s = 0; ; ) {
    if (s >= t)
      return r;
    if (r == n.length)
      break;
    s += n.charCodeAt(r) == 9 ? e - s % e : 1, r = kn(n, r);
  }
  return n.length;
}
c(X8, "Ig$1");
m(X8, "findColumn");
const sk = "ͼ", S3 = typeof Symbol > "u" ? "__" + sk : Symbol.for(sk), ak = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), C3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var Rh;
const N8 = (Rh = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function r(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    c(r, "n"), m(r, "splitSelector");
    function s(a, o, l, d) {
      let u = [], p = /^@(\w+)\b/.exec(a[0]), f = p && p[1] == "keyframes";
      if (p && o == null) return l.push(a[0] + ";");
      for (let y in o) {
        let g = o[y];
        if (/&/.test(y))
          s(
            y.split(/,\s*/).map((b) => a.map((S) => b.replace(/&/, S))).reduce((b, S) => b.concat(S)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!p) throw new RangeError("The value of a property (" + y + ") should be a primitive value.");
          s(r(y), g, u, f);
        } else g != null && u.push(y.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + g + ";");
      }
      (u.length || f) && l.push((i && !p && !d ? a.map(i) : a).join(", ") + " {" + u.join(" ") + "}");
    }
    c(s, "s"), m(s, "render");
    for (let a in t) s(r(a), t[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = C3[S3] || 1;
    return C3[S3] = t + 1, sk + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, e, i) {
    let r = t[ak], s = i && i.nonce;
    r ? s && r.setNonce(s) : r = new lW(t, s), r.mount(Array.isArray(e) ? e : [e], t);
  }
}, c(Rh, "Fh"), Rh);
m(N8, "StyleModule");
let sa = N8, P3 = /* @__PURE__ */ new Map();
var Eh;
const j8 = (Eh = class {
  constructor(t, e) {
    let i = t.ownerDocument || t, r = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && r.CSSStyleSheet) {
      let s = P3.get(i);
      if (s) return t[ak] = s;
      this.sheet = new r.CSSStyleSheet(), P3.set(i, this);
    } else
      this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e);
    this.modules = [], t[ak] = this;
  }
  mount(t, e) {
    let i = this.sheet, r = 0, s = 0;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = this.modules.indexOf(o);
      if (l < s && l > -1 && (this.modules.splice(l, 1), s--, l = -1), l == -1) {
        if (this.modules.splice(s++, 0, o), i) for (let d = 0; d < o.rules.length; d++)
          i.insertRule(o.rules[d], r++);
      } else {
        for (; s < l; ) r += this.modules[s++].rules.length;
        r += o.rules.length, s++;
      }
    }
    if (i)
      e.adoptedStyleSheets.indexOf(this.sheet) < 0 && (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]);
    else {
      let a = "";
      for (let l = 0; l < this.modules.length; l++)
        a += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = a;
      let o = e.head || e;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}, c(Eh, "Hh"), Eh);
m(j8, "StyleSet");
let lW = j8;
var aa = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ow = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, cW = typeof navigator < "u" && /Mac/.test(navigator.platform), hW = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ti = 0; ti < 10; ti++) aa[48 + ti] = aa[96 + ti] = String(ti);
for (var ti = 1; ti <= 24; ti++) aa[ti + 111] = "F" + ti;
for (var ti = 65; ti <= 90; ti++)
  aa[ti] = String.fromCharCode(ti + 32), ow[ti] = String.fromCharCode(ti);
for (var zb in aa) ow.hasOwnProperty(zb) || (ow[zb] = aa[zb]);
function B8(n) {
  var t = cW && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || hW && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", e = !t && n.key || (n.shiftKey ? ow : aa)[n.keyCode] || n.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
c(B8, "qg$1");
m(B8, "keyName");
let gi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, ok = typeof document < "u" ? document : { documentElement: { style: {} } };
const lk = /* @__PURE__ */ /Edge\/(\d+)/.exec(gi.userAgent), U8 = /* @__PURE__ */ /MSIE \d/.test(gi.userAgent), ck = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gi.userAgent), v0 = !!(U8 || ck || lk), Q3 = !v0 && /* @__PURE__ */ /gecko\/(\d+)/i.test(gi.userAgent), Lb = !v0 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(gi.userAgent), dW = "webkitFontSmoothing" in ok.documentElement.style, hk = !v0 && /* @__PURE__ */ /Apple Computer/.test(gi.vendor), T3 = hk && (/* @__PURE__ */ /Mobile\/\w+/.test(gi.userAgent) || gi.maxTouchPoints > 2);
var nt = {
  mac: T3 || /* @__PURE__ */ /Mac/.test(gi.platform),
  windows: /* @__PURE__ */ /Win/.test(gi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(gi.platform),
  ie: v0,
  ie_version: U8 ? ok.documentMode || 6 : ck ? +ck[1] : lk ? +lk[1] : 0,
  gecko: Q3,
  gecko_version: Q3 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(gi.userAgent) || [0, 0])[1] : 0,
  chrome: !!Lb,
  chrome_version: Lb ? +Lb[1] : 0,
  ios: T3,
  android: /* @__PURE__ */ /Android\b/.test(gi.userAgent),
  webkit_version: dW ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(gi.userAgent) || [0, 0])[1] : 0,
  safari: hk,
  safari_version: hk ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(gi.userAgent) || [0, 0])[1] : 0,
  tabSize: ok.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function Rm(n) {
  let t;
  return n.nodeType == 11 ? t = n.getSelection ? n : n.ownerDocument : t = n, t.getSelection();
}
c(Rm, "Fr$1");
m(Rm, "getSelection");
function aO(n, t) {
  return t ? n == t || n.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
c(aO, "Pl$1");
m(aO, "contains");
function Hg(n, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return aO(n, t.anchorNode);
  } catch {
    return !1;
  }
}
c(Hg, "Fn$1");
m(Hg, "hasSelection");
function Jo(n) {
  return n.nodeType == 3 ? la(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
c(Jo, "Vi$1");
m(Jo, "clientRectsFor");
function lh(n, t, e, i) {
  return e ? dk(n, t, e, i, -1) || dk(n, t, e, i, 1) : !1;
}
c(lh, "mr$1");
m(lh, "isEquivalentPosition");
function oa(n) {
  for (var t = 0; ; t++)
    if (n = n.previousSibling, !n)
      return t;
}
c(oa, "ni$1");
m(oa, "domIndex");
function lw(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
c(lw, "as$2");
m(lw, "isBlockElement");
function dk(n, t, e, i, r) {
  for (; ; ) {
    if (n == e && t == i)
      return !0;
    if (t == (r < 0 ? 0 : Mn(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      t = oa(n) + (r < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[t + (r < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      t = r < 0 ? Mn(n) : 0;
    } else
      return !1;
  }
}
c(dk, "jc$1");
m(dk, "scanFor");
function Mn(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
c(Mn, "nt$2");
m(Mn, "maxOffset");
function dy(n, t) {
  let e = t ? n.left : n.right;
  return { left: e, right: e, top: n.top, bottom: n.bottom };
}
c(dy, "yn$1");
m(dy, "flattenRect");
function H8(n) {
  let t = n.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
c(H8, "Bg$1");
m(H8, "windowRect");
function SS(n, t) {
  let e = t.width / n.offsetWidth, i = t.height / n.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - n.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - n.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
c(SS, "JO");
m(SS, "getScale");
function Y8(n, t, e, i, r, s, a, o) {
  let l = n.ownerDocument, d = l.defaultView || window;
  for (let u = n, p = !1; u && !p; )
    if (u.nodeType == 1) {
      let f, y = u == l.body, g = 1, b = 1;
      if (y)
        f = H8(d);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (p = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let Q = u.getBoundingClientRect();
        ({ scaleX: g, scaleY: b } = SS(u, Q)), f = {
          left: Q.left,
          right: Q.left + u.clientWidth * g,
          top: Q.top,
          bottom: Q.top + u.clientHeight * b
        };
      }
      let S = 0, $ = 0;
      if (r == "nearest")
        t.top < f.top ? ($ = t.top - (f.top + a), e > 0 && t.bottom > f.bottom + $ && ($ = t.bottom - f.bottom + a)) : t.bottom > f.bottom && ($ = t.bottom - f.bottom + a, e < 0 && t.top - $ < f.top && ($ = t.top - (f.top + a)));
      else {
        let Q = t.bottom - t.top, E = f.bottom - f.top;
        $ = (r == "center" && Q <= E ? t.top + Q / 2 - E / 2 : r == "start" || r == "center" && e < 0 ? t.top - a : t.bottom - E + a) - f.top;
      }
      if (i == "nearest" ? t.left < f.left ? (S = t.left - (f.left + s), e > 0 && t.right > f.right + S && (S = t.right - f.right + s)) : t.right > f.right && (S = t.right - f.right + s, e < 0 && t.left < f.left + S && (S = t.left - (f.left + s))) : S = (i == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : i == "start" == o ? t.left - s : t.right - (f.right - f.left) + s) - f.left, S || $)
        if (y)
          d.scrollBy(S, $);
        else {
          let Q = 0, E = 0;
          if ($) {
            let z = u.scrollTop;
            u.scrollTop += $ / b, E = (u.scrollTop - z) * b;
          }
          if (S) {
            let z = u.scrollLeft;
            u.scrollLeft += S / g, Q = (u.scrollLeft - z) * g;
          }
          t = {
            left: t.left - Q,
            top: t.top - E,
            right: t.right - Q,
            bottom: t.bottom - E
          }, Q && Math.abs(Q - S) < 1 && (i = "nearest"), E && Math.abs(E - $) < 1 && (r = "nearest");
        }
      if (y)
        break;
      (t.top < f.top || t.bottom > f.bottom || t.left < f.left || t.right > f.right) && (t = {
        left: Math.max(t.left, f.left),
        right: Math.min(t.right, f.right),
        top: Math.max(t.top, f.top),
        bottom: Math.min(t.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
c(Y8, "Ng$1");
m(Y8, "scrollRectIntoView");
function G8(n) {
  let t = n.ownerDocument, e, i;
  for (let r = n.parentNode; r && !(r == t.body || e && i); )
    if (r.nodeType == 1)
      !i && r.scrollHeight > r.clientHeight && (i = r), !e && r.scrollWidth > r.clientWidth && (e = r), r = r.assignedSlot || r.parentNode;
    else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return { x: e, y: i };
}
c(G8, "Gg$1");
m(G8, "scrollableParents");
var _h;
const K8 = (_h = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? Mn(e) : 0), i, Math.min(t.focusOffset, i ? Mn(i) : 0));
  }
  set(t, e, i, r) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = r;
  }
}, c(_h, "Kh"), _h);
m(K8, "DOMSelectionState");
let uW = K8, Ha = null;
nt.safari && nt.safari_version >= 26 && (Ha = !1);
function CS(n) {
  if (n.setActive)
    return n.setActive();
  if (Ha)
    return n.focus(Ha);
  let t = [];
  for (let e = n; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (n.focus(Ha == null ? {
    get preventScroll() {
      return Ha = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ha) {
    Ha = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], r = t[e++], s = t[e++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
c(CS, "ed$1");
m(CS, "focusPreventScroll");
let M3;
function la(n, t, e = t) {
  let i = M3 || (M3 = document.createRange());
  return i.setEnd(n, e), i.setStart(n, t), i;
}
c(la, "si$1");
m(la, "textRange");
function ao(n, t, e, i) {
  let r = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = i);
  let s = new KeyboardEvent("keydown", r);
  s.synthetic = !0, n.dispatchEvent(s);
  let a = new KeyboardEvent("keyup", r);
  return a.synthetic = !0, n.dispatchEvent(a), s.defaultPrevented || a.defaultPrevented;
}
c(ao, "Ri$1");
m(ao, "dispatchKey");
function J8(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
c(J8, "Fg$1");
m(J8, "getRoot");
function PS(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
c(PS, "td$1");
m(PS, "clearAttributes");
function t7(n, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Mn(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let r = e.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (e = r, i = Mn(e));
    } else {
      if (e == n)
        return !0;
      i = oa(e), e = e.parentNode;
    }
}
c(t7, "Hg$1");
m(t7, "atElementStart");
function QS(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
c(QS, "id$1");
m(QS, "isScrolledToBottom");
function TS(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = Mn(e);
    } else if (e.parentNode && !lw(e))
      i = oa(e), e = e.parentNode;
    else
      return null;
  }
}
c(TS, "rd$1");
m(TS, "textNodeBefore");
function MS(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !lw(e))
      i = oa(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
c(MS, "nd$1");
m(MS, "textNodeAfter");
var Vs;
const e7 = (Vs = class {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new Vs(t.parentNode, oa(t), e);
  }
  static after(t, e) {
    return new Vs(t.parentNode, oa(t) + 1, e);
  }
}, c(Vs, "Rr"), Vs);
m(e7, "DOMPos");
let Hi = e7;
const AS = [];
var Ds;
const i7 = (Ds = class {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let e = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return e;
      e += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, e) {
    if (this.flags & 2) {
      let i = this.dom, r = null, s;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (s = r ? r.nextSibling : i.firstChild)) {
            let o = Ds.get(s);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(s);
          }
          a.sync(t, e), a.flags &= -8;
        }
        if (s = r ? r.nextSibling : i.firstChild, e && !e.written && e.node == i && s != a.dom && (e.written = !0), a.dom.parentNode == i)
          for (; s && s != a.dom; )
            s = uk(s);
        else
          i.insertBefore(a.dom, s);
        r = a.dom;
      }
      for (s = r ? r.nextSibling : i.firstChild, s && e && e.node == i && (e.written = !0); s; )
        s = uk(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(t, e), i.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, e) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[e];
    else {
      let r = Mn(t) == 0 ? 0 : e == 0 ? -1 : 1;
      for (; ; ) {
        let s = t.parentNode;
        if (s == this.dom)
          break;
        r == 0 && s.firstChild != s.lastChild && (t == s.firstChild ? r = -1 : r = 1), t = s;
      }
      r < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ds.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, s = 0; ; r++) {
      let a = this.children[r];
      if (a.dom == i)
        return s;
      s += a.length + a.breakAfter;
    }
  }
  domBoundsAround(t, e, i = 0) {
    let r = -1, s = -1, a = -1, o = -1;
    for (let l = 0, d = i, u = i; l < this.children.length; l++) {
      let p = this.children[l], f = d + p.length;
      if (d < t && f > e)
        return p.domBoundsAround(t, e, d);
      if (f >= t && r == -1 && (r = l, s = d), d > e && p.dom.parentNode == this.dom) {
        a = l, o = u;
        break;
      }
      u = f, d = f + p.breakAfter;
    }
    return {
      from: s,
      to: o < 0 ? i + this.length : o,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let e = this.parent; e; e = e.parent) {
      if (t && (e.flags |= 2), e.flags & 1)
        return;
      e.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let e = t.parent;
      if (!e)
        return t;
      t = e;
    }
  }
  replaceChildren(t, e, i = AS) {
    this.markDirty();
    for (let r = t; r < e; r++) {
      let s = this.children[r];
      s.parent == this && i.indexOf(s) < 0 && s.destroy();
    }
    i.length < 250 ? this.children.splice(t, e - t, ...i) : this.children = [].concat(this.children.slice(0, t), i, this.children.slice(e));
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new r7(this.children, t, this.children.length);
  }
  childPos(t, e = 1) {
    return this.childCursor().findPos(t, e);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, e, i, r, s, a) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}, c(Ds, "vr"), Ds);
m(i7, "ContentView");
let Kt = i7;
Kt.prototype.breakAfter = 0;
function uk(n) {
  let t = n.nextSibling;
  return n.parentNode.removeChild(n), t;
}
c(uk, "Dc$1");
m(uk, "rm$1");
var zh;
const n7 = (zh = class {
  constructor(t, e, i) {
    this.children = t, this.pos = e, this.i = i, this.off = 0;
  }
  findPos(t, e = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (e > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}, c(zh, "Jh"), zh);
m(n7, "ChildCursor");
let r7 = n7;
function RS(n, t, e, i, r, s, a, o, l) {
  let { children: d } = n, u = d.length ? d[t] : null, p = s.length ? s[s.length - 1] : null, f = p ? p.breakAfter : a;
  if (!(t == i && u && !a && !f && s.length < 2 && u.merge(e, r, s.length ? p : null, e == 0, o, l))) {
    if (i < d.length) {
      let y = d[i];
      y && (r < y.length || y.breakAfter && p?.breakAfter) ? (t == i && (y = y.split(r), r = 0), !f && p && y.merge(0, r, p, !0, 0, l) ? s[s.length - 1] = y : ((r || y.children.length && !y.children[0].length) && y.merge(0, r, null, !1, 0, l), s.push(y))) : y?.breakAfter && (p ? p.breakAfter = 1 : a = 1), i++;
    }
    for (u && (u.breakAfter = a, e > 0 && (!a && s.length && u.merge(e, u.length, s[0], !1, o, 0) ? u.breakAfter = s.shift().breakAfter : (e < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(e, u.length, null, !1, o, 0), t++)); t < i && s.length; )
      if (d[i - 1].become(s[s.length - 1]))
        i--, s.pop(), l = s.length ? 0 : o;
      else if (d[t].become(s[0]))
        t++, s.shift(), o = s.length ? 0 : l;
      else
        break;
    !s.length && t && i < d.length && !d[t - 1].breakAfter && d[i].merge(0, 0, d[t - 1], !1, o, l) && t--, (t < i || s.length) && n.replaceChildren(t, i, s);
  }
}
c(RS, "sd$1");
m(RS, "replaceRange");
function ES(n, t, e, i, r, s) {
  let a = n.childCursor(), { i: o, off: l } = a.findPos(e, 1), { i: d, off: u } = a.findPos(t, -1), p = t - e;
  for (let f of i)
    p += f.length;
  n.length += p, RS(n, d, u, o, l, i, 0, r, s);
}
c(ES, "od$1");
m(ES, "mergeChildrenInto");
const pW = 256;
var Ws;
const s7 = (Ws = class extends Kt {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, e, i) {
    return this.flags & 8 || i && (!(i instanceof Ws) || this.length - (e - t) + i.length > pW || i.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0);
  }
  split(t) {
    let e = new Ws(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= this.flags & 8, e;
  }
  localPosFromDOM(t, e) {
    return t == this.dom ? e : e ? this.text.length : 0;
  }
  domAtPos(t) {
    return new Hi(this.dom, t);
  }
  domBoundsAround(t, e, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, e) {
    return o7(this.dom, t, e);
  }
}, c(Ws, "Tr"), Ws);
m(s7, "TextView");
let ca = s7;
var qs;
const a7 = (qs = class extends Kt {
  constructor(t, e = [], i = 0) {
    super(), this.mark = t, this.children = e, this.length = i;
    for (let r of e)
      r.setParent(this);
  }
  setAttrs(t) {
    if (PS(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let e in this.mark.attrs)
        t.setAttribute(e, this.mark.attrs[e]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e);
  }
  merge(t, e, i, r, s, a) {
    return i && (!(i instanceof qs && i.mark.eq(this.mark)) || t && s <= 0 || e < this.length && a <= 0) ? !1 : (ES(this, t, e, i ? i.children.slice() : [], s - 1, a - 1), this.markDirty(), !0);
  }
  split(t) {
    let e = [], i = 0, r = -1, s = 0;
    for (let o of this.children) {
      let l = i + o.length;
      l > t && e.push(i < t ? o.split(t - i) : o), r < 0 && i >= t && (r = s), i = l, s++;
    }
    let a = this.length - t;
    return this.length = t, r > -1 && (this.children.length = r, this.markDirty()), new qs(this.mark, e, a);
  }
  domAtPos(t) {
    return zS(this, t);
  }
  coordsAt(t, e) {
    return IS(this, t, e);
  }
}, c(qs, "Ar"), qs);
m(a7, "MarkView");
let Em = a7;
function o7(n, t, e) {
  let i = n.nodeValue.length;
  t > i && (t = i);
  let r = t, s = t, a = 0;
  t == 0 && e < 0 || t == i && e >= 0 ? nt.chrome || nt.gecko || (t ? (r--, a = 1) : s < i && (s++, a = -1)) : e < 0 ? r-- : s < i && s++;
  let o = la(n, r, s).getClientRects();
  if (!o.length)
    return null;
  let l = o[(a ? a < 0 : e >= 0) ? 0 : o.length - 1];
  return nt.safari && !a && l.width == 0 && (l = Array.prototype.find.call(o, (d) => d.width) || l), a ? dy(l, a < 0) : l || null;
}
c(o7, "Jg$1");
m(o7, "textCoords");
var Yn;
const l7 = (Yn = class extends Kt {
  static create(t, e, i) {
    return new Yn(t, e, i);
  }
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null;
  }
  split(t) {
    let e = Yn.create(this.widget, this.length - t, this.side);
    return this.length -= t, e;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, e, i, r, s, a) {
    return i && (!(i instanceof Yn) || !this.widget.compare(i.widget) || t > 0 && s <= 0 || e < this.length && a <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  become(t) {
    return t instanceof Yn && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Dt.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: e } = t, i = e && e.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : Dt.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? Hi.before(this.dom) : Hi.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    if (i)
      return i;
    let r = this.dom.getClientRects(), s = null;
    if (!r.length)
      return null;
    let a = this.side ? this.side < 0 : t > 0;
    for (let o = a ? r.length - 1 : 0; s = r[o], !(t > 0 ? o == 0 : o == r.length - 1 || s.top < s.bottom); o += a ? -1 : 1)
      ;
    return dy(s, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, c(Yn, "qt"), Yn);
m(l7, "WidgetView");
let _S = l7;
var Fs;
const c7 = (Fs = class extends Kt {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Fs && t.side == this.side;
  }
  split() {
    return new Fs(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? Hi.before(this.dom) : Hi.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Dt.empty;
  }
  get isHidden() {
    return !0;
  }
}, c(Fs, "Lr"), Fs);
m(c7, "WidgetBufferView");
let pk = c7;
ca.prototype.children = _S.prototype.children = pk.prototype.children = AS;
function zS(n, t) {
  let e = n.dom, { children: i } = n, r = 0;
  for (let s = 0; r < i.length; r++) {
    let a = i[r], o = s + a.length;
    if (!(o == s && a.getSide() <= 0)) {
      if (t > s && t < o && a.dom.parentNode == e)
        return a.domAtPos(t - s);
      if (t <= s)
        break;
      s = o;
    }
  }
  for (let s = r; s > 0; s--) {
    let a = i[s - 1];
    if (a.dom.parentNode == e)
      return a.domAtPos(a.length);
  }
  for (let s = r; s < i.length; s++) {
    let a = i[s];
    if (a.dom.parentNode == e)
      return a.domAtPos(0);
  }
  return new Hi(e, 0);
}
c(zS, "ld$1");
m(zS, "inlineDOMAtPos");
function LS(n, t, e) {
  let i, { children: r } = n;
  e > 0 && t instanceof Em && r.length && (i = r[r.length - 1]) instanceof Em && i.mark.eq(t.mark) ? LS(i, t.children[0], e - 1) : (r.push(t), t.setParent(n)), n.length += t.length;
}
c(LS, "ad$1");
m(LS, "joinInlineInto");
function IS(n, t, e) {
  let i = null, r = -1, s = null, a = -1;
  function o(d, u) {
    for (let p = 0, f = 0; p < d.children.length && f <= u; p++) {
      let y = d.children[p], g = f + y.length;
      g >= u && (y.children.length ? o(y, u - f) : (!s || s.isHidden && (e > 0 || d7(s, y))) && (g > u || f == g && y.getSide() > 0) ? (s = y, a = u - f) : (f < u || f == g && y.getSide() < 0 && !y.isHidden) && (i = y, r = u - f)), f = g;
    }
  }
  c(o, "l"), m(o, "scan"), o(n, t);
  let l = (e < 0 ? i : s) || i || s;
  return l ? l.coordsAt(Math.max(0, l == i ? r : a), e) : h7(n);
}
c(IS, "hd$1");
m(IS, "coordsInChildren");
function h7(n) {
  let t = n.dom.lastChild;
  if (!t)
    return n.dom.getBoundingClientRect();
  let e = Jo(t);
  return e[e.length - 1] || null;
}
c(h7, "e0$1");
m(h7, "fallbackRect");
function d7(n, t) {
  let e = n.coordsAt(0, 1), i = t.coordsAt(0, 1);
  return e && i && i.top < e.bottom;
}
c(d7, "t0$1");
m(d7, "onSameLine");
function oO(n, t) {
  for (let e in n)
    e == "class" && t.class ? t.class += " " + n.class : e == "style" && t.style ? t.style += ";" + n.style : t[e] = n[e];
  return t;
}
c(oO, "$l$1");
m(oO, "combineAttrs");
const A3 = /* @__PURE__ */ Object.create(null);
function cw(n, t, e) {
  if (n == t)
    return !0;
  n || (n = A3), t || (t = A3);
  let i = Object.keys(n), r = Object.keys(t);
  if (i.length - (e && i.indexOf(e) > -1 ? 1 : 0) != r.length - (e && r.indexOf(e) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != e && (r.indexOf(s) == -1 || n[s] !== t[s]))
      return !1;
  return !0;
}
c(cw, "fs$2");
m(cw, "attrsEq");
function lO(n, t, e) {
  let i = !1;
  if (t)
    for (let r in t)
      e && r in e || (i = !0, r == "style" ? n.style.cssText = "" : n.removeAttribute(r));
  if (e)
    for (let r in e)
      t && t[r] == e[r] || (i = !0, r == "style" ? n.style.cssText = e[r] : n.setAttribute(r, e[r]));
  return i;
}
c(lO, "Rl$1");
m(lO, "updateAttrs");
function u7(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < n.attributes.length; e++) {
    let i = n.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
c(u7, "i0$1");
m(u7, "getAttrs$1");
var Lh;
const p7 = (Lh = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}, c(Lh, "ef"), Lh);
m(p7, "WidgetType");
let uy = p7;
var sr = /* @__PURE__ */ (function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
})(sr || (sr = {})), Ih;
const f7 = (Ih = class extends Ko {
  constructor(t, e, i, r) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new VS(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new _m(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, r;
    if (t.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: s, end: a } = WS(t, e);
      i = (s ? e ? -3e8 : -1 : 5e8) - 1, r = (a ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new _m(t, i, r, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new DS(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return hi.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}, c(Ih, "tf"), Ih);
m(f7, "Decoration");
let Jt = f7;
Jt.none = hi.empty;
var xo;
const m7 = (xo = class extends Jt {
  constructor(t) {
    let { start: e, end: i } = WS(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var e, i;
    return this == t || t instanceof xo && this.tagName == t.tagName && (this.class || ((e = this.attrs) === null || e === void 0 ? void 0 : e.class)) == (t.class || ((i = t.attrs) === null || i === void 0 ? void 0 : i.class)) && cw(this.attrs, t.attrs, "class");
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}, c(xo, "Gs"), xo);
m(m7, "MarkDecoration");
let VS = m7;
VS.prototype.point = !1;
var ko;
const y7 = (ko = class extends Jt {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof ko && this.spec.class == t.spec.class && cw(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}, c(ko, "Fs"), ko);
m(y7, "LineDecoration");
let DS = y7;
DS.prototype.mapMode = vi.TrackBefore;
DS.prototype.point = !0;
var So;
const g7 = (So = class extends Jt {
  constructor(t, e, i, r, s, a) {
    super(e, i, s, t), this.block = r, this.isReplace = a, this.mapMode = r ? e <= 0 ? vi.TrackBefore : vi.TrackAfter : vi.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? sr.WidgetRange : this.startSide <= 0 ? sr.WidgetBefore : sr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof So && w7(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}, c(So, "Hs"), So);
m(g7, "PointDecoration");
let _m = g7;
_m.prototype.point = !0;
function WS(n, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = n;
  return e == null && (e = n.inclusive), i == null && (i = n.inclusive), { start: e ?? t, end: i ?? t };
}
c(WS, "fd$1");
m(WS, "getInclusive");
function w7(n, t) {
  return n == t || !!(n && t && n.compare(t));
}
c(w7, "r0$1");
m(w7, "widgetsEq");
function Yg(n, t, e, i = 0) {
  let r = e.length - 1;
  r >= 0 && e[r] + i >= n ? e[r] = Math.max(e[r], t) : e.push(n, t);
}
c(Yg, "Hn$1");
m(Yg, "addRange");
var Gn;
const v7 = (Gn = class extends Kt {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, e, i, r, s, a) {
    if (i) {
      if (!(i instanceof Gn))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), ES(this, t, e, i ? i.children.slice() : [], s, a), !0;
  }
  split(t) {
    let e = new Gn();
    if (e.breakAfter = this.breakAfter, this.length == 0)
      return e;
    let { i, off: r } = this.childPos(t);
    r && (e.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      e.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, e;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    cw(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, e) {
    LS(this, t, e);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let e = t.spec.attributes, i = t.spec.class;
    e && (this.attrs = oO(e, this.attrs || {})), i && (this.attrs = oO({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return zS(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    var i;
    this.dom ? this.flags & 4 && (PS(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (lO(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e);
    let r = this.dom.lastChild;
    for (; r && Kt.get(r) instanceof Em; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = Kt.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!nt.ios || !this.children.some((s) => s instanceof ca))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, e;
    for (let i of this.children) {
      if (!(i instanceof ca) || /[^ -~]/.test(i.text))
        return null;
      let r = Jo(i.dom);
      if (r.length != 1)
        return null;
      t += r[0].width, e = r[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: e
    } : null;
  }
  coordsAt(t, e) {
    let i = IS(this, t, e);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
        let a = (s - r.textHeight) / 2;
        return { top: i.top + a, bottom: i.bottom - a, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(t) {
    return t instanceof Gn && this.children.length == 0 && t.children.length == 0 && cw(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, e) {
    for (let i = 0, r = 0; i < t.children.length; i++) {
      let s = t.children[i], a = r + s.length;
      if (a >= e) {
        if (s instanceof Gn)
          return s;
        if (a > e)
          break;
      }
      r = a + s.breakAfter;
    }
    return null;
  }
}, c(Gn, "Dt"), Gn);
m(v7, "LineView");
let mi = v7;
var Dr;
const O7 = (Dr = class extends Kt {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, e, i, r, s, a) {
    return i && (!(i instanceof Dr) || !this.widget.compare(i.widget) || t > 0 && s <= 0 || e < this.length && a <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  domAtPos(t) {
    return t == 0 ? Hi.before(this.dom) : Hi.after(this.dom, t == this.length);
  }
  split(t) {
    let e = this.length - t;
    this.length = t;
    let i = new Dr(this.widget, e, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return AS;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Dt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof Dr && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, e) {
    return this.widget.coordsAt(this.dom, t, e) || (this.widget instanceof fk ? null : dy(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: e, endSide: i } = this.deco;
    return e == i ? !1 : t < 0 ? e < 0 : i > 0;
  }
}, c(Dr, "yi"), Dr);
m(O7, "BlockWidgetView");
let Gg = O7;
var Vh;
const b7 = (Vh = class extends uy {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}, c(Vh, "rf"), Vh);
m(b7, "BlockGapWidget");
let fk = b7;
var Co;
const $7 = (Co = class {
  constructor(t, e, i, r) {
    this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof Gg && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new mi()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(rg(new pk(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof Gg) && this.getLine();
  }
  buildText(t, e, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = a, this.textOff = 0;
      }
      let r = Math.min(this.text.length - this.textOff, t), s = Math.min(
        r,
        512
        /* T.Chunk */
      );
      this.flushBuffer(e.slice(e.length - i)), this.getLine().append(rg(new ca(this.text.slice(this.textOff, this.textOff + s)), e), i), this.atCursorPos = !0, this.textOff += s, t -= s, i = r <= s ? 0 : e.length;
    }
  }
  span(t, e, i, r) {
    this.buildText(e - t, i, r), this.pos = e, this.openStart < 0 && (this.openStart = r);
  }
  point(t, e, i, r, s, a) {
    if (this.disallowBlockEffectsFor[a] && i instanceof _m) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (e > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = e - t;
    if (i instanceof _m)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Gg(i.widget || zm.block, o, i));
      else {
        let l = _S.create(i.widget || zm.inline, o, o ? 0 : i.startSide), d = this.atCursorPos && !l.isEditable && s <= r.length && (t < e || i.startSide > 0), u = !l.isEditable && (t < e || s > r.length || i.startSide <= 0), p = this.getLine();
        this.pendingBuffer == 2 && !d && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), d && (p.append(rg(new pk(1), r), s), s = r.length + Math.max(0, s - r.length)), p.append(rg(l, r), s), this.atCursorPos = u, this.pendingBuffer = u ? t < e || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = s);
  }
  static build(t, e, i, r, s) {
    let a = new Co(t, e, i, s);
    return a.openEnd = hi.spans(r, e, i, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}, c(Co, "Ks"), Co);
m($7, "ContentBuilder");
let Ib = $7;
function rg(n, t) {
  for (let e of t)
    n = new Em(e, [n], n.length);
  return n;
}
c(rg, "Ln$1");
m(rg, "wrapMarks");
var Dh;
const x7 = (Dh = class extends uy {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}, c(Dh, "nf"), Dh);
m(x7, "NullWidget");
let zm = x7;
zm.inline = /* @__PURE__ */ new zm("span");
zm.block = /* @__PURE__ */ new zm("div");
var Pe = /* @__PURE__ */ (function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
})(Pe || (Pe = {}));
const tl = Pe.LTR, qS = Pe.RTL;
function FS(n) {
  let t = [];
  for (let e = 0; e < n.length; e++)
    t.push(1 << +n[e]);
  return t;
}
c(FS, "cd$1");
m(FS, "dec");
const fW = /* @__PURE__ */ FS("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), mW = /* @__PURE__ */ FS("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), mk = /* @__PURE__ */ Object.create(null), Vn = [];
for (let n of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ n.charCodeAt(0), e = /* @__PURE__ */ n.charCodeAt(1);
  mk[t] = e, mk[e] = -t;
}
function ZS(n) {
  return n <= 247 ? fW[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? mW[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
c(ZS, "ud$1");
m(ZS, "charType");
const yW = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var Wh;
const k7 = (Wh = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? qS : tl;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, r) {
    let s = -1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      if (o.from <= e && o.to >= e) {
        if (o.level == i)
          return a;
        (s < 0 || (r != 0 ? r < 0 ? o.from < e : o.to > e : t[s].level > o.level)) && (s = a);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}, c(Wh, "sf"), Wh);
m(k7, "BidiSpan");
let Qs = k7;
function XS(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++) {
    let i = n[e], r = t[e];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !XS(i.inner, r.inner))
      return !1;
  }
  return !0;
}
c(XS, "Od$1");
m(XS, "isolatesEq");
const Nt = [];
function S7(n, t, e, i, r) {
  for (let s = 0; s <= i.length; s++) {
    let a = s ? i[s - 1].to : t, o = s < i.length ? i[s].from : e, l = s ? 256 : r;
    for (let d = a, u = l, p = l; d < o; d++) {
      let f = ZS(n.charCodeAt(d));
      f == 512 ? f = u : f == 8 && p == 4 && (f = 16), Nt[d] = f == 4 ? 2 : f, f & 7 && (p = f), u = f;
    }
    for (let d = a, u = l, p = l; d < o; d++) {
      let f = Nt[d];
      if (f == 128)
        d < o - 1 && u == Nt[d + 1] && u & 24 ? f = Nt[d] = u : Nt[d] = 256;
      else if (f == 64) {
        let y = d + 1;
        for (; y < o && Nt[y] == 64; )
          y++;
        let g = d && u == 8 || y < e && Nt[y] == 8 ? p == 1 ? 1 : 8 : 256;
        for (let b = d; b < y; b++)
          Nt[b] = g;
        d = y - 1;
      } else f == 8 && p == 1 && (Nt[d] = 1);
      u = f, f & 7 && (p = f);
    }
  }
}
c(S7, "l0$1");
m(S7, "computeCharTypes");
function C7(n, t, e, i, r) {
  let s = r == 1 ? 2 : 1;
  for (let a = 0, o = 0, l = 0; a <= i.length; a++) {
    let d = a ? i[a - 1].to : t, u = a < i.length ? i[a].from : e;
    for (let p = d, f, y, g; p < u; p++)
      if (y = mk[f = n.charCodeAt(p)])
        if (y < 0) {
          for (let b = o - 3; b >= 0; b -= 3)
            if (Vn[b + 1] == -y) {
              let S = Vn[b + 2], $ = S & 2 ? r : S & 4 ? S & 1 ? s : r : 0;
              $ && (Nt[p] = Nt[Vn[b]] = $), o = b;
              break;
            }
        } else {
          if (Vn.length == 189)
            break;
          Vn[o++] = p, Vn[o++] = f, Vn[o++] = l;
        }
      else if ((g = Nt[p]) == 2 || g == 1) {
        let b = g == r;
        l = b ? 0 : 1;
        for (let S = o - 3; S >= 0; S -= 3) {
          let $ = Vn[S + 2];
          if ($ & 2)
            break;
          if (b)
            Vn[S + 2] |= 2;
          else {
            if ($ & 4)
              break;
            Vn[S + 2] |= 4;
          }
        }
      }
  }
}
c(C7, "a0$1");
m(C7, "processBracketPairs");
function P7(n, t, e, i) {
  for (let r = 0, s = i; r <= e.length; r++) {
    let a = r ? e[r - 1].to : n, o = r < e.length ? e[r].from : t;
    for (let l = a; l < o; ) {
      let d = Nt[l];
      if (d == 256) {
        let u = l + 1;
        for (; ; )
          if (u == o) {
            if (r == e.length)
              break;
            u = e[r++].to, o = r < e.length ? e[r].from : t;
          } else if (Nt[u] == 256)
            u++;
          else
            break;
        let p = s == 1, f = (u < t ? Nt[u] : i) == 1, y = p == f ? p ? 1 : 2 : i;
        for (let g = u, b = r, S = b ? e[b - 1].to : n; g > l; )
          g == S && (g = e[--b].from, S = b ? e[b - 1].to : n), Nt[--g] = y;
        l = u;
      } else
        s = d, l++;
    }
  }
}
c(P7, "h0$1");
m(P7, "processNeutrals");
function cO(n, t, e, i, r, s, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let l = t, d = 0; l < e; ) {
      let u = !0, p = !1;
      if (d == s.length || l < s[d].from) {
        let b = Nt[l];
        b != o && (u = !1, p = b == 16);
      }
      let f = !u && o == 1 ? [] : null, y = u ? i : i + 1, g = l;
      t: for (; ; )
        if (d < s.length && g == s[d].from) {
          if (p)
            break t;
          let b = s[d];
          if (!u)
            for (let S = b.to, $ = d + 1; ; ) {
              if (S == e)
                break t;
              if ($ < s.length && s[$].from == S)
                S = s[$++].to;
              else {
                if (Nt[S] == o)
                  break t;
                break;
              }
            }
          if (d++, f)
            f.push(b);
          else {
            b.from > l && a.push(new Qs(l, b.from, y));
            let S = b.direction == tl != !(y % 2);
            hO(n, S ? i + 1 : i, r, b.inner, b.from, b.to, a), l = b.to;
          }
          g = b.to;
        } else {
          if (g == e || (u ? Nt[g] != o : Nt[g] == o))
            break;
          g++;
        }
      f ? cO(n, l, g, i + 1, r, f, a) : l < g && a.push(new Qs(l, g, y)), l = g;
    }
  else
    for (let l = e, d = s.length; l > t; ) {
      let u = !0, p = !1;
      if (!d || l > s[d - 1].to) {
        let b = Nt[l - 1];
        b != o && (u = !1, p = b == 16);
      }
      let f = !u && o == 1 ? [] : null, y = u ? i : i + 1, g = l;
      t: for (; ; )
        if (d && g == s[d - 1].to) {
          if (p)
            break t;
          let b = s[--d];
          if (!u)
            for (let S = b.from, $ = d; ; ) {
              if (S == t)
                break t;
              if ($ && s[$ - 1].to == S)
                S = s[--$].from;
              else {
                if (Nt[S - 1] == o)
                  break t;
                break;
              }
            }
          if (f)
            f.push(b);
          else {
            b.to < l && a.push(new Qs(b.to, l, y));
            let S = b.direction == tl != !(y % 2);
            hO(n, S ? i + 1 : i, r, b.inner, b.from, b.to, a), l = b.from;
          }
          g = b.from;
        } else {
          if (g == t || (u ? Nt[g - 1] != o : Nt[g - 1] == o))
            break;
          g--;
        }
      f ? cO(n, g, l, i + 1, r, f, a) : g < l && a.push(new Qs(g, l, y)), l = g;
    }
}
c(cO, "Tl$1");
m(cO, "emitSpans");
function hO(n, t, e, i, r, s, a) {
  let o = t % 2 ? 2 : 1;
  S7(n, r, s, i, o), C7(n, r, s, i, o), P7(r, s, i, o), cO(n, r, s, t, e, i, a);
}
c(hO, "Al$1");
m(hO, "computeSectionOrder");
function Q7(n, t, e) {
  if (!n)
    return [new Qs(0, 0, t == qS ? 1 : 0)];
  if (t == tl && !e.length && !yW.test(n))
    return NS(n.length);
  if (e.length)
    for (; n.length > Nt.length; )
      Nt[Nt.length] = 256;
  let i = [], r = t == tl ? 0 : 1;
  return hO(n, r, r, e, 0, n.length, i), i;
}
c(Q7, "f0$1");
m(Q7, "computeOrder");
function NS(n) {
  return [new Qs(0, n, 0)];
}
c(NS, "dd$1");
m(NS, "trivialOrder");
let T7 = "";
function M7(n, t, e, i, r) {
  var s;
  let a = i.head - n.from, o = Qs.find(t, a, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc), l = t[o], d = l.side(r, e);
  if (a == d) {
    let f = o += r ? 1 : -1;
    if (f < 0 || f >= t.length)
      return null;
    l = t[o = f], a = l.side(!r, e), d = l.side(r, e);
  }
  let u = kn(n.text, a, l.forward(r, e));
  (u < l.from || u > l.to) && (u = d), T7 = n.text.slice(Math.min(a, u), Math.max(a, u));
  let p = o == (r ? t.length - 1 : 0) ? null : t[o + (r ? 1 : -1)];
  return p && u == d && p.level + (r ? 0 : 1) < l.level ? it.cursor(p.side(!r, e) + n.from, p.forward(r, e) ? 1 : -1, p.level) : it.cursor(u + n.from, l.forward(r, e) ? -1 : 1, l.level);
}
c(M7, "c0$1");
m(M7, "moveVisually");
function A7(n, t, e) {
  for (let i = t; i < e; i++) {
    let r = ZS(n.charCodeAt(i));
    if (r == 1)
      return tl;
    if (r == 2 || r == 4)
      return qS;
  }
  return tl;
}
c(A7, "u0$1");
m(A7, "autoDirection");
const R7 = /* @__PURE__ */ $t.define(), E7 = /* @__PURE__ */ $t.define(), _7 = /* @__PURE__ */ $t.define(), z7 = /* @__PURE__ */ $t.define(), yk = /* @__PURE__ */ $t.define(), L7 = /* @__PURE__ */ $t.define(), I7 = /* @__PURE__ */ $t.define(), jS = /* @__PURE__ */ $t.define(), BS = /* @__PURE__ */ $t.define(), V7 = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => n.some((t) => t), "combine")
}), gW = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => n.some((t) => t), "combine")
}), D7 = /* @__PURE__ */ $t.define();
var Zs;
const W7 = (Zs = class {
  constructor(t, e = "nearest", i = "nearest", r = 5, s = 5, a = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = r, this.xMargin = s, this.isSnapshot = a;
  }
  map(t) {
    return t.empty ? this : new Zs(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Zs(it.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, c(Zs, "_r"), Zs);
m(W7, "ScrollTarget");
let Vb = W7;
const z1 = /* @__PURE__ */ jt.define({ map: /* @__PURE__ */ m((n, t) => n.map(t), "map") }), q7 = /* @__PURE__ */ jt.define();
function Qi(n, t, e) {
  let i = n.facet(z7);
  i.length ? i[0](t) : window.onerror && window.onerror(String(t), e, void 0, void 0, t) || (e ? console.error(e + ":", t) : console.error(t));
}
c(Qi, "Re$2");
m(Qi, "logException");
const Ar = /* @__PURE__ */ $t.define({ combine: /* @__PURE__ */ m((n) => n.length ? n[0] : !0, "combine") });
let wW = 0;
const nh = /* @__PURE__ */ $t.define({
  combine(n) {
    return n.filter((t, e) => {
      for (let i = 0; i < e; i++)
        if (n[i].plugin == t.plugin)
          return !1;
      return !0;
    });
  }
});
var Xs;
const F7 = (Xs = class {
  constructor(t, e, i, r, s) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = r, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(nh.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(t) {
    return this.baseExtensions.concat(nh.of({ plugin: this, arg: t }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: r, provide: s, decorations: a } = e || {};
    return new Xs(wW++, t, i, r, (o) => {
      let l = [];
      return a && l.push(hw.of((d) => {
        let u = d.plugin(o);
        return u ? a(u) : Jt.none;
      })), s && l.push(s(o)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return Xs.define((i, r) => new t(i, r), e);
  }
}, c(Xs, "Mr"), Xs);
m(F7, "ViewPlugin");
let Br = F7;
var qh;
const Z7 = (qh = class {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (Qi(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(t, this.spec.arg);
      } catch (e) {
        Qi(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Qi(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, c(qh, "of"), qh);
m(Z7, "PluginInstance");
let Db = Z7;
const X7 = /* @__PURE__ */ $t.define(), US = /* @__PURE__ */ $t.define(), hw = /* @__PURE__ */ $t.define(), N7 = /* @__PURE__ */ $t.define(), Kw = /* @__PURE__ */ $t.define(), j7 = /* @__PURE__ */ $t.define();
function gk(n, t) {
  let e = n.state.facet(j7);
  if (!e.length)
    return e;
  let i = e.map((s) => s instanceof Function ? s(n) : s), r = [];
  return hi.spans(i, t.from, t.to, {
    point() {
    },
    span(s, a, o, l) {
      let d = s - t.from, u = a - t.from, p = r;
      for (let f = o.length - 1; f >= 0; f--, l--) {
        let y = o[f].spec.bidiIsolate, g;
        if (y == null && (y = A7(t.text, d, u)), l > 0 && p.length && (g = p[p.length - 1]).to == d && g.direction == y)
          g.to = u, p = g.inner;
        else {
          let b = { from: d, to: u, direction: y, inner: [] };
          p.push(b), p = b.inner;
        }
      }
    }
  }), r;
}
c(gk, "Nc$1");
m(gk, "getIsolatedRanges");
const B7 = /* @__PURE__ */ $t.define();
function O0(n) {
  let t = 0, e = 0, i = 0, r = 0;
  for (let s of n.state.facet(B7)) {
    let a = s(n);
    a && (a.left != null && (t = Math.max(t, a.left)), a.right != null && (e = Math.max(e, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (r = Math.max(r, a.bottom)));
  }
  return { left: t, right: e, top: i, bottom: r };
}
c(O0, "ah$1");
m(O0, "getScrollMargins");
const sg = /* @__PURE__ */ $t.define();
var Wr;
const U7 = (Wr = class {
  constructor(t, e, i, r) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = r;
  }
  join(t) {
    return new Wr(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let r = t[e - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let r = 0, s = 0, a = 0, o = 0; ; r++) {
      let l = r == t.length ? null : t[r], d = a - o, u = l ? l.fromB : 1e9;
      for (; s < e.length && e[s] < u; ) {
        let p = e[s], f = e[s + 1], y = Math.max(o, p), g = Math.min(u, f);
        if (y <= g && new Wr(y + d, g + d, y, g).addToSet(i), f > u)
          break;
        s += 2;
      }
      if (!l)
        return i;
      new Wr(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), a = l.toA, o = l.toB;
    }
  }
}, c(Wr, "Si"), Wr);
m(U7, "ChangedRange");
let Es = U7;
var Po;
const H7 = (Po = class {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = Tn.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let r = [];
    this.changes.iterChangedRanges((s, a, o, l) => r.push(new Es(s, a, o, l))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Po(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}, c(Po, "Js"), Po);
m(H7, "ViewUpdate");
let R3 = H7;
var Fh;
const Y7 = (Fh = class extends Kt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Jt.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new mi()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Es(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: d, toA: u }) => u < this.minWidthFrom || d > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let r = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? r = this.domChanged.newSel.head : !i6(t.changes, this.hasComposition) && !t.selectionSet && (r = t.state.selection.main.head));
    let s = r > -1 ? K7(this.view, t.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: d, to: u } = this.hasComposition;
      i = new Es(d, u, t.changes.mapPos(d, -1), t.changes.mapPos(u, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (nt.ie || nt.chrome) && !s && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.updateDeco(), l = t6(a, o, t.changes);
    return i = Es.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, t.startState.doc.length, s), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = nt.chrome || nt.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || r.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof Gg && a.widget instanceof fk && s.push(a.dom);
    r.updateGaps(s);
  }
  updateChildren(t, e, i) {
    let r = i ? i.range.addToSet(t.slice()) : t, s = this.childCursor(e);
    for (let a = r.length - 1; ; a--) {
      let o = a >= 0 ? r[a] : null;
      if (!o)
        break;
      let { fromA: l, toA: d, fromB: u, toB: p } = o, f, y, g, b;
      if (i && i.range.fromB < p && i.range.toB > u) {
        let z = Ib.build(this.view.state.doc, u, i.range.fromB, this.decorations, this.dynamicDecorationMap), A = Ib.build(this.view.state.doc, i.range.toB, p, this.decorations, this.dynamicDecorationMap);
        y = z.breakAtStart, g = z.openStart, b = A.openEnd;
        let V = this.compositionView(i);
        A.breakAtStart ? V.breakAfter = 1 : A.content.length && V.merge(V.length, V.length, A.content[0], !1, A.openStart, 0) && (V.breakAfter = A.content[0].breakAfter, A.content.shift()), z.content.length && V.merge(0, 0, z.content[z.content.length - 1], !0, 0, z.openEnd) && z.content.pop(), f = z.content.concat(V).concat(A.content);
      } else
        ({ content: f, breakAtStart: y, openStart: g, openEnd: b } = Ib.build(this.view.state.doc, u, p, this.decorations, this.dynamicDecorationMap));
      let { i: S, off: $ } = s.findPos(d, 1), { i: Q, off: E } = s.findPos(l, -1);
      RS(this, Q, E, S, $, f, y, g, b);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(q7) && (this.editContextFormatting = i.value);
  }
  compositionView(t) {
    let e = new ca(t.text.nodeValue);
    e.flags |= 8;
    for (let { deco: r } of t.marks)
      e = new Em(r, [e], e.length);
    let i = new mi();
    return i.append(e, 0), i;
  }
  fixCompositionDOM(t) {
    let e = /* @__PURE__ */ m((s, a) => {
      a.flags |= 8 | (a.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let o = Kt.get(s);
      o && o != a && (o.dom = null), a.setDOM(s);
    }, "fix"), i = this.childPos(t.range.fromB, 1), r = this.children[i.i];
    e(t.line, r);
    for (let s = t.marks.length - 1; s >= -1; s--)
      i = r.childPos(i.off, 1), r = r.children[i.i], e(s >= 0 ? t.marks[s].node : t.text, r);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, s = !r && !(this.view.state.facet(Ar) || this.dom.tabIndex > -1) && Hg(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || e || s))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let o = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(o.anchor)), d = o.empty ? l : this.moveToLine(this.domAtPos(o.head));
    if (nt.gecko && o.empty && !this.hasComposition && G7(l)) {
      let p = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(p, l.node.childNodes[l.offset] || null)), l = d = new Hi(p, 0), a = !0;
    }
    let u = this.view.observer.selectionRange;
    (a || !u.focusNode || (!lh(l.node, l.offset, u.anchorNode, u.anchorOffset) || !lh(d.node, d.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, o)) && (this.view.observer.ignore(() => {
      nt.android && nt.chrome && this.dom.contains(u.focusNode) && e6(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let p = Rm(this.view.root);
      if (p) if (o.empty) {
        if (nt.gecko) {
          let f = J7(l.node, l.offset);
          if (f && f != 3) {
            let y = (f == 1 ? TS : MS)(l.node, l.offset);
            y && (l = new Hi(y.node, y.offset));
          }
        }
        p.collapse(l.node, l.offset), o.bidiLevel != null && p.caretBidiLevel !== void 0 && (p.caretBidiLevel = o.bidiLevel);
      } else if (p.extend) {
        p.collapse(l.node, l.offset);
        try {
          p.extend(d.node, d.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        o.anchor > o.head && ([l, d] = [d, l]), f.setEnd(d.node, d.offset), f.setStart(l.node, l.offset), p.removeAllRanges(), p.addRange(f);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, d)), this.impreciseAnchor = l.precise ? null : new Hi(u.anchorNode, u.anchorOffset), this.impreciseHead = d.precise ? null : new Hi(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && lh(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = Rm(t.root), { anchorNode: r, anchorOffset: s } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let a = mi.find(this, e.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (e.head == o || e.head == o + a.length)
      return;
    let l = this.coordsAt(e.head, -1), d = this.coordsAt(e.head, 1);
    if (!l || !d || l.bottom > d.top)
      return;
    let u = this.domAtPos(e.head + e.assoc);
    i.collapse(u.node, u.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let p = t.observer.selectionRange;
    t.docView.posFromDOM(p.anchorNode, p.anchorOffset) != e.from && i.collapse(r, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let e = this.dom, i;
    if (t.node != e)
      return t;
    for (let r = t.offset; !i && r < e.childNodes.length; r++) {
      let s = Kt.get(e.childNodes[r]);
      s instanceof mi && (i = s.domAtPos(0));
    }
    for (let r = t.offset - 1; !i && r >= 0; r--) {
      let s = Kt.get(e.childNodes[r]);
      s instanceof mi && (i = s.domAtPos(s.length));
    }
    return i ? new Hi(i.node, i.offset, !0) : t;
  }
  nearest(t) {
    for (let e = t; e; ) {
      let i = Kt.get(e);
      if (i && i.rootView == this)
        return i;
      e = e.parentNode;
    }
    return null;
  }
  posFromDOM(t, e) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, e) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: e, off: i } = this.childCursor().findPos(t, -1);
    for (; e < this.children.length - 1; ) {
      let r = this.children[e];
      if (i < r.length || r instanceof mi)
        break;
      e++, i = 0;
    }
    return this.children[e].domAtPos(i);
  }
  coordsAt(t, e) {
    let i = null, r = 0;
    for (let s = this.length, a = this.children.length - 1; a >= 0; a--) {
      let o = this.children[a], l = s - o.breakAfter, d = l - o.length;
      if (l < t)
        break;
      if (d <= t && (d < t || o.covers(-1)) && (l > t || o.covers(1)) && (!i || o instanceof mi && !(i instanceof mi && e >= 0)))
        i = o, r = d;
      else if (i && d == t && l == t && o instanceof Gg && Math.abs(e) < 2) {
        if (o.deco.startSide < 0)
          break;
        a && (i = null);
      }
      s = d;
    }
    return i ? i.coordsAt(t - r, e) : null;
  }
  coordsForChar(t) {
    let { i: e, off: i } = this.childPos(t, 1), r = this.children[e];
    if (!(r instanceof mi))
      return null;
    for (; r.children.length; ) {
      let { i: o, off: l } = r.childPos(i, 1);
      for (; ; o++) {
        if (o == r.children.length)
          return null;
        if ((r = r.children[o]).length)
          break;
      }
      i = l;
    }
    if (!(r instanceof ca))
      return null;
    let s = kn(r.text, i);
    if (s == i)
      return null;
    let a = la(r.dom, i, s).getClientRects();
    for (let o = 0; o < a.length; o++) {
      let l = a[o];
      if (o == a.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: r } = t, s = this.view.contentDOM.clientWidth, a = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, l = this.view.textDirection == Pe.LTR;
    for (let d = 0, u = 0; u < this.children.length; u++) {
      let p = this.children[u], f = d + p.length;
      if (f > r)
        break;
      if (d >= i) {
        let y = p.dom.getBoundingClientRect();
        if (e.push(y.height), a) {
          let g = p.dom.lastChild, b = g ? Jo(g) : [];
          if (b.length) {
            let S = b[b.length - 1], $ = l ? S.right - y.left : y.right - S.left;
            $ > o && (o = $, this.minWidth = s, this.minWidthFrom = d, this.minWidthTo = f);
          }
        }
      }
      d = f + p.breakAfter;
    }
    return e;
  }
  textDirectionAt(t) {
    let { i: e } = this.childPos(t, 1);
    return getComputedStyle(this.children[e].dom).direction == "rtl" ? Pe.RTL : Pe.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof mi) {
        let a = s.measureTextSize();
        if (a)
          return a;
      }
    let t = document.createElement("div"), e, i, r;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let s = Jo(t.firstChild)[0];
      e = t.getBoundingClientRect().height, i = s ? s.width / 27 : 7, r = s ? s.height : e, t.remove();
    }), { lineHeight: e, charWidth: i, textHeight: r };
  }
  childCursor(t = this.length) {
    let e = this.children.length;
    return e && (t -= this.children[--e].length), new r7(this.children, t, e);
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let s = r == e.viewports.length ? null : e.viewports[r], a = s ? s.from - 1 : this.length;
      if (a > i) {
        let o = (e.lineBlockAt(a).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(Jt.replace({
          widget: new fk(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return Jt.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(hw).map((s) => (this.dynamicDecorationMap[t++] = typeof s == "function") ? s(this.view) : s), i = !1, r = this.view.state.facet(N7).map((s, a) => {
      let o = typeof s == "function";
      return o && (i = !0), o ? s(this.view) : s;
    });
    for (r.length && (this.dynamicDecorationMap[t++] = i, e.push(hi.join(r))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let d = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = d.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let d of this.view.state.facet(D7))
      try {
        if (d(this.view, t.range, t))
          return !0;
      } catch (u) {
        Qi(this.view.state, u, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), r;
    if (!i)
      return;
    !e.empty && (r = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let s = O0(this.view), a = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: o, offsetHeight: l } = this.view.scrollDOM;
    Y8(this.view.scrollDOM, a, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, o), -o), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == Pe.LTR);
  }
  lineHasWidget(t) {
    let { i: e } = this.childCursor().findPos(t);
    if (e == this.children.length)
      return !1;
    let i = /* @__PURE__ */ m((r) => r instanceof _S || r.children.some(i), "scan");
    return i(this.children[e]);
  }
}, c(Fh, "lf"), Fh);
m(Y7, "DocView");
let E3 = Y7;
function G7(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
c(G7, "p0$1");
m(G7, "betweenUneditable");
function HS(n, t) {
  let e = n.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = TS(e.focusNode, e.focusOffset), r = MS(e.focusNode, e.focusOffset), s = i || r;
  if (r && i && r.node != i.node) {
    let o = Kt.get(r.node);
    if (!o || o instanceof ca && o.text != r.node.nodeValue)
      s = r;
    else if (n.docView.lastCompositionAfterCursor) {
      let l = Kt.get(i.node);
      !l || l instanceof ca && l.text != i.node.nodeValue || (s = r);
    }
  }
  if (n.docView.lastCompositionAfterCursor = s != i, !s)
    return null;
  let a = t - s.offset;
  return { from: a, to: a + s.node.nodeValue.length, node: s.node };
}
c(HS, "Td$1");
m(HS, "findCompositionNode");
function K7(n, t, e) {
  let i = HS(n, e);
  if (!i)
    return null;
  let { node: r, from: s, to: a } = i, o = r.nodeValue;
  if (/[\n\r]/.test(o) || n.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let l = t.invertedDesc, d = new Es(l.mapPos(s), l.mapPos(a), s, a), u = [];
  for (let p = r.parentNode; ; p = p.parentNode) {
    let f = Kt.get(p);
    if (f instanceof Em)
      u.push({ node: p, deco: f.mark });
    else {
      if (f instanceof mi || p.nodeName == "DIV" && p.parentNode == n.contentDOM)
        return { range: d, text: r, marks: u, line: p };
      if (p != n.contentDOM)
        u.push({ node: p, deco: new VS({
          inclusive: !0,
          attributes: u7(p),
          tagName: p.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
c(K7, "m0$1");
m(K7, "findCompositionRange");
function J7(n, t) {
  return n.nodeType != 1 ? 0 : (t && n.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < n.childNodes.length && n.childNodes[t].contentEditable == "false" ? 2 : 0);
}
c(J7, "g0$1");
m(J7, "nextToUneditable");
var Wb, Zh;
let vW = (Wb = (Zh = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    Yg(t, e, this.changes);
  }
  comparePoint(t, e) {
    Yg(t, e, this.changes);
  }
  boundChange(t) {
    Yg(t, t, this.changes);
  }
}, c(Zh, "Ai$1"), Zh), m(Wb, "DecorationComparator"), Wb);
function t6(n, t, e) {
  let i = new vW();
  return hi.compare(n, t, e, i), i.changes;
}
c(t6, "y0$1");
m(t6, "findChangedDeco");
function e6(n, t) {
  for (let e = n; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
c(e6, "S0$1");
m(e6, "inUneditable");
function i6(n, t) {
  let e = !1;
  return t && n.iterChangedRanges((i, r) => {
    i < t.to && r > t.from && (e = !0);
  }), e;
}
c(i6, "b0$1");
m(i6, "touchesComposition");
function n6(n, t, e = 1) {
  let i = n.charCategorizer(t), r = n.doc.lineAt(t), s = t - r.from;
  if (r.length == 0)
    return it.cursor(t);
  s == 0 ? e = 1 : s == r.length && (e = -1);
  let a = s, o = s;
  e < 0 ? a = kn(r.text, s, !1) : o = kn(r.text, s);
  let l = i(r.text.slice(a, o));
  for (; a > 0; ) {
    let d = kn(r.text, a, !1);
    if (i(r.text.slice(d, a)) != l)
      break;
    a = d;
  }
  for (; o < r.length; ) {
    let d = kn(r.text, o);
    if (i(r.text.slice(o, d)) != l)
      break;
    o = d;
  }
  return it.range(a + r.from, o + r.from);
}
c(n6, "w0$1");
m(n6, "groupAt");
function r6(n, t) {
  return t.left > n ? t.left - n : Math.max(0, n - t.right);
}
c(r6, "x0$1");
m(r6, "getdx");
function s6(n, t) {
  return t.top > n ? t.top - n : Math.max(0, n - t.bottom);
}
c(s6, "P0$1");
m(s6, "getdy");
function cv(n, t) {
  return n.top < t.bottom - 1 && n.bottom > t.top + 1;
}
c(cv, "Ao$1");
m(cv, "yOverlap");
function wk(n, t) {
  return t < n.top ? { top: t, left: n.left, right: n.right, bottom: n.bottom } : n;
}
c(wk, "Gc$1");
m(wk, "upTop");
function vk(n, t) {
  return t > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: t } : n;
}
c(vk, "Fc$1");
m(vk, "upBot");
function dO(n, t, e) {
  let i, r, s, a, o = !1, l, d, u, p;
  for (let g = n.firstChild; g; g = g.nextSibling) {
    let b = Jo(g);
    for (let S = 0; S < b.length; S++) {
      let $ = b[S];
      r && cv(r, $) && ($ = wk(vk($, r.bottom), r.top));
      let Q = r6(t, $), E = s6(e, $);
      if (Q == 0 && E == 0)
        return g.nodeType == 3 ? Ok(g, t, e) : dO(g, t, e);
      (!i || a > E || a == E && s > Q) && (i = g, r = $, s = Q, a = E, o = Q ? t < $.left ? S > 0 : S < b.length - 1 : !0), Q == 0 ? e > $.bottom && (!u || u.bottom < $.bottom) ? (l = g, u = $) : e < $.top && (!p || p.top > $.top) && (d = g, p = $) : u && cv(u, $) ? u = vk(u, $.bottom) : p && cv(p, $) && (p = wk(p, $.top));
    }
  }
  if (u && u.bottom >= e ? (i = l, r = u) : p && p.top <= e && (i = d, r = p), !i)
    return { node: n, offset: 0 };
  let f = Math.max(r.left, Math.min(r.right, t));
  if (i.nodeType == 3)
    return Ok(i, f, e);
  if (o && i.contentEditable != "false")
    return dO(i, f, e);
  let y = Array.prototype.indexOf.call(n.childNodes, i) + (t >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: n, offset: y };
}
c(dO, "_l$1");
m(dO, "domPosAtCoords");
function Ok(n, t, e) {
  let i = n.nodeValue.length, r = -1, s = 1e9, a = 0;
  for (let o = 0; o < i; o++) {
    let l = la(n, o, o + 1).getClientRects();
    for (let d = 0; d < l.length; d++) {
      let u = l[d];
      if (u.top == u.bottom)
        continue;
      a || (a = t - u.left);
      let p = (u.top > e ? u.top - e : e - u.bottom) - 1;
      if (u.left - 1 <= t && u.right + 1 >= t && p < s) {
        let f = t >= (u.left + u.right) / 2, y = f;
        if (nt.chrome || nt.gecko) {
          let g = la(n, o).getBoundingClientRect();
          Math.abs(g.left - u.right) < 0.1 && (y = !f);
        }
        if (p <= 0)
          return { node: n, offset: o + (y ? 1 : 0) };
        r = o + (y ? 1 : 0), s = p;
      }
    }
  }
  return { node: n, offset: r > -1 ? r : a > 0 ? n.nodeValue.length : 0 };
}
c(Ok, "Hc$1");
m(Ok, "domPosInText");
function YS(n, t, e, i = -1) {
  var r, s;
  let a = n.contentDOM.getBoundingClientRect(), o = a.top + n.viewState.paddingTop, l, { docHeight: d } = n.viewState, { x: u, y: p } = t, f = p - o;
  if (f < 0)
    return 0;
  if (f > d)
    return n.state.doc.length;
  for (let z = n.viewState.heightOracle.textHeight / 2, A = !1; l = n.elementAtHeight(f), l.type != sr.Text; )
    for (; f = i > 0 ? l.bottom + z : l.top - z, !(f >= 0 && f <= d); ) {
      if (A)
        return e ? null : 0;
      A = !0, i = -i;
    }
  p = o + f;
  let y = l.from;
  if (y < n.viewport.from)
    return n.viewport.from == 0 ? 0 : e ? null : bk(n, a, l, u, p);
  if (y > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : e ? null : bk(n, a, l, u, p);
  let g = n.dom.ownerDocument, b = n.root.elementFromPoint ? n.root : g, S = b.elementFromPoint(u, p);
  S && !n.contentDOM.contains(S) && (S = null), S || (u = Math.max(a.left + 1, Math.min(a.right - 1, u)), S = b.elementFromPoint(u, p), S && !n.contentDOM.contains(S) && (S = null));
  let $, Q = -1;
  if (S && ((r = n.docView.nearest(S)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (g.caretPositionFromPoint) {
      let z = g.caretPositionFromPoint(u, p);
      z && ({ offsetNode: $, offset: Q } = z);
    } else if (g.caretRangeFromPoint) {
      let z = g.caretRangeFromPoint(u, p);
      z && ({ startContainer: $, startOffset: Q } = z);
    }
    $ && (!n.contentDOM.contains($) || nt.safari && a6($, Q, u) || nt.chrome && o6($, Q, u)) && ($ = void 0), $ && (Q = Math.min(Mn($), Q));
  }
  if (!$ || !n.docView.dom.contains($)) {
    let z = mi.find(n.docView, y);
    if (!z)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: $, offset: Q } = dO(z.dom, u, p));
  }
  let E = n.docView.nearest($);
  if (!E)
    return null;
  if (E.isWidget && ((s = E.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let z = E.dom.getBoundingClientRect();
    return t.y < z.top || t.y <= z.bottom && t.x <= (z.left + z.right) / 2 ? E.posAtStart : E.posAtEnd;
  } else
    return E.localPosFromDOM($, Q) + E.posAtStart;
}
c(YS, "Ad$1");
m(YS, "posAtCoords");
function bk(n, t, e, i, r) {
  let s = Math.round((i - t.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && e.height > n.defaultLineHeight * 1.5) {
    let o = n.viewState.heightOracle.textHeight, l = Math.floor((r - e.top - (n.defaultLineHeight - o) * 0.5) / o);
    s += l * n.viewState.heightOracle.lineLength;
  }
  let a = n.state.sliceDoc(e.from, e.to);
  return e.from + X8(a, s, n.state.tabSize);
}
c(bk, "Kc$1");
m(bk, "posAtCoordsImprecise");
function GS(n, t, e) {
  let i, r = n;
  if (n.nodeType != 3 || t != (i = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = r.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let a = r.parentNode;
      if (!a || a.nodeName == "DIV")
        break;
      r = a;
    }
  }
  return la(n, i - 1, i).getBoundingClientRect().right > e;
}
c(GS, "Ld$1");
m(GS, "isEndOfLineBefore");
function a6(n, t, e) {
  return GS(n, t, e);
}
c(a6, "k0$1");
m(a6, "isSuspiciousSafariCaretResult");
function o6(n, t, e) {
  if (t != 0)
    return GS(n, t, e);
  for (let r = n; ; ) {
    let s = r.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != r)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    r = s;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : la(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return e - i.left > 5;
}
c(o6, "$0$1");
m(o6, "isSuspiciousChromeCaretResult");
function l6(n, t, e) {
  let i = n.lineBlockAt(t);
  if (Array.isArray(i.type)) {
    let r;
    for (let s of i.type) {
      if (s.from > t)
        break;
      if (!(s.to < t)) {
        if (s.from < t && s.to > t)
          return s;
        (!r || s.type == sr.Text && (r.type != s.type || (e < 0 ? s.from < t : s.to > t))) && (r = s);
      }
    }
    return r || i;
  }
  return i;
}
c(l6, "R0$1");
m(l6, "blockAt");
function c6(n, t, e, i) {
  let r = l6(n, t.head, t.assoc || -1), s = !i || r.type != sr.Text || !(n.lineWrapping || r.widgetLineBreaks) ? null : n.coordsAtPos(t.assoc < 0 && t.head > r.from ? t.head - 1 : t.head);
  if (s) {
    let a = n.dom.getBoundingClientRect(), o = n.textDirectionAt(r.from), l = n.posAtCoords({
      x: e == (o == Pe.LTR) ? a.right - 1 : a.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return it.cursor(l, e ? -1 : 1);
  }
  return it.cursor(e ? r.to : r.from, e ? -1 : 1);
}
c(c6, "v0$1");
m(c6, "moveToLineBoundary");
function $k(n, t, e, i) {
  let r = n.state.doc.lineAt(t.head), s = n.bidiSpans(r), a = n.textDirectionAt(r.from);
  for (let o = t, l = null; ; ) {
    let d = M7(r, s, a, o, e), u = T7;
    if (!d) {
      if (r.number == (e ? n.state.doc.lines : 1))
        return o;
      u = `
`, r = n.state.doc.line(r.number + (e ? 1 : -1)), s = n.bidiSpans(r), d = n.visualLineSide(r, !e);
    }
    if (l) {
      if (!l(u))
        return o;
    } else {
      if (!i)
        return d;
      l = i(u);
    }
    o = d;
  }
}
c($k, "Jc$1");
m($k, "moveByChar");
function h6(n, t, e) {
  let i = n.state.charCategorizer(t), r = i(e);
  return (s) => {
    let a = i(s);
    return r == _r.Space && (r = a), r == a;
  };
}
c(h6, "T0$1");
m(h6, "byGroup");
function d6(n, t, e, i) {
  let r = t.head, s = e ? 1 : -1;
  if (r == (e ? n.state.doc.length : 0))
    return it.cursor(r, t.assoc);
  let a = t.goalColumn, o, l = n.contentDOM.getBoundingClientRect(), d = n.coordsAtPos(r, t.assoc || -1), u = n.documentTop;
  if (d)
    a == null && (a = d.left - l.left), o = s < 0 ? d.top : d.bottom;
  else {
    let y = n.viewState.lineBlockAt(r);
    a == null && (a = Math.min(l.right - l.left, n.defaultCharacterWidth * (r - y.from))), o = (s < 0 ? y.top : y.bottom) + u;
  }
  let p = l.left + a, f = i ?? n.viewState.heightOracle.textHeight >> 1;
  for (let y = 0; ; y += 10) {
    let g = o + (f + y) * s, b = YS(n, { x: p, y: g }, !1, s);
    if (g < l.top || g > l.bottom || (s < 0 ? b < r : b > r)) {
      let S = n.docView.coordsForChar(b), $ = !S || g < S.top ? -1 : 1;
      return it.cursor(b, $, void 0, a);
    }
  }
}
c(d6, "A0$1");
m(d6, "moveVertically");
function ch(n, t, e) {
  for (; ; ) {
    let i = 0;
    for (let r of n)
      r.between(t - 1, t + 1, (s, a, o) => {
        if (t > s && t < a) {
          let l = i || e || (t - s < a - t ? -1 : 1);
          t = l < 0 ? s : a, i = l;
        }
      });
    if (!i)
      return t;
  }
}
c(ch, "Sr$1");
m(ch, "skipAtomicRanges");
function KS(n, t) {
  let e = null;
  for (let i = 0; i < t.ranges.length; i++) {
    let r = t.ranges[i], s = null;
    if (r.empty) {
      let a = ch(n, r.from, 0);
      a != r.from && (s = it.cursor(a, -1));
    } else {
      let a = ch(n, r.from, -1), o = ch(n, r.to, 1);
      (a != r.from || o != r.to) && (s = it.range(r.from == r.anchor ? a : o, r.from == r.head ? a : o));
    }
    s && (e || (e = t.ranges.slice()), e[i] = s);
  }
  return e ? it.create(e, t.mainIndex) : t;
}
c(KS, "_d$1");
m(KS, "skipAtomsForSelection");
function hv(n, t, e) {
  let i = ch(n.state.facet(Kw).map((r) => r(n)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : it.cursor(i, i < e.from ? 1 : -1);
}
c(hv, "Lo$1");
m(hv, "skipAtoms");
const ag = "￿";
var Xh;
const u6 = (Xh = class {
  constructor(t, e) {
    this.points = t, this.text = "", this.lineSeparator = e.facet(Le.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += ag;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let r = t; ; ) {
      this.findPointBefore(i, r);
      let s = this.text.length;
      this.readNode(r);
      let a = r.nextSibling;
      if (a == e)
        break;
      let o = Kt.get(r), l = Kt.get(a);
      (o && l ? o.breakAfter : (o ? o.breakAfter : lw(r)) || lw(a) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > s) && !f6(a, e) && this.lineBreak(), r = a;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, a = 1, o;
      if (this.lineSeparator ? (s = e.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = r.exec(e)) && (s = o.index, a = o[0].length), this.append(e.slice(i, s < 0 ? e.length : s)), s < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= a - 1);
      i = s + a;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let e = Kt.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (p6(t, i.node, i.offset) ? e : 0));
  }
}, c(Xh, "af"), Xh);
m(u6, "DOMReader");
let OW = u6;
function p6(n, t, e) {
  for (; ; ) {
    if (!t || e < Mn(t))
      return !1;
    if (t == n)
      return !0;
    e = oa(t) + 1, t = t.parentNode;
  }
}
c(p6, "L0$1");
m(p6, "isAtEnd");
function f6(n, t) {
  let e;
  for (; !(n == t || !n); n = n.nextSibling) {
    let i = Kt.get(n);
    if (!(i?.isWidget || n.cmIgnore))
      return !1;
    i && (e || (e = [])).push(i);
  }
  if (e) {
    for (let i of e)
      if (i.overrideDOMText?.length)
        return !1;
  }
  return !0;
}
c(f6, "_0$1");
m(f6, "isEmptyToEnd");
var Nh;
const m6 = (Nh = class {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}, c(Nh, "hf"), Nh);
m(m6, "DOMPoint");
let _3 = m6;
var jh;
const y6 = (jh = class {
  constructor(t, e, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: s, impreciseAnchor: a } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = t.docView.domBoundsAround(e, i, 0))) {
      let o = s || a ? [] : w6(t), l = new OW(o, t.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = v6(o, this.bounds.from);
    } else {
      let o = t.observer.selectionRange, l = s && s.node == o.focusNode && s.offset == o.focusOffset || !aO(t.contentDOM, o.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(o.focusNode, o.focusOffset), d = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !aO(t.contentDOM, o.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(o.anchorNode, o.anchorOffset), u = t.viewport;
      if ((nt.ios || nt.chrome) && t.state.selection.main.empty && l != d && (u.from > 0 || u.to < t.state.doc.length)) {
        let p = Math.min(l, d), f = Math.max(l, d), y = u.from - p, g = u.to - f;
        (y == 0 || y == 1 || p == 0) && (g == 0 || g == -1 || f == t.state.doc.length) && (l = 0, d = t.state.doc.length);
      }
      t.inputState.composing > -1 && t.state.selection.ranges.length > 1 ? this.newSel = t.state.selection.replaceRange(it.range(d, l)) : this.newSel = it.single(d, l);
    }
  }
}, c(jh, "ff"), jh);
m(y6, "DOMChange");
let bW = y6;
function JS(n, t) {
  let e, { newSel: i } = t, r = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: a, to: o } = t.bounds, l = r.from, d = null;
    (s === 8 || nt.android && t.text.length < o - a) && (l = r.to, d = "end");
    let u = tC(n.state.doc.sliceString(a, o, ag), t.text, l - a, d);
    u && (nt.chrome && s == 13 && u.toB == u.from + 2 && t.text.slice(u.from, u.toB) == ag + ag && u.toB--, e = {
      from: a + u.from,
      to: a + u.toA,
      insert: Dt.of(t.text.slice(u.from, u.toB).split(ag))
    });
  } else i && (!n.hasFocus && n.state.facet(Ar) || i.main.eq(r)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !r.empty && i && i.main.empty ? e = { from: r.from, to: r.to, insert: n.state.doc.slice(r.from, r.to) } : (nt.mac || nt.android) && e && e.from == e.to && e.from == r.head - 1 && /^\. ?$/.test(e.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = it.single(i.main.anchor - 1, i.main.head - 1)), e = { from: e.from, to: e.to, insert: Dt.of([e.insert.toString().replace(".", " ")]) }) : e && e.from >= r.from && e.to <= r.to && (e.from != r.from || e.to != r.to) && r.to - r.from - (e.to - e.from) <= 4 ? e = {
    from: r.from,
    to: r.to,
    insert: n.state.doc.slice(r.from, e.from).append(e.insert).append(n.state.doc.slice(e.to, r.to))
  } : n.state.doc.lineAt(r.from).to < r.to && n.docView.lineHasWidget(r.to) && n.inputState.insertingTextAt > Date.now() - 50 ? e = {
    from: r.from,
    to: r.to,
    insert: n.state.toText(n.inputState.insertingText)
  } : nt.chrome && e && e.from == e.to && e.from == r.head && e.insert.toString() == `
 ` && n.lineWrapping && (i && (i = it.single(i.main.anchor - 1, i.main.head - 1)), e = { from: r.from, to: r.to, insert: Dt.of([" "]) }), e)
    return b0(n, e, i, s);
  if (i && !i.main.eq(r)) {
    let a = !1, o = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (a = !0), o = n.inputState.lastSelectionOrigin, o == "select.pointer" && (i = KS(n.state.facet(Kw).map((l) => l(n)), i))), n.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
c(JS, "Md$1");
m(JS, "applyDOMChange");
function b0(n, t, e, i = -1) {
  if (nt.ios && n.inputState.flushIOSKey(t))
    return !0;
  let r = n.state.selection.main;
  if (nt.android && (t.to == r.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == r.from || t.from == r.from - 1 && n.state.sliceDoc(t.from, r.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && ao(n.contentDOM, "Enter", 13) || (t.from == r.from - 1 && t.to == r.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > r.head) && ao(n.contentDOM, "Backspace", 8) || t.from == r.from && t.to == r.to + 1 && t.insert.length == 0 && ao(n.contentDOM, "Delete", 46)))
    return !0;
  let s = t.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let a, o = /* @__PURE__ */ m(() => a || (a = g6(n, t, e)), "defaultInsert");
  return n.state.facet(L7).some((l) => l(n, t.from, t.to, s, o)) || n.dispatch(o()), !0;
}
c(b0, "hh");
m(b0, "applyDOMChangeInner");
function g6(n, t, e) {
  let i, r = n.state, s = r.selection.main, a = -1;
  if (t.from == t.to && t.from < s.from || t.from > s.to) {
    let l = t.from < s.from ? -1 : 1, d = l < 0 ? s.from : s.to, u = ch(r.facet(Kw).map((p) => p(n)), d, l);
    t.from == u && (a = u);
  }
  if (a > -1)
    i = {
      changes: t,
      selection: it.cursor(t.from + t.insert.length, -1)
    };
  else if (t.from >= s.from && t.to <= s.to && t.to - t.from >= (s.to - s.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && n.inputState.composing < 0) {
    let l = s.from < t.from ? r.sliceDoc(s.from, t.from) : "", d = s.to > t.to ? r.sliceDoc(t.to, s.to) : "";
    i = r.replaceSelection(n.state.toText(l + t.insert.sliceString(0, void 0, n.state.lineBreak) + d));
  } else {
    let l = r.changes(t), d = e && e.main.to <= l.newLength ? e.main : void 0;
    if (r.selection.ranges.length > 1 && (n.inputState.composing >= 0 || n.inputState.compositionPendingChange) && t.to <= s.to + 10 && t.to >= s.to - 10) {
      let u = n.state.sliceDoc(t.from, t.to), p, f = e && HS(n, e.main.head);
      if (f) {
        let g = t.insert.length - (t.to - t.from);
        p = { from: f.from, to: f.to - g };
      } else
        p = n.state.doc.lineAt(s.head);
      let y = s.to - t.to;
      i = r.changeByRange((g) => {
        if (g.from == s.from && g.to == s.to)
          return { changes: l, range: d || g.map(l) };
        let b = g.to - y, S = b - u.length;
        if (n.state.sliceDoc(S, b) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        b >= p.from && S <= p.to)
          return { range: g };
        let $ = r.changes({ from: S, to: b, insert: t.insert }), Q = g.to - s.to;
        return {
          changes: $,
          range: d ? it.range(Math.max(0, d.anchor + Q), Math.max(0, d.head + Q)) : g.map($)
        };
      });
    } else
      i = {
        changes: l,
        selection: d && r.selection.replaceRange(d)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: o, scrollIntoView: !0 });
}
c(g6, "M0$1");
m(g6, "applyDefaultInsert");
function tC(n, t, e, i) {
  let r = Math.min(n.length, t.length), s = 0;
  for (; s < r && n.charCodeAt(s) == t.charCodeAt(s); )
    s++;
  if (s == r && n.length == t.length)
    return null;
  let a = n.length, o = t.length;
  for (; a > 0 && o > 0 && n.charCodeAt(a - 1) == t.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let l = Math.max(0, s - Math.min(a, o));
    e -= a + l - s;
  }
  if (a < s && n.length < t.length) {
    let l = e <= s && e >= a ? s - e : 0;
    s -= l, o = s + (o - a), a = s;
  } else if (o < s) {
    let l = e <= s && e >= o ? s - e : 0;
    s -= l, a = s + (a - o), o = s;
  }
  return { from: s, toA: a, toB: o };
}
c(tC, "Zd$1");
m(tC, "findDiff");
function w6(n) {
  let t = [];
  if (n.root.activeElement != n.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: r, focusOffset: s } = n.observer.selectionRange;
  return e && (t.push(new _3(e, i)), (r != e || s != i) && t.push(new _3(r, s))), t;
}
c(w6, "Z0$1");
m(w6, "selectionPoints");
function v6(n, t) {
  if (n.length == 0)
    return null;
  let e = n[0].pos, i = n.length == 2 ? n[1].pos : e;
  return e > -1 && i > -1 ? it.single(e + t, i + t) : null;
}
c(v6, "C0$1");
m(v6, "selectionFromPoints");
var Bh;
const O6 = (Bh = class {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.insertingText = "", this.insertingTextAt = 0, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, nt.safari && t.contentDOM.addEventListener("input", () => null), nt.gecko && V6(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !T6(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(t.type, t)) : this.runHandlers(t.type, t));
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let r of i.observers)
        r(this.view, e);
      for (let r of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (r(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = b6(t), i = this.handlers, r = this.view.contentDOM;
    for (let s in e)
      if (s != "scroll") {
        let a = !e[s].handlers.length, o = i[s];
        o && a != !o.handlers.length && (r.removeEventListener(s, this.handleEvent), o = null), o || r.addEventListener(s, this.handleEvent, { passive: a });
      }
    for (let s in i)
      s != "scroll" && !e[s] && r.removeEventListener(s, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && x6.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), nt.android && nt.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return nt.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = $6.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || xW.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ao(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return !/^key/.test(t.type) || t.synthetic ? !1 : this.composing > 0 ? !0 : nt.safari && !nt.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}, c(Bh, "cf"), Bh);
m(O6, "InputState");
let $W = O6;
function xk(n, t) {
  return (e, i) => {
    try {
      return t.call(n, i, e);
    } catch (r) {
      Qi(e.state, r);
    }
  };
}
c(xk, "eu$1");
m(xk, "bindHandler");
function b6(n) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  c(e, "t"), m(e, "record");
  for (let i of n) {
    let r = i.spec, s = r && r.plugin.domEventHandlers, a = r && r.plugin.domEventObservers;
    if (s)
      for (let o in s) {
        let l = s[o];
        l && e(o).handlers.push(xk(i.value, l));
      }
    if (a)
      for (let o in a) {
        let l = a[o];
        l && e(o).observers.push(xk(i.value, l));
      }
  }
  for (let i in An)
    e(i).handlers.push(An[i]);
  for (let i in cn)
    e(i).observers.push(cn[i]);
  return t;
}
c(b6, "X0$1");
m(b6, "computeHandlers");
const $6 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], xW = "dthko", x6 = [16, 17, 18, 20, 91, 92, 224, 225], L1 = 6;
function og(n) {
  return Math.max(0, n) * 0.7 + 8;
}
c(og, "Zn$1");
m(og, "dragScrollSpeed");
function k6(n, t) {
  return Math.max(Math.abs(n.clientX - t.clientX), Math.abs(n.clientY - t.clientY));
}
c(k6, "Y0$1");
m(k6, "dist");
var Uh;
const S6 = (Uh = class {
  constructor(t, e, i, r) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = G8(t.contentDOM), this.atoms = t.state.facet(Kw).map((a) => a(t));
    let s = t.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(Le.allowMultipleSelections) && C6(t, e), this.dragging = Q6(t, e) && iC(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && k6(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, r = 0, s = 0, a = this.view.win.innerWidth, o = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: r, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: o } = this.scrollParents.y.getBoundingClientRect());
    let l = O0(this.view);
    t.clientX - l.left <= r + L1 ? e = -og(r - t.clientX) : t.clientX + l.right >= a - L1 && (e = og(t.clientX - a)), t.clientY - l.top <= s + L1 ? i = -og(s - t.clientY) : t.clientY + l.bottom >= o - L1 && (i = og(t.clientY - o)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(t) {
    let { view: e } = this, i = KS(this.atoms, this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, c(Uh, "uf"), Uh);
m(S6, "MouseSelection");
let kW = S6;
function C6(n, t) {
  let e = n.state.facet(R7);
  return e.length ? e[0](t) : nt.mac ? t.metaKey : t.ctrlKey;
}
c(C6, "V0$1");
m(C6, "addsSelectionRange");
function P6(n, t) {
  let e = n.state.facet(E7);
  return e.length ? e[0](t) : nt.mac ? !t.altKey : !t.ctrlKey;
}
c(P6, "W0$1");
m(P6, "dragMovesSelection");
function Q6(n, t) {
  let { main: e } = n.state.selection;
  if (e.empty)
    return !1;
  let i = Rm(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < r.length; s++) {
    let a = r[s];
    if (a.left <= t.clientX && a.right >= t.clientX && a.top <= t.clientY && a.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
c(Q6, "U0$1");
m(Q6, "isInPrimarySelection");
function T6(n, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != n.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = Kt.get(e)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
c(T6, "I0$1");
m(T6, "eventBelongsToEditor");
const An = /* @__PURE__ */ Object.create(null), cn = /* @__PURE__ */ Object.create(null), M6 = nt.ie && nt.ie_version < 15 || nt.ios && nt.webkit_version < 604;
function A6(n) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    n.focus(), e.remove(), eC(n, e.value);
  }, 50);
}
c(A6, "z0$1");
m(A6, "capturePaste");
function Jw(n, t, e) {
  for (let i of n.facet(t))
    e = i(e, n);
  return e;
}
c(Jw, "So$1");
m(Jw, "textFilter");
function eC(n, t) {
  t = Jw(n.state, jS, t);
  let { state: e } = n, i, r = 1, s = e.toText(t), a = s.lines == e.selection.ranges.length;
  if (Pk != null && e.selection.ranges.every((o) => o.empty) && Pk == s.toString()) {
    let o = -1;
    i = e.changeByRange((l) => {
      let d = e.doc.lineAt(l.from);
      if (d.from == o)
        return { range: l };
      o = d.from;
      let u = e.toText((a ? s.line(r++).text : t) + e.lineBreak);
      return {
        changes: { from: d.from, insert: u },
        range: it.cursor(l.from + u.length)
      };
    });
  } else a ? i = e.changeByRange((o) => {
    let l = s.line(r++);
    return {
      changes: { from: o.from, to: o.to, insert: l.text },
      range: it.cursor(o.from + l.length)
    };
  }) : i = e.replaceSelection(s);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
c(eC, "Yd$1");
m(eC, "doPaste");
cn.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
An.keydown = (n, t) => (n.inputState.setSelectionOrigin("select"), t.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
cn.touchstart = (n, t) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
cn.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
An.mousedown = (n, t) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of n.state.facet(_7))
    if (e = i(n, t), e)
      break;
  if (!e && t.button == 0 && (e = E6(n, t)), e) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new kW(n, t, e, i)), i && n.observer.ignore(() => {
      CS(n.contentDOM);
      let s = n.root.activeElement;
      s && !s.contains(n.contentDOM) && s.blur();
    });
    let r = n.inputState.mouseSelection;
    if (r)
      return r.start(t), r.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function kk(n, t, e, i) {
  if (i == 1)
    return it.cursor(t, e);
  if (i == 2)
    return n6(n.state, t, e);
  {
    let r = mi.find(n.docView, t), s = n.state.doc.lineAt(r ? r.posAtEnd : t), a = r ? r.posAtStart : s.from, o = r ? r.posAtEnd : s.to;
    return o < n.state.doc.length && o == s.to && o++, it.range(a, o);
  }
}
c(kk, "tu$1");
m(kk, "rangeForClick");
let z3 = /* @__PURE__ */ m((n, t, e) => t >= e.top && t <= e.bottom && n >= e.left && n <= e.right, "inside");
function R6(n, t, e, i) {
  let r = mi.find(n.docView, t);
  if (!r)
    return 1;
  let s = t - r.posAtStart;
  if (s == 0)
    return 1;
  if (s == r.length)
    return -1;
  let a = r.coordsAt(s, -1);
  if (a && z3(e, i, a))
    return -1;
  let o = r.coordsAt(s, 1);
  return o && z3(e, i, o) ? 1 : a && a.bottom >= i ? -1 : 1;
}
c(R6, "j0$1");
m(R6, "findPositionSide");
function Sk(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: e, bias: R6(n, e, t.clientX, t.clientY) };
}
c(Sk, "ru$1");
m(Sk, "queryPos");
const SW = nt.ie && nt.ie_version <= 11;
let L3 = null, I3 = 0, V3 = 0;
function iC(n) {
  if (!SW)
    return n.detail;
  let t = L3, e = V3;
  return L3 = n, V3 = Date.now(), I3 = !t || e > Date.now() - 400 && Math.abs(t.clientX - n.clientX) < 2 && Math.abs(t.clientY - n.clientY) < 2 ? (I3 + 1) % 3 : 1;
}
c(iC, "Vd$1");
m(iC, "getClickType");
function E6(n, t) {
  let e = Sk(n, t), i = iC(t), r = n.state.selection;
  return {
    update(s) {
      s.docChanged && (e.pos = s.changes.mapPos(e.pos), r = r.map(s.changes));
    },
    get(s, a, o) {
      let l = Sk(n, s), d, u = kk(n, l.pos, l.bias, i);
      if (e.pos != l.pos && !a) {
        let p = kk(n, e.pos, e.bias, i), f = Math.min(p.from, u.from), y = Math.max(p.to, u.to);
        u = f < u.from ? it.range(f, y) : it.range(y, f);
      }
      return a ? r.replaceRange(r.main.extend(u.from, u.to)) : o && i == 1 && r.ranges.length > 1 && (d = _6(r, l.pos)) ? d : o ? r.addRange(u) : it.create([u]);
    }
  };
}
c(E6, "D0$1");
m(E6, "basicMouseSelection");
function _6(n, t) {
  for (let e = 0; e < n.ranges.length; e++) {
    let { from: i, to: r } = n.ranges[e];
    if (i <= t && r >= t)
      return it.create(n.ranges.slice(0, e).concat(n.ranges.slice(e + 1)), n.mainIndex == e ? 0 : n.mainIndex - (n.mainIndex > e ? 1 : 0));
  }
  return null;
}
c(_6, "B0$1");
m(_6, "removeRangeAround");
An.dragstart = (n, t) => {
  let { selection: { main: e } } = n.state;
  if (t.target.draggable) {
    let r = n.docView.nearest(t.target);
    if (r && r.isWidget) {
      let s = r.posAtStart, a = s + r.length;
      (s >= e.to || a <= e.from) && (e = it.range(s, a));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", Jw(n.state, BS, n.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
An.dragend = (n) => (n.inputState.draggedContent = null, !1);
function Ck(n, t, e, i) {
  if (e = Jw(n.state, jS, e), !e)
    return;
  let r = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: s } = n.inputState, a = i && s && P6(n, t) ? { from: s.from, to: s.to } : null, o = { from: r, insert: e }, l = n.state.changes(a ? [a, o] : o);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(r, -1), head: l.mapPos(r, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
c(Ck, "lu$1");
m(Ck, "dropText");
An.drop = (n, t) => {
  if (!t.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), r = 0, s = /* @__PURE__ */ m(() => {
      ++r == e.length && Ck(n, t, i.filter((a) => a != null).join(n.state.lineBreak), !1);
    }, "finishFile");
    for (let a = 0; a < e.length; a++) {
      let o = new FileReader();
      o.onerror = s, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), s();
      }, o.readAsText(e[a]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return Ck(n, t, i, !0), !0;
  }
  return !1;
};
An.paste = (n, t) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let e = M6 ? null : t.clipboardData;
  return e ? (eC(n, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (A6(n), !1);
};
function z6(n, t) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
c(z6, "N0$1");
m(z6, "captureCopy");
function L6(n) {
  let t = [], e = [], i = !1;
  for (let r of n.selection.ranges)
    r.empty || (t.push(n.sliceDoc(r.from, r.to)), e.push(r));
  if (!t.length) {
    let r = -1;
    for (let { from: s } of n.selection.ranges) {
      let a = n.doc.lineAt(s);
      a.number > r && (t.push(a.text), e.push({ from: a.from, to: Math.min(n.doc.length, a.to + 1) })), r = a.number;
    }
    i = !0;
  }
  return { text: Jw(n, BS, t.join(n.lineBreak)), ranges: e, linewise: i };
}
c(L6, "G0$1");
m(L6, "copiedRange");
let Pk = null;
An.copy = An.cut = (n, t) => {
  let { text: e, ranges: i, linewise: r } = L6(n.state);
  if (!e && !r)
    return !1;
  Pk = r ? e : null, t.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = M6 ? null : t.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", e), !0) : (z6(n, e), !1);
};
const I6 = /* @__PURE__ */ as.define();
function nC(n, t) {
  let e = [];
  for (let i of n.facet(I7)) {
    let r = i(n, t);
    r && e.push(r);
  }
  return e.length ? n.update({ effects: e, annotations: I6.of(!0) }) : null;
}
c(nC, "Ud$1");
m(nC, "focusChangeTransaction");
function rC(n) {
  setTimeout(() => {
    let t = n.hasFocus;
    if (t != n.inputState.notifiedFocused) {
      let e = nC(n.state, t);
      e ? n.dispatch(e) : n.update([]);
    }
  }, 10);
}
c(rC, "Id");
m(rC, "updateForFocusChange");
cn.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), rC(n);
};
cn.blur = (n) => {
  n.observer.clearSelectionRange(), rC(n);
};
cn.compositionstart = cn.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
cn.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, nt.chrome && nt.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
cn.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
An.beforeinput = (n, t) => {
  var e, i;
  if ((t.inputType == "insertText" || t.inputType == "insertCompositionText") && (n.inputState.insertingText = t.data, n.inputState.insertingTextAt = Date.now()), t.inputType == "insertReplacementText" && n.observer.editContext) {
    let s = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), a = t.getTargetRanges();
    if (s && a.length) {
      let o = a[0], l = n.posAtDOM(o.startContainer, o.startOffset), d = n.posAtDOM(o.endContainer, o.endOffset);
      return b0(n, { from: l, to: d, insert: n.state.toText(s) }, null), !0;
    }
  }
  let r;
  if (nt.chrome && nt.android && (r = $6.find((s) => s.inputType == t.inputType)) && (n.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let s = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > s + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return nt.ios && t.inputType == "deleteContentForward" && n.observer.flushSoon(), nt.safari && t.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => cn.compositionend(n, t), 20), !1;
};
const D3 = /* @__PURE__ */ new Set();
function V6(n) {
  D3.has(n) || (D3.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
c(V6, "F0$1");
m(V6, "firefoxCopyCutHack");
const W3 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Lm = !1;
function Qk() {
  Lm = !1;
}
c(Qk, "fu$1");
m(Qk, "clearHeightChangeFlag");
var Hh;
const D6 = (Hh = class {
  constructor(t) {
    this.lineWrapping = t, this.doc = Dt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return W3.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let r = t[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (e = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, r, s, a) {
    let o = W3.indexOf(t) > -1, l = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = e, this.charWidth = i, this.textHeight = r, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let d = 0; d < a.length; d++) {
        let u = a[d];
        u < 0 ? d++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}, c(Hh, "Of"), Hh);
m(D6, "HeightOracle");
let CW = D6;
var Yh;
const W6 = (Yh = class {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, c(Yh, "df"), Yh);
m(W6, "MeasuredHeights");
let PW = W6;
var Qo;
const q6 = (Qo = class {
  /**
  @internal
  */
  constructor(t, e, i, r, s) {
    this.from = t, this.length = e, this.top = i, this.height = r, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? sr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof _m ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new Qo(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}, c(Qo, "eo"), Qo);
m(q6, "BlockInfo");
let Ss = q6;
var Gt = /* @__PURE__ */ (function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
})(Gt || (Gt = {}));
const dv = 1e-3;
var qr;
const F6 = (qr = class {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > dv && (Lm = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return qr.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, r) {
    let s = this, a = i.doc;
    for (let o = r.length - 1; o >= 0; o--) {
      let { fromA: l, toA: d, fromB: u, toB: p } = r[o], f = s.lineAt(l, Gt.ByPosNoHeight, i.setDoc(e), 0, 0), y = f.to >= d ? f : s.lineAt(d, Gt.ByPosNoHeight, i, 0, 0);
      for (p += y.to - d, d = y.to; o > 0 && f.from <= r[o - 1].toA; )
        l = r[o - 1].fromA, u = r[o - 1].fromB, o--, l < f.from && (f = s.lineAt(l, Gt.ByPosNoHeight, i, 0, 0));
      u += f.from - l, l = f.from;
      let g = MW.build(i.setDoc(a), t, u, p);
      s = dw(s, s.replace(l, d, g));
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new jn(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, r = 0, s = 0;
    for (; ; )
      if (e == i)
        if (r > s * 2) {
          let o = t[e - 1];
          o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, r -= o.size;
        } else if (s > r * 2) {
          let o = t[i];
          o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, s -= o.size;
        } else
          break;
      else if (r < s) {
        let o = t[e++];
        o && (r += o.size);
      } else {
        let o = t[--i];
        o && (s += o.size);
      }
    let a = 0;
    return t[e - 1] == null ? (a = 1, e--) : t[e] == null && (a = 1, i++), new QW(qr.of(t.slice(0, e)), a, qr.of(t.slice(i)));
  }
}, c(qr, "bi"), qr);
m(F6, "HeightMap");
let Cn = F6;
function dw(n, t) {
  return n == t ? n : (n.constructor != t.constructor && (Lm = !0), t);
}
c(dw, "Os$1");
m(dw, "replace");
Cn.prototype.size = 1;
var Gh;
const Z6 = (Gh = class extends Cn {
  constructor(t, e, i) {
    super(t, e), this.deco = i;
  }
  blockAt(t, e, i, r) {
    return new Ss(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(t, e, i, r, s) {
    return this.blockAt(0, i, r, s);
  }
  forEachLine(t, e, i, r, s, a) {
    t <= s + this.length && e >= s && a(this.blockAt(0, i, r, s));
  }
  updateHeight(t, e = 0, i = !1, r) {
    return r && r.from <= e && r.more && this.setHeight(r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, c(Gh, "pf"), Gh);
m(Z6, "HeightMapBlock");
let X6 = Z6;
var Ns;
const N6 = (Ns = class extends X6 {
  constructor(t, e) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, e, i, r) {
    return new Ss(r, this.length, i, this.height, this.breaks);
  }
  replace(t, e, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof Ns || r instanceof hh && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof hh ? r = new Ns(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Cn.of(i);
  }
  updateHeight(t, e = 0, i = !1, r) {
    return r && r.from <= e && r.more ? this.setHeight(r.heights[r.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, c(Ns, "Zr"), Ns);
m(N6, "HeightMapText");
let jn = N6;
var oi;
const j6 = (oi = class extends Cn {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, r = t.doc.lineAt(e + this.length).number, s = r - i + 1, a, o = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * s);
      a = l / s, this.length > s + 1 && (o = (this.height - l) / (this.length - s - 1));
    } else
      a = this.height / s;
    return { firstLine: i, lastLine: r, perLine: a, perChar: o };
  }
  blockAt(t, e, i, r) {
    let { firstLine: s, lastLine: a, perLine: o, perChar: l } = this.heightMetrics(e, r);
    if (e.lineWrapping) {
      let d = r + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), u = e.doc.lineAt(d), p = o + u.length * l, f = Math.max(i, t - p / 2);
      return new Ss(u.from, u.length, f, p, 0);
    } else {
      let d = Math.max(0, Math.min(a - s, Math.floor((t - i) / o))), { from: u, length: p } = e.doc.line(s + d);
      return new Ss(u, p, i + o * d, o, 0);
    }
  }
  lineAt(t, e, i, r, s) {
    if (e == Gt.ByHeight)
      return this.blockAt(t, i, r, s);
    if (e == Gt.ByPosNoHeight) {
      let { from: y, to: g } = i.doc.lineAt(t);
      return new Ss(y, g - y, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: l } = this.heightMetrics(i, s), d = i.doc.lineAt(t), u = o + d.length * l, p = d.number - a, f = r + o * p + l * (d.from - s - p);
    return new Ss(d.from, d.length, Math.max(r, Math.min(f, r + this.height - u)), u, 0);
  }
  forEachLine(t, e, i, r, s, a) {
    t = Math.max(t, s), e = Math.min(e, s + this.length);
    let { firstLine: o, perLine: l, perChar: d } = this.heightMetrics(i, s);
    for (let u = t, p = r; u <= e; ) {
      let f = i.doc.lineAt(u);
      if (u == t) {
        let g = f.number - o;
        p += l * g + d * (t - s - g);
      }
      let y = l + d * f.length;
      a(new Ss(f.from, f.length, p, y, 0)), p += y, u = f.to + 1;
    }
  }
  replace(t, e, i) {
    let r = this.length - e;
    if (r > 0) {
      let s = i[i.length - 1];
      s instanceof oi ? i[i.length - 1] = new oi(s.length + r) : i.push(null, new oi(r - 1));
    }
    if (t > 0) {
      let s = i[0];
      s instanceof oi ? i[0] = new oi(t + s.length) : i.unshift(new oi(t - 1), null);
    }
    return Cn.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new oi(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new oi(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, r) {
    let s = e + this.length;
    if (r && r.from <= e + this.length && r.more) {
      let a = [], o = Math.max(e, r.from), l = -1;
      for (r.from > e && a.push(new oi(r.from - e - 1).updateHeight(t, e)); o <= s && r.more; ) {
        let u = t.doc.lineAt(o).length;
        a.length && a.push(null);
        let p = r.heights[r.index++];
        l == -1 ? l = p : Math.abs(p - l) >= dv && (l = -2);
        let f = new jn(u, p);
        f.outdated = !1, a.push(f), o += u + 1;
      }
      o <= s && a.push(null, new oi(s - o).updateHeight(t, o));
      let d = Cn.of(a);
      return (l < 0 || Math.abs(d.height - this.height) >= dv || Math.abs(l - this.heightMetrics(t, e).perLine) >= dv) && (Lm = !0), dw(this, d);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, c(oi, "ke"), oi);
m(j6, "HeightMapGap");
let hh = j6;
var Kh;
const B6 = (Kh = class extends Cn {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, r) {
    let s = i + this.left.height;
    return t < s ? this.left.blockAt(t, e, i, r) : this.right.blockAt(t, e, s, r + this.left.length + this.break);
  }
  lineAt(t, e, i, r, s) {
    let a = r + this.left.height, o = s + this.left.length + this.break, l = e == Gt.ByHeight ? t < a : t < o, d = l ? this.left.lineAt(t, e, i, r, s) : this.right.lineAt(t, e, i, a, o);
    if (this.break || (l ? d.to < o : d.from > o))
      return d;
    let u = e == Gt.ByPosNoHeight ? Gt.ByPosNoHeight : Gt.ByPos;
    return l ? d.join(this.right.lineAt(o, u, i, a, o)) : this.left.lineAt(o, u, i, r, s).join(d);
  }
  forEachLine(t, e, i, r, s, a) {
    let o = r + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, e, i, r, s, a), e >= l && this.right.forEachLine(t, e, i, o, l, a);
    else {
      let d = this.lineAt(l, Gt.ByPos, i, r, s);
      t < d.from && this.left.forEachLine(t, d.from - 1, i, r, s, a), d.to >= t && d.from <= e && a(d), e > d.to && this.right.forEachLine(d.to + 1, e, i, o, l, a);
    }
  }
  replace(t, e, i) {
    let r = this.left.length + this.break;
    if (e < r)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - r, e - r, i));
    let s = [];
    t > 0 && this.decomposeLeft(t, s);
    let a = s.length;
    for (let o of i)
      s.push(o);
    if (t > 0 && Tk(s, a - 1), e < this.length) {
      let o = s.length;
      this.decomposeRight(e, s), Tk(s, o);
    }
    return Cn.of(s);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, r = i + this.break;
    if (t >= r)
      return this.right.decomposeRight(t - r, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < r && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? Cn.of(this.break ? [t, null, e] : [t, e]) : (this.left = dw(this.left, t), this.right = dw(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, r) {
    let { left: s, right: a } = this, o = e + s.length + this.break, l = null;
    return r && r.from <= e + s.length && r.more ? l = s = s.updateHeight(t, e, i, r) : s.updateHeight(t, e, i), r && r.from <= o + a.length && r.more ? l = a = a.updateHeight(t, o, i, r) : a.updateHeight(t, o, i), l ? this.balanced(s, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}, c(Kh, "mf"), Kh);
m(B6, "HeightMapBranch");
let QW = B6;
function Tk(n, t) {
  let e, i;
  n[t] == null && (e = n[t - 1]) instanceof hh && (i = n[t + 1]) instanceof hh && n.splice(t - 1, 3, new hh(e.length + 1 + i.length));
}
c(Tk, "cu$1");
m(Tk, "mergeGaps");
const TW = 5;
var To;
const U6 = (To = class {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof jn ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new jn(i - this.pos, -1)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let a = e - t;
      i.block ? this.addBlock(new X6(a, r, i)) : (a || s || r >= TW) && this.addLineDeco(r, s, a);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new jn(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new hh(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof jn)
      return t;
    let e = new jn(0, -1);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, t), r.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof jn) && !this.isCovered ? this.nodes.push(new jn(0, -1)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let r of this.nodes)
      r instanceof jn && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, r) {
    let s = new To(i, t);
    return hi.spans(e, i, r, s, 0), s.finish(i);
  }
}, c(To, "to"), To);
m(U6, "NodeBuilder");
let MW = U6;
function H6(n, t, e) {
  let i = new AW();
  return hi.compare(n, t, e, i, 0), i.changes;
}
c(H6, "K0$1");
m(H6, "heightRelevantDecoChanges");
var Jh;
const Y6 = (Jh = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, r) {
    (t < e || i && i.heightRelevant || r && r.heightRelevant) && Yg(t, e, this.changes, 5);
  }
}, c(Jh, "gf"), Jh);
m(Y6, "DecorationComparator");
let AW = Y6;
function G6(n, t) {
  let e = n.getBoundingClientRect(), i = n.ownerDocument, r = i.defaultView || window, s = Math.max(0, e.left), a = Math.min(r.innerWidth, e.right), o = Math.max(0, e.top), l = Math.min(r.innerHeight, e.bottom);
  for (let d = n.parentNode; d && d != i.body; )
    if (d.nodeType == 1) {
      let u = d, p = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && p.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), a = Math.min(a, f.right), o = Math.max(o, f.top), l = Math.min(d == n.parentNode ? r.innerHeight : l, f.bottom);
      }
      d = p.position == "absolute" || p.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (d.nodeType == 11)
      d = d.host;
    else
      break;
  return {
    left: s - e.left,
    right: Math.max(s, a) - e.left,
    top: o - (e.top + t),
    bottom: Math.max(o, l) - (e.top + t)
  };
}
c(G6, "J0$1");
m(G6, "visiblePixelRange");
function K6(n) {
  let t = n.getBoundingClientRect(), e = n.ownerDocument.defaultView || window;
  return t.left < e.innerWidth && t.right > 0 && t.top < e.innerHeight && t.bottom > 0;
}
c(K6, "e1");
m(K6, "inWindow");
function J6(n, t) {
  let e = n.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
c(J6, "t1");
m(J6, "fullPixelRange");
var td;
const tT = (td = class {
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.size = i, this.displaySize = r;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let r = t[i], s = e[i];
      if (r.from != s.from || r.to != s.to || r.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return Jt.replace({
      widget: new RW(this.displaySize * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}, c(td, "Qf"), td);
m(tT, "LineGap");
let qb = tT;
var ed;
const eT = (ed = class extends uy {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, c(ed, "yf"), ed);
m(eT, "LineGapWidget");
let RW = eT;
var id;
const iT = (id = class {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = F3, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Pe.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(US).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new CW(e), this.stateDeco = t.facet(hw).filter((i) => typeof i != "function"), this.heightMap = Cn.empty().applyChanges(this.stateDeco, Dt.empty, this.heightOracle.setDoc(t.doc), [new Es(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Jt.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? e.head : e.anchor;
      if (!t.some(({ from: s, to: a }) => r >= s && r <= a)) {
        let { from: s, to: a } = this.lineBlockAt(r);
        t.push(new I1(s, a));
      }
    }
    return this.viewports = t.sort((i, r) => i.from - r.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? F3 : new EW(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(rh(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(hw).filter((u) => typeof u != "function");
    let r = t.changedRanges, s = Es.extendWithRanges(r, H6(i, this.stateDeco, t ? t.changes : Tn.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    Qk(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != a || Lm) && (t.flags |= 2), o ? (this.scrollAnchorPos = t.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let l = s.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < l.from || e.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e));
    let d = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, t.flags |= this.updateForViewport(), (d || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(gW) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), r = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Pe.RTL : Pe.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(s), o = e.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let d = 0, u = 0;
    if (o.width && o.height) {
      let { scaleX: z, scaleY: A } = SS(e, o);
      (z > 5e-3 && Math.abs(this.scaleX - z) > 5e-3 || A > 5e-3 && Math.abs(this.scaleY - A) > 5e-3) && (this.scaleX = z, this.scaleY = A, d |= 16, a = l = !0);
    }
    let p = (parseInt(i.paddingTop) || 0) * this.scaleY, f = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != p || this.paddingBottom != f) && (this.paddingTop = p, this.paddingBottom = f, d |= 18), this.editorWidth != t.scrollDOM.clientWidth && (r.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, d |= 16);
    let y = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != y && (this.scrollAnchorHeight = -1, this.scrollTop = y), this.scrolledToBottom = QS(t.scrollDOM);
    let g = (this.printing ? J6 : G6)(e, this.paddingTop), b = g.top - this.pixelViewport.top, S = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let $ = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ($ != this.inView && (this.inView = $, $ && (l = !0)), !this.inView && !this.scrollTarget && !K6(t.dom))
      return 0;
    let Q = o.width;
    if ((this.contentDOMWidth != Q || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, d |= 16), l) {
      let z = t.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(z) && (a = !0), a || r.lineWrapping && Math.abs(Q - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: A, charWidth: V, textHeight: D } = t.docView.measureTextSize();
        a = A > 0 && r.refresh(s, A, V, D, Math.max(5, Q / V), z), a && (t.docView.minWidth = 0, d |= 16);
      }
      b > 0 && S > 0 ? u = Math.max(b, S) : b < 0 && S < 0 && (u = Math.min(b, S)), Qk();
      for (let A of this.viewports) {
        let V = A.from == this.viewport.from ? z : t.docView.measureVisibleLineHeights(A);
        this.heightMap = (a ? Cn.empty().applyChanges(this.stateDeco, Dt.empty, this.heightOracle, [new Es(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(r, 0, a, new PW(A.from, V));
      }
      Lm && (d |= 2);
    }
    let E = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return E && (d & 2 && (d |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), d |= this.updateForViewport()), (d & 2 || E) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, t)), d |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), d;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, l = new I1(r.lineAt(a - i * 1e3, Gt.ByHeight, s, 0, 0).from, r.lineAt(o + (1 - i) * 1e3, Gt.ByHeight, s, 0, 0).to);
    if (e) {
      let { head: d } = e.range;
      if (d < l.from || d > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = r.lineAt(d, Gt.ByPos, s, 0, 0), f;
        e.y == "center" ? f = (p.top + p.bottom) / 2 - u / 2 : e.y == "start" || e.y == "nearest" && d < l.from ? f = p.top : f = p.bottom - u, l = new I1(r.lineAt(f - 1e3 / 2, Gt.ByHeight, s, 0, 0).from, r.lineAt(f + u + 1e3 / 2, Gt.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), r = e.mapPos(t.to, 1);
    return new I1(this.heightMap.lineAt(i, Gt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, Gt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(t, Gt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(e, Gt.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (t == 0 || r <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || s >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && r > a - 2 * 1e3 && s < o + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let r of t)
      e.touchesRange(r.from, r.to) || i.push(new qb(e.mapPos(r.from), e.mapPos(r.to), r.size, r.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, s = r >> 1, a = r << 1;
    if (this.defaultTextDirection != Pe.LTR && !i)
      return [];
    let o = [], l = /* @__PURE__ */ m((u, p, f, y) => {
      if (p - u < s)
        return;
      let g = this.state.selection.main, b = [g.from];
      g.empty || b.push(g.to);
      for (let $ of b)
        if ($ > u && $ < p) {
          l(u, $ - 10, f, y), l($ + 10, p, f, y);
          return;
        }
      let S = sT(t, ($) => $.from >= f.from && $.to <= f.to && Math.abs($.from - u) < s && Math.abs($.to - p) < s && !b.some((Q) => $.from < Q && $.to > Q));
      if (!S) {
        if (p < f.to && e && i && e.visibleRanges.some((E) => E.from <= p && E.to >= p)) {
          let E = e.moveToLineBoundary(it.cursor(p), !1, !0).head;
          E > u && (p = E);
        }
        let $ = this.gapSize(f, u, p, y), Q = i || $ < 2e6 ? $ : 2e6;
        S = new qb(u, p, $, Q);
      }
      o.push(S);
    }, "addGap"), d = /* @__PURE__ */ m((u) => {
      if (u.length < a || u.type != sr.Text)
        return;
      let p = rT(u.from, u.to, this.stateDeco);
      if (p.total < a)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, y, g;
      if (i) {
        let b = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, S, $;
        if (f != null) {
          let Q = cg(p, f), E = ((this.visibleBottom - this.visibleTop) / 2 + b) / u.height;
          S = Q - E, $ = Q + E;
        } else
          S = (this.visibleTop - u.top - b) / u.height, $ = (this.visibleBottom - u.top + b) / u.height;
        y = lg(p, S), g = lg(p, $);
      } else {
        let b = p.total * this.heightOracle.charWidth, S = r * this.heightOracle.charWidth, $ = 0;
        if (b > 2e6)
          for (let V of t)
            V.from >= u.from && V.from < u.to && V.size != V.displaySize && V.from * this.heightOracle.charWidth + $ < this.pixelViewport.left && ($ = V.size - V.displaySize);
        let Q = this.pixelViewport.left + $, E = this.pixelViewport.right + $, z, A;
        if (f != null) {
          let V = cg(p, f), D = ((E - Q) / 2 + S) / b;
          z = V - D, A = V + D;
        } else
          z = (Q - S) / b, A = (E + S) / b;
        y = lg(p, z), g = lg(p, A);
      }
      y > u.from && l(u.from, y, u, p), g < u.to && l(g, u.to, u, p);
    }, "checkLine");
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(d) : d(u);
    return o;
  }
  gapSize(t, e, i, r) {
    let s = cg(r, i) - cg(r, e);
    return this.heightOracle.lineWrapping ? t.height * s : r.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(t) {
    qb.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = Jt.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    hi.spans(e, this.viewport.from, this.viewport.to, {
      span(s, a) {
        i.push({ from: s, to: a });
      },
      point() {
      }
    }, 20);
    let r = 0;
    if (i.length != this.visibleRanges.length)
      r = 12;
    else
      for (let s = 0; s < i.length && !(r & 8); s++) {
        let a = this.visibleRanges[s], o = i[s];
        (a.from != o.from || a.to != o.to) && (r |= 4, t && t.mapPos(a.from, -1) == o.from && t.mapPos(a.to, 1) == o.to || (r |= 8));
      }
    return this.visibleRanges = i, r;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || rh(this.heightMap.lineAt(t, Gt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || rh(this.heightMap.lineAt(this.scaler.fromDOM(t), Gt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return rh(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, c(id, "Sf"), id);
m(iT, "ViewState");
let q3 = iT;
var nd;
const nT = (nd = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, c(nd, "bf"), nd);
m(nT, "Viewport");
let I1 = nT;
function rT(n, t, e) {
  let i = [], r = n, s = 0;
  return hi.spans(e, n, t, {
    span() {
    },
    point(a, o) {
      a > r && (i.push({ from: r, to: a }), s += a - r), r = o;
    }
  }, 20), r < t && (i.push({ from: r, to: t }), s += t - r), { total: s, ranges: i };
}
c(rT, "i1");
m(rT, "lineStructure");
function lg({ total: n, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(n * e);
  for (let r = 0; ; r++) {
    let { from: s, to: a } = t[r], o = a - s;
    if (i <= o)
      return s + i;
    i -= o;
  }
}
c(lg, "Cn$1");
m(lg, "findPosition");
function cg(n, t) {
  let e = 0;
  for (let { from: i, to: r } of n.ranges) {
    if (t <= r) {
      e += t - i;
      break;
    }
    e += r - i;
  }
  return e / n.total;
}
c(cg, "Xn$1");
m(cg, "findFraction");
function sT(n, t) {
  for (let e of n)
    if (t(e))
      return e;
}
c(sT, "r1");
m(sT, "find");
const F3 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
var Mo;
const aT = (Mo = class {
  constructor(t, e, i) {
    let r = 0, s = 0, a = 0;
    this.viewports = i.map(({ from: o, to: l }) => {
      let d = e.lineAt(o, Gt.ByPos, t, 0, 0).top, u = e.lineAt(l, Gt.ByPos, t, 0, 0).bottom;
      return r += u - d, { from: o, to: l, top: d, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (e.height - r);
    for (let o of this.viewports)
      o.domTop = a + (o.top - s) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), s = o.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, r = 0; ; e++) {
      let s = e < this.viewports.length ? this.viewports[e] : null;
      if (!s || t < s.top)
        return r + (t - i) * this.scale;
      if (t <= s.bottom)
        return s.domTop + (t - s.top);
      i = s.bottom, r = s.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, r = 0; ; e++) {
      let s = e < this.viewports.length ? this.viewports[e] : null;
      if (!s || t < s.domTop)
        return i + (t - r) / this.scale;
      if (t <= s.domBottom)
        return s.top + (t - s.domTop);
      i = s.bottom, r = s.domBottom;
    }
  }
  eq(t) {
    return t instanceof Mo ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}, c(Mo, "io"), Mo);
m(aT, "BigScaler");
let EW = aT;
function rh(n, t) {
  if (t.scale == 1)
    return n;
  let e = t.toDOM(n.top), i = t.toDOM(n.bottom);
  return new Ss(n.from, n.length, e, i - e, Array.isArray(n._content) ? n._content.map((r) => rh(r, t)) : n._content);
}
c(rh, "ur$1");
m(rh, "scaleBlock");
const V1 = /* @__PURE__ */ $t.define({ combine: /* @__PURE__ */ m((n) => n.join(" "), "combine") }), Mk = /* @__PURE__ */ $t.define({ combine: /* @__PURE__ */ m((n) => n.indexOf(!0) > -1, "combine") }), Ak = /* @__PURE__ */ sa.newName(), oT = /* @__PURE__ */ sa.newName(), lT = /* @__PURE__ */ sa.newName(), cT = { "&light": "." + oT, "&dark": "." + lT };
function uO(n, t, e) {
  return new sa(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return n;
        if (!e || !e[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return e[r];
      }) : n + " " + i;
    }
  });
}
c(uO, "Bl$1");
m(uO, "buildTheme");
const _W = /* @__PURE__ */ uO("." + Ak, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, cT), zW = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Fb = nt.ie && nt.ie_version <= 11;
var rd;
const hT = (rd = class {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new uW(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (nt.ie && nt.ie_version <= 11 || nt.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && nt.android && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(nt.chrome && nt.chrome_version < 126) && (this.editContext = new IW(t), t.state.facet(Ar) && (t.contentDOM.editContext = this.editContext.editContext)), Fb && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(Ar) ? i.root.activeElement != this.dom : !Hg(this.dom, r))
      return;
    let s = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (s && s.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (nt.ie && nt.ie_version <= 11 || nt.android && nt.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && lh(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = Rm(t.root);
    if (!e)
      return !1;
    let i = nt.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && dT(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let r = Hg(this.dom, i);
    return r && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && t7(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, zW), Fb && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Fb && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = /* @__PURE__ */ m(() => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && ao(this.dom, s.key, s.keyCode));
      }, "flush");
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, r = !1;
    for (let s of t) {
      let a = this.readMutation(s);
      a && (a.typeOver && (r = !0), e == -1 ? { from: e, to: i } = a : (e = Math.min(a.from, e), i = Math.max(a.to, i)));
    }
    return { from: e, to: i, typeOver: r };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), r = this.selectionChanged && Hg(this.dom, this.selectionRange);
    if (t < 0 && !r)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new bW(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = JS(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !e.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), r;
  }
  readMutation(t) {
    let e = this.view.docView.nearest(t.target);
    if (!e || e.ignoreMutation(t))
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "attributes" && (e.flags |= 4), t.type == "childList") {
      let i = Rk(e, t.previousSibling || t.target.previousSibling, -1), r = Rk(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: r ? e.posBefore(r) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(Ar) != t.state.facet(Ar) && (t.view.contentDOM.editContext = t.state.facet(Ar) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}, c(rd, "wf"), rd);
m(hT, "DOMObserver");
let LW = hT;
function Rk(n, t, e) {
  for (; t; ) {
    let i = Kt.get(t);
    if (i && i.parent == n)
      return i;
    let r = t.parentNode;
    t = r != n.dom ? r : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
c(Rk, "Ou");
m(Rk, "findChild");
function Ek(n, t) {
  let e = t.startContainer, i = t.startOffset, r = t.endContainer, s = t.endOffset, a = n.docView.domAtPos(n.state.selection.main.anchor);
  return lh(a.node, a.offset, r, s) && ([e, i, r, s] = [r, s, e, i]), { anchorNode: e, anchorOffset: i, focusNode: r, focusOffset: s };
}
c(Ek, "du$1");
m(Ek, "buildSelectionRangeFromRange");
function dT(n, t) {
  if (t.getComposedRanges) {
    let r = t.getComposedRanges(n.root)[0];
    if (r)
      return Ek(n, r);
  }
  let e = null;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), e = r.getTargetRanges()[0];
  }
  return c(i, "i"), m(i, "read"), n.contentDOM.addEventListener("beforeinput", i, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", i, !0), e ? Ek(n, e) : null;
}
c(dT, "o1");
m(dT, "safariSelectionRangeHack");
var sd;
const uT = (sd = class {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let r = t.state.selection.main, { anchor: s, head: a } = r, o = this.toEditorPos(i.updateRangeStart), l = this.toEditorPos(i.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let d = l - o > i.text.length;
      o == this.from && s < this.from ? o = s : l == this.to && s > this.to && (l = s);
      let u = tC(t.state.sliceDoc(o, l), i.text, (d ? r.from : r.to) - o, d ? "end" : null);
      if (!u) {
        let f = it.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        f.main.eq(r) || t.dispatch({ selection: f, userEvent: "select" });
        return;
      }
      let p = {
        from: u.from + o,
        to: u.toA + o,
        insert: Dt.of(i.text.slice(u.from, u.toB).split(`
`))
      };
      if ((nt.mac || nt.android) && p.from == a - 1 && /^\. ?$/.test(i.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (p = { from: o, to: l, insert: Dt.of([i.text.replace(".", " ")]) }), this.pendingContextChange = p, !t.state.readOnly) {
        let f = this.to - this.from + (p.to - p.from + p.insert.length);
        b0(t, p, it.single(this.toEditorPos(i.selectionStart, f), this.toEditorPos(i.selectionEnd, f)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state)), p.from < p.to && !p.insert.length && t.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(e.text.slice(Math.max(0, i.updateRangeStart - 1), Math.min(e.text.length, i.updateRangeStart + 1))) && this.handlers.compositionend(i);
    }, this.handlers.characterboundsupdate = (i) => {
      let r = [], s = null;
      for (let a = this.toEditorPos(i.rangeStart), o = this.toEditorPos(i.rangeEnd); a < o; a++) {
        let l = t.coordsForChar(a);
        s = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || s || new DOMRect(), r.push(s);
      }
      e.updateCharacterBounds(i.rangeStart, r);
    }, this.handlers.textformatupdate = (i) => {
      let r = [];
      for (let s of i.getTextFormats()) {
        let a = s.underlineStyle, o = s.underlineThickness;
        if (!/none/i.test(a) && !/none/i.test(o)) {
          let l = this.toEditorPos(s.rangeStart), d = this.toEditorPos(s.rangeEnd);
          if (l < d) {
            let u = `text-decoration: underline ${/^[a-z]/.test(a) ? a + " " : a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${/thin/i.test(o) ? 1 : 2}px`;
            r.push(Jt.mark({ attributes: { style: u } }).range(l, d));
          }
        }
      }
      t.dispatch({ effects: q7.of(Jt.set(r)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(t.state);
      }
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: /* @__PURE__ */ m((i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let r = Rm(i.root);
      r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect());
    }, "read") };
  }
  applyEdits(t) {
    let e = 0, i = !1, r = this.pendingContextChange;
    return t.changes.iterChanges((s, a, o, l, d) => {
      if (i)
        return;
      let u = d.length - (a - s);
      if (r && a >= r.to)
        if (r.from == s && r.to == a && r.insert.eq(d)) {
          r = this.pendingContextChange = null, e += u, this.to += u;
          return;
        } else
          r = null, this.revertPending(t.state);
      if (s += e, a += e, a <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || a > this.to || this.to - this.from + d.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(a), d.toString()), this.to += u;
      }
      e += u;
    }), r && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange, i = t.startState.selection.main;
    this.composing && (this.composing.drifted || !t.changes.touchesRange(i.from, i.to) && t.transactions.some((r) => !r.isUserEvent("input.type") && r.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), r = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != r) && this.editContext.updateSelection(i, r);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, e = this.to - this.from) {
    t = Math.min(t, e);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (t - i.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let e = this.composing;
    return e && e.drifted ? e.contextBase + (t - e.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}, c(sd, "xf"), sd);
m(uT, "EditContextManager");
let IW = uT;
var js;
const pT = (js = class {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((r) => r.forEach((s) => i(s, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = t.root || J8(t.parent) || document, this.viewState = new q3(t.state || Le.create(t)), t.scrollTo && t.scrollTo.is(z1) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(nh).map((r) => new Db(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new LW(this), this.inputState = new $W(this), this.inputState.ensureHandlers(this.plugins), this.docView = new E3(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof Oi ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, r, s = this.state;
    for (let f of t) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let a = this.hasFocus, o = 0, l = null;
    t.some((f) => f.annotation(I6)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = nC(s, a), l || (o = 1));
    let d = this.observer.delayedAndroidKey, u = null;
    if (d ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(Le.phrases) != this.state.facet(Le.phrases))
      return this.setState(s);
    r = R3.create(this, s, t), r.flags |= o;
    let p = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of t) {
        if (p && (p = p.map(f.changes)), f.scrollIntoView) {
          let { main: y } = f.state.selection;
          p = new Vb(y.empty ? y : it.cursor(y.head, y.head > y.anchor ? -1 : 1));
        }
        for (let y of f.effects)
          y.is(z1) && (p = y.value.clip(this.state));
      }
      this.viewState.update(r, p), this.bidiCache = X3.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), e = this.docView.update(r), this.state.facet(sg) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(V1) != r.state.facet(V1) && (this.viewState.mustMeasureContent = !0), (e || i || p || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !r.empty)
      for (let f of this.state.facet(yk))
        try {
          f(r);
        } catch (y) {
          Qi(this.state, y, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !JS(this, u) && d.force && ao(this.contentDOM, d.key, d.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new q3(t), this.plugins = t.facet(nh).map((i) => new Db(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new E3(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(nh), i = t.state.facet(nh);
    if (e != i) {
      let r = [];
      for (let s of i) {
        let a = e.indexOf(s);
        if (a < 0)
          r.push(new Db(s));
        else {
          let o = this.plugins[a];
          o.mustUpdate = t, r.push(o);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != t && s.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = t;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          Qi(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: a } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (QS(i))
            s = -1, a = this.viewState.heightMap.height;
          else {
            let y = this.viewState.scrollAnchorAt(r);
            s = y.from, a = y.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let d = [];
        l & 4 || ([this.measureRequests, d] = [d, this.measureRequests]);
        let u = d.map((y) => {
          try {
            return y.read(this);
          } catch (g) {
            return Qi(this.state, g), Z3;
          }
        }), p = R3.create(this, this.state, []), f = !1;
        p.flags |= l, e ? e.flags |= l : e = p, this.updateState = 2, p.empty || (this.updatePlugins(p), this.inputState.update(p), this.updateAttrs(), f = this.docView.update(p), f && this.docViewUpdate());
        for (let y = 0; y < d.length; y++)
          if (u[y] != Z3)
            try {
              let g = d[y];
              g.write && g.write(u[y], this);
            } catch (g) {
              Qi(this.state, g);
            }
        if (f && this.docView.updateSelection(!0), !p.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let y = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - a;
              if (y > 1 || y < -1) {
                r = r + y, i.scrollTop = r / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let o of this.state.facet(yk))
        o(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Ak + " " + (this.state.facet(Mk) ? lT : oT) + " " + this.state.facet(V1);
  }
  updateAttrs() {
    let t = _k(this, X7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Ar) ? "true" : "false",
      class: "cm-content",
      style: `${nt.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), _k(this, US, e);
    let i = this.observer.ignore(() => {
      let r = lO(this.contentDOM, this.contentAttrs, e), s = lO(this.dom, this.editorAttrs, t);
      return r || s;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let r of i.effects)
        if (r.is(js.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(sg);
    let t = this.state.facet(js.cspNonce);
    sa.mount(this.root, this.styleModules.concat(_W).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.plugin != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.plugin == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return hv(this, t, $k(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return hv(this, t, $k(this, t, e, (i) => h6(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), r = this.textDirectionAt(t.from), s = i[e ? i.length - 1 : 0];
    return it.cursor(s.side(e, r) + t.from, s.forward(!e, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return c6(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return hv(this, t, d6(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    return this.readMeasured(), YS(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(t), s = this.bidiSpans(r), a = s[Qs.find(s, t - r.from, -1, e)];
    return dy(i, a.dir == Pe.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(V7) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > VW)
      return NS(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let s of this.bidiCache)
      if (s.from == t.from && s.dir == e && (s.fresh || XS(s.isolates, i = gk(this, t))))
        return s.order;
    i || (i = gk(this, t));
    let r = Q7(t.text, e, i);
    return this.bidiCache.push(new X3(t.from, t.to, e, i, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || nt.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      CS(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return z1.of(new Vb(typeof t == "number" ? it.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return z1.of(new Vb(it.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return Br.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return Br.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = sa.newName(), r = [V1.of(i), sg.of(uO(`.${i}`, t))];
    return e && e.dark && r.push(Mk.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return Cl.lowest(sg.of(uO("." + Ak, t, cT)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content");
    return ((e = (i && Kt.get(i) || Kt.get(t))?.rootView) === null || e === void 0 ? void 0 : e.view) || null;
  }
}, c(js, "Cr"), js);
m(pT, "EditorView");
let Ct = pT;
Ct.styleModule = sg;
Ct.inputHandler = L7;
Ct.clipboardInputFilter = jS;
Ct.clipboardOutputFilter = BS;
Ct.scrollHandler = D7;
Ct.focusChangeEffect = I7;
Ct.perLineTextDirection = V7;
Ct.exceptionSink = z7;
Ct.updateListener = yk;
Ct.editable = Ar;
Ct.mouseSelectionStyle = _7;
Ct.dragMovesSelection = E7;
Ct.clickAddsSelectionRange = R7;
Ct.decorations = hw;
Ct.outerDecorations = N7;
Ct.atomicRanges = Kw;
Ct.bidiIsolatedRanges = j7;
Ct.scrollMargins = B7;
Ct.darkTheme = Mk;
Ct.cspNonce = /* @__PURE__ */ $t.define({ combine: /* @__PURE__ */ m((n) => n.length ? n[0] : "", "combine") });
Ct.contentAttributes = US;
Ct.editorAttributes = X7;
Ct.lineWrapping = /* @__PURE__ */ Ct.contentAttributes.of({ class: "cm-lineWrapping" });
Ct.announce = /* @__PURE__ */ jt.define();
const VW = 4096, Z3 = {};
var Ao;
const fT = (Ao = class {
  constructor(t, e, i, r, s, a) {
    this.from = t, this.to = e, this.dir = i, this.isolates = r, this.fresh = s, this.order = a;
  }
  static update(t, e) {
    if (e.empty && !t.some((s) => s.fresh))
      return t;
    let i = [], r = t.length ? t[t.length - 1].dir : Pe.LTR;
    for (let s = Math.max(0, t.length - 10); s < t.length; s++) {
      let a = t[s];
      a.dir == r && !e.touchesRange(a.from, a.to) && i.push(new Ao(e.mapPos(a.from, 1), e.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}, c(Ao, "ro"), Ao);
m(fT, "CachedOrder");
let X3 = fT;
function _k(n, t, e) {
  for (let i = n.state.facet(t), r = i.length - 1; r >= 0; r--) {
    let s = i[r], a = typeof s == "function" ? s(n) : s;
    a && oO(a, e);
  }
  return e;
}
c(_k, "mu$1");
m(_k, "attrsFromFacet");
const DW = nt.mac ? "mac" : nt.windows ? "win" : nt.linux ? "linux" : "key";
function mT(n, t) {
  const e = n.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let r, s, a, o;
  for (let l = 0; l < e.length - 1; ++l) {
    const d = e[l];
    if (/^(cmd|meta|m)$/i.test(d))
      o = !0;
    else if (/^a(lt)?$/i.test(d))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(d))
      s = !0;
    else if (/^s(hift)?$/i.test(d))
      a = !0;
    else if (/^mod$/i.test(d))
      t == "mac" ? o = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + d);
  }
  return r && (i = "Alt-" + i), s && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
c(mT, "h1$1");
m(mT, "normalizeKeyName");
function hg(n, t, e) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e !== !1 && t.shiftKey && (n = "Shift-" + n), n;
}
c(hg, "Yn$1");
m(hg, "modifiers");
const WW = /* @__PURE__ */ Cl.default(/* @__PURE__ */ Ct.domEventHandlers({
  keydown(n, t) {
    return wT(yT(t.state), n, t, "editor");
  }
})), $0 = /* @__PURE__ */ $t.define({ enables: WW }), N3 = /* @__PURE__ */ new WeakMap();
function yT(n) {
  let t = n.facet($0), e = N3.get(t);
  return e || N3.set(t, e = gT(t.reduce((i, r) => i.concat(r), []))), e;
}
c(yT, "c1");
m(yT, "getKeymap");
let Cs = null;
const qW = 4e3;
function gT(n, t = DW) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ m((a, o) => {
    let l = i[a];
    if (l == null)
      i[a] = o;
    else if (l != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, "checkPrefix"), s = /* @__PURE__ */ m((a, o, l, d, u) => {
    var p, f;
    let y = e[a] || (e[a] = /* @__PURE__ */ Object.create(null)), g = o.split(/ (?!$)/).map(($) => mT($, t));
    for (let $ = 1; $ < g.length; $++) {
      let Q = g.slice(0, $).join(" ");
      r(Q, !0), y[Q] || (y[Q] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(E) => {
          let z = Cs = { view: E, prefix: Q, scope: a };
          return setTimeout(() => {
            Cs == z && (Cs = null);
          }, qW), !0;
        }]
      });
    }
    let b = g.join(" ");
    r(b, !1);
    let S = y[b] || (y[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (p = y._any) === null || p === void 0 ? void 0 : p.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && S.run.push(l), d && (S.preventDefault = !0), u && (S.stopPropagation = !0);
  }, "add");
  for (let a of n) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let d of o) {
        let u = e[d] || (e[d] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: p } = a;
        for (let f in u)
          u[f].run.push((y) => p(y, zk));
      }
    let l = a[t] || a.key;
    if (l)
      for (let d of o)
        s(d, l, a.run, a.preventDefault, a.stopPropagation), a.shift && s(d, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return e;
}
c(gT, "O1$1");
m(gT, "buildKeymap");
let zk = null;
function wT(n, t, e, i) {
  zk = t;
  let r = B8(t), s = bs(r, 0), a = Ja(s) == r.length && r != " ", o = "", l = !1, d = !1, u = !1;
  Cs && Cs.view == e && Cs.scope == i && (o = Cs.prefix + " ", x6.indexOf(t.keyCode) < 0 && (d = !0, Cs = null));
  let p = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ m((S) => {
    if (S) {
      for (let $ of S.run)
        if (!p.has($) && (p.add($), $(e)))
          return S.stopPropagation && (u = !0), !0;
      S.preventDefault && (S.stopPropagation && (u = !0), d = !0);
    }
    return !1;
  }, "runFor"), y = n[i], g, b;
  return y && (f(y[o + hg(r, t, !a)]) ? l = !0 : a && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(nt.windows && t.ctrlKey && t.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(nt.mac && t.altKey && !(t.ctrlKey || t.metaKey)) && (g = aa[t.keyCode]) && g != r ? (f(y[o + hg(g, t, !0)]) || t.shiftKey && (b = ow[t.keyCode]) != r && b != g && f(y[o + hg(b, t, !1)])) && (l = !0) : a && t.shiftKey && f(y[o + hg(r, t, !0)]) && (l = !0), !l && f(y._any) && (l = !0)), d && (l = !0), l && u && t.stopPropagation(), zk = null, l;
}
c(wT, "d1$1");
m(wT, "runHandlers");
const vT = /* @__PURE__ */ jt.define({
  map(n, t) {
    return n == null ? null : t.mapPos(n);
  }
}), dg = /* @__PURE__ */ ss.define({
  create() {
    return null;
  },
  update(n, t) {
    return n != null && (n = t.changes.mapPos(n)), t.effects.reduce((e, i) => i.is(vT) ? i.value : e, n);
  }
}), FW = /* @__PURE__ */ Br.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var t;
    let e = n.state.field(dg);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(dg) != e || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, t = n.state.field(dg), e = t != null && n.coordsAtPos(t);
    if (!e)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: e.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      n ? (this.cursor.style.left = n.left / t + "px", this.cursor.style.top = n.top / e + "px", this.cursor.style.height = n.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(dg) != n && this.view.dispatch({ effects: vT.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function ZW() {
  return [dg, FW];
}
c(ZW, "m1$1");
m(ZW, "dropCursor");
function Lk(n, t, e, i, r) {
  t.lastIndex = 0;
  for (let s = n.iterRange(e, i), a = e, o; !s.next().done; a += s.value.length)
    if (!s.lineBreak)
      for (; o = t.exec(s.value); )
        r(a + o.index, o);
}
c(Lk, "Qu$1");
m(Lk, "iterMatches");
function OT(n, t) {
  let e = n.visibleRanges;
  if (e.length == 1 && e[0].from == n.viewport.from && e[0].to == n.viewport.to)
    return e;
  let i = [];
  for (let { from: r, to: s } of e)
    r = Math.max(n.state.doc.lineAt(r).from, r - t), s = Math.min(n.state.doc.lineAt(s).to, s + t), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = s : i.push({ from: r, to: s });
  return i;
}
c(OT, "g1$1");
m(OT, "matchRanges");
var ad;
const bT = (ad = class {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: r, boundary: s, maxLength: a = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, r)
      this.addMatch = (o, l, d, u) => r(u, d, d + o[0].length, o, l);
    else if (typeof i == "function")
      this.addMatch = (o, l, d, u) => {
        let p = i(o, l, d);
        p && u(d, d + o[0].length, p);
      };
    else if (i)
      this.addMatch = (o, l, d, u) => u(d, d + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new rO(), i = e.add.bind(e);
    for (let { from: r, to: s } of OT(t, this.maxLength))
      Lk(t.state.doc, this.regexp, r, s, (a, o) => this.addMatch(o, t, a, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, r = -1;
    return t.docChanged && t.changes.iterChanges((s, a, o, l) => {
      l >= t.view.viewport.from && o <= t.view.viewport.to && (i = Math.min(o, i), r = Math.max(l, r));
    }), t.viewportMoved || r - i > 1e3 ? this.createDeco(t.view) : r > -1 ? this.updateRange(t.view, e.map(t.changes), i, r) : e;
  }
  updateRange(t, e, i, r) {
    for (let s of t.visibleRanges) {
      let a = Math.max(s.from, i), o = Math.min(s.to, r);
      if (o >= a) {
        let l = t.state.doc.lineAt(a), d = l.to < o ? t.state.doc.lineAt(o) : l, u = Math.max(s.from, l.from), p = Math.min(s.to, d.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              u = a;
              break;
            }
          for (; o < d.to; o++)
            if (this.boundary.test(d.text[o - d.from])) {
              p = o;
              break;
            }
        }
        let f = [], y, g = /* @__PURE__ */ m((b, S, $) => f.push($.range(b, S)), "add");
        if (l == d)
          for (this.regexp.lastIndex = u - l.from; (y = this.regexp.exec(l.text)) && y.index < p - l.from; )
            this.addMatch(y, t, y.index + l.from, g);
        else
          Lk(t.state.doc, this.regexp, u, p, (b, S) => this.addMatch(S, t, b, g));
        e = e.update({ filterFrom: u, filterTo: p, filter: /* @__PURE__ */ m((b, S) => b < u || S > p, "filter"), add: f });
      }
    }
    return e;
  }
}, c(ad, "Pf"), ad);
m(bT, "MatchDecorator");
let XW = bT;
var od;
const $T = (od = class extends uy {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(t) {
    let e = t.firstChild ? Jo(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), r = dy(e[0], i.direction != "rtl"), s = parseInt(i.lineHeight);
    return r.bottom - r.top > s * 1.5 ? { left: r.left, right: r.right, top: r.top, bottom: r.top + s } : r;
  }
  ignoreEvent() {
    return !1;
  }
}, c(od, "kf"), od);
m($T, "Placeholder");
let NW = $T;
function jW(n) {
  let t = Br.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = n ? Jt.set([Jt.widget({ widget: new NW(n), side: 1 }).range(0)]) : Jt.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Jt.none : this.placeholder;
    }
  }, { decorations: /* @__PURE__ */ m((e) => e.decorations, "decorations") });
  return typeof n == "string" ? [
    t,
    Ct.contentAttributes.of({ "aria-placeholder": n })
  ] : t;
}
c(jW, "Q1$1");
m(jW, "placeholder");
const D1 = "-10000px";
var ld;
const xT = (ld = class {
  constructor(t, e, i, r) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = r, this.input = t.state.facet(e), this.tooltips = this.input.filter((a) => a);
    let s = null;
    this.tooltipViews = this.tooltips.map((a) => s = i(a, s));
  }
  update(t, e) {
    var i;
    let r = t.state.facet(this.facet), s = r.filter((l) => l);
    if (r === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let a = [], o = e ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let d = s[l], u = -1;
      if (d) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let f = this.tooltips[p];
          f && f.create == d.create && (u = p);
        }
        if (u < 0)
          a[l] = this.createTooltipView(d, l ? a[l - 1] : null), o && (o[l] = !!d.above);
        else {
          let p = a[l] = this.tooltipViews[u];
          o && (o[l] = e[u]), p.update && p.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return e && (o.forEach((l, d) => e[d] = l), e.length = o.length), this.input = r, this.tooltips = s, this.tooltipViews = a, !0;
  }
}, c(ld, "$f"), ld);
m(xT, "TooltipViewManager");
let BW = xT;
function kT(n) {
  let t = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: t.clientHeight, right: t.clientWidth };
}
c(kT, "y1$1");
m(kT, "windowSpace");
const Zb = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => {
    var t, e, i;
    return {
      position: nt.ios ? "absolute" : ((t = n.find((r) => r.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = n.find((r) => r.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = n.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || kT
    };
  }, "combine")
}), j3 = /* @__PURE__ */ new WeakMap(), ST = /* @__PURE__ */ Br.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = n.state.facet(Zb);
    this.position = t.position, this.parent = t.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new BW(n, CT, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(n, this.above);
    t && this.observeIntersection();
    let e = t || n.geometryChanged, i = n.state.facet(Zb);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(n, t) {
    let e = n.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", e.dom.appendChild(r);
    }
    return e.dom.style.position = this.position, e.dom.style.top = D1, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var n, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, t = 1, e = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (nt.safari) {
        let a = s.getBoundingClientRect();
        e = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      } else
        e = !!s.offsetParent && s.offsetParent != this.container.ownerDocument.body;
    }
    if (e || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (n = s.width / this.parent.offsetWidth, t = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: t } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), r = O0(this.view);
    return {
      visible: {
        left: i.left + r.left,
        top: i.top + r.top,
        right: i.right - r.right,
        bottom: i.bottom - r.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, a) => {
        let o = this.manager.tooltipViews[a];
        return o.getCoords ? o.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(Zb).tooltipSpace(this.view),
      scaleX: n,
      scaleY: t,
      makeAbsolute: e
    };
  }
  writeMeasure(n) {
    var t;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { visible: e, space: i, scaleX: r, scaleY: s } = n, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let l = this.manager.tooltips[o], d = this.manager.tooltipViews[o], { dom: u } = d, p = n.pos[o], f = n.size[o];
      if (!p || l.clip !== !1 && (p.bottom <= Math.max(e.top, i.top) || p.top >= Math.min(e.bottom, i.bottom) || p.right < Math.max(e.left, i.left) - 0.1 || p.left > Math.min(e.right, i.right) + 0.1)) {
        u.style.top = D1;
        continue;
      }
      let y = l.arrow ? d.dom.querySelector(".cm-tooltip-arrow") : null, g = y ? 7 : 0, b = f.right - f.left, S = (t = j3.get(d)) !== null && t !== void 0 ? t : f.bottom - f.top, $ = d.offset || HW, Q = this.view.textDirection == Pe.LTR, E = f.width > i.right - i.left ? Q ? i.left : i.right - f.width : Q ? Math.max(i.left, Math.min(p.left - (y ? 14 : 0) + $.x, i.right - b)) : Math.min(Math.max(i.left, p.left - b + (y ? 14 : 0) - $.x), i.right - b), z = this.above[o];
      !l.strictSide && (z ? p.top - S - g - $.y < i.top : p.bottom + S + g + $.y > i.bottom) && z == i.bottom - p.bottom > p.top - i.top && (z = this.above[o] = !z);
      let A = (z ? p.top - i.top : i.bottom - p.bottom) - g;
      if (A < S && d.resize !== !1) {
        if (A < this.view.defaultLineHeight) {
          u.style.top = D1;
          continue;
        }
        j3.set(d, S), u.style.height = (S = A) / s + "px";
      } else u.style.height && (u.style.height = "");
      let V = z ? p.top - S - g - $.y : p.bottom + g + $.y, D = E + b;
      if (d.overlap !== !0)
        for (let X of a)
          X.left < D && X.right > E && X.top < V + S && X.bottom > V && (V = z ? X.top - S - 2 - g : X.bottom + g + 2);
      if (this.position == "absolute" ? (u.style.top = (V - n.parent.top) / s + "px", Ik(u, (E - n.parent.left) / r)) : (u.style.top = V / s + "px", Ik(u, E / r)), y) {
        let X = p.left + (Q ? $.x : -$.x) - (E + 14 - 7);
        y.style.left = X / r + "px";
      }
      d.overlap !== !0 && a.push({ left: E, top: V, right: D, bottom: V + S }), u.classList.toggle("cm-tooltip-above", z), u.classList.toggle("cm-tooltip-below", !z), d.positioned && d.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = D1;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function Ik(n, t) {
  let e = parseInt(n.style.left, 10);
  (isNaN(e) || Math.abs(t - e) > 1) && (n.style.left = t + "px");
}
c(Ik, "Su$1");
m(Ik, "setLeftStyle");
const UW = /* @__PURE__ */ Ct.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), HW = { x: 0, y: 0 }, CT = /* @__PURE__ */ $t.define({
  enables: [ST, UW]
});
function sC(n, t) {
  let e = n.plugin(ST);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
c(sC, "Gd$1");
m(sC, "getTooltip");
var cd;
const PT = (cd = class extends Ko {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}, c(cd, "Rf"), cd);
m(PT, "GutterMarker");
let Im = PT;
Im.prototype.elementClass = "";
Im.prototype.toDOM = void 0;
Im.prototype.mapMode = vi.TrackBefore;
Im.prototype.startSide = Im.prototype.endSide = -1;
Im.prototype.point = !0;
const QT = 1024;
let YW = 0;
var hd;
const TT = (hd = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, c(hd, "vf"), hd);
m(TT, "Range");
let on = TT;
var dd;
const MT = (dd = class {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = YW++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = t.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = je.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}, c(dd, "Tf"), dd);
m(MT, "NodeProp");
let Pt = MT;
Pt.closedBy = new Pt({ deserialize: /* @__PURE__ */ m((n) => n.split(" "), "deserialize") });
Pt.openedBy = new Pt({ deserialize: /* @__PURE__ */ m((n) => n.split(" "), "deserialize") });
Pt.group = new Pt({ deserialize: /* @__PURE__ */ m((n) => n.split(" "), "deserialize") });
Pt.isolate = new Pt({ deserialize: /* @__PURE__ */ m((n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
}, "deserialize") });
Pt.contextHash = new Pt({ perNode: !0 });
Pt.lookAhead = new Pt({ perNode: !0 });
Pt.mounted = new Pt({ perNode: !0 });
var ud;
const AT = (ud = class {
  constructor(t, e, i) {
    this.tree = t, this.overlay = e, this.parser = i;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[Pt.mounted.id];
  }
}, c(ud, "Af"), ud);
m(AT, "MountedTree");
let uw = AT;
const GW = /* @__PURE__ */ Object.create(null);
var Ro;
const RT = (Ro = class {
  /**
  @internal
  */
  constructor(t, e, i, r = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : GW, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), r = new Ro(t.name || "", e, t.id, i);
    if (t.props) {
      for (let s of t.props)
        if (Array.isArray(s) || (s = s(r)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[s[0].id] = s[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(Pt.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let r of i.split(" "))
        e[r] = t[i];
    return (i) => {
      for (let r = i.prop(Pt.group), s = -1; s < (r ? r.length : 0); s++) {
        let a = e[s < 0 ? i.name : r[s]];
        if (a)
          return a;
      }
    };
  }
}, c(Ro, "no"), Ro);
m(RT, "NodeType");
let je = RT;
je.none = new je(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var Eo;
const ET = (Eo = class {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let r = null;
      for (let s of t) {
        let a = s(i);
        if (a) {
          r || (r = Object.assign({}, i.props));
          let o = a[1], l = a[0];
          l.combine && l.id in r && (o = l.combine(r[l.id], o)), r[l.id] = o;
        }
      }
      e.push(r ? new je(i.name, r, i.id, i.flags) : i);
    }
    return new Eo(e);
  }
}, c(Eo, "so"), Eo);
m(ET, "NodeSet");
let x0 = ET;
const W1 = /* @__PURE__ */ new WeakMap(), B3 = /* @__PURE__ */ new WeakMap();
var Ht;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ht || (Ht = {}));
var Bs;
const _T = (Bs = class {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, e, i, r, s) {
    if (this.type = t, this.children = e, this.positions = i, this.length = r, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of s)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = uw.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (e && (e += ","), e += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new fO(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, e = 0, i = 0) {
    let r = W1.get(this) || this.topNode, s = new fO(r);
    return s.moveTo(t, e), W1.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new hn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, e = 0) {
    let i = Dm(W1.get(this) || this.topNode, t, e, !1);
    return W1.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, e = 0) {
    let i = Dm(B3.get(this) || this.topNode, t, e, !0);
    return B3.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, e = 0) {
    return ZT(this, t, e);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: e, leave: i, from: r = 0, to: s = this.length } = t, a = t.mode || 0, o = (a & Ht.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Ht.IncludeAnonymous); ; ) {
      let d = !1;
      if (l.from <= s && l.to >= r && (!o && l.type.isAnonymous || e(l) !== !1)) {
        if (l.firstChild())
          continue;
        d = !0;
      }
      for (; d && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        d = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : S0(je.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, r) => new Bs(this.type, e, i, r, this.propValues), t.makeTree || ((e, i, r) => new Bs(je.none, e, i, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return NT(t);
  }
}, c(Bs, "Xr"), Bs);
m(_T, "Tree");
let Lt = _T;
Lt.empty = new Lt(je.none, [], [], 0);
var _o;
const zT = (_o = class {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _o(this.buffer, this.index);
  }
}, c(_o, "oo"), _o);
m(zT, "FlatBufferCursor");
let KW = zT;
var zo;
const LT = (zo = class {
  /**
  Create a tree buffer.
  */
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return je.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], r = this.set.types[e], s = r.name;
    if (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)), t += 4, i == t)
      return s;
    let a = [];
    for (; t < i; )
      a.push(this.childString(t)), t = this.buffer[t + 3];
    return s + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, e, i, r, s) {
    let { buffer: a } = this, o = -1;
    for (let l = t; l != e && !(aC(s, r, a[l + 1], a[l + 2]) && (o = l, i > 0)); l = a[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(t, e, i) {
    let r = this.buffer, s = new Uint16Array(e - t), a = 0;
    for (let o = t, l = 0; o < e; ) {
      s[l++] = r[o++], s[l++] = r[o++] - i;
      let d = s[l++] = r[o++] - i;
      s[l++] = r[o++] - t, a = Math.max(a, d);
    }
    return new zo(s, a, this.set);
  }
}, c(zo, "lo"), zo);
m(LT, "TreeBuffer");
let Vm = LT;
function aC(n, t, e, i) {
  switch (n) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
c(aC, "Hd$1");
m(aC, "checkSide");
function Dm(n, t, e, i) {
  for (var r; n.from == n.to || (e < 1 ? n.from >= t : n.from > t) || (e > -1 ? n.to <= t : n.to < t); ) {
    let a = !i && n instanceof hn && n.index < 0 ? null : n.parent;
    if (!a)
      return n;
    n = a;
  }
  let s = i ? 0 : Ht.IgnoreOverlays;
  if (i)
    for (let a = n, o = a.parent; o; a = o, o = a.parent)
      a instanceof hn && a.index < 0 && ((r = o.enter(t, e, s)) === null || r === void 0 ? void 0 : r.from) != a.from && (n = o);
  for (; ; ) {
    let a = n.enter(t, e, s);
    if (!a)
      return n;
    n = a;
  }
}
c(Dm, "sn$1");
m(Dm, "resolveNode");
var pd;
const IT = (pd = class {
  cursor(t = 0) {
    return new fO(this, t);
  }
  getChild(t, e = null, i = null) {
    let r = Vk(this, t, e, i);
    return r.length ? r[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return Vk(this, t, e, i);
  }
  resolve(t, e = 0) {
    return Dm(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return Dm(this, t, e, !0);
  }
  matchContext(t) {
    return pO(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let e = this.childBefore(t), i = this;
    for (; e; ) {
      let r = e.lastChild;
      if (!r || r.to != e.to)
        break;
      r.type.isError && r.from == r.to ? (i = e, e = r.prevSibling) : e = r;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}, c(pd, "Lf"), pd);
m(IT, "BaseNode");
let VT = IT;
var Fr;
const DT = (Fr = class extends VT {
  constructor(t, e, i, r) {
    super(), this._tree = t, this.from = e, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, r, s = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: l } = a._tree, d = e > 0 ? o.length : -1; t != d; t += e) {
        let u = o[t], p = l[t] + a.from;
        if (aC(r, i, p, p + u.length)) {
          if (u instanceof Vm) {
            if (s & Ht.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, e, i - p, r);
            if (f > -1)
              return new pw(new JW(a, u, t, p), null, f);
          } else if (s & Ht.IncludeAnonymous || !u.type.isAnonymous || k0(u)) {
            let f;
            if (!(s & Ht.IgnoreMounts) && (f = uw.get(u)) && !f.overlay)
              return new Fr(f.tree, p, t, a);
            let y = new Fr(u, p, t, a);
            return s & Ht.IncludeAnonymous || !y.type.isAnonymous ? y : y.nextChild(e < 0 ? u.children.length - 1 : 0, e, i, r);
          }
        }
      }
      if (s & Ht.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? t = a.index + e : t = e < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    let r;
    if (!(i & Ht.IgnoreOverlays) && (r = uw.get(this._tree)) && r.overlay) {
      let s = t - this.from;
      for (let { from: a, to: o } of r.overlay)
        if ((e > 0 ? a <= s : a < s) && (e < 0 ? o >= s : o > s))
          return new Fr(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}, c(Fr, "wi"), Fr);
m(DT, "TreeNode");
let hn = DT;
function Vk(n, t, e, i) {
  let r = n.cursor(), s = [];
  if (!r.firstChild())
    return s;
  if (e != null) {
    for (let a = !1; !a; )
      if (a = r.type.is(e), !r.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return s;
    if (r.type.is(t) && s.push(r.node), !r.nextSibling())
      return i == null ? s : [];
  }
}
c(Vk, "wu$1");
m(Vk, "getChildren");
function pO(n, t, e = t.length - 1) {
  for (let i = n; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
c(pO, "ta$1");
m(pO, "matchNodeContext");
var fd;
const WT = (fd = class {
  constructor(t, e, i, r) {
    this.parent = t, this.buffer = e, this.index = i, this.start = r;
  }
}, c(fd, "_f"), fd);
m(WT, "BufferContext");
let JW = WT;
var Kn;
const qT = (Kn = class extends VT {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, e, i) {
    super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, e, i) {
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.context.start, i);
    return s < 0 ? null : new Kn(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    if (i & Ht.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return s < 0 ? null : new Kn(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Kn(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new Kn(this.context, this._parent, t.findChild(
      e,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, r = this.index + 4, s = i.buffer[this.index + 3];
    if (s > r) {
      let a = i.buffer[this.index + 1];
      t.push(i.slice(r, s, a)), e.push(0);
    }
    return new Lt(this.type, t, e, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}, c(Kn, "Bt"), Kn);
m(qT, "BufferNode");
let pw = qT;
function oC(n) {
  if (!n.length)
    return null;
  let t = 0, e = n[0];
  for (let s = 1; s < n.length; s++) {
    let a = n[s];
    (a.from > e.from || a.to < e.to) && (e = a, t = s);
  }
  let i = e instanceof hn && e.index < 0 ? null : e.parent, r = n.slice();
  return i ? r[t] = i : r.splice(t, 1), new tq(r, e);
}
c(oC, "Kd$1");
m(oC, "iterStack");
var md;
const FT = (md = class {
  constructor(t, e) {
    this.heads = t, this.node = e;
  }
  get next() {
    return oC(this.heads);
  }
}, c(md, "Mf"), md);
m(FT, "StackIterator");
let tq = FT;
function ZT(n, t, e) {
  let i = n.resolveInner(t, e), r = null;
  for (let s = i instanceof hn ? i : i.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let a = s.parent;
      (r || (r = [i])).push(a.resolve(t, e)), s = a;
    } else {
      let a = uw.get(s.tree);
      if (a && a.overlay && a.overlay[0].from <= t && a.overlay[a.overlay.length - 1].to >= t) {
        let o = new hn(a.tree, a.overlay[0].from + s.from, -1, s);
        (r || (r = [i])).push(Dm(o, t, e, !1));
      }
    }
  return r ? oC(r) : i;
}
c(ZT, "P1$1");
m(ZT, "stackIterator");
var yd;
const XT = (yd = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, e = 0) {
    if (this.mode = e, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof hn)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: r } = this.buffer;
    return this.type = e || r.set.types[r.buffer[t]], this.from = i + r.buffer[t + 1], this.to = i + r.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof hn ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: r } = this.buffer, s = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, e, i = this.mode) {
    return this.buffer ? i & Ht.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ht.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Ht.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(e.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = e.buffer[this.index + 3];
      if (r < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: r } = this;
    if (r) {
      if (t > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (r.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = r);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let s = e + t, a = t < 0 ? -1 : i._tree.children.length; s != a; s += t) {
          let o = i._tree.children[s];
          if (this.mode & Ht.IncludeAnonymous || o instanceof Vm || !o.type.isAnonymous || k0(o))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer)
      t: for (let r = this.index, s = this.stack.length; s >= 0; ) {
        for (let a = t; a; a = a._parent)
          if (a.index == r) {
            if (r == this.index)
              return a;
            e = a, i = s + 1;
            break t;
          }
        r = this.stack[--s];
      }
    for (let r = i; r < this.stack.length; r++)
      e = new pw(this.buffer, e, this.stack[r]);
    return this.bufferNode = new pw(this.buffer, e, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, e) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; ; ) {
        if (r && e && e(this), r = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return pO(this.node.parent, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let r = t.length - 1, s = this.stack.length - 1; r >= 0; s--) {
      if (s < 0)
        return pO(this._tree, t, r);
      let a = i[e.buffer[this.stack[s]]];
      if (!a.isAnonymous) {
        if (t[r] && t[r] != a.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}, c(yd, "Zf"), yd);
m(XT, "TreeCursor");
let fO = XT;
function k0(n) {
  return n.children.some((t) => t instanceof Vm || !t.type.isAnonymous || k0(t));
}
c(k0, "fh$1");
m(k0, "hasChild");
function NT(n) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: r = QT, reused: s = [], minRepeatType: a = i.types.length } = n, o = Array.isArray(e) ? new KW(e, e.length) : e, l = i.types, d = 0, u = 0;
  function p(A, V, D, X, Y, mt) {
    let { id: ct, start: et, end: bt, size: st } = o, Rt = u, Qt = d;
    if (st < 0)
      if (o.next(), st == -1) {
        let Ee = s[ct];
        D.push(Ee), X.push(et - A);
        return;
      } else if (st == -3) {
        d = ct;
        return;
      } else if (st == -4) {
        u = ct;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${st}`);
    let It = l[ct], Wt, qt, xi = et - A;
    if (bt - et <= r && (qt = S(o.pos - V, Y))) {
      let Ee = new Uint16Array(qt.size - qt.skip), le = o.pos - qt.size, ee = Ee.length;
      for (; o.pos > le; )
        ee = $(qt.start, Ee, ee);
      Wt = new Vm(Ee, bt - qt.start, i), xi = qt.start - A;
    } else {
      let Ee = o.pos - st;
      o.next();
      let le = [], ee = [], fe = ct >= a ? ct : -1, ki = 0, Wi = bt;
      for (; o.pos > Ee; )
        fe >= 0 && o.id == fe && o.size >= 0 ? (o.end <= Wi - r && (g(le, ee, et, ki, o.end, Wi, fe, Rt, Qt), ki = le.length, Wi = o.end), o.next()) : mt > 2500 ? f(et, Ee, le, ee) : p(et, Ee, le, ee, fe, mt + 1);
      if (fe >= 0 && ki > 0 && ki < le.length && g(le, ee, et, ki, et, Wi, fe, Rt, Qt), le.reverse(), ee.reverse(), fe > -1 && ki > 0) {
        let rn = y(It, Qt);
        Wt = S0(It, le, ee, 0, le.length, 0, bt - et, rn, rn);
      } else
        Wt = b(It, le, ee, bt - et, Rt - bt, Qt);
    }
    D.push(Wt), X.push(xi);
  }
  c(p, "u"), m(p, "takeNode");
  function f(A, V, D, X) {
    let Y = [], mt = 0, ct = -1;
    for (; o.pos > V; ) {
      let { id: et, start: bt, end: st, size: Rt } = o;
      if (Rt > 4)
        o.next();
      else {
        if (ct > -1 && bt < ct)
          break;
        ct < 0 && (ct = st - r), Y.push(et, bt, st), mt++, o.next();
      }
    }
    if (mt) {
      let et = new Uint16Array(mt * 4), bt = Y[Y.length - 2];
      for (let st = Y.length - 3, Rt = 0; st >= 0; st -= 3)
        et[Rt++] = Y[st], et[Rt++] = Y[st + 1] - bt, et[Rt++] = Y[st + 2] - bt, et[Rt++] = Rt;
      D.push(new Vm(et, Y[2] - bt, i)), X.push(bt - A);
    }
  }
  c(f, "O"), m(f, "takeFlatNode");
  function y(A, V) {
    return (D, X, Y) => {
      let mt = 0, ct = D.length - 1, et, bt;
      if (ct >= 0 && (et = D[ct]) instanceof Lt) {
        if (!ct && et.type == A && et.length == Y)
          return et;
        (bt = et.prop(Pt.lookAhead)) && (mt = X[ct] + et.length + bt);
      }
      return b(A, D, X, Y, mt, V);
    };
  }
  c(y, "d"), m(y, "makeBalanced");
  function g(A, V, D, X, Y, mt, ct, et, bt) {
    let st = [], Rt = [];
    for (; A.length > X; )
      st.push(A.pop()), Rt.push(V.pop() + D - Y);
    A.push(b(i.types[ct], st, Rt, mt - Y, et - mt, bt)), V.push(Y - D);
  }
  c(g, "p"), m(g, "makeRepeatLeaf");
  function b(A, V, D, X, Y, mt, ct) {
    if (mt) {
      let et = [Pt.contextHash, mt];
      ct = ct ? [et].concat(ct) : [et];
    }
    if (Y > 25) {
      let et = [Pt.lookAhead, Y];
      ct = ct ? [et].concat(ct) : [et];
    }
    return new Lt(A, V, D, X, ct);
  }
  c(b, "m"), m(b, "makeTree");
  function S(A, V) {
    let D = o.fork(), X = 0, Y = 0, mt = 0, ct = D.end - r, et = { size: 0, start: 0, skip: 0 };
    t: for (let bt = D.pos - A; D.pos > bt; ) {
      let st = D.size;
      if (D.id == V && st >= 0) {
        et.size = X, et.start = Y, et.skip = mt, mt += 4, X += 4, D.next();
        continue;
      }
      let Rt = D.pos - st;
      if (st < 0 || Rt < bt || D.start < ct)
        break;
      let Qt = D.id >= a ? 4 : 0, It = D.start;
      for (D.next(); D.pos > Rt; ) {
        if (D.size < 0)
          if (D.size == -3)
            Qt += 4;
          else
            break t;
        else D.id >= a && (Qt += 4);
        D.next();
      }
      Y = It, X += st, mt += Qt;
    }
    return (V < 0 || X == A) && (et.size = X, et.start = Y, et.skip = mt), et.size > 4 ? et : void 0;
  }
  c(S, "Q"), m(S, "findBufferSize");
  function $(A, V, D) {
    let { id: X, start: Y, end: mt, size: ct } = o;
    if (o.next(), ct >= 0 && X < a) {
      let et = D;
      if (ct > 4) {
        let bt = o.pos - (ct - 4);
        for (; o.pos > bt; )
          D = $(A, V, D);
      }
      V[--D] = et, V[--D] = mt - A, V[--D] = Y - A, V[--D] = X;
    } else ct == -3 ? d = X : ct == -4 && (u = X);
    return D;
  }
  c($, "y"), m($, "copyToBuffer");
  let Q = [], E = [];
  for (; o.pos > 0; )
    p(n.start || 0, n.bufferStart || 0, Q, E, -1, 0);
  let z = (t = n.length) !== null && t !== void 0 ? t : Q.length ? E[0] + Q[0].length : 0;
  return new Lt(l[n.topID], Q.reverse(), E.reverse(), z);
}
c(NT, "k1$1");
m(NT, "buildTree");
const U3 = /* @__PURE__ */ new WeakMap();
function Kg(n, t) {
  if (!n.isAnonymous || t instanceof Vm || t.type != n)
    return 1;
  let e = U3.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != n || !(i instanceof Lt)) {
        e = 1;
        break;
      }
      e += Kg(n, i);
    }
    U3.set(t, e);
  }
  return e;
}
c(Kg, "Jn$1");
m(Kg, "nodeSize");
function S0(n, t, e, i, r, s, a, o, l) {
  let d = 0;
  for (let g = i; g < r; g++)
    d += Kg(n, t[g]);
  let u = Math.ceil(
    d * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], f = [];
  function y(g, b, S, $, Q) {
    for (let E = S; E < $; ) {
      let z = E, A = b[E], V = Kg(n, g[E]);
      for (E++; E < $; E++) {
        let D = Kg(n, g[E]);
        if (V + D >= u)
          break;
        V += D;
      }
      if (E == z + 1) {
        if (V > u) {
          let D = g[z];
          y(D.children, D.positions, 0, D.children.length, b[z] + Q);
          continue;
        }
        p.push(g[z]);
      } else {
        let D = b[E - 1] + g[E - 1].length - A;
        p.push(S0(n, g, b, z, E, A, D, null, l));
      }
      f.push(A + Q - s);
    }
  }
  return c(y, "d"), m(y, "divide"), y(t, e, i, r, 0), (o || l)(p, f, a);
}
c(S0, "ch$1");
m(S0, "balanceRange");
var gd;
const jT = (gd = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, e, i) {
    let r = this.map.get(t);
    r || this.map.set(t, r = /* @__PURE__ */ new Map()), r.set(e, i);
  }
  getBuffer(t, e) {
    let i = this.map.get(t);
    return i && i.get(e);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, e) {
    t instanceof pw ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof hn && this.map.set(t.tree, e);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof pw ? this.getBuffer(t.context.buffer, t.index) : t instanceof hn ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, e) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}, c(gd, "Cf"), gd);
m(jT, "NodeWeakMap");
let BT = jT;
var Us;
const UT = (Us = class {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, e, i, r, s = !1, a = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = r, this.open = (s ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, e = [], i = !1) {
    let r = [new Us(0, t.length, t, 0, !1, i)];
    for (let s of e)
      s.to > t.length && r.push(s);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let r = [], s = 1, a = t.length ? t[0] : null;
    for (let o = 0, l = 0, d = 0; ; o++) {
      let u = o < e.length ? e[o] : null, p = u ? u.fromA : 1e9;
      if (p - l >= i)
        for (; a && a.from < p; ) {
          let f = a;
          if (l >= f.from || p <= f.to || d) {
            let y = Math.max(f.from, l) - d, g = Math.min(f.to, p) - d;
            f = y >= g ? null : new Us(y, g, f.tree, f.offset + d, o > 0, !!u);
          }
          if (f && r.push(f), a.to > p)
            break;
          a = s < t.length ? t[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, d = u.toA - u.toB;
    }
    return r;
  }
}, c(Us, "Er"), Us);
m(UT, "TreeFragment");
let dh = UT;
var wd;
const HT = (wd = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, i) {
    return typeof t == "string" && (t = new eq(t)), i = i ? i.length ? i.map((r) => new on(r.from, r.to)) : [new on(0, 0)] : [new on(0, t.length)], this.createParse(t, e || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, i) {
    let r = this.startParse(t, e, i);
    for (; ; ) {
      let s = r.advance();
      if (s)
        return s;
    }
  }
}, c(wd, "Xf"), wd);
m(HT, "Parser");
let C0 = HT;
var vd;
const YT = (vd = class {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}, c(vd, "Ef"), vd);
m(YT, "StringInput");
let eq = YT;
function lC(n) {
  return (t, e, i, r) => new nq(t, n, e, i, r);
}
c(lC, "Jd$1");
m(lC, "parseMixed");
var Od;
const GT = (Od = class {
  constructor(t, e, i, r, s) {
    this.parser = t, this.parse = e, this.overlay = i, this.target = r, this.from = s;
  }
}, c(Od, "Yf"), Od);
m(GT, "InnerParse");
let H3 = GT;
function Dk(n) {
  if (!n.length || n.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
c(Dk, "Pu$1");
m(Dk, "checkRanges");
var bd;
const KT = (bd = class {
  constructor(t, e, i, r, s, a, o) {
    this.parser = t, this.predicate = e, this.mounts = i, this.index = r, this.start = s, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
}, c(bd, "Vf"), bd);
m(KT, "ActiveOverlay");
let iq = KT;
const Wk = new Pt({ perNode: !0 });
var $d;
const JT = ($d = class {
  constructor(t, e, i, r, s) {
    this.nest = e, this.input = i, this.fragments = r, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let r of this.inner)
          r.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new Lt(i.type, i.children, i.positions, i.length, i.propValues.concat([[Wk, this.stoppedAt]]))), i;
    }
    let t = this.inner[this.innerDone], e = t.parse.advance();
    if (e) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      i[Pt.mounted.id] = new uw(e, t.overlay, t.parser), t.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let e = this.innerDone; e < this.inner.length; e++)
      this.inner[e].from < t && (t = Math.min(t, this.inner[e].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let e = this.innerDone; e < this.inner.length; e++)
        this.inner[e].parse.stopAt(t);
  }
  startInner() {
    let t = new rq(this.fragments), e = null, i = null, r = new fO(new hn(this.baseTree, this.ranges[0].from, 0, null), Ht.IncludeAnonymous | Ht.IgnoreMounts);
    t: for (let s, a; ; ) {
      let o = !0, l;
      if (this.stoppedAt != null && r.from >= this.stoppedAt)
        o = !1;
      else if (t.hasNode(r)) {
        if (e) {
          let d = e.mounts.find((u) => u.frag.from <= r.from && u.frag.to >= r.to && u.mount.overlay);
          if (d)
            for (let u of d.mount.overlay) {
              let p = u.from + d.pos, f = u.to + d.pos;
              p >= r.from && f <= r.to && !e.ranges.some((y) => y.from < f && y.to > p) && e.ranges.push({ from: p, to: f });
            }
        }
        o = !1;
      } else if (i && (a = tM(i.ranges, r.from, r.to)))
        o = a != 2;
      else if (!r.type.isAnonymous && (s = this.nest(r, this.input)) && (r.from < r.to || !s.overlay)) {
        r.tree || (eM(r), e && e.depth++, i && i.depth++);
        let d = t.findMounts(r.from, s.parser);
        if (typeof s.overlay == "function")
          e = new iq(s.parser, s.overlay, d, this.inner.length, r.from, r.tree, e);
        else {
          let u = Fk(this.ranges, s.overlay || (r.from < r.to ? [new on(r.from, r.to)] : []));
          u.length && Dk(u), (u.length || !s.overlay) && this.inner.push(new H3(s.parser, u.length ? s.parser.startParse(this.input, Zk(d, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((p) => new on(p.from - r.from, p.to - r.from)) : null, r.tree, u.length ? u[0].from : r.from)), s.overlay ? u.length && (i = { ranges: u, depth: 0, prev: i }) : o = !1;
        }
      } else if (e && (l = e.predicate(r)) && (l === !0 && (l = new on(r.from, r.to)), l.from < l.to)) {
        let d = e.ranges.length - 1;
        d >= 0 && e.ranges[d].to == l.from ? e.ranges[d] = { from: e.ranges[d].from, to: l.to } : e.ranges.push(l);
      }
      if (o && r.firstChild())
        e && e.depth++, i && i.depth++;
      else
        for (; !r.nextSibling(); ) {
          if (!r.parent())
            break t;
          if (e && !--e.depth) {
            let d = Fk(this.ranges, e.ranges);
            d.length && (Dk(d), this.inner.splice(e.index, 0, new H3(e.parser, e.parser.startParse(this.input, Zk(e.mounts, d), d), e.ranges.map((u) => new on(u.from - e.start, u.to - e.start)), e.target, d[0].from))), e = e.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}, c($d, "Wf"), $d);
m(JT, "MixedParse");
let nq = JT;
function tM(n, t, e) {
  for (let i of n) {
    if (i.from >= e)
      break;
    if (i.to > t)
      return i.from <= t && i.to >= e ? 2 : 1;
  }
  return 0;
}
c(tM, "$1$1");
m(tM, "checkCover");
function qk(n, t, e, i, r, s) {
  if (t < e) {
    let a = n.buffer[t + 1];
    i.push(n.slice(t, e, a)), r.push(a - s);
  }
}
c(qk, "ku$1");
m(qk, "sliceBuf");
function eM(n) {
  let { node: t } = n, e = [], i = t.context.buffer;
  do
    e.push(n.index), n.parent();
  while (!n.tree);
  let r = n.tree, s = r.children.indexOf(i), a = r.children[s], o = a.buffer, l = [s];
  function d(u, p, f, y, g, b) {
    let S = e[b], $ = [], Q = [];
    qk(a, u, S, $, Q, y);
    let E = o[S + 1], z = o[S + 2];
    l.push($.length);
    let A = b ? d(S + 4, o[S + 3], a.set.types[o[S]], E, z - E, b - 1) : t.toTree();
    return $.push(A), Q.push(E - y), qk(a, o[S + 3], p, $, Q, y), new Lt(f, $, Q, g);
  }
  c(d, "h"), m(d, "split"), r.children[s] = d(0, o.length, je.none, 0, a.length, e.length - 1);
  for (let u of l) {
    let p = n.tree.children[u], f = n.tree.positions[u];
    n.yield(new hn(p, f + n.from, u, n._tree));
  }
}
c(eM, "R1$1");
m(eM, "materialize");
var xd;
const iM = (xd = class {
  constructor(t, e) {
    this.offset = e, this.done = !1, this.cursor = t.cursor(Ht.IncludeAnonymous | Ht.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: e } = this, i = t - this.offset;
    for (; !this.done && e.from < i; )
      e.to >= t && e.enter(i, 1, Ht.IgnoreOverlays | Ht.ExcludeBuffers) || e.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let e = this.cursor.tree; ; ) {
        if (e == t.tree)
          return !0;
        if (e.children.length && e.positions[0] == 0 && e.children[0] instanceof Lt)
          e = e.children[0];
        else
          break;
      }
    return !1;
  }
}, c(xd, "Uf"), xd);
m(iM, "StructureCursor");
let Y3 = iM;
var Xb, kd;
let rq = (Xb = (kd = class {
  constructor(t) {
    var e;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let i = this.curFrag = t[0];
      this.curTo = (e = i.tree.prop(Wk)) !== null && e !== void 0 ? e : i.to, this.inner = new Y3(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let e = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = e.tree.prop(Wk)) !== null && t !== void 0 ? t : e.to, this.inner = new Y3(e.tree, -e.offset);
    }
  }
  findMounts(t, e) {
    var i;
    let r = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let a = (i = s.tree) === null || i === void 0 ? void 0 : i.prop(Pt.mounted);
        if (a && a.parser == e)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && r.push({
              frag: l,
              pos: s.from - l.offset,
              mount: a
            });
          }
      }
    }
    return r;
  }
}, c(kd, "Li"), kd), m(Xb, "FragmentCursor"), Xb);
function Fk(n, t) {
  let e = null, i = t;
  for (let r = 1, s = 0; r < n.length; r++) {
    let a = n[r - 1].to, o = n[r].from;
    for (; s < i.length; s++) {
      let l = i[s];
      if (l.from >= o)
        break;
      l.to <= a || (e || (i = e = t.slice()), l.from < a ? (e[s] = new on(l.from, a), l.to > o && e.splice(s + 1, 0, new on(o, l.to))) : l.to > o ? e[s--] = new on(o, l.to) : e.splice(s--, 1));
    }
  }
  return i;
}
c(Fk, "$u$1");
m(Fk, "punchRanges");
function nM(n, t, e, i) {
  let r = 0, s = 0, a = !1, o = !1, l = -1e9, d = [];
  for (; ; ) {
    let u = r == n.length ? 1e9 : a ? n[r].to : n[r].from, p = s == t.length ? 1e9 : o ? t[s].to : t[s].from;
    if (a != o) {
      let f = Math.max(l, e), y = Math.min(u, p, i);
      f < y && d.push(new on(f, y));
    }
    if (l = Math.min(u, p), l == 1e9)
      break;
    u == l && (a ? (a = !1, r++) : a = !0), p == l && (o ? (o = !1, s++) : o = !0);
  }
  return d;
}
c(nM, "T1$1");
m(nM, "findCoverChanges");
function Zk(n, t) {
  let e = [];
  for (let { pos: i, mount: r, frag: s } of n) {
    let a = i + (r.overlay ? r.overlay[0].from : 0), o = a + r.tree.length, l = Math.max(s.from, a), d = Math.min(s.to, o);
    if (r.overlay) {
      let u = r.overlay.map((f) => new on(f.from + i, f.to + i)), p = nM(t, u, l, d);
      for (let f = 0, y = l; ; f++) {
        let g = f == p.length, b = g ? d : p[f].from;
        if (b > y && e.push(new dh(y, b, r.tree, -a, s.from >= y || s.openStart, s.to <= b || s.openEnd)), g)
          break;
        y = p[f].to;
      }
    } else
      e.push(new dh(l, d, r.tree, -a, s.from >= a || s.openStart, s.to <= o || s.openEnd));
  }
  return e;
}
c(Zk, "Ru$1");
m(Zk, "enterFragments");
let sq = 0;
var Hs;
const rM = (Hs = class {
  /**
  @internal
  */
  constructor(t, e, i, r) {
    this.name = t, this.set = e, this.base = i, this.modified = r, this.id = sq++;
  }
  toString() {
    let { name: t } = this;
    for (let e of this.modified)
      e.name && (t = `${e.name}(${t})`);
    return t;
  }
  static define(t, e) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof Hs && (e = t), e?.base)
      throw new Error("Can not derive from a modified tag");
    let r = new Hs(i, [], null, []);
    if (r.set.push(r), e)
      for (let s of e.set)
        r.set.push(s);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let e = new G3(t);
    return (i) => i.modified.indexOf(e) > -1 ? i : G3.get(i.base || i, i.modified.concat(e).sort((r, s) => r.id - s.id));
  }
}, c(Hs, "Yr"), Hs);
m(rM, "Tag");
let Bn = rM, aq = 0;
var Lo;
const sM = (Lo = class {
  constructor(t) {
    this.name = t, this.instances = [], this.id = aq++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((o) => o.base == t && aM(e, o.modified));
    if (i)
      return i;
    let r = [], s = new Bn(t.name, r, t, e);
    for (let o of e)
      o.instances.push(s);
    let a = oM(e);
    for (let o of t.set)
      if (!o.modified.length)
        for (let l of a)
          r.push(Lo.get(o, l));
    return s;
  }
}, c(Lo, "ao"), Lo);
m(sM, "Modifier");
let G3 = sM;
function aM(n, t) {
  return n.length == t.length && n.every((e, i) => e == t[i]);
}
c(aM, "_1$1");
m(aM, "sameArray");
function oM(n) {
  let t = [[]];
  for (let e = 0; e < n.length; e++)
    for (let i = 0, r = t.length; i < r; i++)
      t.push(t[i].concat(n[e]));
  return t.sort((e, i) => i.length - e.length);
}
c(oM, "M1$1");
m(oM, "powerSet");
function Pl(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in n) {
    let i = n[e];
    Array.isArray(i) || (i = [i]);
    for (let r of e.split(" "))
      if (r) {
        let s = [], a = 2, o = r;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == r.length) {
            a = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!f)
            throw new RangeError("Invalid path: " + r);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), p += f[0].length, p == r.length)
            break;
          let y = r[p++];
          if (p == r.length && y == "!") {
            a = 0;
            break;
          }
          if (y != "/")
            throw new RangeError("Invalid path: " + r);
          o = r.slice(p);
        }
        let l = s.length - 1, d = s[l];
        if (!d)
          throw new RangeError("Invalid path: " + r);
        let u = new fw(i, a, l > 0 ? s.slice(0, l) : null);
        t[d] = u.sort(t[d]);
      }
  }
  return lM.add(t);
}
c(Pl, "Ji$1");
m(Pl, "styleTags");
const lM = new Pt({
  combine(n, t) {
    let e, i, r;
    for (; n || t; ) {
      if (!n || t && n.depth >= t.depth ? (r = t, t = t.next) : (r = n, n = n.next), e && e.mode == r.mode && !r.context && !e.context)
        continue;
      let s = new fw(r.tags, r.mode, r.context);
      e ? e.next = s : i = s, e = s;
    }
    return i;
  }
});
var Nb, Sd;
let fw = (Nb = (Sd = class {
  constructor(t, e, i, r) {
    this.tags = t, this.mode = e, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}, c(Sd, "_i$1"), Sd), m(Nb, "Rule"), Nb);
fw.empty = new fw([], 2, null);
function cC(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      e[s.tag.id] = s.class;
    else
      for (let a of s.tag)
        e[a.id] = s.class;
  let { scope: i, all: r = null } = t || {};
  return {
    style: /* @__PURE__ */ m((s) => {
      let a = r;
      for (let o of s)
        for (let l of o.set) {
          let d = e[l.id];
          if (d) {
            a = a ? a + " " + d : d;
            break;
          }
        }
      return a;
    }, "style"),
    scope: i
  };
}
c(cC, "tp");
m(cC, "tagHighlighter");
function cM(n, t) {
  let e = null;
  for (let i of n) {
    let r = i.style(t);
    r && (e = e ? e + " " + r : r);
  }
  return e;
}
c(cM, "Z1$1");
m(cM, "highlightTags");
function hM(n, t, e, i = 0, r = n.length) {
  let s = new oq(i, Array.isArray(t) ? t : [t], e);
  s.highlightRange(n.cursor(), i, r, "", s.highlighters), s.flush(r);
}
c(hM, "C1$1");
m(hM, "highlightTree");
var Cd;
const dM = (Cd = class {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, r, s) {
    let { type: a, from: o, to: l } = t;
    if (o >= i || l <= e)
      return;
    a.isTop && (s = this.highlighters.filter((y) => !y.scope || y.scope(a)));
    let d = r, u = uM(t) || fw.empty, p = cM(s, u.tags);
    if (p && (d && (d += " "), d += p, u.mode == 1 && (r += (r ? " " : "") + p)), this.startSpan(Math.max(e, o), d), u.opaque)
      return;
    let f = t.tree && t.tree.prop(Pt.mounted);
    if (f && f.overlay) {
      let y = t.node.enter(f.overlay[0].from + o, 1), g = this.highlighters.filter((S) => !S.scope || S.scope(f.tree.type)), b = t.firstChild();
      for (let S = 0, $ = o; ; S++) {
        let Q = S < f.overlay.length ? f.overlay[S] : null, E = Q ? Q.from + o : l, z = Math.max(e, $), A = Math.min(i, E);
        if (z < A && b)
          for (; t.from < A && (this.highlightRange(t, z, A, r, s), this.startSpan(Math.min(A, t.to), d), !(t.to >= E || !t.nextSibling())); )
            ;
        if (!Q || E > i)
          break;
        $ = Q.to + o, $ > e && (this.highlightRange(y.cursor(), Math.max(e, Q.from + o), Math.min(i, $), "", g), this.startSpan(Math.min(i, $), d));
      }
      b && t.parent();
    } else if (t.firstChild()) {
      f && (r = "");
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, r, s), this.startSpan(Math.min(i, t.to), d);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}, c(Cd, "If"), Cd);
m(dM, "HighlightBuilder");
let oq = dM;
function uM(n) {
  let t = n.type.prop(lM);
  for (; t && t.context && !n.matchContext(t.context); )
    t = t.next;
  return t || null;
}
c(uM, "X1$1");
m(uM, "getStyleTags");
const J = Bn.define, q1 = J(), $s = J(), K3 = J($s), J3 = J($s), xs = J(), F1 = J(xs), jb = J(xs), Zn = J(), za = J(Zn), Dn = J(), Wn = J(), Xk = J(), Ry = J(Xk), Z1 = J(), T = {
  /**
  A comment.
  */
  comment: q1,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: J(q1),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: J(q1),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: J(q1),
  /**
  Any kind of identifier.
  */
  name: $s,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: J($s),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: K3,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: J(K3),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: J3,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: J(J3),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: J($s),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: J($s),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: J($s),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: J($s),
  /**
  A literal value.
  */
  literal: xs,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: F1,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: J(F1),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: J(F1),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: J(F1),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: jb,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: J(jb),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: J(jb),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: J(xs),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: J(xs),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: J(xs),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: J(xs),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: J(xs),
  /**
  A language keyword.
  */
  keyword: Dn,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: J(Dn),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: J(Dn),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: J(Dn),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: J(Dn),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: J(Dn),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: J(Dn),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: J(Dn),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: J(Dn),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: J(Dn),
  /**
  An operator.
  */
  operator: Wn,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: J(Wn),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: J(Wn),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: J(Wn),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: J(Wn),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: J(Wn),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: J(Wn),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: J(Wn),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: J(Wn),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: J(Wn),
  /**
  Program or markup punctuation.
  */
  punctuation: Xk,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: J(Xk),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Ry,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: J(Ry),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: J(Ry),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: J(Ry),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: J(Ry),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Zn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: za,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: J(za),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: J(za),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: J(za),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: J(za),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: J(za),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: J(za),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: J(Zn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: J(Zn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: J(Zn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: J(Zn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: J(Zn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: J(Zn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: J(Zn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: J(Zn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: J(),
  /**
  Deleted text.
  */
  deleted: J(),
  /**
  Changed text.
  */
  changed: J(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: J(),
  /**
  Metadata or meta-instruction.
  */
  meta: Z1,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: J(Z1),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: J(Z1),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: J(Z1),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Bn.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Bn.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Bn.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Bn.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Bn.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Bn.defineModifier("special")
};
for (let n in T) {
  let t = T[n];
  t instanceof Bn && (t.name = n);
}
cC([
  { tag: T.link, class: "tok-link" },
  { tag: T.heading, class: "tok-heading" },
  { tag: T.emphasis, class: "tok-emphasis" },
  { tag: T.strong, class: "tok-strong" },
  { tag: T.keyword, class: "tok-keyword" },
  { tag: T.atom, class: "tok-atom" },
  { tag: T.bool, class: "tok-bool" },
  { tag: T.url, class: "tok-url" },
  { tag: T.labelName, class: "tok-labelName" },
  { tag: T.inserted, class: "tok-inserted" },
  { tag: T.deleted, class: "tok-deleted" },
  { tag: T.literal, class: "tok-literal" },
  { tag: T.string, class: "tok-string" },
  { tag: T.number, class: "tok-number" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "tok-string2" },
  { tag: T.variableName, class: "tok-variableName" },
  { tag: T.local(T.variableName), class: "tok-variableName tok-local" },
  { tag: T.definition(T.variableName), class: "tok-variableName tok-definition" },
  { tag: T.special(T.variableName), class: "tok-variableName2" },
  { tag: T.definition(T.propertyName), class: "tok-propertyName tok-definition" },
  { tag: T.typeName, class: "tok-typeName" },
  { tag: T.namespace, class: "tok-namespace" },
  { tag: T.className, class: "tok-className" },
  { tag: T.macroName, class: "tok-macroName" },
  { tag: T.propertyName, class: "tok-propertyName" },
  { tag: T.operator, class: "tok-operator" },
  { tag: T.comment, class: "tok-comment" },
  { tag: T.meta, class: "tok-meta" },
  { tag: T.invalid, class: "tok-invalid" },
  { tag: T.punctuation, class: "tok-punctuation" }
]);
var Bb;
const Ts = /* @__PURE__ */ new Pt();
function t1(n) {
  return $t.define({
    combine: n ? (t) => t.concat(n) : void 0
  });
}
c(t1, "bo$1");
m(t1, "defineLanguageFacet");
const hC = /* @__PURE__ */ new Pt();
var Pd;
const pM = (Pd = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, e, i = [], r = "") {
    this.data = t, this.name = r, Le.prototype.hasOwnProperty("tree") || Object.defineProperty(Le.prototype, "tree", { get() {
      return ae(this);
    } }), this.parser = e, this.extension = [
      Wm.of(this),
      Le.languageData.of((s, a, o) => {
        let l = Nk(s, a, o), d = l.type.prop(Ts);
        if (!d)
          return [];
        let u = s.facet(d), p = l.type.prop(hC);
        if (p) {
          let f = l.resolve(a - l.from, o);
          for (let y of p)
            if (y.test(f, s)) {
              let g = s.facet(y.facet);
              return y.type == "replace" ? g : g.concat(u);
            }
        }
        return u;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, e, i = -1) {
    return Nk(t, e, i).type.prop(Ts) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let e = t.facet(Wm);
    if (e?.data == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], r = /* @__PURE__ */ m((s, a) => {
      if (s.prop(Ts) == this.data) {
        i.push({ from: a, to: a + s.length });
        return;
      }
      let o = s.prop(Pt.mounted);
      if (o) {
        if (o.tree.prop(Ts) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + a, to: l.to + a });
          else
            i.push({ from: a, to: a + s.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (r(o.tree, o.overlay[0].from + a), i.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let d = s.children[l];
        d instanceof Lt && r(d, s.positions[l] + a);
      }
    }, "explore");
    return r(ae(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}, c(Pd, "zf"), Pd);
m(pM, "Language");
let Yi = pM;
Yi.setState = /* @__PURE__ */ jt.define();
function Nk(n, t, e) {
  let i = n.facet(Wm), r = ae(n).topNode;
  if (!i || i.allowsNesting)
    for (let s = r; s; s = s.enter(t, e, Ht.ExcludeBuffers))
      s.type.isTop && (r = s);
  return r;
}
c(Nk, "Au$1");
m(Nk, "topNodeAt");
var Ys;
const fM = (Ys = class extends Yi {
  constructor(t, e, i) {
    super(t, e, [], i), this.parser = e;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let e = t1(t.languageData);
    return new Ys(e, t.parser.configure({
      props: [Ts.add((i) => i.isTop ? e : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, e) {
    return new Ys(this.data, this.parser.configure(t), e || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}, c(Ys, "Vr"), Ys);
m(fM, "LRLanguage");
let dC = fM;
function ae(n) {
  let t = n.field(Yi.state, !1);
  return t ? t.tree : Lt.empty;
}
c(ae, "H$2");
m(ae, "syntaxTree");
var Qd;
const mM = (Qd = class {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}, c(Qd, "jf"), Qd);
m(mM, "DocInput");
let lq = mM, Ey = null;
var Gs;
const yM = (Gs = class {
  constructor(t, e, i = [], r, s, a, o, l) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = r, this.treeLen = s, this.viewport = a, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Gs(t, e, [], Lt.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new lq(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != Lt.empty && this.isDone(e ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let r = Date.now() + t;
        t = /* @__PURE__ */ m(() => Date.now() > r, "until");
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(dh.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (e ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(dh.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = Ey;
    Ey = this;
    try {
      return t();
    } finally {
      Ey = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = jk(t, e.from, e.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, e) {
    let { fragments: i, tree: r, treeLen: s, viewport: a, skipped: o } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((d, u, p, f) => l.push({ fromA: d, toA: u, fromB: p, toB: f })), i = dh.applyChanges(i, l), r = Lt.empty, s = 0, a = { from: t.mapPos(a.from, -1), to: t.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let d of this.skipped) {
          let u = t.mapPos(d.from, 1), p = t.mapPos(d.to, -1);
          u < p && o.push({ from: u, to: p });
        }
      }
    }
    return new Gs(this.parser, e, i, r, s, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: s } = this.skipped[i];
      r < t.to && s > t.from && (this.fragments = jk(this.fragments, r, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends C0 {
      createParse(e, i, r) {
        let s = r[0].from, a = r[r.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let o = Ey;
            if (o) {
              for (let l of r)
                o.tempSkipped.push(l);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = a, new Lt(je.none, [], [], a - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Ey;
  }
}, c(Gs, "Wr"), Gs);
m(yM, "ParseContext");
let mO = yM;
function jk(n, t, e) {
  return dh.applyChanges(n, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
c(jk, "Lu$1");
m(jk, "cutFragments");
var Ks;
const gM = (Ks = class {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new Ks(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = mO.create(t.facet(Wm).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new Ks(i);
  }
}, c(Ks, "Ur"), Ks);
m(gM, "LanguageState");
let Bk = gM;
Yi.state = /* @__PURE__ */ ss.define({
  create: Bk.init,
  update(n, t) {
    for (let e of t.effects)
      if (e.is(Yi.setState))
        return e.value;
    return t.startState.facet(Wm) != t.state.facet(Wm) ? Bk.init(t.state) : n.apply(t);
  }
});
let wM = /* @__PURE__ */ m((n) => {
  let t = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
}, "requestIdle");
typeof requestIdleCallback < "u" && (wM = /* @__PURE__ */ m((n) => {
  let t = -1, e = setTimeout(
    () => {
      t = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
}, "requestIdle"));
const Ub = typeof navigator < "u" && !((Bb = navigator.scheduling) === null || Bb === void 0) && Bb.isInputPending ? () => navigator.scheduling.isInputPending() : null;
var Hb, Td;
const cq = /* @__PURE__ */ Br.fromClass((Hb = (Td = class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Yi.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Yi.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = wM(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, s = i.field(Yi.state);
    if (s.tree == s.context.tree && s.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, t && !Ub ? Math.max(25, t.timeRemaining() - 5) : 1e9), o = s.context.treeLen < r && i.doc.length > r + 1e3, l = s.context.work(() => Ub && Ub() || Date.now() > a, r + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Yi.setState.of(new Bk(s.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Qi(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, c(Td, "Mi$1"), Td), m(Hb, "ParseWorker"), Hb), {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Wm = /* @__PURE__ */ $t.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: /* @__PURE__ */ m((n) => [
    Yi.state,
    cq,
    Ct.contentAttributes.compute([n], (t) => {
      let e = t.facet(n);
      return e && e.name ? { "data-language": e.name } : {};
    })
  ], "enables")
});
var Md;
const vM = (Md = class {
  /**
  Create a language support object.
  */
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}, c(Md, "qf"), Md);
m(vM, "LanguageSupport");
let qm = vM;
var Io;
const OM = (Io = class {
  constructor(t, e, i, r, s, a = void 0) {
    this.name = t, this.alias = e, this.extensions = i, this.filename = r, this.loadFunc = s, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((t) => this.support = t, (t) => {
      throw this.loading = null, t;
    }));
  }
  /**
  Create a language description.
  */
  static of(t) {
    let { load: e, support: i } = t;
    if (!e) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      e = /* @__PURE__ */ m(() => Promise.resolve(i), "load");
    }
    return new Io(t.name, (t.alias || []).concat(t.name).map((r) => r.toLowerCase()), t.extensions || [], t.filename, e, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(t, e) {
    for (let r of t)
      if (r.filename && r.filename.test(e))
        return r;
    let i = /\.([^.]+)$/.exec(e);
    if (i) {
      for (let r of t)
        if (r.extensions.indexOf(i[1]) > -1)
          return r;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(t, e, i = !0) {
    e = e.toLowerCase();
    for (let r of t)
      if (r.alias.some((s) => s == e))
        return r;
    if (i)
      for (let r of t)
        for (let s of r.alias) {
          let a = e.indexOf(s);
          if (a > -1 && (s.length > 2 || !/\w/.test(e[a - 1]) && !/\w/.test(e[a + s.length])))
            return r;
        }
    return null;
  }
}, c(Io, "ho"), Io);
m(OM, "LanguageDescription");
let tQ = OM;
const hq = /* @__PURE__ */ $t.define(), P0 = /* @__PURE__ */ $t.define({
  combine: /* @__PURE__ */ m((n) => {
    if (!n.length)
      return "  ";
    let t = n[0];
    if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return t;
  }, "combine")
});
function mw(n) {
  let t = n.facet(P0);
  return t.charCodeAt(0) == 9 ? n.tabSize * t.length : t.length;
}
c(mw, "hi$1");
m(mw, "getIndentUnit");
function Uk(n, t) {
  let e = "", i = n.tabSize, r = n.facet(P0)[0];
  if (r == "	") {
    for (; t >= i; )
      e += "	", t -= i;
    r = " ";
  }
  for (let s = 0; s < t; s++)
    e += r;
  return e;
}
c(Uk, "ws$1");
m(Uk, "indentString");
function bM(n, t) {
  n instanceof Le && (n = new uC(n));
  for (let i of n.state.facet(hq)) {
    let r = i(n, t);
    if (r !== void 0)
      return r;
  }
  let e = ae(n.state);
  return e.length >= t ? xM(n, e, t) : null;
}
c(bM, "rp");
m(bM, "getIndentation");
var Ad;
const $M = (Ad = class {
  /**
  Create an indent context.
  */
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = mw(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: r, simulateDoubleBreak: s } = this.options;
    return r != null && r >= i.from && r <= i.to ? s && r == t ? { text: "", from: t } : (e < 0 ? r < t : r <= t) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(t, e);
    return i.slice(t - r, Math.min(i.length, t + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(t, e = 1) {
    let { text: i, from: r } = this.lineAt(t, e), s = this.countColumn(i, t - r), a = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return a > -1 && (s += a - this.countColumn(i, i.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, e = t.length) {
    return ra(t, this.state.tabSize, e);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, e = 1) {
    let { text: i, from: r } = this.lineAt(t, e), s = this.options.overrideIndentation;
    if (s) {
      let a = s(r);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}, c(Ad, "Df"), Ad);
m($M, "IndentContext");
let uC = $M;
const py = /* @__PURE__ */ new Pt();
function xM(n, t, e) {
  let i = t.resolveStack(e), r = t.resolveInner(e, -1).resolve(e, 0).enterUnfinishedNodesBefore(e);
  if (r != i.node) {
    let s = [];
    for (let a = r; a && !(a.from < i.node.from || a.to > i.node.to || a.from == i.node.from && a.type == i.node.type); a = a.parent)
      s.push(a);
    for (let a = s.length - 1; a >= 0; a--)
      i = { node: s[a], next: i };
  }
  return pC(i, n, e);
}
c(xM, "V1$1");
m(xM, "syntaxIndentation");
function pC(n, t, e) {
  for (let i = n; i; i = i.next) {
    let r = SM(i.node);
    if (r)
      return r(dq.create(t, e, i));
  }
  return 0;
}
c(pC, "np");
m(pC, "indentFor");
function kM(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
c(kM, "W1$1");
m(kM, "ignoreClosed");
function SM(n) {
  let t = n.type.prop(py);
  if (t)
    return t;
  let e = n.firstChild, i;
  if (e && (i = e.type.prop(Pt.closedBy))) {
    let r = n.lastChild, s = r && i.indexOf(r.name) > -1;
    return (a) => fC(a, !0, 1, void 0, s && !kM(a) ? r.from : void 0);
  }
  return n.parent == null ? CM : null;
}
c(SM, "U1$1");
m(SM, "indentStrategy");
function CM() {
  return 0;
}
c(CM, "I1$1");
m(CM, "topIndent");
var Vo;
const PM = (Vo = class extends uC {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Vo(t, e, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let e = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (QM(i, t))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return pC(this.context.next, this.base, this.pos);
  }
}, c(Vo, "fo"), Vo);
m(PM, "TreeIndentContext");
let dq = PM;
function QM(n, t) {
  for (let e = t; e; e = e.parent)
    if (n == e)
      return !0;
  return !1;
}
c(QM, "z1$1");
m(QM, "isParent");
function TM(n) {
  let t = n.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let r = n.options.simulateBreak, s = n.state.doc.lineAt(e.from), a = r == null || r <= s.from ? s.to : Math.min(s.to, r);
  for (let o = e.to; ; ) {
    let l = t.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= a)
        return null;
      let d = /^ */.exec(s.text.slice(e.to - s.from))[0].length;
      return { from: e.from, to: e.to + d };
    }
    o = l.to;
  }
}
c(TM, "j1$1");
m(TM, "bracketedAligned");
function MM({ closing: n, align: t = !0, units: e = 1 }) {
  return (i) => fC(i, t, e, n);
}
c(MM, "q1$1");
m(MM, "delimitedIndent");
function fC(n, t, e, i, r) {
  let s = n.textAfter, a = s.match(/^\s*/)[0].length, o = i && s.slice(a, a + i.length) == i || r == n.pos + a, l = t ? TM(n) : null;
  return l ? o ? n.column(l.from) : n.column(l.to) : n.baseIndent + (o ? 0 : n.unit * e);
}
c(fC, "sp");
m(fC, "delimitedStrategy");
const uq = /* @__PURE__ */ m((n) => n.baseIndent, "flatIndent");
function Jg({ except: n, units: t = 1 } = {}) {
  return (e) => {
    let i = n && n.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
c(Jg, "es$2");
m(Jg, "continuedIndent");
const pq = /* @__PURE__ */ $t.define(), e1 = /* @__PURE__ */ new Pt();
function mC(n) {
  let t = n.firstChild, e = n.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? n.to : e.from } : null;
}
c(mC, "op");
m(mC, "foldInside");
var Do;
const AM = (Do = class {
  constructor(t, e) {
    this.specs = t;
    let i;
    function r(o) {
      let l = sa.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    c(r, "n"), m(r, "def");
    const s = typeof e.all == "string" ? e.all : e.all ? r(e.all) : void 0, a = e.scope;
    this.scope = a instanceof Yi ? (o) => o.prop(Ts) == a.data : a ? (o) => o == a : void 0, this.style = cC(t.map((o) => ({
      tag: o.tag,
      class: o.class || r(Object.assign({}, o, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new sa(i) : null, this.themeType = e.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, e) {
    return new Do(t, e || {});
  }
}, c(Do, "co"), Do);
m(AM, "HighlightStyle");
let RM = AM;
const Hk = /* @__PURE__ */ $t.define(), EM = /* @__PURE__ */ $t.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function uv(n) {
  let t = n.facet(Hk);
  return t.length ? t : n.facet(EM);
}
c(uv, "Eo$1");
m(uv, "getHighlighters");
function fq(n, t) {
  let e = [yq], i;
  return n instanceof RM && (n.module && e.push(Ct.styleModule.of(n.module)), i = n.themeType), t?.fallback ? e.push(EM.of(n)) : i ? e.push(Hk.computeN([Ct.darkTheme], (r) => r.facet(Ct.darkTheme) == (i == "dark") ? [n] : [])) : e.push(Hk.of(n)), e;
}
c(fq, "N1$1");
m(fq, "syntaxHighlighting");
var Rd;
const _M = (Rd = class {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ae(t.state), this.decorations = this.buildDeco(t, uv(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let e = ae(t.state), i = uv(t.state), r = i != uv(t.startState), { viewport: s } = t.view, a = t.changes.mapPos(this.decoratedTo, 1);
    e.length < s.to && !r && e.type == this.tree.type && a >= s.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = a) : (e != this.tree || t.viewportChanged || r) && (this.tree = e, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = s.to);
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return Jt.none;
    let i = new rO();
    for (let { from: r, to: s } of t.visibleRanges)
      hM(this.tree, e, (a, o, l) => {
        i.add(a, o, this.markCache[l] || (this.markCache[l] = Jt.mark({ class: l })));
      }, r, s);
    return i.finish();
  }
}, c(Rd, "Bf"), Rd);
m(_M, "TreeHighlighter");
let mq = _M;
const yq = /* @__PURE__ */ Cl.high(/* @__PURE__ */ Br.fromClass(mq, {
  decorations: /* @__PURE__ */ m((n) => n.decorations, "decorations")
})), gq = 1e4, wq = "()[]{}", zM = /* @__PURE__ */ new Pt();
function yO(n, t, e) {
  let i = n.prop(t < 0 ? Pt.openedBy : Pt.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let r = e.indexOf(n.name);
    if (r > -1 && r % 2 == (t < 0 ? 1 : 0))
      return [e[r + t]];
  }
  return null;
}
c(yO, "da$1");
m(yO, "matchingNodes");
function gO(n) {
  let t = n.type.prop(zM);
  return t ? t(n.node) : n;
}
c(gO, "pa$1");
m(gO, "findHandle");
function io(n, t, e, i = {}) {
  let r = i.maxScanDistance || gq, s = i.brackets || wq, a = ae(n), o = a.resolveInner(t, e);
  for (let l = o; l; l = l.parent) {
    let d = yO(l.type, e, s);
    if (d && l.from < l.to) {
      let u = gO(l);
      if (u && (e > 0 ? t >= u.from && t < u.to : t > u.from && t <= u.to))
        return LM(n, t, e, l, u, d, s);
    }
  }
  return IM(n, t, e, a, o.type, r, s);
}
c(io, "gi$1");
m(io, "matchBrackets");
function LM(n, t, e, i, r, s, a) {
  let o = i.parent, l = { from: r.from, to: r.to }, d = 0, u = o?.cursor();
  if (u && (e < 0 ? u.childBefore(i.from) : u.childAfter(i.to)))
    do
      if (e < 0 ? u.to <= i.from : u.from >= i.to) {
        if (d == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let p = gO(u);
          return { start: l, end: p ? { from: p.from, to: p.to } : void 0, matched: !0 };
        } else if (yO(u.type, e, a))
          d++;
        else if (yO(u.type, -e, a)) {
          if (d == 0) {
            let p = gO(u);
            return {
              start: l,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: !1
            };
          }
          d--;
        }
      }
    while (e < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
c(LM, "K1$1");
m(LM, "matchMarkedBrackets");
function IM(n, t, e, i, r, s, a) {
  let o = e < 0 ? n.sliceDoc(t - 1, t) : n.sliceDoc(t, t + 1), l = a.indexOf(o);
  if (l < 0 || l % 2 == 0 != e > 0)
    return null;
  let d = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, u = n.doc.iterRange(t, e > 0 ? n.doc.length : 0), p = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let y = u.value;
    e < 0 && (f += y.length);
    let g = t + f * e;
    for (let b = e > 0 ? 0 : y.length - 1, S = e > 0 ? y.length : -1; b != S; b += e) {
      let $ = a.indexOf(y[b]);
      if (!($ < 0 || i.resolveInner(g + b, 1).type != r))
        if ($ % 2 == 0 == e > 0)
          p++;
        else {
          if (p == 1)
            return { start: d, end: { from: g + b, to: g + b + 1 }, matched: $ >> 1 == l >> 1 };
          p--;
        }
    }
    e > 0 && (f += y.length);
  }
  return u.done ? { start: d, matched: !1 } : null;
}
c(IM, "J1$1");
m(IM, "matchPlainBrackets");
function Yk(n, t, e, i = 0, r = 0) {
  t == null && (t = n.search(/[^\s\u00a0]/), t == -1 && (t = n.length));
  let s = r;
  for (let a = i; a < t; a++)
    n.charCodeAt(a) == 9 ? s += e - s % e : s++;
  return s;
}
c(Yk, "_u$1");
m(Yk, "countCol");
var Ed;
const VM = (Ed = class {
  /**
  Create a stream.
  */
  constructor(t, e, i, r) {
    this.string = t, this.tabSize = e, this.indentUnit = i, this.overrideIndent = r, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(t) {
    let e = this.string.charAt(this.pos), i;
    if (typeof t == "string" ? i = e == t : i = e && (t instanceof RegExp ? t.test(e) : t(e)), i)
      return ++this.pos, e;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(t) {
    let e = this.pos;
    for (; this.eat(t); )
      ;
    return this.pos > e;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let t = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > t;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(t) {
    let e = this.string.indexOf(t, this.pos);
    if (e > -1)
      return this.pos = e, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(t) {
    this.pos -= t;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Yk(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var t;
    return (t = this.overrideIndent) !== null && t !== void 0 ? t : Yk(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(t, e, i) {
    if (typeof t == "string") {
      let r = /* @__PURE__ */ m((a) => i ? a.toLowerCase() : a, "cased"), s = this.string.substr(this.pos, t.length);
      return r(s) == r(t) ? (e !== !1 && (this.pos += t.length), !0) : null;
    } else {
      let r = this.string.slice(this.pos).match(t);
      return r && r.index > 0 ? null : (r && e !== !1 && (this.pos += r[0].length), r);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}, c(Ed, "Nf"), Ed);
m(VM, "StringStream");
let DM = VM;
function WM(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || qM,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || wC,
    mergeTokens: n.mergeTokens !== !1
  };
}
c(WM, "eQ");
m(WM, "fullParser");
function qM(n) {
  if (typeof n != "object")
    return n;
  let t = {};
  for (let e in n) {
    let i = n[e];
    t[e] = i instanceof Array ? i.slice() : i;
  }
  return t;
}
c(qM, "tQ");
m(qM, "defaultCopyState");
const eQ = /* @__PURE__ */ new WeakMap();
var Wo;
const FM = (Wo = class extends Yi {
  constructor(t) {
    let e = t1(t.languageData), i = WM(t), r, s = new class extends C0 {
      createParse(a, o, l) {
        return new Oq(r, a, o, l);
      }
    }();
    super(e, s, [], t.name), this.topNode = BM(e, this), r = this, this.streamParser = i, this.stateAfter = new Pt({ perNode: !0 }), this.tokenTable = t.tokenTable ? new jM(i.tokenTable) : $q;
  }
  /**
  Define a stream language.
  */
  static define(t) {
    return new Wo(t);
  }
  /**
  @internal
  */
  getIndent(t) {
    let e, { overrideIndentation: i } = t.options;
    i && (e = eQ.get(t.state), e != null && e < t.pos - 1e4 && (e = void 0));
    let r = Q0(this, t.node.tree, t.node.from, t.node.from, e ?? t.pos), s, a;
    if (r ? (a = r.state, s = r.pos + 1) : (a = this.streamParser.startState(t.unit), s = t.node.from), t.pos - s > 1e4)
      return null;
    for (; s < t.pos; ) {
      let l = t.state.doc.lineAt(s), d = Math.min(t.pos, l.to);
      if (l.length) {
        let u = i ? i(l.from) : -1, p = new DM(l.text, t.state.tabSize, t.unit, u < 0 ? void 0 : u);
        for (; p.pos < d - l.from; )
          gC(this.streamParser.token, p, a);
      } else
        this.streamParser.blankLine(a, t.unit);
      if (d == t.pos)
        break;
      s = l.to + 1;
    }
    let o = t.lineAt(t.pos);
    return i && e == null && eQ.set(t.state, o.from), this.streamParser.indent(a, /^\s*(.*)/.exec(o.text)[1], t);
  }
  get allowsNesting() {
    return !1;
  }
}, c(Wo, "uo"), Wo);
m(FM, "StreamLanguage");
let vq = FM;
function Q0(n, t, e, i, r) {
  let s = e >= i && e + t.length <= r && t.prop(n.stateAfter);
  if (s)
    return { state: n.streamParser.copyState(s), pos: e + t.length };
  for (let a = t.children.length - 1; a >= 0; a--) {
    let o = t.children[a], l = e + t.positions[a], d = o instanceof Lt && l < r && Q0(n, o, l, i, r);
    if (d)
      return d;
  }
  return null;
}
c(Q0, "Oh$1");
m(Q0, "findState");
function yC(n, t, e, i, r) {
  if (r && e <= 0 && i >= t.length)
    return t;
  !r && e == 0 && t.type == n.topNode && (r = !0);
  for (let s = t.children.length - 1; s >= 0; s--) {
    let a = t.positions[s], o = t.children[s], l;
    if (a < i && o instanceof Lt) {
      if (!(l = yC(n, o, e - a, i - a, r)))
        break;
      return r ? new Lt(t.type, t.children.slice(0, s).concat(l), t.positions.slice(0, s + 1), a + l.length) : l;
    }
  }
  return null;
}
c(yC, "hp");
m(yC, "cutTree");
function ZM(n, t, e, i, r) {
  for (let s of t) {
    let a = s.from + (s.openStart ? 25 : 0), o = s.to - (s.openEnd ? 25 : 0), l = a <= e && o > e && Q0(n, s.tree, 0 - s.offset, e, o), d;
    if (l && l.pos <= i && (d = yC(n, s.tree, e + s.offset, l.pos + s.offset, !1)))
      return { state: l.state, tree: d };
  }
  return { state: n.streamParser.startState(r ? mw(r) : 4), tree: Lt.empty };
}
c(ZM, "iQ");
m(ZM, "findStartInFragments");
var Yb, _d;
let Oq = (Yb = (_d = class {
  constructor(t, e, i, r) {
    this.lang = t, this.input = e, this.fragments = i, this.ranges = r, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = r[r.length - 1].to;
    let s = mO.get(), a = r[0].from, { state: o, tree: l } = ZM(t, i, a, this.to, s?.state);
    this.state = o, this.parsedPos = this.chunkStart = a + l.length;
    for (let d = 0; d < l.children.length; d++)
      this.chunks.push(l.children[d]), this.chunkPos.push(l.positions[d]);
    s && this.parsedPos < s.viewport.from - 1e5 && r.some((d) => d.from <= s.viewport.from && d.to >= s.viewport.from) && (this.state = this.lang.streamParser.startState(mw(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let t = mO.get(), e = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      e,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (t && (i = Math.min(i, t.viewport.to)); this.parsedPos < i; )
      this.parseLine(t);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= e ? this.finish() : t && this.parsedPos >= t.viewport.to ? (t.skipUntilInView(this.parsedPos, e), this.finish()) : null;
  }
  stopAt(t) {
    this.stoppedAt = t;
  }
  lineAfter(t) {
    let e = this.input.chunk(t);
    if (this.input.lineChunks)
      e == `
` && (e = "");
    else {
      let i = e.indexOf(`
`);
      i > -1 && (e = e.slice(0, i));
    }
    return t + e.length <= this.to ? e : e.slice(0, this.to - t);
  }
  nextLine() {
    let t = this.parsedPos, e = this.lineAfter(t), i = t + e.length;
    for (let r = this.rangeIndex; ; ) {
      let s = this.ranges[r].to;
      if (s >= i || (e = e.slice(0, s - (i - e.length)), r++, r == this.ranges.length))
        break;
      let a = this.ranges[r].from, o = this.lineAfter(a);
      e += o, i = a + o.length;
    }
    return { line: e, end: i };
  }
  skipGapsTo(t, e, i) {
    for (; ; ) {
      let r = this.ranges[this.rangeIndex].to, s = t + e;
      if (i > 0 ? r > s : r >= s)
        break;
      let a = this.ranges[++this.rangeIndex].from;
      e += a - r;
    }
    return e;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(t, e, i, r) {
    let s = 4;
    if (this.ranges.length > 1) {
      r = this.skipGapsTo(e, r, 1), e += r;
      let o = this.chunk.length;
      r = this.skipGapsTo(i, r, -1), i += r, s += this.chunk.length - o;
    }
    let a = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && s == 4 && a >= 0 && this.chunk[a] == t && this.chunk[a + 2] == e ? this.chunk[a + 2] = i : this.chunk.push(t, e, i, s), r;
  }
  parseLine(t) {
    let { line: e, end: i } = this.nextLine(), r = 0, { streamParser: s } = this.lang, a = new DM(e, t ? t.state.tabSize : 4, t ? mw(t.state) : 2);
    if (a.eol())
      s.blankLine(this.state, a.indentUnit);
    else
      for (; !a.eol(); ) {
        let o = gC(s.token, a, this.state);
        if (o && (r = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + a.start, this.parsedPos + a.pos, r)), a.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let t = Lt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: bq,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    t = new Lt(t.type, t.children, t.positions, t.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(t), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Lt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}, c(_d, "Zi$1"), _d), m(Yb, "Parse"), Yb);
function gC(n, t, e) {
  t.start = t.pos;
  for (let i = 0; i < 10; i++) {
    let r = n(t, e);
    if (t.pos > t.start)
      return r;
  }
  throw new Error("Stream parser failed to advance stream.");
}
c(gC, "fp");
m(gC, "readToken$1");
const wC = /* @__PURE__ */ Object.create(null), yw = [je.none], bq = /* @__PURE__ */ new x0(yw), iQ = [], nQ = /* @__PURE__ */ Object.create(null), XM = /* @__PURE__ */ Object.create(null);
for (let [n, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  XM[n] = /* @__PURE__ */ vC(wC, t);
var zd;
const NM = (zd = class {
  constructor(t) {
    this.extra = t, this.table = Object.assign(/* @__PURE__ */ Object.create(null), XM);
  }
  resolve(t) {
    return t ? this.table[t] || (this.table[t] = vC(this.extra, t)) : 0;
  }
}, c(zd, "Gf"), zd);
m(NM, "TokenTable");
let jM = NM;
const $q = /* @__PURE__ */ new jM(wC);
function pv(n, t) {
  iQ.indexOf(n) > -1 || (iQ.push(n), console.warn(t));
}
c(pv, "Yo$1");
m(pv, "warnForPart");
function vC(n, t) {
  let e = [];
  for (let o of t.split(" ")) {
    let l = [];
    for (let d of o.split(".")) {
      let u = n[d] || T[d];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : pv(d, `Modifier ${d} used at start of tag`) : l.length ? pv(d, `Tag ${d} used as modifier`) : l = Array.isArray(u) ? u : [u] : pv(d, `Unknown highlighting tag ${d}`);
    }
    for (let d of l)
      e.push(d);
  }
  if (!e.length)
    return 0;
  let i = t.replace(/ /g, "_"), r = i + " " + e.map((o) => o.id), s = nQ[r];
  if (s)
    return s.id;
  let a = nQ[r] = je.define({
    id: yw.length,
    name: i,
    props: [Pl({ [i]: e })]
  });
  return yw.push(a), a.id;
}
c(vC, "up");
m(vC, "createTokenType");
function BM(n, t) {
  let e = je.define({ id: yw.length, name: "Document", props: [
    Ts.add(() => n),
    py.add(() => (i) => t.getIndent(i))
  ], top: !0 });
  return yw.push(e), e;
}
c(BM, "oQ");
m(BM, "docID");
Pe.RTL, Pe.LTR;
var Ld;
const UM = (Ld = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, e, i, r) {
    this.state = t, this.pos = e, this.explicit = i, this.view = r, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let e = ae(this.state).resolveInner(this.pos, -1);
    for (; e && t.indexOf(e.name) < 0; )
      e = e.parent;
    return e ? {
      from: e.from,
      to: this.pos,
      text: this.state.sliceDoc(e.from, this.pos),
      type: e.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), r = e.text.slice(i - e.from, this.pos - e.from), s = r.search($C(t, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: r.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, e, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(e), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}, c(Ld, "Ff"), Ld);
m(UM, "CompletionContext");
let OC = UM;
function Gk(n) {
  let t = Object.keys(n).join(""), e = /\w/.test(t);
  return e && (t = t.replace(/\w/g, "")), `[${e ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
c(Gk, "Xu$1");
m(Gk, "toSet");
function HM(n) {
  let t = /* @__PURE__ */ Object.create(null), e = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of n) {
    t[r[0]] = !0;
    for (let s = 1; s < r.length; s++)
      e[r[s]] = !0;
  }
  let i = Gk(t) + Gk(e) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
c(HM, "lQ");
m(HM, "prefixMatch");
function bC(n) {
  let t = n.map((r) => typeof r == "string" ? { label: r } : r), [e, i] = t.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : HM(t);
  return (r) => {
    let s = r.matchBefore(i);
    return s || r.explicit ? { from: s ? s.from : r.pos, options: t, validFor: e } : null;
  };
}
c(bC, "Op$1");
m(bC, "completeFromList");
function YM(n, t) {
  return (e) => {
    for (let i = ae(e.state).resolveInner(e.pos, -1); i; i = i.parent) {
      if (n.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(e);
  };
}
c(YM, "aQ");
m(YM, "ifNotIn");
var Id;
const GM = (Id = class {
  constructor(t, e, i, r) {
    this.completion = t, this.source = e, this.match = i, this.score = r;
  }
}, c(Id, "Hf"), Id);
m(GM, "Option");
let rQ = GM;
function _s(n) {
  return n.selection.main.from;
}
c(_s, "ei$1");
m(_s, "cur");
function $C(n, t) {
  var e;
  let { source: i } = n, r = t && i[0] != "^", s = i[i.length - 1] != "$";
  return !r && !s ? n : new RegExp(`${r ? "^" : ""}(?:${i})${s ? "$" : ""}`, (e = n.flags) !== null && e !== void 0 ? e : n.ignoreCase ? "i" : "");
}
c($C, "dp");
m($C, "ensureAnchor");
const xC = /* @__PURE__ */ as.define();
function KM(n, t, e, i) {
  let { main: r } = n.selection, s = e - r.from, a = i - r.from;
  return {
    ...n.changeByRange((o) => {
      if (o != r && e != i && n.sliceDoc(o.from + s, o.from + a) != n.sliceDoc(e, i))
        return { range: o };
      let l = n.toText(t);
      return {
        changes: { from: o.from + s, to: i == r.from ? o.to : o.from + a, insert: l },
        range: it.cursor(o.from + s + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
c(KM, "hQ");
m(KM, "insertCompletionText");
const sQ = /* @__PURE__ */ new WeakMap();
function JM(n) {
  if (!Array.isArray(n))
    return n;
  let t = sQ.get(n);
  return t || sQ.set(n, t = bC(n)), t;
}
c(JM, "fQ");
m(JM, "asSource");
const wO = /* @__PURE__ */ jt.define(), gw = /* @__PURE__ */ jt.define();
var Vd;
const tA = (Vd = class {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e = 0; e < t.length; ) {
      let i = bs(t, e), r = Ja(i);
      this.chars.push(i);
      let s = t.slice(e, e + r), a = s.toUpperCase();
      this.folded.push(bs(a == s ? s.toLowerCase() : a, 0)), e += r;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, e) {
    return this.score = t, this.matched = e, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: e, folded: i, any: r, precise: s, byWord: a } = this;
    if (e.length == 1) {
      let Q = bs(t, 0), E = Ja(Q), z = E == t.length ? 0 : -100;
      if (Q != e[0]) if (Q == i[0])
        z += -200;
      else
        return null;
      return this.ret(z, [0, E]);
    }
    let o = t.indexOf(this.pattern);
    if (o == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = e.length, d = 0;
    if (o < 0) {
      for (let Q = 0, E = Math.min(t.length, 200); Q < E && d < l; ) {
        let z = bs(t, Q);
        (z == e[d] || z == i[d]) && (r[d++] = Q), Q += Ja(z);
      }
      if (d < l)
        return null;
    }
    let u = 0, p = 0, f = !1, y = 0, g = -1, b = -1, S = /[a-z]/.test(t), $ = !0;
    for (let Q = 0, E = Math.min(t.length, 200), z = 0; Q < E && p < l; ) {
      let A = bs(t, Q);
      o < 0 && (u < l && A == e[u] && (s[u++] = Q), y < l && (A == e[y] || A == i[y] ? (y == 0 && (g = Q), b = Q + 1, y++) : y = 0));
      let V, D = A < 255 ? A >= 48 && A <= 57 || A >= 97 && A <= 122 ? 2 : A >= 65 && A <= 90 ? 1 : 0 : (V = e8(A)) != V.toLowerCase() ? 1 : V != V.toUpperCase() ? 2 : 0;
      (!Q || D == 1 && S || z == 0 && D != 0) && (e[p] == A || i[p] == A && (f = !0) ? a[p++] = Q : a.length && ($ = !1)), z = D, Q += Ja(A);
    }
    return p == l && a[0] == 0 && $ ? this.result(-100 + (f ? -200 : 0), a, t) : y == l && g == 0 ? this.ret(-200 - t.length + (b == t.length ? 0 : -100), [0, b]) : o > -1 ? this.ret(-700 - t.length, [o, o + this.pattern.length]) : y == l ? this.ret(-900 - t.length, [g, b]) : p == l ? this.result(-100 + (f ? -200 : 0) + -700 + ($ ? 0 : -1100), a, t) : e.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, t);
  }
  result(t, e, i) {
    let r = [], s = 0;
    for (let a of e) {
      let o = a + (this.astral ? Ja(bs(i, a)) : 1);
      s && r[s - 1] == a ? r[s - 1] = o : (r[s++] = a, r[s++] = o);
    }
    return this.ret(t - i.length, r);
  }
}, c(Vd, "Kf"), Vd);
m(tA, "FuzzyMatcher");
let xq = tA;
var Dd;
const eA = (Dd = class {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let e = t.slice(0, this.pattern.length), i = e == this.pattern ? 0 : e.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, e.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}, c(Dd, "Jf"), Dd);
m(eA, "StrictMatcher");
let kq = eA;
const Ne = /* @__PURE__ */ $t.define({
  combine(n) {
    return kS(n, {
      activateOnTyping: !0,
      activateOnCompletion: /* @__PURE__ */ m(() => !1, "activateOnCompletion"),
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: /* @__PURE__ */ m(() => "", "tooltipClass"),
      optionClass: /* @__PURE__ */ m(() => "", "optionClass"),
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: iA,
      filterStrict: !1,
      compareCompletions: /* @__PURE__ */ m((t, e) => (t.sortText || t.label).localeCompare(e.sortText || e.label), "compareCompletions"),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: /* @__PURE__ */ m((t, e) => t && e, "defaultKeymap"),
      closeOnBlur: /* @__PURE__ */ m((t, e) => t && e, "closeOnBlur"),
      icons: /* @__PURE__ */ m((t, e) => t && e, "icons"),
      tooltipClass: /* @__PURE__ */ m((t, e) => (i) => Kk(t(i), e(i)), "tooltipClass"),
      optionClass: /* @__PURE__ */ m((t, e) => (i) => Kk(t(i), e(i)), "optionClass"),
      addToOptions: /* @__PURE__ */ m((t, e) => t.concat(e), "addToOptions"),
      filterStrict: /* @__PURE__ */ m((t, e) => t || e, "filterStrict")
    });
  }
});
function Kk(n, t) {
  return n ? t ? n + " " + t : n : t;
}
c(Kk, "Yu$1");
m(Kk, "joinClass");
function iA(n, t, e, i, r, s) {
  let a = n.textDirection == Pe.RTL, o = a, l = !1, d = "top", u, p, f = t.left - r.left, y = r.right - t.right, g = i.right - i.left, b = i.bottom - i.top;
  if (o && f < Math.min(g, y) ? o = !1 : !o && y < Math.min(g, f) && (o = !0), g <= (o ? f : y))
    u = Math.max(r.top, Math.min(e.top, r.bottom - b)) - t.top, p = Math.min(400, o ? f : y);
  else {
    l = !0, p = Math.min(
      400,
      (a ? t.right : r.right - t.left) - 30
      /* Info.Margin */
    );
    let Q = r.bottom - t.bottom;
    Q >= b || Q > t.top ? u = e.bottom - t.top : (d = "bottom", u = t.bottom - e.top);
  }
  let S = (t.bottom - t.top) / s.offsetHeight, $ = (t.right - t.left) / s.offsetWidth;
  return {
    style: `${d}: ${u / S}px; max-width: ${p / $}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
c(iA, "cQ");
m(iA, "defaultPositionInfo");
function nA(n) {
  let t = n.addToOptions.slice();
  return n.icons && t.push({
    render(e) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), e.type && i.classList.add(...e.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(e, i, r, s) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = e.displayLabel || e.label, l = 0;
      for (let d = 0; d < s.length; ) {
        let u = s[d++], p = s[d++];
        u > l && a.appendChild(document.createTextNode(o.slice(l, u)));
        let f = a.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(o.slice(u, p))), f.className = "cm-completionMatchedText", l = p;
      }
      return l < o.length && a.appendChild(document.createTextNode(o.slice(l))), a;
    },
    position: 50
  }, {
    render(e) {
      if (!e.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = e.detail, i;
    },
    position: 80
  }), t.sort((e, i) => e.position - i.position).map((e) => e.render);
}
c(nA, "uQ");
m(nA, "optionContent");
function fv(n, t, e) {
  if (n <= e)
    return { from: 0, to: n };
  if (t < 0 && (t = 0), t <= n >> 1) {
    let r = Math.floor(t / e);
    return { from: r * e, to: (r + 1) * e };
  }
  let i = Math.floor((n - t) / e);
  return { from: n - (i + 1) * e, to: n - i * e };
}
c(fv, "Vo$1");
m(fv, "rangeAroundSelected");
var Wd;
const rA = (Wd = class {
  constructor(t, e, i) {
    this.view = t, this.stateField = e, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: /* @__PURE__ */ m(() => this.measureInfo(), "read"),
      write: /* @__PURE__ */ m((l) => this.placeInfo(l), "write"),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = t.state.field(e), { options: s, selected: a } = r.open, o = t.state.facet(Ne);
    this.optionContent = nA(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = fv(s.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: d } = t.state.field(e).open;
      for (let u = l.target, p; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (p = /-(\d+)$/.exec(u.id)) && +p[1] < d.length) {
          this.applyCompletion(t, d[+p[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let d = t.state.field(this.stateField, !1);
      d && d.tooltip && t.state.facet(Ne).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: gw.of(null) });
    }), this.showOptions(s, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, e) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var e;
    let i = t.state.field(this.stateField), r = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != r) {
      let { options: s, selected: a, disabled: o } = i.open;
      (!r.open || r.open.options != s) && (this.range = fv(s.length, a, t.state.facet(Ne).maxRenderedOptions), this.showOptions(s, i.id)), this.updateSel(), o != ((e = r.open) === null || e === void 0 ? void 0 : e.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(t) {
    let e = this.tooltipClass(t);
    if (e != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of e.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = e;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), e = t.open;
    (e.selected > -1 && e.selected < this.range.from || e.selected >= this.range.to) && (this.range = fv(e.options.length, e.selected, this.view.state.facet(Ne).maxRenderedOptions), this.showOptions(e.options, t.id));
    let i = this.updateSelectedOption(e.selected);
    if (i) {
      this.destroyInfo();
      let { completion: r } = e.options[e.selected], { info: s } = r;
      if (!s)
        return;
      let a = typeof s == "string" ? document.createTextNode(s) : s(r);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(o, r);
      }).catch((o) => Qi(this.view.state, o, "completion info")) : (this.addInfoPane(a, r), i.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(t, e) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", i.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: r, destroy: s } = t;
      i.appendChild(r), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let e = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), e = i) : i.hasAttribute("aria-selected") && (i.removeAttribute("aria-selected"), i.removeAttribute("aria-describedby"));
    return e && aA(this.list, e), e;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let e = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = t.getBoundingClientRect(), s = this.space;
    if (!s) {
      let a = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return r.top > Math.min(s.bottom, e.bottom) - 10 || r.bottom < Math.max(s.top, e.top) + 10 ? null : this.view.state.facet(Ne).positionInfo(this.view, e, r, i, s, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, e, i) {
    const r = document.createElement("ul");
    r.id = e, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions")), r.addEventListener("mousedown", (a) => {
      a.target == r && a.preventDefault();
    });
    let s = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: l } = t[a], { section: d } = o;
      if (d) {
        let f = typeof d == "string" ? d : d.name;
        if (f != s && (a > i.from || i.from == 0))
          if (s = f, typeof d != "string" && d.header)
            r.appendChild(d.header(d));
          else {
            let y = r.appendChild(document.createElement("completion-section"));
            y.textContent = f;
          }
      }
      const u = r.appendChild(document.createElement("li"));
      u.id = e + "-" + a, u.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (u.className = p);
      for (let f of this.optionContent) {
        let y = f(o, this.view.state, this.view, l);
        y && u.appendChild(y);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < t.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}, c(Wd, "ec"), Wd);
m(rA, "CompletionTooltip");
let Sq = rA;
function sA(n, t) {
  return (e) => new Sq(e, n, t);
}
c(sA, "OQ");
m(sA, "completionTooltip");
function aA(n, t) {
  let e = n.getBoundingClientRect(), i = t.getBoundingClientRect(), r = e.height / n.offsetHeight;
  i.top < e.top ? n.scrollTop -= (e.top - i.top) / r : i.bottom > e.bottom && (n.scrollTop += (i.bottom - e.bottom) / r);
}
c(aA, "dQ");
m(aA, "scrollIntoView");
function Jk(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
c(Jk, "Vu");
m(Jk, "score");
function oA(n, t) {
  let e = [], i = null, r = null, s = /* @__PURE__ */ m((u) => {
    e.push(u);
    let { section: p } = u.completion;
    if (p) {
      i || (i = []);
      let f = typeof p == "string" ? p : p.name;
      i.some((y) => y.name == f) || i.push(typeof p == "string" ? { name: f } : p);
    }
  }, "addOption"), a = t.facet(Ne);
  for (let u of n)
    if (u.hasResult()) {
      let p = u.result.getMatch;
      if (u.result.filter === !1)
        for (let f of u.result.options)
          s(new rQ(f, u.source, p ? p(f) : [], 1e9 - e.length));
      else {
        let f = t.sliceDoc(u.from, u.to), y, g = a.filterStrict ? new kq(f) : new xq(f);
        for (let b of u.result.options)
          if (y = g.match(b.label)) {
            let S = b.displayLabel ? p ? p(b, y.matched) : [] : y.matched, $ = y.score + (b.boost || 0);
            if (s(new rQ(b, u.source, S, $)), typeof b.section == "object" && b.section.rank === "dynamic") {
              let { name: Q } = b.section;
              r || (r = /* @__PURE__ */ Object.create(null)), r[Q] = Math.max($, r[Q] || -1e9);
            }
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), p = 0, f = /* @__PURE__ */ m((y, g) => (y.rank === "dynamic" && g.rank === "dynamic" ? r[g.name] - r[y.name] : 0) || (typeof y.rank == "number" ? y.rank : 1e9) - (typeof g.rank == "number" ? g.rank : 1e9) || (y.name < g.name ? -1 : 1), "cmp");
    for (let y of i.sort(f))
      p -= 1e5, u[y.name] = p;
    for (let y of e) {
      let { section: g } = y.completion;
      g && (y.score += u[typeof g == "string" ? g : g.name]);
    }
  }
  let o = [], l = null, d = a.compareCompletions;
  for (let u of e.sort((p, f) => f.score - p.score || d(p.completion, f.completion))) {
    let p = u.completion;
    !l || l.label != p.label || l.detail != p.detail || l.type != null && p.type != null && l.type != p.type || l.apply != p.apply || l.boost != p.boost ? o.push(u) : Jk(u.completion) > Jk(l) && (o[o.length - 1] = u), l = u.completion;
  }
  return o;
}
c(oA, "pQ");
m(oA, "sortOptions");
var Jn;
const lA = (Jn = class {
  constructor(t, e, i, r, s, a) {
    this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = r, this.selected = s, this.disabled = a;
  }
  setSelected(t, e) {
    return t == this.selected || t >= this.options.length ? this : new Jn(this.options, t5(e, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, e, i, r, s, a) {
    if (r && !a && t.some((d) => d.isPending))
      return r.setDisabled();
    let o = oA(t, e);
    if (!o.length)
      return r && t.some((d) => d.isPending) ? r.setDisabled() : null;
    let l = e.facet(Ne).selectOnOpen ? 0 : -1;
    if (r && r.selected != l && r.selected != -1) {
      let d = r.options[r.selected].completion;
      for (let u = 0; u < o.length; u++)
        if (o[u].completion == d) {
          l = u;
          break;
        }
    }
    return new Jn(o, t5(i, l), {
      pos: t.reduce((d, u) => u.hasResult() ? Math.min(d, u.from) : d, 1e8),
      create: Aq,
      above: s.aboveCursor
    }, r ? r.timestamp : Date.now(), l, !1);
  }
  map(t) {
    return new Jn(this.options, this.attrs, { ...this.tooltip, pos: t.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Jn(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}, c(Jn, "Nt"), Jn);
m(lA, "CompletionDialog");
let Cq = lA;
var Js;
const cA = (Js = class {
  constructor(t, e, i) {
    this.active = t, this.id = e, this.open = i;
  }
  static start() {
    return new Js(Mq, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: e } = t, i = e.facet(Ne), r = (i.override || e.languageDataAt("autocomplete", _s(e)).map(JM)).map((o) => (this.active.find((l) => l.source == o) || new no(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    r.length == this.active.length && r.every((o, l) => o == this.active[l]) && (r = this.active);
    let s = this.open, a = t.effects.some((o) => o.is(SC));
    s && t.docChanged && (s = s.map(t.changes)), t.selection || r.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !hA(r, this.active) || a ? s = Cq.build(r, e, this.id, s, i, a) : s && s.disabled && !r.some((o) => o.isPending) && (s = null), !s && r.every((o) => !o.isPending) && r.some((o) => o.hasResult()) && (r = r.map((o) => o.hasResult() ? new no(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(mA) && (s = s && s.setSelected(o.value, this.id));
    return r == this.active && s == this.open ? this : new Js(r, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? Qq : Tq;
  }
}, c(Js, "Ir"), Js);
m(cA, "CompletionState");
let Pq = cA;
function hA(n, t) {
  if (n == t)
    return !0;
  for (let e = 0, i = 0; ; ) {
    for (; e < n.length && !n[e].hasResult(); )
      e++;
    for (; i < t.length && !t[i].hasResult(); )
      i++;
    let r = e == n.length, s = i == t.length;
    if (r || s)
      return r == s;
    if (n[e++].result != t[i++].result)
      return !1;
  }
}
c(hA, "mQ");
m(hA, "sameResults");
const Qq = {
  "aria-autocomplete": "list"
}, Tq = {};
function t5(n, t) {
  let e = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return t > -1 && (e["aria-activedescendant"] = n + "-" + t), e;
}
c(t5, "Wu$1");
m(t5, "makeAttrs");
const Mq = [];
function kC(n, t) {
  if (n.isUserEvent("input.complete")) {
    let i = n.annotation(xC);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let e = n.isUserEvent("input.type");
  return e && t.activateOnTyping ? 5 : e ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
c(kC, "pp");
m(kC, "getUpdateType");
var tr;
const dA = (tr = class {
  constructor(t, e, i = !1) {
    this.source = t, this.state = e, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, e) {
    let i = kC(t, e), r = this;
    (i & 8 || i & 16 && this.touches(t)) && (r = new tr(
      r.source,
      0
      /* State.Inactive */
    )), i & 4 && r.state == 0 && (r = new tr(
      this.source,
      1
      /* State.Pending */
    )), r = r.updateFor(t, i);
    for (let s of t.effects)
      if (s.is(wO))
        r = new tr(r.source, 1, s.value);
      else if (s.is(gw))
        r = new tr(
          r.source,
          0
          /* State.Inactive */
        );
      else if (s.is(SC))
        for (let a of s.value)
          a.source == r.source && (r = a);
    return r;
  }
  updateFor(t, e) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(_s(t.state));
  }
}, c(tr, "Gt"), tr);
m(dA, "ActiveSource");
let no = dA;
var Zr;
const uA = (Zr = class extends no {
  constructor(t, e, i, r, s, a) {
    super(t, 3, e), this.limit = i, this.result = r, this.from = s, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, e) {
    var i;
    if (!(e & 3))
      return this.map(t.changes);
    let r = this.result;
    r.map && !t.changes.empty && (r = r.map(r, t.changes));
    let s = t.changes.mapPos(this.from), a = t.changes.mapPos(this.to, 1), o = _s(t.state);
    if (o > a || !r || e & 2 && (_s(t.startState) == this.from || o < this.limit))
      return new no(
        this.source,
        e & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = t.changes.mapPos(this.limit);
    return fA(r.validFor, t.state, s, a) ? new Zr(this.source, this.explicit, l, r, s, a) : r.update && (r = r.update(r, s, a, new OC(t.state, o, !1))) ? new Zr(this.source, this.explicit, l, r, r.from, (i = r.to) !== null && i !== void 0 ? i : _s(t.state)) : new no(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new Zr(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new no(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}, c(Zr, "xi"), Zr);
m(uA, "ActiveResult");
let pA = uA;
function fA(n, t, e, i) {
  if (!n)
    return !1;
  let r = t.sliceDoc(e, i);
  return typeof n == "function" ? n(r, e, i, t) : $C(n, !0).test(r);
}
c(fA, "SQ");
m(fA, "checkValid");
const SC = /* @__PURE__ */ jt.define({
  map(n, t) {
    return n.map((e) => e.map(t));
  }
}), mA = /* @__PURE__ */ jt.define(), wi = /* @__PURE__ */ ss.define({
  create() {
    return Pq.start();
  },
  update(n, t) {
    return n.update(t);
  },
  provide: /* @__PURE__ */ m((n) => [
    CT.from(n, (t) => t.tooltip),
    Ct.contentAttributes.from(n, (t) => t.attrs)
  ], "provide")
});
function T0(n, t) {
  const e = t.completion.apply || t.completion.label;
  let i = n.state.field(wi).active.find((r) => r.source == t.source);
  return i instanceof pA ? (typeof e == "string" ? n.dispatch({
    ...KM(n.state, e, i.from, i.to),
    annotations: xC.of(t.completion)
  }) : e(n, t.completion, i.from, i.to), !0) : !1;
}
c(T0, "gh$1");
m(T0, "applyCompletion");
const Aq = /* @__PURE__ */ sA(wi, T0);
function ug(n, t = "option") {
  return (e) => {
    let i = e.state.field(wi, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < e.state.facet(Ne).interactionDelay)
      return !1;
    let r = 1, s;
    t == "page" && (s = sC(e, i.open.tooltip)) && (r = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + r * (n ? 1 : -1) : n ? 0 : a - 1;
    return o < 0 ? o = t == "page" ? 0 : a - 1 : o >= a && (o = t == "page" ? a - 1 : 0), e.dispatch({ effects: mA.of(o) }), !0;
  };
}
c(ug, "jn$1");
m(ug, "moveCompletionSelection");
const Rq = /* @__PURE__ */ m((n) => {
  let t = n.state.field(wi, !1);
  return n.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < n.state.facet(Ne).interactionDelay ? !1 : T0(n, t.open.options[t.open.selected]);
}, "acceptCompletion"), Gb = /* @__PURE__ */ m((n) => n.state.field(wi, !1) ? (n.dispatch({ effects: wO.of(!0) }), !0) : !1, "startCompletion"), Eq = /* @__PURE__ */ m((n) => {
  let t = n.state.field(wi, !1);
  return !t || !t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: gw.of(null) }), !0);
}, "closeCompletion");
var qd;
const yA = (qd = class {
  constructor(t, e) {
    this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}, c(qd, "tc"), qd);
m(yA, "RunningQuery");
let _q = yA;
const zq = 50, Lq = 1e3, Iq = /* @__PURE__ */ Br.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of n.state.field(wi).active)
      t.isPending && this.startQuery(t);
  }
  update(n) {
    let t = n.state.field(wi), e = n.state.facet(Ne);
    if (!n.selectionSet && !n.docChanged && n.startState.field(wi) == t)
      return;
    let i = n.transactions.some((s) => {
      let a = kC(s, e);
      return a & 8 || (s.selection || s.docChanged) && !(a & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let a = this.running[s];
      if (i || a.context.abortOnDocChange && n.docChanged || a.updates.length + n.transactions.length > zq && Date.now() - a.time > Lq) {
        for (let o of a.context.abortListeners)
          try {
            o();
          } catch (l) {
            Qi(this.view.state, l);
          }
        a.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        a.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((s) => s.effects.some((a) => a.is(wO))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : e.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((s) => s.isPending && !this.running.some((a) => a.active.source == s.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let s of n.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, t = n.field(wi);
    for (let e of t.active)
      e.isPending && !this.running.some((i) => i.active.source == e.source) && this.startQuery(e);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ne).updateSyncTime));
  }
  startQuery(n) {
    let { state: t } = this.view, e = _s(t), i = new OC(t, e, n.explicit, this.view), r = new _q(n, i);
    this.running.push(r), Promise.resolve(n.source(i)).then((s) => {
      r.context.aborted || (r.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: gw.of(null) }), Qi(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ne).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], e = this.view.state.facet(Ne), i = this.view.state.field(wi);
    for (let r = 0; r < this.running.length; r++) {
      let s = this.running[r];
      if (s.done === void 0)
        continue;
      if (this.running.splice(r--, 1), s.done) {
        let o = _s(s.updates.length ? s.updates[0].startState : this.view.state), l = Math.min(o, s.done.from + (s.active.explicit ? 0 : 1)), d = new pA(s.active.source, s.active.explicit, l, s.done, s.done.from, (n = s.done.to) !== null && n !== void 0 ? n : o);
        for (let u of s.updates)
          d = d.update(u, e);
        if (d.hasResult()) {
          t.push(d);
          continue;
        }
      }
      let a = i.active.find((o) => o.source == s.active.source);
      if (a && a.isPending)
        if (s.done == null) {
          let o = new no(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let l of s.updates)
            o = o.update(l, e);
          o.isPending || t.push(o);
        } else
          this.startQuery(a);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: SC.of(t) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let t = this.view.state.field(wi, !1);
      if (t && t.tooltip && this.view.state.facet(Ne).closeOnBlur) {
        let e = t.open && sC(this.view, t.open.tooltip);
        (!e || !e.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: gw.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: wO.of(!1) }), 20), this.composing = 0;
    }
  }
}), Vq = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Dq = /* @__PURE__ */ Cl.highest(/* @__PURE__ */ Ct.domEventHandlers({
  keydown(n, t) {
    let e = t.state.field(wi, !1);
    if (!e || !e.open || e.open.disabled || e.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(Vq && n.altKey) || n.metaKey)
      return !1;
    let i = e.open.options[e.open.selected], r = e.active.find((a) => a.source == i.source), s = i.completion.commitCharacters || r.result.commitCharacters;
    return s && s.indexOf(n.key) > -1 && T0(t, i), !1;
  }
})), gA = /* @__PURE__ */ Ct.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var Fd;
const wA = (Fd = class {
  constructor(t, e, i, r) {
    this.field = t, this.line = e, this.from = i, this.to = r;
  }
}, c(Fd, "ic"), Fd);
m(wA, "FieldPos");
let Wq = wA;
var qo;
const vA = (qo = class {
  constructor(t, e, i) {
    this.field = t, this.from = e, this.to = i;
  }
  map(t) {
    let e = t.mapPos(this.from, -1, vi.TrackDel), i = t.mapPos(this.to, 1, vi.TrackDel);
    return e == null || i == null ? null : new qo(this.field, e, i);
  }
}, c(qo, "Oo"), qo);
m(vA, "FieldRange");
let qq = vA;
var Fo;
const OA = (Fo = class {
  constructor(t, e) {
    this.lines = t, this.fieldPositions = e;
  }
  instantiate(t, e) {
    let i = [], r = [e], s = t.doc.lineAt(e), a = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let d = a, u = /^\t*/.exec(l)[0].length;
        for (let p = 0; p < u; p++)
          d += t.facet(P0);
        r.push(e + d.length - u), l = d + l.slice(u);
      }
      i.push(l), e += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new qq(l.field, r[l.line] + l.from, r[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(t) {
    let e = [], i = [], r = [], s;
    for (let a of t.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(a); ) {
        let o = s[1] ? +s[1] : null, l = s[2] || s[3] || "", d = -1, u = l.replace(/\\[{}]/g, (p) => p[1]);
        for (let p = 0; p < e.length; p++)
          (o != null ? e[p].seq == o : u && e[p].name == u) && (d = p);
        if (d < 0) {
          let p = 0;
          for (; p < e.length && (o == null || e[p].seq != null && e[p].seq < o); )
            p++;
          e.splice(p, 0, { seq: o, name: u }), d = p;
          for (let f of r)
            f.field >= d && f.field++;
        }
        for (let p of r)
          if (p.line == i.length && p.from > s.index) {
            let f = s[2] ? 3 + (s[1] || "").length : 2;
            p.from -= f, p.to -= f;
          }
        r.push(new Wq(d, i.length, s.index, s.index + u.length)), a = a.slice(0, s.index) + l + a.slice(s.index + s[0].length);
      }
      a = a.replace(/\\([{}])/g, (o, l, d) => {
        for (let u of r)
          u.line == i.length && u.from > d && (u.from--, u.to--);
        return l;
      }), i.push(a);
    }
    return new Fo(i, r);
  }
}, c(Fo, "po"), Fo);
m(OA, "Snippet");
let Fq = OA, Zq = /* @__PURE__ */ Jt.widget({ widget: /* @__PURE__ */ new class extends uy {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Xq = /* @__PURE__ */ Jt.mark({ class: "cm-snippetField" });
var Zo;
const bA = (Zo = class {
  constructor(t, e) {
    this.ranges = t, this.active = e, this.deco = Jt.set(t.map((i) => (i.from == i.to ? Zq : Xq).range(i.from, i.to)), !0);
  }
  map(t) {
    let e = [];
    for (let i of this.ranges) {
      let r = i.map(t);
      if (!r)
        return null;
      e.push(r);
    }
    return new Zo(e, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((e) => this.ranges.some((i) => i.field == this.active && i.from <= e.from && i.to >= e.to));
  }
}, c(Zo, "mo"), Zo);
m(bA, "ActiveSnippet");
let M0 = bA;
const i1 = /* @__PURE__ */ jt.define({
  map(n, t) {
    return n && n.map(t);
  }
}), Nq = /* @__PURE__ */ jt.define(), ww = /* @__PURE__ */ ss.define({
  create() {
    return null;
  },
  update(n, t) {
    for (let e of t.effects) {
      if (e.is(i1))
        return e.value;
      if (e.is(Nq) && n)
        return new M0(n.ranges, e.value);
    }
    return n && t.docChanged && (n = n.map(t.changes)), n && t.selection && !n.selectionInsideField(t.selection) && (n = null), n;
  },
  provide: /* @__PURE__ */ m((n) => Ct.decorations.from(n, (t) => t ? t.deco : Jt.none), "provide")
});
function A0(n, t) {
  return it.create(n.filter((e) => e.field == t).map((e) => it.range(e.from, e.to)));
}
c(A0, "Qh");
m(A0, "fieldSelection");
function $A(n) {
  let t = Fq.parse(n);
  return (e, i, r, s) => {
    let { text: a, ranges: o } = t.instantiate(e.state, r), { main: l } = e.state.selection, d = {
      changes: { from: r, to: s == l.from ? l.to : s, insert: Dt.of(a) },
      scrollIntoView: !0,
      annotations: i ? [xC.of(i), Oi.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (d.selection = A0(o, 0)), o.some((u) => u.field > 0)) {
      let u = new M0(o, 0), p = d.effects = [i1.of(u)];
      e.state.field(ww, !1) === void 0 && p.push(jt.appendConfig.of([ww, Yq, Gq, gA]));
    }
    e.dispatch(e.state.update(d));
  };
}
c($A, "LQ");
m($A, "snippet");
function CC(n) {
  return ({ state: t, dispatch: e }) => {
    let i = t.field(ww, !1);
    if (!i || n < 0 && i.active == 0)
      return !1;
    let r = i.active + n, s = n > 0 && !i.ranges.some((a) => a.field == r + n);
    return e(t.update({
      selection: A0(i.ranges, r),
      effects: i1.of(s ? null : new M0(i.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
c(CC, "yp");
m(CC, "moveField");
const jq = /* @__PURE__ */ m(({ state: n, dispatch: t }) => n.field(ww, !1) ? (t(n.update({ effects: i1.of(null) })), !0) : !1, "clearSnippet"), Bq = /* @__PURE__ */ CC(1), Uq = /* @__PURE__ */ CC(-1), Hq = [
  { key: "Tab", run: Bq, shift: Uq },
  { key: "Escape", run: jq }
], aQ = /* @__PURE__ */ $t.define({
  combine(n) {
    return n.length ? n[0] : Hq;
  }
}), Yq = /* @__PURE__ */ Cl.highest(/* @__PURE__ */ $0.compute([aQ], (n) => n.facet(aQ)));
function fi(n, t) {
  return { ...t, apply: $A(n) };
}
c(fi, "ye$2");
m(fi, "snippetCompletion");
const Gq = /* @__PURE__ */ Ct.domEventHandlers({
  mousedown(n, t) {
    let e = t.state.field(ww, !1), i;
    if (!e || (i = t.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let r = e.ranges.find((s) => s.from <= i && s.to >= i);
    return !r || r.field == e.active ? !1 : (t.dispatch({
      selection: A0(e.ranges, r.field),
      effects: i1.of(e.ranges.some((s) => s.field > r.field) ? new M0(e.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), xA = /* @__PURE__ */ new class extends Ko {
}();
xA.startSide = 1;
xA.endSide = -1;
function Kq(n = {}) {
  return [
    Dq,
    wi,
    Ne.of(n),
    Iq,
    tF,
    gA
  ];
}
c(Kq, "YQ");
m(Kq, "autocompletion");
const Jq = [
  { key: "Ctrl-Space", run: Gb },
  { mac: "Alt-`", run: Gb },
  { mac: "Alt-i", run: Gb },
  { key: "Escape", run: Eq },
  { key: "ArrowDown", run: /* @__PURE__ */ ug(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ ug(!1) },
  { key: "PageDown", run: /* @__PURE__ */ ug(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ ug(!1, "page") },
  { key: "Enter", run: Rq }
], tF = /* @__PURE__ */ Cl.highest(/* @__PURE__ */ $0.computeN([Ne], (n) => n.facet(Ne).defaultKeymap ? [Jq] : []));
function eF(n) {
  let t = n.field(wi, !1);
  return t && t.active.some((e) => e.isPending) ? "pending" : t && t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}
c(eF, "UQ");
m(eF, "completionStatus");
var Xo;
const kA = (Xo = class {
  static create(t, e, i, r, s) {
    let a = r + (r << 8) + t + (e << 4) | 0;
    return new Xo(t, e, i, a, s, [], []);
  }
  constructor(t, e, i, r, s, a, o) {
    this.type = t, this.value = e, this.from = i, this.hash = r, this.end = s, this.children = a, this.positions = o, this.hashProp = [[Pt.contextHash, r]];
  }
  addChild(t, e) {
    t.prop(Pt.contextHash) != this.hash && (t = new Lt(t.type, t.children, t.positions, t.length, this.hashProp)), this.children.push(t), this.positions.push(e);
  }
  toTree(t, e = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (e = Math.max(e, this.positions[i] + this.children[i].length + this.from)), new Lt(t.types[this.type], this.children, this.positions, e - this.from).balance({
      makeTree: /* @__PURE__ */ m((r, s, a) => new Lt(je.none, r, s, a, this.hashProp), "makeTree")
    });
  }
}, c(Xo, "go"), Xo);
m(kA, "CompositeBlock");
let oQ = kA;
var H;
(function(n) {
  n[n.Document = 1] = "Document", n[n.CodeBlock = 2] = "CodeBlock", n[n.FencedCode = 3] = "FencedCode", n[n.Blockquote = 4] = "Blockquote", n[n.HorizontalRule = 5] = "HorizontalRule", n[n.BulletList = 6] = "BulletList", n[n.OrderedList = 7] = "OrderedList", n[n.ListItem = 8] = "ListItem", n[n.ATXHeading1 = 9] = "ATXHeading1", n[n.ATXHeading2 = 10] = "ATXHeading2", n[n.ATXHeading3 = 11] = "ATXHeading3", n[n.ATXHeading4 = 12] = "ATXHeading4", n[n.ATXHeading5 = 13] = "ATXHeading5", n[n.ATXHeading6 = 14] = "ATXHeading6", n[n.SetextHeading1 = 15] = "SetextHeading1", n[n.SetextHeading2 = 16] = "SetextHeading2", n[n.HTMLBlock = 17] = "HTMLBlock", n[n.LinkReference = 18] = "LinkReference", n[n.Paragraph = 19] = "Paragraph", n[n.CommentBlock = 20] = "CommentBlock", n[n.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", n[n.Escape = 22] = "Escape", n[n.Entity = 23] = "Entity", n[n.HardBreak = 24] = "HardBreak", n[n.Emphasis = 25] = "Emphasis", n[n.StrongEmphasis = 26] = "StrongEmphasis", n[n.Link = 27] = "Link", n[n.Image = 28] = "Image", n[n.InlineCode = 29] = "InlineCode", n[n.HTMLTag = 30] = "HTMLTag", n[n.Comment = 31] = "Comment", n[n.ProcessingInstruction = 32] = "ProcessingInstruction", n[n.Autolink = 33] = "Autolink", n[n.HeaderMark = 34] = "HeaderMark", n[n.QuoteMark = 35] = "QuoteMark", n[n.ListMark = 36] = "ListMark", n[n.LinkMark = 37] = "LinkMark", n[n.EmphasisMark = 38] = "EmphasisMark", n[n.CodeMark = 39] = "CodeMark", n[n.CodeText = 40] = "CodeText", n[n.CodeInfo = 41] = "CodeInfo", n[n.LinkTitle = 42] = "LinkTitle", n[n.LinkLabel = 43] = "LinkLabel", n[n.URL = 44] = "URL";
})(H || (H = {}));
var Zd;
const SA = (Zd = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.start = t, this.content = e, this.marks = [], this.parsers = [];
  }
}, c(Zd, "rc"), Zd);
m(SA, "LeafBlock");
let iF = SA;
var Xd;
const CA = (Xd = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let t = this.skipSpace(this.basePos);
    this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(t) {
    return uh(this.text, t);
  }
  /**
  @internal
  */
  reset(t) {
    for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(t) {
    this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(t) {
    this.baseIndent = t, this.basePos = this.findColumn(t);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(t) {
    this.markers.push(t);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(t, e = 0, i = 0) {
    for (let r = e; r < t; r++)
      i += this.text.charCodeAt(r) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(t) {
    let e = 0;
    for (let i = 0; e < this.text.length && i < t; e++)
      i += this.text.charCodeAt(e) == 9 ? 4 - i % 4 : 1;
    return e;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let t = "";
    for (let e = 0; e < this.basePos; e++)
      t += " ";
    return t + this.text.slice(this.basePos);
  }
}, c(Xd, "nc"), Xd);
m(CA, "Line");
let nF = CA;
function e5(n, t, e) {
  if (e.pos == e.text.length || n != t.block && e.indent >= t.stack[e.depth + 1].value + e.baseIndent)
    return !0;
  if (e.indent >= e.baseIndent + 4)
    return !1;
  let i = (n.type == H.OrderedList ? _0 : E0)(e, t, !1);
  return i > 0 && (n.type != H.BulletList || R0(e, t, !1) < 0) && e.text.charCodeAt(e.pos + i - 1) == n.value;
}
c(e5, "Iu");
m(e5, "skipForList");
const PA = {
  [H.Blockquote](n, t, e) {
    return e.next != 62 ? !1 : (e.markers.push(_t(H.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1)), e.moveBase(e.pos + (Ji(e.text.charCodeAt(e.pos + 1)) ? 2 : 1)), n.end = t.lineStart + e.text.length, !0);
  },
  [H.ListItem](n, t, e) {
    return e.indent < e.baseIndent + n.value && e.next > -1 ? !1 : (e.moveBaseColumn(e.baseIndent + n.value), !0);
  },
  [H.OrderedList]: e5,
  [H.BulletList]: e5,
  [H.Document]() {
    return !0;
  }
};
function Ji(n) {
  return n == 32 || n == 9 || n == 10 || n == 13;
}
c(Ji, "Ee$2");
m(Ji, "space$2");
function uh(n, t = 0) {
  for (; t < n.length && Ji(n.charCodeAt(t)); )
    t++;
  return t;
}
c(uh, "wr$1");
m(uh, "skipSpace");
function i5(n, t, e) {
  for (; t > e && Ji(n.charCodeAt(t - 1)); )
    t--;
  return t;
}
c(i5, "zu$1");
m(i5, "skipSpaceBack");
function PC(n) {
  if (n.next != 96 && n.next != 126)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  if (t < n.pos + 3)
    return -1;
  if (n.next == 96) {
    for (let e = t; e < n.text.length; e++)
      if (n.text.charCodeAt(e) == 96)
        return -1;
  }
  return t;
}
c(PC, "wp");
m(PC, "isFencedCode");
function QC(n) {
  return n.next != 62 ? -1 : n.text.charCodeAt(n.pos + 1) == 32 ? 2 : 1;
}
c(QC, "xp");
m(QC, "isBlockquote");
function R0(n, t, e) {
  if (n.next != 42 && n.next != 45 && n.next != 95)
    return -1;
  let i = 1;
  for (let r = n.pos + 1; r < n.text.length; r++) {
    let s = n.text.charCodeAt(r);
    if (s == n.next)
      i++;
    else if (!Ji(s))
      return -1;
  }
  return e && n.next == 45 && AC(n) > -1 && n.depth == t.stack.length && t.parser.leafBlockParsers.indexOf(RA.SetextHeading) > -1 || i < 3 ? -1 : 1;
}
c(R0, "yh$1");
m(R0, "isHorizontalRule");
function TC(n, t) {
  for (let e = n.stack.length - 1; e >= 0; e--)
    if (n.stack[e].type == t)
      return !0;
  return !1;
}
c(TC, "Pp$1");
m(TC, "inList");
function E0(n, t, e) {
  return (n.next == 45 || n.next == 43 || n.next == 42) && (n.pos == n.text.length - 1 || Ji(n.text.charCodeAt(n.pos + 1))) && (!e || TC(t, H.BulletList) || n.skipSpace(n.pos + 2) < n.text.length) ? 1 : -1;
}
c(E0, "Sh$1");
m(E0, "isBulletList");
function _0(n, t, e) {
  let i = n.pos, r = n.next;
  for (; r >= 48 && r <= 57; ) {
    if (i++, i == n.text.length)
      return -1;
    r = n.text.charCodeAt(i);
  }
  return i == n.pos || i > n.pos + 9 || r != 46 && r != 41 || i < n.text.length - 1 && !Ji(n.text.charCodeAt(i + 1)) || e && !TC(t, H.OrderedList) && (n.skipSpace(i + 1) == n.text.length || i > n.pos + 1 || n.next != 49) ? -1 : i + 1 - n.pos;
}
c(_0, "bh$1");
m(_0, "isOrderedList");
function MC(n) {
  if (n.next != 35)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == 35; )
    t++;
  if (t < n.text.length && n.text.charCodeAt(t) != 32)
    return -1;
  let e = t - n.pos;
  return e > 6 ? -1 : e;
}
c(MC, "kp");
m(MC, "isAtxHeading");
function AC(n) {
  if (n.next != 45 && n.next != 61 || n.indent >= n.baseIndent + 4)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  let e = t;
  for (; t < n.text.length && Ji(n.text.charCodeAt(t)); )
    t++;
  return t == n.text.length ? e : -1;
}
c(AC, "$p");
m(AC, "isSetextUnderline");
const n5 = /^[ \t]*$/, QA = /-->/, TA = /\?>/, r5 = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, QA],
  [/^\s*<\?/, TA],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, n5],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, n5]
];
function RC(n, t, e) {
  if (n.next != 60)
    return -1;
  let i = n.text.slice(n.pos);
  for (let r = 0, s = r5.length - (e ? 1 : 0); r < s; r++)
    if (r5[r][0].test(i))
      return r;
  return -1;
}
c(RC, "Tp$1");
m(RC, "isHTMLBlock");
function s5(n, t) {
  let e = n.countIndent(t, n.pos, n.indent), i = n.countIndent(n.skipSpace(t), t, e);
  return i >= e + 5 ? e + 1 : i;
}
c(s5, "ju$1");
m(s5, "getListIndent");
function gs(n, t, e) {
  let i = n.length - 1;
  i >= 0 && n[i].to == t && n[i].type == H.CodeText ? n[i].to = e : n.push(_t(H.CodeText, t, e));
}
c(gs, "Yt$2");
m(gs, "addCodeText");
const X1 = {
  LinkReference: void 0,
  IndentedCode(n, t) {
    let e = t.baseIndent + 4;
    if (t.indent < e)
      return !1;
    let i = t.findColumn(e), r = n.lineStart + i, s = n.lineStart + t.text.length, a = [], o = [];
    for (gs(a, r, s); n.nextLine() && t.depth >= n.stack.length; )
      if (t.pos == t.text.length) {
        gs(o, n.lineStart - 1, n.lineStart);
        for (let l of t.markers)
          o.push(l);
      } else {
        if (t.indent < e)
          break;
        {
          if (o.length) {
            for (let d of o)
              d.type == H.CodeText ? gs(a, d.from, d.to) : a.push(d);
            o = [];
          }
          gs(a, n.lineStart - 1, n.lineStart);
          for (let d of t.markers)
            a.push(d);
          s = n.lineStart + t.text.length;
          let l = n.lineStart + t.findColumn(t.baseIndent + 4);
          l < s && gs(a, l, s);
        }
      }
    return o.length && (o = o.filter((l) => l.type != H.CodeText), o.length && (t.markers = o.concat(t.markers))), n.addNode(n.buffer.writeElements(a, -r).finish(H.CodeBlock, s - r), r), !0;
  },
  FencedCode(n, t) {
    let e = PC(t);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, r = t.next, s = e - t.pos, a = t.skipSpace(e), o = i5(t.text, t.text.length, a), l = [_t(H.CodeMark, i, i + s)];
    a < o && l.push(_t(H.CodeInfo, n.lineStart + a, n.lineStart + o));
    for (let d = !0; n.nextLine() && t.depth >= n.stack.length; d = !1) {
      let u = t.pos;
      if (t.indent - t.baseIndent < 4)
        for (; u < t.text.length && t.text.charCodeAt(u) == r; )
          u++;
      if (u - t.pos >= s && t.skipSpace(u) == t.text.length) {
        for (let p of t.markers)
          l.push(p);
        l.push(_t(H.CodeMark, n.lineStart + t.pos, n.lineStart + u)), n.nextLine();
        break;
      } else {
        d || gs(l, n.lineStart - 1, n.lineStart);
        for (let y of t.markers)
          l.push(y);
        let p = n.lineStart + t.basePos, f = n.lineStart + t.text.length;
        p < f && gs(l, p, f);
      }
    }
    return n.addNode(n.buffer.writeElements(l, -i).finish(H.FencedCode, n.prevLineEnd() - i), i), !0;
  },
  Blockquote(n, t) {
    let e = QC(t);
    return e < 0 ? !1 : (n.startContext(H.Blockquote, t.pos), n.addNode(H.QuoteMark, n.lineStart + t.pos, n.lineStart + t.pos + 1), t.moveBase(t.pos + e), null);
  },
  HorizontalRule(n, t) {
    if (R0(t, n, !1) < 0)
      return !1;
    let e = n.lineStart + t.pos;
    return n.nextLine(), n.addNode(H.HorizontalRule, e), !0;
  },
  BulletList(n, t) {
    let e = E0(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != H.BulletList && n.startContext(H.BulletList, t.basePos, t.next);
    let i = s5(t, t.pos + 1);
    return n.startContext(H.ListItem, t.basePos, i - t.baseIndent), n.addNode(H.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  OrderedList(n, t) {
    let e = _0(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != H.OrderedList && n.startContext(H.OrderedList, t.basePos, t.text.charCodeAt(t.pos + e - 1));
    let i = s5(t, t.pos + e);
    return n.startContext(H.ListItem, t.basePos, i - t.baseIndent), n.addNode(H.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  ATXHeading(n, t) {
    let e = MC(t);
    if (e < 0)
      return !1;
    let i = t.pos, r = n.lineStart + i, s = i5(t.text, t.text.length, i), a = s;
    for (; a > i && t.text.charCodeAt(a - 1) == t.next; )
      a--;
    (a == s || a == i || !Ji(t.text.charCodeAt(a - 1))) && (a = t.text.length);
    let o = n.buffer.write(H.HeaderMark, 0, e).writeElements(n.parser.parseInline(t.text.slice(i + e + 1, a), r + e + 1), -r);
    a < t.text.length && o.write(H.HeaderMark, a - i, s - i);
    let l = o.finish(H.ATXHeading1 - 1 + e, t.text.length - i);
    return n.nextLine(), n.addNode(l, r), !0;
  },
  HTMLBlock(n, t) {
    let e = RC(t, n, !1);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, r = r5[e][1], s = [], a = r != n5;
    for (; !r.test(t.text) && n.nextLine(); ) {
      if (t.depth < n.stack.length) {
        a = !1;
        break;
      }
      for (let d of t.markers)
        s.push(d);
    }
    a && n.nextLine();
    let o = r == QA ? H.CommentBlock : r == TA ? H.ProcessingInstructionBlock : H.HTMLBlock, l = n.prevLineEnd();
    return n.addNode(n.buffer.writeElements(s, -i).finish(o, l - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var Nd;
const MA = (Nd = class {
  constructor(t) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content);
  }
  nextLine(t, e, i) {
    if (this.stage == -1)
      return !1;
    let r = i.content + `
` + e.scrub(), s = this.advance(r);
    return s > -1 && s < r.length ? this.complete(t, i, s) : !1;
  }
  finish(t, e) {
    return (this.stage == 2 || this.stage == 3) && uh(e.content, this.pos) == e.content.length ? this.complete(t, e, e.content.length) : !1;
  }
  complete(t, e, i) {
    return t.addLeafElement(e, _t(H.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(t) {
    return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (t === !1 && (this.stage = -1), !1);
  }
  advance(t) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(LC(t, this.pos, this.start, !0)))
          return -1;
        if (t.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(_t(H.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(_C(t, uh(t, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let e = uh(t, this.pos), i = 0;
        if (e > this.pos) {
          let r = zC(t, e, this.start);
          if (r) {
            let s = mv(t, r.to - this.start);
            s > 0 && (this.nextStage(r), i = s);
          }
        }
        return i || (i = mv(t, this.pos)), i > 0 && i < t.length ? i : -1;
      } else
        return mv(t, this.pos);
    }
  }
}, c(Nd, "sc"), Nd);
m(MA, "LinkReferenceParser");
let rF = MA;
function mv(n, t) {
  for (; t < n.length; t++) {
    let e = n.charCodeAt(t);
    if (e == 10)
      break;
    if (!Ji(e))
      return -1;
  }
  return t;
}
c(mv, "Uo$1");
m(mv, "lineEnd");
var jd;
const AA = (jd = class {
  nextLine(t, e, i) {
    let r = e.depth < t.stack.length ? -1 : AC(e), s = e.next;
    if (r < 0)
      return !1;
    let a = _t(H.HeaderMark, t.lineStart + e.pos, t.lineStart + r);
    return t.nextLine(), t.addLeafElement(i, _t(s == 61 ? H.SetextHeading1 : H.SetextHeading2, i.start, t.prevLineEnd(), [
      ...t.parser.parseInline(i.content, i.start),
      a
    ])), !0;
  }
  finish() {
    return !1;
  }
}, c(jd, "oc"), jd);
m(AA, "SetextHeadingParser");
let sF = AA;
const RA = {
  LinkReference(n, t) {
    return t.content.charCodeAt(0) == 91 ? new rF(t) : null;
  },
  SetextHeading() {
    return new sF();
  }
}, aF = [
  (n, t) => MC(t) >= 0,
  (n, t) => PC(t) >= 0,
  (n, t) => QC(t) >= 0,
  (n, t) => E0(t, n, !0) >= 0,
  (n, t) => _0(t, n, !0) >= 0,
  (n, t) => R0(t, n, !0) >= 0,
  (n, t) => RC(t, n, !0) >= 0
], oF = { text: "", end: 0 };
var Bd;
const EA = (Bd = class {
  /**
  @internal
  */
  constructor(t, e, i, r) {
    this.parser = t, this.input = e, this.ranges = r, this.line = new nF(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = r[r.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = r[0].from, this.block = oQ.create(H.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new hF(i, e) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: t } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let r = t.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < t.markers.length && (!r || t.markers[i].from < r.end); ) {
          let s = t.markers[i++];
          this.addNode(s.type, s.from, s.to);
        }
        if (!r)
          break;
        this.finishContext();
      }
      if (t.pos < t.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(t.basePos))
      return null;
    t: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let r = i(this, t);
          if (r != !1) {
            if (r == !0)
              return null;
            t.forward();
            continue t;
          }
        }
      break;
    }
    let e = new iF(this.lineStart + t.pos, t.text.slice(t.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let r = i(this, e);
        r && e.parsers.push(r);
      }
    t: for (; this.nextLine() && t.pos != t.text.length; ) {
      if (t.indent < t.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, t, e))
            break t;
      }
      for (let i of e.parsers)
        if (i.nextLine(this, t, e))
          return null;
      e.content += `
` + t.scrub();
      for (let i of t.markers)
        e.marks.push(i);
    }
    return this.finishLeaf(e), null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  reuseFragment(t) {
    if (!this.fragments.moveTo(this.absoluteLineStart + t, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let e = this.fragments.takeNodes(this);
    return e ? (this.absoluteLineStart += e, this.lineStart = VC(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(t = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[t].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(t) {
    let e = oF;
    if (e.end = t, t >= this.to)
      e.text = "";
    else if (e.text = this.lineChunkAt(t), e.end += e.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, r = this.rangeI;
      for (; this.ranges[r].to < e.end; ) {
        r++;
        let s = this.ranges[r].from, a = this.lineChunkAt(s);
        e.end = s + a.length, e.text = e.text.slice(0, this.ranges[r - 1].to - i) + a, i = e.end - e.text.length;
      }
    }
    return e;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: t } = this, { text: e, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, t.reset(e); t.depth < this.stack.length; t.depth++) {
      let r = this.stack[t.depth], s = this.parser.skipContextMarkup[r.type];
      if (!s)
        throw new Error("Unhandled block context " + H[r.type]);
      let a = this.line.markers.length;
      if (!s(r, this, t)) {
        this.line.markers.length > a && (r.end = this.line.markers[this.line.markers.length - 1].to);
        break;
      }
      t.forward();
    }
  }
  lineChunkAt(t) {
    let e = this.input.chunk(t), i;
    if (this.input.lineChunks)
      i = e == `
` ? "" : e;
    else {
      let r = e.indexOf(`
`);
      i = r < 0 ? e : e.slice(0, r);
    }
    return t + i.length > this.to ? i.slice(0, this.to - t) : i;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(t, e, i = 0) {
    this.block = oQ.create(t, i, this.lineStart + e, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(t, e, i = 0) {
    this.startContext(this.parser.getNodeType(t), e, i);
  }
  /**
  @internal
  */
  addNode(t, e, i) {
    typeof t == "number" && (t = new Lt(this.parser.nodeSet.types[t], Fm, Fm, (i ?? this.prevLineEnd()) - e)), this.block.addChild(t, e - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(t) {
    this.block.addChild(t.toTree(this.parser.nodeSet), t.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(t, e) {
    this.addNode(this.buffer.writeElements(bO(e.children, t.marks), -e.from).finish(e.type, e.to - e.from), e.from);
  }
  /**
  @internal
  */
  finishContext() {
    let t = this.stack.pop(), e = this.stack[this.stack.length - 1];
    e.addChild(t.toTree(this.parser.nodeSet), t.from - e.from), this.block = e;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(t) {
    return this.ranges.length > 1 ? EC(this.ranges, 0, t.topNode, this.ranges[0].from, this.reusePlaceholders) : t;
  }
  /**
  @internal
  */
  finishLeaf(t) {
    for (let i of t.parsers)
      if (i.finish(this, t))
        return;
    let e = bO(this.parser.parseInline(t.content, t.start), t.marks);
    this.addNode(this.buffer.writeElements(e, -t.start).finish(H.Paragraph, t.content.length), t.start);
  }
  elt(t, e, i, r) {
    return typeof t == "string" ? _t(this.parser.getNodeType(t), e, i, r) : new WA(t, e);
  }
  /**
  @internal
  */
  get buffer() {
    return new VA(this.parser.nodeSet);
  }
}, c(Bd, "lc"), Bd);
m(EA, "BlockContext");
let lF = EA;
function EC(n, t, e, i, r) {
  let s = n[t].to, a = [], o = [], l = e.from + i;
  function d(u, p) {
    for (; p ? u >= s : u > s; ) {
      let f = n[t + 1].from - s;
      i += f, u += f, t++, s = n[t].to;
    }
  }
  c(d, "h"), m(d, "movePastNext");
  for (let u = e.firstChild; u; u = u.nextSibling) {
    d(u.from + i, !0);
    let p = u.from + i, f, y = r.get(u.tree);
    y ? f = y : u.to + i > s ? (f = EC(n, t, u, i, r), d(u.to + i, !1)) : f = u.toTree(), a.push(f), o.push(p - l);
  }
  return d(e.to + i, !1), new Lt(e.type, a, o, e.to + i - l, e.tree ? e.tree.propValues : void 0);
}
c(EC, "Lp$1");
m(EC, "injectGaps");
var No;
const _A = (No = class extends C0 {
  /**
  @internal
  */
  constructor(t, e, i, r, s, a, o, l, d) {
    super(), this.nodeSet = t, this.blockParsers = e, this.leafBlockParsers = i, this.blockNames = r, this.endLeafBlock = s, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = l, this.wrappers = d, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let u of t.types)
      this.nodeTypes[u.name] = u.id;
  }
  createParse(t, e, i) {
    let r = new lF(this, t, e, i);
    for (let s of this.wrappers)
      r = s(r, t, e, i);
    return r;
  }
  /**
  Reconfigure the parser.
  */
  configure(t) {
    let e = vO(t);
    if (!e)
      return this;
    let { nodeSet: i, skipContextMarkup: r } = this, s = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), l = this.inlineParsers.slice(), d = this.inlineNames.slice(), u = this.endLeafBlock.slice(), p = this.wrappers;
    if (Ic(e.defineNodes)) {
      r = Object.assign({}, r);
      let f = i.types.slice(), y;
      for (let g of e.defineNodes) {
        let { name: b, block: S, composite: $, style: Q } = typeof g == "string" ? { name: g } : g;
        if (f.some((A) => A.name == b))
          continue;
        $ && (r[f.length] = (A, V, D) => $(V, D, A.value));
        let E = f.length, z = $ ? ["Block", "BlockContext"] : S ? E >= H.ATXHeading1 && E <= H.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        f.push(je.define({
          id: E,
          name: b,
          props: z && [[Pt.group, z]]
        })), Q && (y || (y = {}), Array.isArray(Q) || Q instanceof Bn ? y[b] = Q : Object.assign(y, Q));
      }
      i = new x0(f), y && (i = i.extend(Pl(y)));
    }
    if (Ic(e.props) && (i = i.extend(...e.props)), Ic(e.remove))
      for (let f of e.remove) {
        let y = this.blockNames.indexOf(f), g = this.inlineNames.indexOf(f);
        y > -1 && (s[y] = a[y] = void 0), g > -1 && (l[g] = void 0);
      }
    if (Ic(e.parseBlock))
      for (let f of e.parseBlock) {
        let y = o.indexOf(f.name);
        if (y > -1)
          s[y] = f.parse, a[y] = f.leaf;
        else {
          let g = f.before ? pg(o, f.before) : f.after ? pg(o, f.after) + 1 : o.length - 1;
          s.splice(g, 0, f.parse), a.splice(g, 0, f.leaf), o.splice(g, 0, f.name);
        }
        f.endLeaf && u.push(f.endLeaf);
      }
    if (Ic(e.parseInline))
      for (let f of e.parseInline) {
        let y = d.indexOf(f.name);
        if (y > -1)
          l[y] = f.parse;
        else {
          let g = f.before ? pg(d, f.before) : f.after ? pg(d, f.after) + 1 : d.length - 1;
          l.splice(g, 0, f.parse), d.splice(g, 0, f.name);
        }
      }
    return e.wrap && (p = p.concat(e.wrap)), new No(i, s, a, o, u, r, l, d, p);
  }
  /**
  @internal
  */
  getNodeType(t) {
    let e = this.nodeTypes[t];
    if (e == null)
      throw new RangeError(`Unknown node type '${t}'`);
    return e;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(t, e) {
    let i = new IC(this, t, e);
    t: for (let r = e; r < i.end; ) {
      let s = i.char(r);
      for (let a of this.inlineParsers)
        if (a) {
          let o = a(i, s, r);
          if (o >= 0) {
            r = o;
            continue t;
          }
        }
      r++;
    }
    return i.resolveMarkers(0);
  }
}, c(No, "Qo"), No);
m(_A, "MarkdownParser");
let zA = _A;
function Ic(n) {
  return n != null && n.length > 0;
}
c(Ic, "or$1");
m(Ic, "nonEmpty");
function vO(n) {
  if (!Array.isArray(n))
    return n;
  if (n.length == 0)
    return null;
  let t = vO(n[0]);
  if (n.length == 1)
    return t;
  let e = vO(n.slice(1));
  if (!e || !t)
    return t || e;
  let i = /* @__PURE__ */ m((a, o) => (a || Fm).concat(o || Fm), "conc"), r = t.wrap, s = e.wrap;
  return {
    props: i(t.props, e.props),
    defineNodes: i(t.defineNodes, e.defineNodes),
    parseBlock: i(t.parseBlock, e.parseBlock),
    parseInline: i(t.parseInline, e.parseInline),
    remove: i(t.remove, e.remove),
    wrap: r ? s ? (a, o, l, d) => r(s(a, o, l, d), o, l, d) : r : s
  };
}
c(vO, "Ma$1");
m(vO, "resolveConfig");
function pg(n, t) {
  let e = n.indexOf(t);
  if (e < 0)
    throw new RangeError(`Position specified relative to unknown parser ${t}`);
  return e;
}
c(pg, "Dn$1");
m(pg, "findName");
let LA = [je.none];
for (let n = 1, t; t = H[n]; n++)
  LA[n] = je.define({
    id: n,
    name: t,
    props: n >= H.Escape ? [] : [[Pt.group, n in PA ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: t == "Document"
  });
const Fm = [];
var Ud;
const IA = (Ud = class {
  constructor(t) {
    this.nodeSet = t, this.content = [], this.nodes = [];
  }
  write(t, e, i, r = 0) {
    return this.content.push(t, e, i, 4 + r * 4), this;
  }
  writeElements(t, e = 0) {
    for (let i of t)
      i.writeTo(this, e);
    return this;
  }
  finish(t, e) {
    return Lt.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: t,
      length: e
    });
  }
}, c(Ud, "ac"), Ud);
m(IA, "Buffer");
let VA = IA;
var Kb, Hd;
let vw = (Kb = (Hd = class {
  /**
  @internal
  */
  constructor(t, e, i, r = Fm) {
    this.type = t, this.from = e, this.to = i, this.children = r;
  }
  /**
  @internal
  */
  writeTo(t, e) {
    let i = t.content.length;
    t.writeElements(this.children, e), t.content.push(this.type, this.from + e, this.to + e, t.content.length + 4 - i);
  }
  /**
  @internal
  */
  toTree(t) {
    return new VA(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}, c(Hd, "Ci$1"), Hd), m(Kb, "Element"), Kb);
var Yd;
const DA = (Yd = class {
  constructor(t, e) {
    this.tree = t, this.from = e;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Fm;
  }
  writeTo(t, e) {
    t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + e, this.to + e, -1);
  }
  toTree() {
    return this.tree;
  }
}, c(Yd, "hc"), Yd);
m(DA, "TreeElement");
let WA = DA;
function _t(n, t, e, i) {
  return new vw(n, t, e, i);
}
c(_t, "V$1");
m(_t, "elt");
const qA = { resolve: "Emphasis", mark: "EmphasisMark" }, FA = { resolve: "Emphasis", mark: "EmphasisMark" }, eo = {}, OO = {};
var Gd;
const ZA = (Gd = class {
  constructor(t, e, i, r) {
    this.type = t, this.from = e, this.to = i, this.side = r;
  }
}, c(Gd, "fc"), Gd);
m(ZA, "InlineDelimiter");
let Ni = ZA;
const lQ = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Ow = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Ow = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const Jb = {
  Escape(n, t, e) {
    if (t != 92 || e == n.end - 1)
      return -1;
    let i = n.char(e + 1);
    for (let r = 0; r < lQ.length; r++)
      if (lQ.charCodeAt(r) == i)
        return n.append(_t(H.Escape, e, e + 2));
    return -1;
  },
  Entity(n, t, e) {
    if (t != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(n.slice(e + 1, e + 31));
    return i ? n.append(_t(H.Entity, e, e + 1 + i[0].length)) : -1;
  },
  InlineCode(n, t, e) {
    if (t != 96 || e && n.char(e - 1) == 96)
      return -1;
    let i = e + 1;
    for (; i < n.end && n.char(i) == 96; )
      i++;
    let r = i - e, s = 0;
    for (; i < n.end; i++)
      if (n.char(i) == 96) {
        if (s++, s == r && n.char(i + 1) != 96)
          return n.append(_t(H.InlineCode, e, i + 1, [
            _t(H.CodeMark, e, e + r),
            _t(H.CodeMark, i + 1 - r, i + 1)
          ]));
      } else
        s = 0;
    return -1;
  },
  HTMLTag(n, t, e) {
    if (t != 60 || e == n.end - 1)
      return -1;
    let i = n.slice(e + 1, n.end), r = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (r)
      return n.append(_t(H.Autolink, e, e + 1 + r[0].length, [
        _t(H.LinkMark, e, e + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        _t(H.URL, e + 1, e + r[0].length),
        _t(H.LinkMark, e + r[0].length, e + 1 + r[0].length)
      ]));
    let s = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (s)
      return n.append(_t(H.Comment, e, e + 1 + s[0].length));
    let a = /^\?[^]*?\?>/.exec(i);
    if (a)
      return n.append(_t(H.ProcessingInstruction, e, e + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? n.append(_t(H.HTMLTag, e, e + 1 + o[0].length)) : -1;
  },
  Emphasis(n, t, e) {
    if (t != 95 && t != 42)
      return -1;
    let i = e + 1;
    for (; n.char(i) == t; )
      i++;
    let r = n.slice(e - 1, e), s = n.slice(i, i + 1), a = Ow.test(r), o = Ow.test(s), l = /\s|^$/.test(r), d = /\s|^$/.test(s), u = !d && (!o || l || a), p = !l && (!a || d || o), f = u && (t == 42 || !p || a), y = p && (t == 42 || !u || o);
    return n.append(new Ni(t == 95 ? qA : FA, e, i, (f ? 1 : 0) | (y ? 2 : 0)));
  },
  HardBreak(n, t, e) {
    if (t == 92 && n.char(e + 1) == 10)
      return n.append(_t(H.HardBreak, e, e + 2));
    if (t == 32) {
      let i = e + 1;
      for (; n.char(i) == 32; )
        i++;
      if (n.char(i) == 10 && i >= e + 2)
        return n.append(_t(H.HardBreak, e, i + 1));
    }
    return -1;
  },
  Link(n, t, e) {
    return t == 91 ? n.append(new Ni(
      eo,
      e,
      e + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(n, t, e) {
    return t == 33 && n.char(e + 1) == 91 ? n.append(new Ni(
      OO,
      e,
      e + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(n, t, e) {
    if (t != 93)
      return -1;
    for (let i = n.parts.length - 1; i >= 0; i--) {
      let r = n.parts[i];
      if (r instanceof Ni && (r.type == eo || r.type == OO)) {
        if (!r.side || n.skipSpace(r.to) == e && !/[(\[]/.test(n.slice(e + 1, e + 2)))
          return n.parts[i] = null, -1;
        let s = n.takeContent(i), a = n.parts[i] = XA(n, s, r.type == eo ? H.Link : H.Image, r.from, e + 1);
        if (r.type == eo)
          for (let o = 0; o < i; o++) {
            let l = n.parts[o];
            l instanceof Ni && l.type == eo && (l.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function XA(n, t, e, i, r) {
  let { text: s } = n, a = n.char(r), o = r;
  if (t.unshift(_t(H.LinkMark, i, i + (e == H.Image ? 2 : 1))), t.push(_t(H.LinkMark, r - 1, r)), a == 40) {
    let l = n.skipSpace(r + 1), d = _C(s, l - n.offset, n.offset), u;
    d && (l = n.skipSpace(d.to), l != d.to && (u = zC(s, l - n.offset, n.offset), u && (l = n.skipSpace(u.to)))), n.char(l) == 41 && (t.push(_t(H.LinkMark, r, r + 1)), o = l + 1, d && t.push(d), u && t.push(u), t.push(_t(H.LinkMark, l, o)));
  } else if (a == 91) {
    let l = LC(s, r - n.offset, n.offset, !1);
    l && (t.push(l), o = l.to);
  }
  return _t(e, i, o, t);
}
c(XA, "jQ");
m(XA, "finishLink");
function _C(n, t, e) {
  if (n.charCodeAt(t) == 60) {
    for (let i = t + 1; i < n.length; i++) {
      let r = n.charCodeAt(i);
      if (r == 62)
        return _t(H.URL, t + e, i + 1 + e);
      if (r == 60 || r == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, r = t;
    for (let s = !1; r < n.length; r++) {
      let a = n.charCodeAt(r);
      if (Ji(a))
        break;
      if (s)
        s = !1;
      else if (a == 40)
        i++;
      else if (a == 41) {
        if (!i)
          break;
        i--;
      } else a == 92 && (s = !0);
    }
    return r > t ? _t(H.URL, t + e, r + e) : r == n.length ? null : !1;
  }
}
c(_C, "Cp");
m(_C, "parseURL");
function zC(n, t, e) {
  let i = n.charCodeAt(t);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let r = i == 40 ? 41 : i;
  for (let s = t + 1, a = !1; s < n.length; s++) {
    let o = n.charCodeAt(s);
    if (a)
      a = !1;
    else {
      if (o == r)
        return _t(H.LinkTitle, t + e, s + 1 + e);
      o == 92 && (a = !0);
    }
  }
  return null;
}
c(zC, "Xp$1");
m(zC, "parseLinkTitle");
function LC(n, t, e, i) {
  for (let r = !1, s = t + 1, a = Math.min(n.length, s + 999); s < a; s++) {
    let o = n.charCodeAt(s);
    if (r)
      r = !1;
    else {
      if (o == 93)
        return i ? !1 : _t(H.LinkLabel, t + e, s + 1 + e);
      if (i && !Ji(o) && (i = !1), o == 91)
        return !1;
      o == 92 && (r = !0);
    }
  }
  return null;
}
c(LC, "Ep$1");
m(LC, "parseLinkLabel");
var Kd;
const NA = (Kd = class {
  /**
  @internal
  */
  constructor(t, e, i) {
    this.parser = t, this.text = e, this.offset = i, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(t) {
    return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(t, e) {
    return this.text.slice(t - this.offset, e - this.offset);
  }
  /**
  @internal
  */
  append(t) {
    return this.parts.push(t), t.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(t, e, i, r, s) {
    return this.append(new Ni(t, e, i, (r ? 1 : 0) | (s ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let e = this.parts[t];
      if (e instanceof Ni && (e.type == eo || e.type == OO))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(t) {
    return this.append(t);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(t) {
    for (let i = t; i < this.parts.length; i++) {
      let r = this.parts[i];
      if (!(r instanceof Ni && r.type.resolve && r.side & 2))
        continue;
      let s = r.type == qA || r.type == FA, a = r.to - r.from, o, l = i - 1;
      for (; l >= t; l--) {
        let g = this.parts[l];
        if (g instanceof Ni && g.side & 1 && g.type == r.type && // Ignore emphasis delimiters where the character count doesn't match
        !(s && (r.side & 1 || g.side & 2) && (g.to - g.from + a) % 3 == 0 && ((g.to - g.from) % 3 || a % 3))) {
          o = g;
          break;
        }
      }
      if (!o)
        continue;
      let d = r.type.resolve, u = [], p = o.from, f = r.to;
      if (s) {
        let g = Math.min(2, o.to - o.from, a);
        p = o.to - g, f = r.from + g, d = g == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && u.push(this.elt(o.type.mark, p, o.to));
      for (let g = l + 1; g < i; g++)
        this.parts[g] instanceof vw && u.push(this.parts[g]), this.parts[g] = null;
      r.type.mark && u.push(this.elt(r.type.mark, r.from, f));
      let y = this.elt(d, p, f, u);
      this.parts[l] = s && o.from != p ? new Ni(o.type, o.from, p, o.side) : null, (this.parts[i] = s && r.to != f ? new Ni(r.type, f, r.to, r.side) : null) ? this.parts.splice(i, 0, y) : this.parts[i] = y;
    }
    let e = [];
    for (let i = t; i < this.parts.length; i++) {
      let r = this.parts[i];
      r instanceof vw && e.push(r);
    }
    return e;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(t) {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let i = this.parts[e];
      if (i instanceof Ni && i.type == t && i.side & 1)
        return e;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(t) {
    let e = this.resolveMarkers(t);
    return this.parts.length = t, e;
  }
  /**
  Return the delimiter at the given index. Mostly useful to get
  additional info out of a delimiter index returned by
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter).
  Returns null if there is no delimiter at this index.
  */
  getDelimiterAt(t) {
    let e = this.parts[t];
    return e instanceof Ni ? e : null;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(t) {
    return uh(this.text, t - this.offset) + this.offset;
  }
  elt(t, e, i, r) {
    return typeof t == "string" ? _t(this.parser.getNodeType(t), e, i, r) : new WA(t, e);
  }
}, c(Kd, "cc"), Kd);
m(NA, "InlineContext");
let IC = NA;
IC.linkStart = eo;
IC.imageStart = OO;
function bO(n, t) {
  if (!t.length)
    return n;
  if (!n.length)
    return t;
  let e = n.slice(), i = 0;
  for (let r of t) {
    for (; i < e.length && e[i].to < r.to; )
      i++;
    if (i < e.length && e[i].from < r.from) {
      let s = e[i];
      s instanceof vw && (e[i] = new vw(s.type, s.from, s.to, bO(s.children, [r])));
    } else
      e.splice(i++, 0, r);
  }
  return e;
}
c(bO, "Za$1");
m(bO, "injectMarks");
const cF = [H.CodeBlock, H.ListItem, H.OrderedList, H.BulletList];
var t2, Jd;
let hF = (t2 = (Jd = class {
  constructor(t, e) {
    this.fragments = t, this.input = e, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(t, e) {
    for (; this.fragment && this.fragment.to <= t; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (t ? t - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let s = this.fragment.to;
      for (; s > 0 && this.input.read(s - 1, s) != `
`; )
        s--;
      this.fragmentEnd = s ? s - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let r = t + this.fragment.offset;
    for (; i.to <= r; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= r)
        return this.fragment.from <= e;
      if (!i.childAfter(r))
        return !1;
    }
  }
  matches(t) {
    let e = this.cursor.tree;
    return e && e.prop(Pt.contextHash) == t;
  }
  takeNodes(t) {
    let e = this.cursor, i = this.fragment.offset, r = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), s = t.absoluteLineStart, a = s, o = t.block.children.length, l = a, d = o;
    for (; ; ) {
      if (e.to - i > r) {
        if (e.type.isAnonymous && e.firstChild())
          continue;
        break;
      }
      let u = VC(e.from - i, t.ranges);
      if (e.to - i <= t.ranges[t.rangeI].to)
        t.addNode(e.tree, u);
      else {
        let p = new Lt(t.parser.nodeSet.types[H.Paragraph], [], [], 0, t.block.hashProp);
        t.reusePlaceholders.set(p, e.tree), t.addNode(p, u);
      }
      if (e.type.is("Block") && (cF.indexOf(e.type.id) < 0 ? (a = e.to - i, o = t.block.children.length) : (a = l, o = d, l = e.to - i, d = t.block.children.length)), !e.nextSibling())
        break;
    }
    for (; t.block.children.length > o; )
      t.block.children.pop(), t.block.positions.pop();
    return a - s;
  }
}, c(Jd, "Xi$1"), Jd), m(t2, "FragmentCursor"), t2);
function VC(n, t) {
  let e = n;
  for (let i = 1; i < t.length; i++) {
    let r = t[i - 1].to, s = t[i].from;
    r < n && (e -= s - r);
  }
  return e;
}
c(VC, "Yp$1");
m(VC, "toRelative");
const dF = Pl({
  "Blockquote/...": T.quote,
  HorizontalRule: T.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": T.heading1,
  "ATXHeading2/... SetextHeading2/...": T.heading2,
  "ATXHeading3/...": T.heading3,
  "ATXHeading4/...": T.heading4,
  "ATXHeading5/...": T.heading5,
  "ATXHeading6/...": T.heading6,
  "Comment CommentBlock": T.comment,
  Escape: T.escape,
  Entity: T.character,
  "Emphasis/...": T.emphasis,
  "StrongEmphasis/...": T.strong,
  "Link/... Image/...": T.link,
  "OrderedList/... BulletList/...": T.list,
  "BlockQuote/...": T.quote,
  "InlineCode CodeText": T.monospace,
  "URL Autolink": T.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": T.processingInstruction,
  "CodeInfo LinkLabel": T.labelName,
  LinkTitle: T.string,
  Paragraph: T.content
}), uF = new zA(new x0(LA).extend(dF), Object.keys(X1).map((n) => X1[n]), Object.keys(X1).map((n) => RA[n]), Object.keys(X1), aF, PA, Object.keys(Jb).map((n) => Jb[n]), Object.keys(Jb), []);
function jA(n, t, e) {
  let i = [];
  for (let r = n.firstChild, s = t; ; r = r.nextSibling) {
    let a = r ? r.from : e;
    if (a > s && i.push({ from: s, to: a }), !r)
      break;
    s = r.to;
  }
  return i;
}
c(jA, "GQ");
m(jA, "leftOverSpace");
function BA(n) {
  let { codeParser: t, htmlParser: e } = n;
  return { wrap: lC((i, r) => {
    let s = i.type.id;
    if (t && (s == H.CodeBlock || s == H.FencedCode)) {
      let a = "";
      if (s == H.FencedCode) {
        let l = i.node.getChild(H.CodeInfo);
        l && (a = r.read(l.from, l.to));
      }
      let o = t(a);
      if (o)
        return { parser: o, overlay: /* @__PURE__ */ m((l) => l.type.id == H.CodeText, "overlay") };
    } else if (e && (s == H.HTMLBlock || s == H.HTMLTag || s == H.CommentBlock))
      return { parser: e, overlay: jA(i.node, i.from, i.to) };
    return null;
  }) };
}
c(BA, "FQ");
m(BA, "parseCode");
const pF = { resolve: "Strikethrough", mark: "StrikethroughMark" }, fF = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": T.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: T.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(n, t, e) {
      if (t != 126 || n.char(e + 1) != 126 || n.char(e + 2) == 126)
        return -1;
      let i = n.slice(e - 1, e), r = n.slice(e + 2, e + 3), s = /\s|^$/.test(i), a = /\s|^$/.test(r), o = Ow.test(i), l = Ow.test(r);
      return n.addDelimiter(pF, e, e + 2, !a && (!l || s || o), !s && (!o || a || l));
    },
    after: "Emphasis"
  }]
};
function ph(n, t, e = 0, i, r = 0) {
  let s = 0, a = !0, o = -1, l = -1, d = !1, u = /* @__PURE__ */ m(() => {
    i.push(n.elt("TableCell", r + o, r + l, n.parser.parseInline(t.slice(o, l), r + o)));
  }, "parseCell");
  for (let p = e; p < t.length; p++) {
    let f = t.charCodeAt(p);
    f == 124 && !d ? ((!a || o > -1) && s++, a = !1, i && (o > -1 && u(), i.push(n.elt("TableDelimiter", p + r, p + r + 1))), o = l = -1) : (d || f != 32 && f != 9) && (o < 0 && (o = p), l = p + 1), d = !d && f == 92;
  }
  return o > -1 && (s++, i && u()), s;
}
c(ph, "xr$1");
m(ph, "parseRow");
function a5(n, t) {
  for (let e = t; e < n.length; e++) {
    let i = n.charCodeAt(e);
    if (i == 124)
      return !0;
    i == 92 && e++;
  }
  return !1;
}
c(a5, "Du$1");
m(a5, "hasPipe");
const UA = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var tu;
const HA = (tu = class {
  constructor() {
    this.rows = null;
  }
  nextLine(t, e, i) {
    if (this.rows == null) {
      this.rows = !1;
      let r;
      if ((e.next == 45 || e.next == 58 || e.next == 124) && UA.test(r = e.text.slice(e.pos))) {
        let s = [];
        ph(t, i.content, 0, s, i.start) == ph(t, r, e.pos) && (this.rows = [
          t.elt("TableHeader", i.start, i.start + i.content.length, s),
          t.elt("TableDelimiter", t.lineStart + e.pos, t.lineStart + e.text.length)
        ]);
      }
    } else if (this.rows) {
      let r = [];
      ph(t, e.text, e.pos, r, t.lineStart), this.rows.push(t.elt("TableRow", t.lineStart + e.pos, t.lineStart + e.text.length, r));
    }
    return !1;
  }
  finish(t, e) {
    return this.rows ? (t.addLeafElement(e, t.elt("Table", e.start, e.start + e.content.length, this.rows)), !0) : !1;
  }
}, c(tu, "uc"), tu);
m(HA, "TableParser");
let cQ = HA;
const mF = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": T.heading } },
    "TableRow",
    { name: "TableCell", style: T.content },
    { name: "TableDelimiter", style: T.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(n, t) {
      return a5(t.content, 0) ? new cQ() : null;
    },
    endLeaf(n, t, e) {
      if (e.parsers.some((r) => r instanceof cQ) || !a5(t.text, t.basePos))
        return !1;
      let i = n.peekLine();
      return UA.test(i) && ph(n, t.text, t.basePos) == ph(n, i, t.basePos);
    },
    before: "SetextHeading"
  }]
};
var eu;
const YA = (eu = class {
  nextLine() {
    return !1;
  }
  finish(t, e) {
    return t.addLeafElement(e, t.elt("Task", e.start, e.start + e.content.length, [
      t.elt("TaskMarker", e.start, e.start + 3),
      ...t.parser.parseInline(e.content.slice(3), e.start + 3)
    ])), !0;
  }
}, c(eu, "Oc"), eu);
m(YA, "TaskParser");
let yF = YA;
const gF = {
  defineNodes: [
    { name: "Task", block: !0, style: T.list },
    { name: "TaskMarker", style: T.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(n, t) {
      return /^\[[ xX]\][ \t]/.test(t.content) && n.parentType().name == "ListItem" ? new yF() : null;
    },
    after: "SetextHeading"
  }]
}, hQ = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, dQ = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, wF = /[\w-]+\.[\w-]+($|\/)/, uQ = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, pQ = /\/[a-zA-Z\d@.]+/gy;
function o5(n, t, e, i) {
  let r = 0;
  for (let s = t; s < e; s++)
    n[s] == i && r++;
  return r;
}
c(o5, "Hu$1");
m(o5, "count");
function GA(n, t) {
  dQ.lastIndex = t;
  let e = dQ.exec(n);
  if (!e || wF.exec(e[0])[0].indexOf("_") > -1)
    return -1;
  let i = t + e[0].length;
  for (; ; ) {
    let r = n[i - 1], s;
    if (/[?!.,:*_~]/.test(r) || r == ")" && o5(n, t, i, ")") > o5(n, t, i, "("))
      i--;
    else if (r == ";" && (s = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(n.slice(t, i))))
      i = t + s.index;
    else
      break;
  }
  return i;
}
c(GA, "iy$1");
m(GA, "autolinkURLEnd");
function l5(n, t) {
  uQ.lastIndex = t;
  let e = uQ.exec(n);
  if (!e)
    return -1;
  let i = e[0][e[0].length - 1];
  return i == "_" || i == "-" ? -1 : t + e[0].length - (i == "." ? 1 : 0);
}
c(l5, "Ku$1");
m(l5, "autolinkEmailEnd");
const vF = {
  parseInline: [{
    name: "Autolink",
    parse(n, t, e) {
      let i = e - n.offset;
      if (i && /\w/.test(n.text[i - 1]))
        return -1;
      hQ.lastIndex = i;
      let r = hQ.exec(n.text), s = -1;
      if (!r)
        return -1;
      if (r[1] || r[2]) {
        if (s = GA(n.text, i + r[0].length), s > -1 && n.hasOpenLink) {
          let a = /([^\[\]]|\[[^\]]*\])*/.exec(n.text.slice(i, s));
          s = i + a[0].length;
        }
      } else r[3] ? s = l5(n.text, i) : (s = l5(n.text, i + r[0].length), s > -1 && r[0] == "xmpp:" && (pQ.lastIndex = s, r = pQ.exec(n.text), r && (s = r.index + r[0].length)));
      return s < 0 ? -1 : (n.addElement(n.elt("URL", e, s + n.offset)), s + n.offset);
    }
  }]
}, OF = [mF, gF, fF, vF];
function DC(n, t, e) {
  return (i, r, s) => {
    if (r != n || i.char(s + 1) == n)
      return -1;
    let a = [i.elt(e, s, s + 1)];
    for (let o = s + 1; o < i.end; o++) {
      let l = i.char(o);
      if (l == n)
        return i.addElement(i.elt(t, s, o + 1, a.concat(i.elt(e, o, o + 1))));
      if (l == 92 && a.push(i.elt("Escape", o, o++ + 2)), Ji(l))
        break;
    }
    return -1;
  };
}
c(DC, "Wp$1");
m(DC, "parseSubSuper");
const bF = {
  defineNodes: [
    { name: "Superscript", style: T.special(T.content) },
    { name: "SuperscriptMark", style: T.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: DC(94, "Superscript", "SuperscriptMark")
  }]
}, $F = {
  defineNodes: [
    { name: "Subscript", style: T.special(T.content) },
    { name: "SubscriptMark", style: T.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: DC(126, "Subscript", "SubscriptMark")
  }]
}, xF = {
  defineNodes: [{ name: "Emoji", style: T.character }],
  parseInline: [{
    name: "Emoji",
    parse(n, t, e) {
      let i;
      return t != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(n.slice(e + 1, n.end))) ? -1 : n.addElement(n.elt("Emoji", e, e + 1 + i[0].length));
    }
  }]
};
var ta;
const KA = (ta = class {
  /**
  @internal
  */
  constructor(t, e, i, r, s, a, o, l, d, u = 0, p) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = r, this.pos = s, this.score = a, this.buffer = o, this.bufferBase = l, this.curContext = d, this.lookAhead = u, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, e, i = 0) {
    let r = t.parser.context;
    return new ta(t, [], e, i, i, 0, [], 0, r ? new fQ(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var e;
    let i = t >> 19, r = t & 65535, { parser: s } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let o = s.dynamicPrecedence(r);
    if (o && (this.score += o), i == 0) {
      this.pushState(s.getGoto(this.state, r, !0), this.reducePos), r < s.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), d = l ? this.stack[l - 2] : this.p.ranges[0].from, u = this.reducePos - d;
    u >= 2e3 && !(!((e = this.p.parser.nodeSet.types[r]) === null || e === void 0) && e.isAnonymous) && (d == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = d, this.p.lastBigReductionSize = u));
    let p = l ? this.stack[l - 1] : 0, f = this.bufferBase + this.buffer.length - p;
    if (r < s.minRepeatTerm || t & 131072) {
      let y = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, d, y, f + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[l];
    else {
      let y = this.stack[l - 3];
      this.state = s.getGoto(y, r, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(r, d);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, e, i, r = 4, s = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (e == i)
          return;
        if (a.buffer[o - 2] >= e) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!s || this.pos == i)
      this.buffer.push(t, e, i, r);
    else {
      let a = this.buffer.length;
      if (a > 0 && (this.buffer[a - 4] != 0 || this.buffer[a - 1] < 0)) {
        let o = !1;
        for (let l = a; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            o = !0;
            break;
          }
        if (o)
          for (; a > 0 && this.buffer[a - 2] > i; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, r > 4 && (r -= 4);
      }
      this.buffer[a] = t, this.buffer[a + 1] = e, this.buffer[a + 2] = i, this.buffer[a + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, e, i, r) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let s = t, { parser: a } = this.p;
      (r > this.pos || e <= a.maxNode) && (this.pos = r, a.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(s, i), this.shiftContext(e, i), e <= a.maxNode && this.buffer.push(e, i, r, 4);
    } else
      this.pos = r, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, r, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, e, i, r) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let r = this.pos;
    this.reducePos = this.pos = r + t.length, this.pushState(e, r), this.buffer.push(
      i,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), r = t.bufferBase + e;
    for (; t && r == t.bufferBase; )
      t = t.parent;
    return new ta(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let e = new SF(this); ; ) {
      let i = this.p.parser.stateSlot(
        e.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(e.state, t);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      e.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let s = 0, a; s < e.length; s += 2)
        (a = e[s + 1]) != this.state && this.p.parser.hasAction(a, t) && r.push(e[s], a);
      if (this.stack.length < 120)
        for (let s = 0; r.length < 8 && s < e.length; s += 2) {
          let a = e[s + 1];
          r.some((o, l) => l & 1 && o == a) || r.push(e[s], a);
        }
      e = r;
    }
    let i = [];
    for (let r = 0; r < e.length && i.length < 4; r += 2) {
      let s = e[r + 1];
      if (s == this.state)
        continue;
      let a = this.split();
      a.pushState(s, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(e[r], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, e = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((e & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, r = e & 65535, s = this.stack.length - i * 3;
      if (s < 0 || t.getGoto(this.stack[s], r, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        e = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, e = [], i = /* @__PURE__ */ m((r, s) => {
      if (!e.includes(r))
        return e.push(r), t.allActions(r, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let o = (a >> 19) - s;
            if (o > 1) {
              let l = a & 65535, d = this.stack.length - o * 3;
              if (d >= 0 && t.getGoto(this.stack[d], l, !1) >= 0)
                return o << 19 | 65536 | l;
            }
          } else {
            let o = i(a, s + 1);
            if (o != null)
              return o;
          }
        });
    }, "explore");
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new fQ(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}, c(ta, "zr"), ta);
m(KA, "Stack");
let kF = KA;
var iu;
const JA = (iu = class {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}, c(iu, "dc"), iu);
m(JA, "StackContext");
let fQ = JA;
var nu;
const tR = (nu = class {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = r;
  }
}, c(nu, "pc"), nu);
m(tR, "SimulatedStack");
let SF = tR;
var ea;
const eR = (ea = class {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new ea(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new ea(this.stack, this.pos, this.index);
  }
}, c(ea, "jr"), ea);
m(eR, "StackBufferCursor");
let CF = eR;
function sh(n, t = Uint16Array) {
  if (typeof n != "string")
    return n;
  let e = null;
  for (let i = 0, r = 0; i < n.length; ) {
    let s = 0;
    for (; ; ) {
      let a = n.charCodeAt(i++), o = !1;
      if (a == 126) {
        s = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, o = !0), s += l, o)
        break;
      s *= 46;
    }
    e ? e[r++] = s : e = new t(s);
  }
  return e;
}
c(sh, "dr$1");
m(sh, "decodeArray");
var ru;
const iR = (ru = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}, c(ru, "mc"), ru);
m(iR, "CachedToken");
let yv = iR;
const mQ = new yv();
var su;
const nR = (su = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = mQ, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, e) {
    let i = this.range, r = this.rangeIndex, s = this.pos + t;
    for (; s < i.from; ) {
      if (!r)
        return null;
      let a = this.ranges[--r];
      s -= i.from - a.to, i = a;
    }
    for (; e < 0 ? s > i.to : s >= i.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let a = this.ranges[++r];
      s += a.from - i.to, i = a;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let e = this.chunkOff + t, i, r;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, r = this.chunk.charCodeAt(e);
    else {
      let s = this.resolveOffset(t, 1);
      if (s == null)
        return -1;
      if (i = s, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), r = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, e) {
    this.token.value = t, this.token.end = e;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = mQ, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let r of this.ranges) {
      if (r.from >= e)
        break;
      r.to > t && (i += this.input.read(Math.max(r.from, t), Math.min(r.to, e)));
    }
    return i;
  }
}, c(su, "gc"), su);
m(nR, "InputStream");
let PF = nR;
var au;
const rR = (au = class {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    let { parser: i } = e.p;
    WC(this.data, t, e, this.id, i.data, i.tokenPrecTable);
  }
}, c(au, "Qc"), au);
m(rR, "TokenGroup");
let fh = rR;
fh.prototype.contextual = fh.prototype.fallback = fh.prototype.extend = !1;
var ou;
const sR = (ou = class {
  constructor(t, e, i) {
    this.precTable = e, this.elseToken = i, this.data = typeof t == "string" ? sh(t) : t;
  }
  token(t, e) {
    let i = t.pos, r = 0;
    for (; ; ) {
      let s = t.next < 0, a = t.resolveOffset(1, 1);
      if (WC(this.data, t, e, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || r++, a == null)
        break;
      t.reset(a, t.token);
    }
    r && (t.reset(i, t.token), t.acceptToken(this.elseToken, r));
  }
}, c(ou, "yc"), ou);
m(sR, "LocalTokenGroup");
let $O = sR;
$O.prototype.contextual = fh.prototype.fallback = fh.prototype.extend = !1;
var lu;
const aR = (lu = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, e = {}) {
    this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend;
  }
}, c(lu, "Sc"), lu);
m(aR, "ExternalTokenizer");
let tn = aR;
function WC(n, t, e, i, r, s) {
  let a = 0, o = 1 << i, { dialect: l } = e.p.parser;
  t: for (; (o & n[a]) != 0; ) {
    let d = n[a + 1];
    for (let y = a + 3; y < d; y += 2)
      if ((n[y + 1] & o) > 0) {
        let g = n[y];
        if (l.allows(g) && (t.token.value == -1 || t.token.value == g || oR(g, t.token.value, r, s))) {
          t.acceptToken(g);
          break;
        }
      }
    let u = t.next, p = 0, f = n[a + 2];
    if (t.next < 0 && f > p && n[d + f * 3 - 3] == 65535) {
      a = n[d + f * 3 - 1];
      continue t;
    }
    for (; p < f; ) {
      let y = p + f >> 1, g = d + y + (y << 1), b = n[g], S = n[g + 1] || 65536;
      if (u < b)
        f = y;
      else if (u >= S)
        p = y + 1;
      else {
        a = n[g + 2], t.advance();
        continue t;
      }
    }
    break;
  }
}
c(WC, "Up");
m(WC, "readToken");
function c5(n, t, e) {
  for (let i = t, r; (r = n[i]) != 65535; i++)
    if (r == e)
      return i - t;
  return -1;
}
c(c5, "eO");
m(c5, "findOffset");
function oR(n, t, e, i) {
  let r = c5(e, i, t);
  return r < 0 || c5(e, i, n) < r;
}
c(oR, "ay$1");
m(oR, "overrides");
const qi = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let e2 = null;
function h5(n, t, e) {
  let i = n.cursor(Ht.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(n.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : n.length;
      }
}
c(h5, "tO");
m(h5, "cutAt");
var cu;
const lR = (cu = class {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? h5(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? h5(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], r = this.index[e];
      if (r == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = i.children[r], a = this.start[e] + i.positions[r];
      if (a > t)
        return this.nextStart = a, null;
      if (s instanceof Lt) {
        if (a == t) {
          if (a < this.safeFrom)
            return null;
          let o = a + s.length;
          if (o <= this.safeTo) {
            let l = s.prop(Pt.lookAhead);
            if (!l || o + l < this.fragment.to)
              return s;
          }
        }
        this.index[e]++, a + s.length >= Math.max(this.safeFrom, t) && (this.trees.push(s), this.start.push(a), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = a + s.length;
    }
  }
}, c(cu, "bc"), cu);
m(lR, "FragmentCursor");
let QF = lR;
var hu;
const cR = (hu = class {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new yv());
  }
  getActions(t) {
    let e = 0, i = null, { parser: r } = t.p, { tokenizers: s } = r, a = r.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), o = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let d = 0; d < s.length; d++) {
      if ((1 << d & a) == 0)
        continue;
      let u = s[d], p = this.tokens[d];
      if (!(i && !u.fallback) && ((u.contextual || p.start != t.pos || p.mask != a || p.context != o) && (this.updateCachedToken(p, u, t), p.mask = a, p.context = o), p.lookAhead > p.end + 25 && (l = Math.max(p.lookAhead, l)), p.value != 0)) {
        let f = e;
        if (p.extended > -1 && (e = this.addActions(t, p.extended, p.end, e)), e = this.addActions(t, p.value, p.end, e), !u.extend && (i = p, e > f))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return l && t.setLookAhead(l), !i && t.pos == this.stream.end && (i = new yv(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new yv(), { pos: i, p: r } = t;
    return e.start = i, e.end = Math.min(i + 1, r.stream.end), e.value = i == r.stream.end ? r.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let r = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(r, t), i), t.value > -1) {
      let { parser: s } = i.p;
      for (let a = 0; a < s.specialized.length; a++)
        if (s.specialized[a] == t.value) {
          let o = s.specializers[a](this.stream.read(t.start, t.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            (o & 1) == 0 ? t.value = o >> 1 : t.extended = o >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(r + 1);
  }
  putAction(t, e, i, r) {
    for (let s = 0; s < r; s += 3)
      if (this.actions[s] == t)
        return r;
    return this.actions[r++] = t, this.actions[r++] = e, this.actions[r++] = i, r;
  }
  addActions(t, e, i, r) {
    let { state: s } = t, { parser: a } = t.p, { data: o } = a;
    for (let l = 0; l < 2; l++)
      for (let d = a.stateSlot(
        s,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; d += 3) {
        if (o[d] == 65535)
          if (o[d + 1] == 1)
            d = Un(o, d + 2);
          else {
            r == 0 && o[d + 1] == 2 && (r = this.putAction(Un(o, d + 2), e, i, r));
            break;
          }
        o[d] == e && (r = this.putAction(Un(o, d + 1), e, i, r));
      }
    return r;
  }
}, c(hu, "wc"), hu);
m(cR, "TokenCache");
let TF = cR;
var du;
const hR = (du = class {
  constructor(t, e, i, r) {
    this.parser = t, this.input = e, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new PF(e, r), this.tokens = new TF(t, this.stream), this.topTerm = t.top[1];
    let { from: s } = r[0];
    this.stacks = [kF.start(this, t.top[0], s)], this.fragments = i.length && this.stream.end - s > t.bufferLength * 4 ? new QF(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], r, s;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [a] = t;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > e)
          i.push(o);
        else {
          if (this.advanceStack(o, i, t))
            continue;
          {
            r || (r = [], s = []), r.push(o);
            let l = this.tokens.getMainToken(o);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = r && mR(r);
      if (a)
        return qi && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw qi && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let a = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, s, i);
      if (a)
        return qi && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, l) => l.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t: for (let a = 0; a < i.length - 1; a++) {
        let o = i[a];
        for (let l = a + 1; l < i.length; l++) {
          let d = i[l];
          if (o.sameState(d) || o.buffer.length > 500 && d.buffer.length > 500)
            if ((o.score - d.score || o.buffer.length - d.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(a--, 1);
              continue t;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, e, i) {
    let r = t.pos, { parser: s } = this, a = qi ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let d = t.curContext && t.curContext.tracker.strict, u = d ? t.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(r); p; ) {
        let f = this.parser.nodeSet.types[p.type.id] == p.type ? s.getGoto(t.state, p.type.id) : -1;
        if (f > -1 && p.length && (!d || (p.prop(Pt.contextHash) || 0) == u))
          return t.useNode(p, f), qi && console.log(a + this.stackID(t) + ` (via reuse of ${s.getName(p.type.id)})`), !0;
        if (!(p instanceof Lt) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let y = p.children[0];
        if (y instanceof Lt && p.positions[0] == 0)
          p = y;
        else
          break;
      }
    }
    let o = s.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return t.reduce(o), qi && console.log(a + this.stackID(t) + ` (via always-reduce ${s.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let d = 0; d < l.length; ) {
      let u = l[d++], p = l[d++], f = l[d++], y = d == l.length || !i, g = y ? t : t.split(), b = this.tokens.mainToken;
      if (g.apply(u, p, b ? b.start : g.pos, f), qi && console.log(a + this.stackID(g) + ` (via ${(u & 65536) == 0 ? "shift" : `reduce of ${s.getName(
        u & 65535
        /* Action.ValueMask */
      )}`} for ${s.getName(p)} @ ${r}${g == t ? "" : ", split"})`), y)
        return !0;
      g.pos > r ? e.push(g) : i.push(g);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return d5(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let r = null, s = !1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = e[a << 1], d = e[(a << 1) + 1], u = qi ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (s || (s = !0, o.restart(), qi && console.log(u + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let p = o.split(), f = u;
      for (let y = 0; y < 10 && p.forceReduce() && (qi && console.log(f + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); y++)
        qi && (f = this.stackID(p) + " -> ");
      for (let y of o.recoverByInsert(l))
        qi && console.log(u + this.stackID(y) + " (via recover-insert)"), this.advanceFully(y, i);
      this.stream.end > o.pos ? (d == o.pos && (d++, l = 0), o.recoverByDelete(l, d), qi && console.log(u + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), d5(o, i)) : (!r || r.score < o.score) && (r = o);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), Lt.build({
      buffer: CF.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (e2 || (e2 = /* @__PURE__ */ new WeakMap())).get(t);
    return e || e2.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}, c(du, "xc"), du);
m(hR, "Parse");
let MF = hR;
function d5(n, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == n.pos && i.sameState(n)) {
      t[e].score < n.score && (t[e] = n);
      return;
    }
  }
  t.push(n);
}
c(d5, "iO");
m(d5, "pushStackDedup");
var uu;
const dR = (uu = class {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}, c(uu, "Pc"), uu);
m(dR, "Dialect");
let AF = dR;
const i2 = /* @__PURE__ */ m((n) => n, "id");
var pu;
const uR = (pu = class {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || i2, this.reduce = t.reduce || i2, this.reuse = t.reuse || i2, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}, c(pu, "kc"), pu);
m(uR, "ContextTracker");
let pR = uR;
var ia;
const fR = (ia = class extends C0 {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let o = 0; o < t.repeatNodeCount; o++)
      e.push("");
    let i = Object.keys(t.topRules).map((o) => t.topRules[o][1]), r = [];
    for (let o = 0; o < e.length; o++)
      r.push([]);
    function s(o, l, d) {
      r[o].push([l, l.deserialize(String(d))]);
    }
    if (c(s, "s"), m(s, "setProp"), t.nodeProps)
      for (let o of t.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = Pt[l]);
        for (let d = 1; d < o.length; ) {
          let u = o[d++];
          if (u >= 0)
            s(u, l, o[d++]);
          else {
            let p = o[d + -u];
            for (let f = -u; f > 0; f--)
              s(o[d++], l, p);
            d++;
          }
        }
      }
    this.nodeSet = new x0(e.map((o, l) => je.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: r[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = QT;
    let a = sh(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(u5), this.states = sh(t.states, Uint32Array), this.data = sh(t.stateData), this.goto = sh(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((o) => typeof o == "number" ? new fh(a, o) : o), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let r = new MF(this, t, e, i);
    for (let s of this.wrappers)
      r = s(r, t, e, i);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, e, i = !1) {
    let r = this.goto;
    if (e >= r[0])
      return -1;
    for (let s = r[e + 1]; ; ) {
      let a = r[s++], o = a & 1, l = r[s++];
      if (o && i)
        return l;
      for (let d = s + (a >> 1); s < d; s++)
        if (r[s] == t)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, e) {
    let i = this.data;
    for (let r = 0; r < 2; r++)
      for (let s = this.stateSlot(
        t,
        r ? 2 : 1
        /* ParseState.Actions */
      ), a; ; s += 3) {
        if ((a = i[s]) == 65535)
          if (i[s + 1] == 1)
            a = i[s = Un(i, s + 2)];
          else {
            if (i[s + 1] == 2)
              return Un(i, s + 2);
            break;
          }
        if (a == e || a == 0)
          return Un(i, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  /**
  @internal
  */
  stateFlag(t, e) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & e) > 0;
  }
  /**
  @internal
  */
  validAction(t, e) {
    return !!this.allActions(t, (i) => i == e ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, e) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), r = i ? e(i) : void 0;
    for (let s = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); r == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = Un(this.data, s + 2);
        else
          break;
      r = e(Un(this.data, s + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Un(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let r = this.data[i + 1];
        e.some((s, a) => a & 1 && s == r) || e.push(this.data[i], r);
      }
    }
    return e;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let e = Object.assign(Object.create(ia.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let r = t.tokenizers.find((s) => s.from == i);
      return r ? r.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, r) => {
      let s = t.specializers.find((o) => o.from == i.external);
      if (!s)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: s.to });
      return e.specializers[r] = u5(a), a;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let s of t.split(" ")) {
        let a = e.indexOf(s);
        a >= 0 && (i[a] = !0);
      }
    let r = null;
    for (let s = 0; s < e.length; s++)
      if (!i[s])
        for (let a = this.dialects[e[s]], o; (o = this.data[a++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new AF(t, i, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new ia(t);
  }
}, c(ia, "qr"), ia);
m(fR, "LRParser");
let qC = fR;
function Un(n, t) {
  return n[t] | n[t + 1] << 16;
}
c(Un, "at$2");
m(Un, "pair");
function mR(n) {
  let t = null;
  for (let e of n) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(
      e.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
c(mR, "hy$1");
m(mR, "findFinished");
function u5(n) {
  if (n.external) {
    let t = n.extend ? 1 : 0;
    return (e, i) => n.external(e, i) << 1 | t;
  }
  return n.get;
}
c(u5, "rO");
m(u5, "getSpecializer");
const RF = 55, EF = 1, _F = 56, zF = 2, LF = 57, IF = 3, yQ = 4, VF = 5, FC = 6, yR = 7, gR = 8, wR = 9, vR = 10, DF = 11, WF = 12, qF = 13, n2 = 58, FF = 14, ZF = 15, gQ = 59, OR = 21, XF = 23, bR = 24, NF = 25, p5 = 27, $R = 28, jF = 29, BF = 32, UF = 35, HF = 37, YF = 38, GF = 0, KF = 1, JF = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, tZ = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, wQ = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function xR(n) {
  return n == 45 || n == 46 || n == 58 || n >= 65 && n <= 90 || n == 95 || n >= 97 && n <= 122 || n >= 161;
}
c(xR, "My$1");
m(xR, "nameChar");
let vQ = null, OQ = null, bQ = 0;
function xO(n, t) {
  let e = n.pos + t;
  if (bQ == e && OQ == n) return vQ;
  let i = n.peek(t), r = "";
  for (; xR(i); )
    r += String.fromCharCode(i), i = n.peek(++t);
  return OQ = n, bQ = e, vQ = r ? r.toLowerCase() : i == eZ || i == iZ ? void 0 : null;
}
c(xO, "qa$1");
m(xO, "tagNameAfter");
const kR = 60, kO = 62, ZC = 47, eZ = 63, iZ = 33, nZ = 45;
function f5(n, t) {
  this.name = n, this.parent = t;
}
c(f5, "fO");
m(f5, "ElementContext");
const rZ = [FC, vR, yR, gR, wR], sZ = new pR({
  start: null,
  shift(n, t, e, i) {
    return rZ.indexOf(t) > -1 ? new f5(xO(i, 1) || "", n) : n;
  },
  reduce(n, t) {
    return t == OR && n ? n.parent : n;
  },
  reuse(n, t, e, i) {
    let r = t.type.id;
    return r == FC || r == HF ? new f5(xO(i, 1) || "", n) : n;
  },
  strict: !1
}), aZ = new tn((n, t) => {
  if (n.next != kR) {
    n.next < 0 && t.context && n.acceptToken(n2);
    return;
  }
  n.advance();
  let e = n.next == ZC;
  e && n.advance();
  let i = xO(n, 0);
  if (i === void 0) return;
  if (!i) return n.acceptToken(e ? ZF : FF);
  let r = t.context ? t.context.name : null;
  if (e) {
    if (i == r) return n.acceptToken(DF);
    if (r && tZ[r]) return n.acceptToken(n2, -2);
    if (t.dialectEnabled(GF)) return n.acceptToken(WF);
    for (let s = t.context; s; s = s.parent) if (s.name == i) return;
    n.acceptToken(qF);
  } else {
    if (i == "script") return n.acceptToken(yR);
    if (i == "style") return n.acceptToken(gR);
    if (i == "textarea") return n.acceptToken(wR);
    if (JF.hasOwnProperty(i)) return n.acceptToken(vR);
    r && wQ[r] && wQ[r][i] ? n.acceptToken(n2, -1) : n.acceptToken(FC);
  }
}, { contextual: !0 }), oZ = new tn((n) => {
  for (let t = 0, e = 0; ; e++) {
    if (n.next < 0) {
      e && n.acceptToken(gQ);
      break;
    }
    if (n.next == nZ)
      t++;
    else if (n.next == kO && t >= 2) {
      e >= 3 && n.acceptToken(gQ, -2);
      break;
    } else
      t = 0;
    n.advance();
  }
});
function SR(n) {
  for (; n; n = n.parent)
    if (n.name == "svg" || n.name == "math") return !0;
  return !1;
}
c(SR, "Uy$1");
m(SR, "inForeignElement");
const lZ = new tn((n, t) => {
  if (n.next == ZC && n.peek(1) == kO) {
    let e = t.dialectEnabled(KF) || SR(t.context);
    n.acceptToken(e ? VF : yQ, 2);
  } else n.next == kO && n.acceptToken(yQ, 1);
});
function z0(n, t, e) {
  let i = 2 + n.length;
  return new tn((r) => {
    for (let s = 0, a = 0, o = 0; ; o++) {
      if (r.next < 0) {
        o && r.acceptToken(t);
        break;
      }
      if (s == 0 && r.next == kR || s == 1 && r.next == ZC || s >= 2 && s < i && r.next == n.charCodeAt(s - 2))
        s++, a++;
      else if (s == i && r.next == kO) {
        o > a ? r.acceptToken(t, -a) : r.acceptToken(e, -(a - 2));
        break;
      } else if ((r.next == 10 || r.next == 13) && o) {
        r.acceptToken(t, 1);
        break;
      } else
        s = a = 0;
      r.advance();
    }
  });
}
c(z0, "Ph$1");
m(z0, "contentTokenizer");
const cZ = z0("script", RF, EF), hZ = z0("style", _F, zF), dZ = z0("textarea", LF, IF), uZ = Pl({
  "Text RawText IncompleteTag IncompleteCloseTag": T.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": T.angleBracket,
  TagName: T.tagName,
  "MismatchedCloseTag/TagName": [T.tagName, T.invalid],
  AttributeName: T.attributeName,
  "AttributeValue UnquotedAttributeValue": T.attributeValue,
  Is: T.definitionOperator,
  "EntityReference CharacterReference": T.character,
  Comment: T.blockComment,
  ProcessingInst: T.processingInstruction,
  DoctypeDecl: T.documentMeta
}), pZ = qC.deserialize({
  version: 14,
  states: ",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[",
  stateData: ",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~",
  goto: "%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 68,
  context: sZ,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 22, 31, 34, 37, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 30, 33, 36, 38, "OpenTag"],
    ["group", -10, 14, 15, 18, 19, 20, 21, 40, 41, 42, 43, "Entity", 17, "Entity TextContent", -3, 29, 32, 35, "TextContent Entity"],
    ["isolate", -11, 22, 30, 31, 33, 34, 36, 37, 38, 39, 42, 43, "ltr", -3, 27, 28, 40, ""]
  ],
  propSources: [uZ],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [cZ, hZ, dZ, lZ, aZ, oZ, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 16] },
  dialects: { noMatch: 0, selfClosing: 515 },
  tokenPrec: 517
});
function XC(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let i of n.getChildren(bR)) {
    let r = i.getChild(NF), s = i.getChild(p5) || i.getChild($R);
    r && (e[t.read(r.from, r.to)] = s ? s.type.id == p5 ? t.read(s.from + 1, s.to - 1) : t.read(s.from, s.to) : "");
  }
  return e;
}
c(XC, "Fp$1");
m(XC, "getAttrs");
function m5(n, t) {
  let e = n.getChild(XF);
  return e ? t.read(e.from, e.to) : " ";
}
c(m5, "cO");
m(m5, "findTagName");
function gv(n, t, e) {
  let i;
  for (let r of e)
    if (!r.attrs || r.attrs(i || (i = XC(n.node.parent.firstChild, t))))
      return { parser: r.parser };
  return null;
}
c(gv, "Do$1");
m(gv, "maybeNest");
function NC(n = [], t = []) {
  let e = [], i = [], r = [], s = [];
  for (let o of n)
    (o.tag == "script" ? e : o.tag == "style" ? i : o.tag == "textarea" ? r : s).push(o);
  let a = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of t) (a[o.name] || (a[o.name] = [])).push(o);
  return lC((o, l) => {
    let d = o.type.id;
    if (d == jF) return gv(o, l, e);
    if (d == BF) return gv(o, l, i);
    if (d == UF) return gv(o, l, r);
    if (d == OR && s.length) {
      let u = o.node, p = u.firstChild, f = p && m5(p, l), y;
      if (f) {
        for (let g of s)
          if (g.tag == f && (!g.attrs || g.attrs(y || (y = XC(p, l))))) {
            let b = u.lastChild, S = b.type.id == YF ? b.from : u.to;
            if (S > p.to)
              return { parser: g.parser, overlay: [{ from: p.to, to: S }] };
          }
      }
    }
    if (a && d == bR) {
      let u = o.node, p;
      if (p = u.firstChild) {
        let f = a[l.read(p.from, p.to)];
        if (f) for (let y of f) {
          if (y.tagName && y.tagName != m5(u.parent, l)) continue;
          let g = u.lastChild;
          if (g.type.id == p5) {
            let b = g.from + 1, S = g.lastChild, $ = g.to - (S && S.isError ? 0 : 1);
            if ($ > b) return { parser: y.parser, overlay: [{ from: b, to: $ }] };
          } else if (g.type.id == $R)
            return { parser: y.parser, overlay: [{ from: g.from, to: g.to }] };
        }
      }
    }
    return null;
  });
}
c(NC, "Hp$1");
m(NC, "configureNesting");
const fZ = 122, $Q = 1, mZ = 123, yZ = 124, CR = 2, gZ = 125, wZ = 3, vZ = 4, PR = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], OZ = 58, bZ = 40, QR = 95, $Z = 91, wv = 45, xZ = 46, kZ = 35, SZ = 37, CZ = 38, PZ = 92, QZ = 10, TZ = 42;
function Zm(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 161;
}
c(Zm, "mn$1");
m(Zm, "isAlpha");
function L0(n) {
  return n >= 48 && n <= 57;
}
c(L0, "kh$1");
m(L0, "isDigit");
function y5(n) {
  return L0(n) || n >= 97 && n <= 102 || n >= 65 && n <= 70;
}
c(y5, "OO");
m(y5, "isHex");
const TR = /* @__PURE__ */ m((n, t, e) => (i, r) => {
  for (let s = !1, a = 0, o = 0; ; o++) {
    let { next: l } = i;
    if (Zm(l) || l == wv || l == QR || s && L0(l))
      !s && (l != wv || o > 0) && (s = !0), a === o && l == wv && a++, i.advance();
    else if (l == PZ && i.peek(1) != QZ) {
      if (i.advance(), y5(i.next)) {
        do
          i.advance();
        while (y5(i.next));
        i.next == 32 && i.advance();
      } else i.next > -1 && i.advance();
      s = !0;
    } else {
      s && i.acceptToken(
        a == 2 && r.canShift(CR) ? t : l == bZ ? e : n
      );
      break;
    }
  }
}, "identifierTokens"), MZ = new tn(
  TR(mZ, CR, yZ)
), AZ = new tn(
  TR(gZ, wZ, vZ)
), RZ = new tn((n) => {
  if (PR.includes(n.peek(-1))) {
    let { next: t } = n;
    (Zm(t) || t == QR || t == kZ || t == xZ || t == TZ || t == $Z || t == OZ && Zm(n.peek(1)) || t == wv || t == CZ) && n.acceptToken(fZ);
  }
}), EZ = new tn((n) => {
  if (!PR.includes(n.peek(-1))) {
    let { next: t } = n;
    if (t == SZ && (n.advance(), n.acceptToken($Q)), Zm(t)) {
      do
        n.advance();
      while (Zm(n.next) || L0(n.next));
      n.acceptToken($Q);
    }
  }
}), _Z = Pl({
  "AtKeyword import charset namespace keyframes media supports": T.definitionKeyword,
  "from to selector": T.keyword,
  NamespaceName: T.namespace,
  KeyframeName: T.labelName,
  KeyframeRangeName: T.operatorKeyword,
  TagName: T.tagName,
  ClassName: T.className,
  PseudoClassName: T.constant(T.className),
  IdName: T.labelName,
  "FeatureName PropertyName": T.propertyName,
  AttributeName: T.attributeName,
  NumberLiteral: T.number,
  KeywordQuery: T.keyword,
  UnaryQueryOp: T.operatorKeyword,
  "CallTag ValueName": T.atom,
  VariableName: T.variableName,
  Callee: T.operatorKeyword,
  Unit: T.unit,
  "UniversalSelector NestingSelector": T.definitionOperator,
  "MatchOp CompareOp": T.compareOperator,
  "ChildOp SiblingOp, LogicOp": T.logicOperator,
  BinOp: T.arithmeticOperator,
  Important: T.modifier,
  Comment: T.blockComment,
  ColorLiteral: T.color,
  "ParenthesizedContent StringLiteral": T.string,
  ":": T.punctuation,
  "PseudoOp #": T.derefOperator,
  "; ,": T.separator,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace
}), zZ = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 }, LZ = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 }, IZ = { __proto__: null, selector: 112, layer: 166 }, VZ = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 }, DZ = { __proto__: null, to: 207 }, WZ = qC.deserialize({
  version: 14,
  states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames: "⚠ Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
  maxTerm: 143,
  nodeProps: [
    ["isolate", -2, 5, 36, ""],
    ["openedBy", 20, "(", 28, "[", 31, "{"],
    ["closedBy", 21, ")", 29, "]", 32, "}"]
  ],
  propSources: [_Z],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [RZ, EZ, MZ, AZ, 1, 2, 3, 4, new $O("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
  topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
  specialized: [{ term: 124, get: /* @__PURE__ */ m((n) => zZ[n] || -1, "get") }, { term: 125, get: /* @__PURE__ */ m((n) => LZ[n] || -1, "get") }, { term: 4, get: /* @__PURE__ */ m((n) => IZ[n] || -1, "get") }, { term: 25, get: /* @__PURE__ */ m((n) => VZ[n] || -1, "get") }, { term: 123, get: /* @__PURE__ */ m((n) => DZ[n] || -1, "get") }],
  tokenPrec: 1963
});
let r2 = null;
function vv() {
  if (!r2 && typeof document == "object" && document.body) {
    let { style: n } = document.body, t = [], e = /* @__PURE__ */ new Set();
    for (let i in n)
      i != "cssText" && i != "cssFloat" && typeof n[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())), e.has(i) || (t.push(i), e.add(i)));
    r2 = t.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return r2 || [];
}
c(vv, "No$1");
m(vv, "properties");
const xQ = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((n) => ({ type: "class", label: n })), kQ = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((n) => ({ type: "keyword", label: n })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((n) => ({ type: "constant", label: n }))), qZ = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((n) => ({ type: "type", label: n })), FZ = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((n) => ({ type: "keyword", label: n })), xr = /^(\w[\w-]*|-\w[\w-]*|)$/, ZZ = /^-(-[\w-]*)?$/;
function MR(n, t) {
  var e;
  if ((n.name == "(" || n.type.isError) && (n = n.parent || n), n.name != "ArgList")
    return !1;
  let i = (e = n.parent) === null || e === void 0 ? void 0 : e.firstChild;
  return i?.name != "Callee" ? !1 : t.sliceString(i.from, i.to) == "var";
}
c(MR, "PS");
m(MR, "isVarArg");
const SQ = /* @__PURE__ */ new BT(), XZ = ["Declaration"];
function AR(n) {
  for (let t = n; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return n;
  }
}
c(AR, "$S");
m(AR, "astTop");
function jC(n, t, e) {
  if (t.to - t.from > 4096) {
    let i = SQ.get(t);
    if (i)
      return i;
    let r = [], s = /* @__PURE__ */ new Set(), a = t.cursor(Ht.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of jC(n, a.node, e))
          s.has(o.label) || (s.add(o.label), r.push(o));
      while (a.nextSibling());
    return SQ.set(t, r), r;
  } else {
    let i = [], r = /* @__PURE__ */ new Set();
    return t.cursor().iterate((s) => {
      var a;
      if (e(s) && s.matchContext(XZ) && ((a = s.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = n.sliceString(s.from, s.to);
        r.has(o) || (r.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
c(jC, "im$1");
m(jC, "variableNames");
const NZ = /* @__PURE__ */ m((n) => (t) => {
  let { state: e, pos: i } = t, r = ae(e).resolveInner(i, -1), s = r.type.isError && r.from == r.to - 1 && e.doc.sliceString(r.from, r.to) == "-";
  if (r.name == "PropertyName" || (s || r.name == "TagName") && /^(Block|Styles)$/.test(r.resolve(r.to).name))
    return { from: r.from, options: vv(), validFor: xr };
  if (r.name == "ValueName")
    return { from: r.from, options: kQ, validFor: xr };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: xQ, validFor: xr };
  if (n(r) || (t.explicit || s) && MR(r, e.doc))
    return {
      from: n(r) || s ? r.from : i,
      options: jC(e.doc, AR(r), n),
      validFor: ZZ
    };
  if (r.name == "TagName") {
    for (let { parent: l } = r; l; l = l.parent)
      if (l.name == "Block")
        return { from: r.from, options: vv(), validFor: xr };
    return { from: r.from, options: qZ, validFor: xr };
  }
  if (r.name == "AtKeyword")
    return { from: r.from, options: FZ, validFor: xr };
  if (!t.explicit)
    return null;
  let a = r.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: xQ, validFor: xr } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: kQ, validFor: xr } : a.name == "Block" || a.name == "Styles" ? { from: i, options: vv(), validFor: xr } : null;
}, "defineCSSCompletionSource"), jZ = /* @__PURE__ */ NZ((n) => n.name == "VariableName"), SO = /* @__PURE__ */ dC.define({
  name: "css",
  parser: /* @__PURE__ */ WZ.configure({
    props: [
      /* @__PURE__ */ py.add({
        Declaration: /* @__PURE__ */ Jg()
      }),
      /* @__PURE__ */ e1.add({
        "Block KeyframeList": mC
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function RR() {
  return new qm(SO, SO.data.of({ autocomplete: jZ }));
}
c(RR, "sm$1");
m(RR, "css");
const BZ = 316, UZ = 317, CQ = 1, HZ = 2, YZ = 3, GZ = 4, KZ = 318, JZ = 320, tX = 321, eX = 5, iX = 6, nX = 0, g5 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], ER = 125, rX = 59, w5 = 47, sX = 42, aX = 43, oX = 45, lX = 60, cX = 44, hX = 63, dX = 46, uX = 91, pX = new pR({
  start: !1,
  shift(n, t) {
    return t == eX || t == iX || t == JZ ? n : t == tX;
  },
  strict: !1
}), fX = new tn((n, t) => {
  let { next: e } = n;
  (e == ER || e == -1 || t.context) && n.acceptToken(KZ);
}, { contextual: !0, fallback: !0 }), mX = new tn((n, t) => {
  let { next: e } = n, i;
  g5.indexOf(e) > -1 || e == w5 && ((i = n.peek(1)) == w5 || i == sX) || e != ER && e != rX && e != -1 && !t.context && n.acceptToken(BZ);
}, { contextual: !0 }), yX = new tn((n, t) => {
  n.next == uX && !t.context && n.acceptToken(UZ);
}, { contextual: !0 }), gX = new tn((n, t) => {
  let { next: e } = n;
  if (e == aX || e == oX) {
    if (n.advance(), e == n.next) {
      n.advance();
      let i = !t.context && t.canShift(CQ);
      n.acceptToken(i ? CQ : HZ);
    }
  } else e == hX && n.peek(1) == dX && (n.advance(), n.advance(), (n.next < 48 || n.next > 57) && n.acceptToken(YZ));
}, { contextual: !0 });
function Ov(n, t) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !t && n >= 48 && n <= 57;
}
c(Ov, "Go$1");
m(Ov, "identifierChar");
const wX = new tn((n, t) => {
  if (n.next != lX || !t.dialectEnabled(nX) || (n.advance(), n.next == w5)) return;
  let e = 0;
  for (; g5.indexOf(n.next) > -1; )
    n.advance(), e++;
  if (Ov(n.next, !0)) {
    for (n.advance(), e++; Ov(n.next, !1); )
      n.advance(), e++;
    for (; g5.indexOf(n.next) > -1; )
      n.advance(), e++;
    if (n.next == cX) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!Ov(n.next, !0)) return;
        break;
      }
      if (n.next != "extends".charCodeAt(i)) break;
      n.advance(), e++;
    }
  }
  n.acceptToken(GZ, -e);
}), vX = Pl({
  "get set async static": T.modifier,
  "for while do if else switch try catch finally return throw break continue default case defer": T.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": T.operatorKeyword,
  "let var const using function class extends": T.definitionKeyword,
  "import export from": T.moduleKeyword,
  "with debugger new": T.keyword,
  TemplateString: T.special(T.string),
  super: T.atom,
  BooleanLiteral: T.bool,
  this: T.self,
  null: T.null,
  Star: T.modifier,
  VariableName: T.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": T.function(T.variableName),
  VariableDefinition: T.definition(T.variableName),
  Label: T.labelName,
  PropertyName: T.propertyName,
  PrivatePropertyName: T.special(T.propertyName),
  "CallExpression/MemberExpression/PropertyName": T.function(T.propertyName),
  "FunctionDeclaration/VariableDefinition": T.function(T.definition(T.variableName)),
  "ClassDeclaration/VariableDefinition": T.definition(T.className),
  "NewExpression/VariableName": T.className,
  PropertyDefinition: T.definition(T.propertyName),
  PrivatePropertyDefinition: T.definition(T.special(T.propertyName)),
  UpdateOp: T.updateOperator,
  "LineComment Hashbang": T.lineComment,
  BlockComment: T.blockComment,
  Number: T.number,
  String: T.string,
  Escape: T.escape,
  ArithOp: T.arithmeticOperator,
  LogicOp: T.logicOperator,
  BitOp: T.bitwiseOperator,
  CompareOp: T.compareOperator,
  RegExp: T.regexp,
  Equals: T.definitionOperator,
  Arrow: T.function(T.punctuation),
  ": Spread": T.punctuation,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace,
  "InterpolationStart InterpolationEnd": T.special(T.brace),
  ".": T.derefOperator,
  ", ;": T.separator,
  "@": T.meta,
  TypeName: T.typeName,
  TypeDefinition: T.definition(T.typeName),
  "type enum interface implements namespace module declare": T.definitionKeyword,
  "abstract global Privacy readonly override": T.modifier,
  "is keyof unique infer asserts": T.operatorKeyword,
  JSXAttributeValue: T.attributeValue,
  JSXText: T.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": T.angleBracket,
  "JSXIdentifier JSXNameSpacedName": T.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": T.attributeName,
  "JSXBuiltin/JSXIdentifier": T.standard(T.tagName)
}), OX = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 }, bX = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, $X = { __proto__: null, "<": 193 }, xX = qC.deserialize({
  version: 14,
  states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
  stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
  goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 380,
  context: pX,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [vX],
  skippedNodes: [0, 5, 6, 278],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [mX, yX, gX, wX, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, fX, new $O("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new $O("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
  topRules: { Script: [0, 7], SingleExpression: [1, 276], SingleClassItem: [2, 277] },
  dialects: { jsx: 0, ts: 15175 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 327, get: /* @__PURE__ */ m((n) => OX[n] || -1, "get") }, { term: 343, get: /* @__PURE__ */ m((n) => bX[n] || -1, "get") }, { term: 95, get: /* @__PURE__ */ m((n) => $X[n] || -1, "get") }],
  tokenPrec: 15201
}), _R = [
  /* @__PURE__ */ fi("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ fi('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], kX = /* @__PURE__ */ _R.concat([
  /* @__PURE__ */ fi("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), PQ = /* @__PURE__ */ new BT(), zR = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Vc(n) {
  return (t, e) => {
    let i = t.node.getChild("VariableDefinition");
    return i && e(i, n), !0;
  };
}
c(Vc, "lr$1");
m(Vc, "defID");
const SX = ["FunctionDeclaration"], CX = {
  FunctionDeclaration: /* @__PURE__ */ Vc("function"),
  ClassDeclaration: /* @__PURE__ */ Vc("class"),
  ClassExpression: /* @__PURE__ */ m(() => !0, "ClassExpression"),
  EnumDeclaration: /* @__PURE__ */ Vc("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Vc("type"),
  NamespaceDeclaration: /* @__PURE__ */ Vc("namespace"),
  VariableDefinition(n, t) {
    n.matchContext(SX) || t(n, "variable");
  },
  TypeDefinition(n, t) {
    t(n, "type");
  },
  __proto__: null
};
function BC(n, t) {
  let e = PQ.get(t);
  if (e)
    return e;
  let i = [], r = !0;
  function s(a, o) {
    let l = n.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return c(s, "s"), m(s, "def"), t.cursor(Ht.IncludeAnonymous).iterate((a) => {
    if (r)
      r = !1;
    else if (a.name) {
      let o = CX[a.name];
      if (o && o(a, s) || zR.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of BC(n, a.node))
        i.push(o);
      return !1;
    }
  }), PQ.set(t, i), i;
}
c(BC, "hm$1");
m(BC, "getScope");
const CO = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, UC = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function LR(n) {
  let t = ae(n.state).resolveInner(n.pos, -1);
  if (UC.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && CO.test(n.state.sliceDoc(t.from, t.to));
  if (!e && !n.explicit)
    return null;
  let i = [];
  for (let r = t; r; r = r.parent)
    zR.has(r.name) && (i = i.concat(BC(n.state.doc, r)));
  return {
    options: i,
    from: e ? t.from : n.pos,
    validFor: CO
  };
}
c(LR, "fm$1");
m(LR, "localCompletionSource");
function bv(n, t, e) {
  var i;
  let r = [];
  for (; ; ) {
    let s = t.firstChild, a;
    if (s?.name == "VariableName")
      return r.push(n(s)), { path: r.reverse(), name: e };
    if (s?.name == "MemberExpression" && ((i = a = s.lastChild) === null || i === void 0 ? void 0 : i.name) == "PropertyName")
      r.push(n(a)), t = s;
    else
      return null;
  }
}
c(bv, "Fo$1");
m(bv, "pathFor");
function IR(n) {
  let t = /* @__PURE__ */ m((i) => n.state.doc.sliceString(i.from, i.to), "read"), e = ae(n.state).resolveInner(n.pos, -1);
  return e.name == "PropertyName" ? bv(t, e.parent, t(e)) : (e.name == "." || e.name == "?.") && e.parent.name == "MemberExpression" ? bv(t, e.parent, "") : UC.indexOf(e.name) > -1 ? null : e.name == "VariableName" || e.to - e.from < 20 && CO.test(t(e)) ? { path: [], name: t(e) } : e.name == "MemberExpression" ? bv(t, e, "") : n.explicit ? { path: [], name: "" } : null;
}
c(IR, "cm$1");
m(IR, "completionPath");
function VR(n, t) {
  let e = [], i = /* @__PURE__ */ new Set();
  for (let r = 0; ; r++) {
    for (let a of (Object.getOwnPropertyNames || Object.keys)(n)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(a) || i.has(a))
        continue;
      i.add(a);
      let o;
      try {
        o = n[a];
      } catch {
        continue;
      }
      e.push({
        label: a,
        type: typeof o == "function" ? /^[A-Z]/.test(a) ? "class" : t ? "function" : "method" : t ? "variable" : "property",
        boost: -r
      });
    }
    let s = Object.getPrototypeOf(n);
    if (!s)
      return e;
    n = s;
  }
}
c(VR, "lb$1");
m(VR, "enumeratePropertyCompletions");
function PX(n) {
  let t = /* @__PURE__ */ new Map();
  return (e) => {
    let i = IR(e);
    if (!i)
      return null;
    let r = n;
    for (let a of i.path)
      if (r = r[a], !r)
        return null;
    let s = t.get(r);
    return s || t.set(r, s = VR(r, !i.path.length)), {
      from: e.pos - i.name.length,
      options: s,
      validFor: CO
    };
  };
}
c(PX, "ab$1");
m(PX, "scopeCompletionSource");
const Pn = /* @__PURE__ */ dC.define({
  name: "javascript",
  parser: /* @__PURE__ */ xX.configure({
    props: [
      /* @__PURE__ */ py.add({
        IfStatement: /* @__PURE__ */ Jg({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Jg({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: uq,
        SwitchBody: /* @__PURE__ */ m((n) => {
          let t = n.textAfter, e = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return n.baseIndent + (e ? 0 : i ? 1 : 2) * n.unit;
        }, "SwitchBody"),
        Block: /* @__PURE__ */ MM({ closing: "}" }),
        ArrowFunction: /* @__PURE__ */ m((n) => n.baseIndent + n.unit, "ArrowFunction"),
        "TemplateString BlockComment": /* @__PURE__ */ m(() => null, "TemplateString BlockComment"),
        "Statement Property": /* @__PURE__ */ Jg({ except: /^\s*{/ }),
        JSXElement(n) {
          let t = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        JSXEscape(n) {
          let t = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ e1.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": mC,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), DR = {
  test: /* @__PURE__ */ m((n) => /^JSX/.test(n.name), "test"),
  facet: /* @__PURE__ */ t1({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, WR = /* @__PURE__ */ Pn.configure({ dialect: "ts" }, "typescript"), qR = /* @__PURE__ */ Pn.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ hC.add((n) => n.isTop ? [DR] : void 0)]
}), FR = /* @__PURE__ */ Pn.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ hC.add((n) => n.isTop ? [DR] : void 0)]
}, "typescript");
let ZR = /* @__PURE__ */ m((n) => ({ label: n, type: "keyword" }), "kwCompletion");
const XR = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(ZR), QX = /* @__PURE__ */ XR.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(ZR));
function NR(n = {}) {
  let t = n.jsx ? n.typescript ? FR : qR : n.typescript ? WR : Pn, e = n.typescript ? kX.concat(QX) : _R.concat(XR);
  return new qm(t, [
    Pn.data.of({
      autocomplete: YM(UC, bC(e))
    }),
    Pn.data.of({
      autocomplete: LR
    }),
    n.jsx ? MX : []
  ]);
}
c(NR, "pm$1");
m(NR, "javascript");
function jR(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
c(jR, "fb$1");
m(jR, "findOpenTag");
function v5(n, t, e = n.length) {
  for (let i = t?.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return n.sliceString(i.from, Math.min(i.to, e));
  return "";
}
c(v5, "yO");
m(v5, "elementName$1");
const TX = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), MX = /* @__PURE__ */ Ct.inputHandler.of((n, t, e, i, r) => {
  if ((TX ? n.composing : n.compositionStarted) || n.state.readOnly || t != e || i != ">" && i != "/" || !Pn.isActiveAt(n.state, t, -1))
    return !1;
  let s = r(), { state: a } = s, o = a.changeByRange((l) => {
    var d;
    let { head: u } = l, p = ae(a).resolveInner(u - 1, -1), f;
    if (p.name == "JSXStartTag" && (p = p.parent), !(a.doc.sliceString(u - 1, u) != i || p.name == "JSXAttributeValue" && p.to > u)) {
      if (i == ">" && p.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (i == "/" && p.name == "JSXStartCloseTag") {
        let y = p.parent, g = y.parent;
        if (g && y.from == u - 2 && ((f = v5(a.doc, g.firstChild, u)) || ((d = g.firstChild) === null || d === void 0 ? void 0 : d.name) == "JSXFragmentTag")) {
          let b = `${f}>`;
          return { range: it.cursor(u + b.length, -1), changes: { from: u, insert: b } };
        }
      } else if (i == ">") {
        let y = jR(p);
        if (y && y.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(u, u + 2)) && (f = v5(a.doc, y, u)))
          return { range: l, changes: { from: u, insert: `</${f}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    s,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
function AX(n, t) {
  return t || (t = {
    parserOptions: { ecmaVersion: 2019, sourceType: "module" },
    env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
    rules: {}
  }, n.getRules().forEach((e, i) => {
    var r;
    !((r = e.meta.docs) === null || r === void 0) && r.recommended && (t.rules[i] = 2);
  })), (e) => {
    let { state: i } = e, r = [];
    for (let { from: s, to: a } of Pn.findRegions(i)) {
      let o = i.doc.lineAt(s), l = { line: o.number - 1, col: s - o.from, pos: s };
      for (let d of n.verify(i.sliceDoc(s, a), t))
        r.push(BR(d, i.doc, l));
    }
    return r;
  };
}
c(AX, "ub$1");
m(AX, "esLint");
function O5(n, t, e, i) {
  return e.line(n + i.line).from + t + (n == 1 ? i.col - 1 : -1);
}
c(O5, "SO");
m(O5, "mapPos");
function BR(n, t, e) {
  let i = O5(n.line, n.column, t, e), r = {
    from: i,
    to: n.endLine != null && n.endColumn != 1 ? O5(n.endLine, n.endColumn, t, e) : i,
    message: n.message,
    source: n.ruleId ? "eslint:" + n.ruleId : "eslint",
    severity: n.severity == 1 ? "warning" : "error"
  };
  if (n.fix) {
    let { range: s, text: a } = n.fix, o = s[0] + e.pos - i, l = s[1] + e.pos - i;
    r.actions = [{
      name: "fix",
      apply(d, u) {
        d.dispatch({ changes: { from: u + o, to: u + l, insert: a }, scrollIntoView: !0 });
      }
    }];
  }
  return r;
}
c(BR, "Ob$1");
m(BR, "translateDiagnostic");
const _y = ["_blank", "_self", "_top", "_parent"], s2 = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], a2 = ["get", "post", "put", "delete"], o2 = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Fi = ["true", "false"], ht = {}, RX = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: _y,
      hreflang: null
    }
  },
  abbr: ht,
  address: ht,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ht,
  aside: ht,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ht,
  base: { attrs: { href: null, target: _y } },
  bdi: ht,
  bdo: ht,
  blockquote: { attrs: { cite: null } },
  body: ht,
  br: ht,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: o2,
      formmethod: a2,
      formnovalidate: ["novalidate"],
      formtarget: _y,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ht,
  center: ht,
  cite: ht,
  code: ht,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ht,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ht,
  div: ht,
  dl: ht,
  dt: ht,
  em: ht,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ht,
  figure: ht,
  footer: ht,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": s2,
      autocomplete: ["on", "off"],
      enctype: o2,
      method: a2,
      novalidate: ["novalidate"],
      target: _y
    }
  },
  h1: ht,
  h2: ht,
  h3: ht,
  h4: ht,
  h5: ht,
  h6: ht,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ht,
  hgroup: ht,
  hr: ht,
  html: {
    attrs: { manifest: null }
  },
  i: ht,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: o2,
      formmethod: a2,
      formnovalidate: ["novalidate"],
      formtarget: _y,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ht,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ht,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ht,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: s2,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ht,
  noscript: ht,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ht,
  param: { attrs: { name: null, value: null } },
  pre: ht,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ht,
  rt: ht,
  ruby: ht,
  samp: ht,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: s2
    }
  },
  section: ht,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ht,
  source: { attrs: { src: null, type: null, media: null } },
  span: ht,
  strong: ht,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ht,
  summary: ht,
  sup: ht,
  table: ht,
  tbody: ht,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ht,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ht,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ht,
  time: { attrs: { datetime: null } },
  title: ht,
  tr: ht,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ht,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ht
}, UR = {
  accesskey: null,
  class: null,
  contenteditable: Fi,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Fi,
  autocorrect: Fi,
  autocapitalize: Fi,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Fi,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Fi,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Fi,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Fi,
  "aria-hidden": Fi,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Fi,
  "aria-multiselectable": Fi,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Fi,
  "aria-relevant": null,
  "aria-required": Fi,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, HR = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
for (let n of HR)
  UR[n] = null;
var fu;
const YR = (fu = class {
  constructor(t, e) {
    this.tags = { ...RX, ...t }, this.globalAttrs = { ...UR, ...e }, this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}, c(fu, "$c"), fu);
m(YR, "Schema");
let bw = YR;
bw.default = /* @__PURE__ */ new bw();
function el(n, t, e = n.length) {
  if (!t)
    return "";
  let i = t.firstChild, r = i && i.getChild("TagName");
  return r ? n.sliceString(r.from, Math.min(r.to, e)) : "";
}
c(el, "Hi$1");
m(el, "elementName");
function il(n, t = !1) {
  for (; n; n = n.parent)
    if (n.name == "Element")
      if (t)
        t = !1;
      else
        return n;
  return null;
}
c(il, "Ki$1");
m(il, "findParentElement");
function HC(n, t, e) {
  return e.tags[el(n, il(t))]?.children || e.allTags;
}
c(HC, "ym$1");
m(HC, "allowedChildren");
function I0(n, t) {
  let e = [];
  for (let i = il(t); i && !i.type.isTop; i = il(i.parent)) {
    let r = el(n, i);
    if (r && i.lastChild.name == "CloseTag")
      break;
    r && e.indexOf(r) < 0 && (t.name == "EndTag" || t.from >= i.firstChild.to) && e.push(r);
  }
  return e;
}
c(I0, "Lh$1");
m(I0, "openTags");
const GR = /^[:\-\.\w\u00b7-\uffff]*$/;
function b5(n, t, e, i, r) {
  let s = /\s*>/.test(n.sliceDoc(r, r + 5)) ? "" : ">", a = il(e, e.name == "StartTag" || e.name == "TagName");
  return {
    from: i,
    to: r,
    options: HC(n.doc, a, t).map((o) => ({ label: o, type: "type" })).concat(I0(n.doc, e).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + s,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
c(b5, "bO");
m(b5, "completeTag");
function $5(n, t, e, i) {
  let r = /\s*>/.test(n.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: e,
    to: i,
    options: I0(n.doc, t).map((s, a) => ({ label: s, apply: s + r, type: "type", boost: 99 - a })),
    validFor: GR
  };
}
c($5, "wO");
m($5, "completeCloseTag");
function KR(n, t, e, i) {
  let r = [], s = 0;
  for (let a of HC(n.doc, e, t))
    r.push({ label: "<" + a, type: "type" });
  for (let a of I0(n.doc, e))
    r.push({ label: "</" + a + ">", type: "type", boost: 99 - s++ });
  return { from: i, to: i, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
c(KR, "pb$1");
m(KR, "completeStartTag");
function JR(n, t, e, i, r) {
  let s = il(e), a = s ? t.tags[el(n.doc, s)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], l = a && a.globalAttrs === !1 ? o : o.length ? o.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: i,
    to: r,
    options: l.map((d) => ({ label: d, type: "property" })),
    validFor: GR
  };
}
c(JR, "mb$1");
m(JR, "completeAttrName");
function tE(n, t, e, i, r) {
  var s;
  let a = (s = e.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), o = [], l;
  if (a) {
    let d = n.sliceDoc(a.from, a.to), u = t.globalAttrs[d];
    if (!u) {
      let p = il(e), f = p ? t.tags[el(n.doc, p)] : null;
      u = f?.attrs && f.attrs[d];
    }
    if (u) {
      let p = n.sliceDoc(i, r).toLowerCase(), f = '"', y = '"';
      /^['"]/.test(p) ? (l = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", y = n.sliceDoc(r, r + 1) == p[0] ? "" : p[0], p = p.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let g of u)
        o.push({ label: g, apply: f + g + y, type: "constant" });
    }
  }
  return { from: i, to: r, options: o, validFor: l };
}
c(tE, "gb$1");
m(tE, "completeAttrValue");
function YC(n, t) {
  let { state: e, pos: i } = t, r = ae(e).resolveInner(i, -1), s = r.resolve(i);
  for (let a = i, o; s == r && (o = r.childBefore(a)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    s = r = o, a = l.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? $5(e, r, r.from, i) : b5(e, n, r, r.from, i) : r.name == "StartTag" || r.name == "IncompleteTag" ? b5(e, n, r, i, i) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? $5(e, r, i, i) : r.name == "OpenTag" || r.name == "SelfClosingTag" || r.name == "AttributeName" ? JR(e, n, r, r.name == "AttributeName" ? r.from : i, i) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? tE(e, n, r, r.name == "Is" ? i : r.from, i) : t.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? KR(e, n, r, i) : null;
}
c(YC, "bm$1");
m(YC, "htmlCompletionFor");
function eE(n) {
  return YC(bw.default, n);
}
c(eE, "wm$1");
m(eE, "htmlCompletionSource");
function iE(n) {
  let { extraTags: t, extraGlobalAttributes: e } = n, i = e || t ? new bw(t, e) : bw.default;
  return (r) => YC(i, r);
}
c(iE, "xm$1");
m(iE, "htmlCompletionSourceWith");
const EX = /* @__PURE__ */ Pn.parser.configure({ top: "SingleExpression" }), nE = [
  {
    tag: "script",
    attrs: /* @__PURE__ */ m((n) => n.type == "text/typescript" || n.lang == "ts", "attrs"),
    parser: WR.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ m((n) => n.type == "text/babel" || n.type == "text/jsx", "attrs"),
    parser: qR.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ m((n) => n.type == "text/typescript-jsx", "attrs"),
    parser: FR.parser
  },
  {
    tag: "script",
    attrs(n) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(n.type);
    },
    parser: EX
  },
  {
    tag: "script",
    attrs(n) {
      return !n.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(n.type);
    },
    parser: Pn.parser
  },
  {
    tag: "style",
    attrs(n) {
      return (!n.lang || n.lang == "css") && (!n.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(n.type));
    },
    parser: SO.parser
  }
], rE = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ SO.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ HR.map((n) => ({ name: n, parser: Pn.parser }))), sE = /* @__PURE__ */ dC.define({
  name: "html",
  parser: /* @__PURE__ */ pZ.configure({
    props: [
      /* @__PURE__ */ py.add({
        Element(n) {
          let t = /^(\s*)(<\/)?/.exec(n.textAfter);
          return n.node.to <= n.pos + t[0].length ? n.continue() : n.lineIndent(n.node.from) + (t[2] ? 0 : n.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        },
        Document(n) {
          if (n.pos + /\s*/.exec(n.textAfter)[0].length < n.node.to)
            return n.continue();
          let t = null, e;
          for (let i = n.node; ; ) {
            let r = i.lastChild;
            if (!r || r.name != "Element" || r.to != i.to)
              break;
            t = i = r;
          }
          return t && !((e = t.lastChild) && (e.name == "CloseTag" || e.name == "SelfClosingTag")) ? n.lineIndent(t.from) + n.unit : null;
        }
      }),
      /* @__PURE__ */ e1.add({
        Element(n) {
          let t = n.firstChild, e = n.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: e.name == "CloseTag" ? e.from : n.to };
        }
      }),
      /* @__PURE__ */ zM.add({
        "OpenTag CloseTag": /* @__PURE__ */ m((n) => n.getChild("TagName"), "OpenTag CloseTag")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-_"
  }
}), $v = /* @__PURE__ */ sE.configure({
  wrap: /* @__PURE__ */ NC(nE, rE)
});
function aE(n = {}) {
  let t = "", e;
  n.matchClosingTags === !1 && (t = "noMatch"), n.selfClosingTags === !0 && (t = (t ? t + " " : "") + "selfClosing"), (n.nestedLanguages && n.nestedLanguages.length || n.nestedAttributes && n.nestedAttributes.length) && (e = NC((n.nestedLanguages || []).concat(nE), (n.nestedAttributes || []).concat(rE)));
  let i = e ? sE.configure({ wrap: e, dialect: t }) : t ? $v.configure({ dialect: t }) : $v;
  return new qm(i, [
    $v.data.of({ autocomplete: iE(n) }),
    n.autoCloseTags !== !1 ? _X : [],
    NR().support,
    RR().support
  ]);
}
c(aE, "Rm$1");
m(aE, "html");
const QQ = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), _X = /* @__PURE__ */ Ct.inputHandler.of((n, t, e, i, r) => {
  if (n.composing || n.state.readOnly || t != e || i != ">" && i != "/" || !$v.isActiveAt(n.state, t, -1))
    return !1;
  let s = r(), { state: a } = s, o = a.changeByRange((l) => {
    var d, u, p;
    let f = a.doc.sliceString(l.from - 1, l.to) == i, { head: y } = l, g = ae(a).resolveInner(y, -1), b;
    if (f && i == ">" && g.name == "EndTag") {
      let S = g.parent;
      if (((u = (d = S.parent) === null || d === void 0 ? void 0 : d.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (b = el(a.doc, S.parent, y)) && !QQ.has(b)) {
        let $ = y + (a.doc.sliceString(y, y + 1) === ">" ? 1 : 0), Q = `</${b}>`;
        return { range: l, changes: { from: y, to: $, insert: Q } };
      }
    } else if (f && i == "/" && g.name == "IncompleteCloseTag") {
      let S = g.parent;
      if (g.from == y - 2 && ((p = S.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (b = el(a.doc, S, y)) && !QQ.has(b)) {
        let $ = y + (a.doc.sliceString(y, y + 1) === ">" ? 1 : 0), Q = `${b}>`;
        return {
          range: it.cursor(y + Q.length, -1),
          changes: { from: y, to: $, insert: Q }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    s,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), oE = /* @__PURE__ */ t1({ commentTokens: { block: { open: "<!--", close: "-->" } } }), lE = /* @__PURE__ */ new Pt(), cE = /* @__PURE__ */ uF.configure({
  props: [
    /* @__PURE__ */ e1.add((n) => !n.is("Block") || n.is("Document") || PO(n) != null || hE(n) ? void 0 : (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })),
    /* @__PURE__ */ lE.add(PO),
    /* @__PURE__ */ py.add({
      Document: /* @__PURE__ */ m(() => null, "Document")
    }),
    /* @__PURE__ */ Ts.add({
      Document: oE
    })
  ]
});
function PO(n) {
  let t = /^(?:ATX|Setext)Heading(\d)$/.exec(n.name);
  return t ? +t[1] : void 0;
}
c(PO, "Na$1");
m(PO, "isHeading");
function hE(n) {
  return n.name == "OrderedList" || n.name == "BulletList";
}
c(hE, "Sb$1");
m(hE, "isList");
function dE(n, t) {
  let e = n;
  for (; ; ) {
    let i = e.nextSibling, r;
    if (!i || (r = PO(i.type)) != null && r <= t)
      break;
    e = i;
  }
  return e.to;
}
c(dE, "bb$1");
m(dE, "findSectionEnd");
const zX = /* @__PURE__ */ pq.of((n, t, e) => {
  for (let i = ae(n).resolveInner(e, -1); i && !(i.from < t); i = i.parent) {
    let r = i.type.prop(lE);
    if (r == null)
      continue;
    let s = dE(i, r);
    if (s > e)
      return { from: e, to: s };
  }
  return null;
});
function V0(n) {
  return new Yi(oE, n, [], "markdown");
}
c(V0, "_h$1");
m(V0, "mkLang");
const LX = /* @__PURE__ */ V0(cE), IX = /* @__PURE__ */ cE.configure([OF, $F, bF, xF, {
  props: [
    /* @__PURE__ */ e1.add({
      Table: /* @__PURE__ */ m((n, t) => ({ from: t.doc.lineAt(n.from).to, to: n.to }), "Table")
    })
  ]
}]), QO = /* @__PURE__ */ V0(IX);
function uE(n, t) {
  return (e) => {
    if (e && n) {
      let i = null;
      if (e = /\S*/.exec(e)[0], typeof n == "function" ? i = n(e) : i = tQ.matchLanguageName(n, e, !0), i instanceof tQ)
        return i.support ? i.support.language.parser : mO.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return t ? t.parser : null;
  };
}
c(uE, "Pb$1");
m(uE, "getCodeParser");
var mu;
const pE = (mu = class {
  constructor(t, e, i, r, s, a, o) {
    this.node = t, this.from = e, this.to = i, this.spaceBefore = r, this.spaceAfter = s, this.type = a, this.item = o;
  }
  blank(t, e = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (t != null) {
      for (; i.length < t; )
        i += " ";
      return i;
    } else {
      for (let r = this.to - this.from - i.length - this.spaceAfter.length; r > 0; r--)
        i += " ";
      return i + (e ? this.spaceAfter : "");
    }
  }
  marker(t, e) {
    let i = this.node.name == "OrderedList" ? String(+KC(this.item, t)[2] + e) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
}, c(mu, "Rc"), mu);
m(pE, "Context");
let l2 = pE;
function GC(n, t) {
  let e = [], i = [];
  for (let r = n; r; r = r.parent) {
    if (r.name == "FencedCode")
      return i;
    (r.name == "ListItem" || r.name == "Blockquote") && e.push(r);
  }
  for (let r = e.length - 1; r >= 0; r--) {
    let s = e[r], a, o = t.lineAt(s.from), l = s.from - o.from;
    if (s.name == "Blockquote" && (a = /^ *>( ?)/.exec(o.text.slice(l))))
      i.push(new l2(s, l, l + a[0].length, "", a[1], ">", null));
    else if (s.name == "ListItem" && s.parent.name == "OrderedList" && (a = /^( *)\d+([.)])( *)/.exec(o.text.slice(l)))) {
      let d = a[3], u = a[0].length;
      d.length >= 4 && (d = d.slice(0, d.length - 4), u -= 4), i.push(new l2(s.parent, l, l + u, a[1], d, a[2], s));
    } else if (s.name == "ListItem" && s.parent.name == "BulletList" && (a = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(o.text.slice(l)))) {
      let d = a[4], u = a[0].length;
      d.length > 4 && (d = d.slice(0, d.length - 4), u -= 4);
      let p = a[2];
      a[3] && (p += a[3].replace(/[xX]/, " ")), i.push(new l2(s.parent, l, l + u, a[1], d, p, s));
    }
  }
  return i;
}
c(GC, "Mm$1");
m(GC, "getContext");
function KC(n, t) {
  return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(n.from, n.from + 10));
}
c(KC, "Zm$1");
m(KC, "itemNumber");
function xv(n, t, e, i = 0) {
  for (let r = -1, s = n; ; ) {
    if (s.name == "ListItem") {
      let o = KC(s, t), l = +o[2];
      if (r >= 0) {
        if (l != r + 1)
          return;
        e.push({ from: s.from + o[1].length, to: s.from + o[0].length, insert: String(r + 2 + i) });
      }
      r = l;
    }
    let a = s.nextSibling;
    if (!a)
      break;
    s = a;
  }
}
c(xv, "el$1");
m(xv, "renumberList");
function D0(n, t) {
  let e = /^[ \t]*/.exec(n)[0].length;
  if (!e || t.facet(P0) != "	")
    return n;
  let i = ra(n, 4, e), r = "";
  for (let s = i; s > 0; )
    s >= 4 ? (r += "	", s -= 4) : (r += " ", s--);
  return r + n.slice(e);
}
c(D0, "Mh$1");
m(D0, "normalizeIndent");
const VX = /* @__PURE__ */ m((n = {}) => ({ state: t, dispatch: e }) => {
  let i = ae(t), { doc: r } = t, s = null, a = t.changeByRange((o) => {
    if (!o.empty || !QO.isActiveAt(t, o.from, -1) && !QO.isActiveAt(t, o.from, 1))
      return s = { range: o };
    let l = o.from, d = r.lineAt(l), u = GC(i.resolveInner(l, -1), r);
    for (; u.length && u[u.length - 1].from > l - d.from; )
      u.pop();
    if (!u.length)
      return s = { range: o };
    let p = u[u.length - 1];
    if (p.to - p.spaceAfter.length > l - d.from)
      return s = { range: o };
    let f = l >= p.to - p.spaceAfter.length && !/\S/.test(d.text.slice(p.to));
    if (p.item && f) {
      let $ = p.node.firstChild, Q = p.node.getChild("ListItem", "ListItem");
      if ($.to >= l || Q && Q.to < l || d.from > 0 && !/[^\s>]/.test(r.lineAt(d.from - 1).text) || n.nonTightLists === !1) {
        let E = u.length > 1 ? u[u.length - 2] : null, z, A = "";
        E && E.item ? (z = d.from + E.from, A = E.marker(r, 1)) : z = d.from + (E ? E.to : 0);
        let V = [{ from: z, to: l, insert: A }];
        return p.node.name == "OrderedList" && xv(p.item, r, V, -2), E && E.node.name == "OrderedList" && xv(E.item, r, V), { range: it.cursor(z + A.length), changes: V };
      } else {
        let E = k5(u, t, d);
        return {
          range: it.cursor(l + E.length + 1),
          changes: { from: d.from, insert: E + t.lineBreak }
        };
      }
    }
    if (p.node.name == "Blockquote" && f && d.from) {
      let $ = r.lineAt(d.from - 1), Q = />\s*$/.exec($.text);
      if (Q && Q.index == p.from) {
        let E = t.changes([
          { from: $.from + Q.index, to: $.to },
          { from: d.from + p.from, to: d.to }
        ]);
        return { range: o.map(E), changes: E };
      }
    }
    let y = [];
    p.node.name == "OrderedList" && xv(p.item, r, y);
    let g = p.item && p.item.from < d.from, b = "";
    if (!g || /^[\s\d.)\-+*>]*/.exec(d.text)[0].length >= p.to)
      for (let $ = 0, Q = u.length - 1; $ <= Q; $++)
        b += $ == Q && !g ? u[$].marker(r, 1) : u[$].blank($ < Q ? ra(d.text, 4, u[$ + 1].from) - b.length : null);
    let S = l;
    for (; S > d.from && /\s/.test(d.text.charAt(S - d.from - 1)); )
      S--;
    return b = D0(b, t), fE(p.node, t.doc) && (b = k5(u, t, d) + t.lineBreak + b), y.push({ from: S, to: l, insert: t.lineBreak + b }), { range: it.cursor(S + b.length + 1), changes: y };
  });
  return s ? !1 : (e(t.update(a, { scrollIntoView: !0, userEvent: "input" })), !0);
}, "insertNewlineContinueMarkupCommand"), DX = /* @__PURE__ */ VX();
function x5(n) {
  return n.name == "QuoteMark" || n.name == "ListMark";
}
c(x5, "PO");
m(x5, "isMark");
function fE(n, t) {
  if (n.name != "OrderedList" && n.name != "BulletList")
    return !1;
  let e = n.firstChild, i = n.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let r = t.lineAt(e.to), s = t.lineAt(i.from), a = /^[\s>]*$/.test(r.text);
  return r.number + (a ? 0 : 1) < s.number;
}
c(fE, "kb$1");
m(fE, "nonTightList");
function k5(n, t, e) {
  let i = "";
  for (let r = 0, s = n.length - 2; r <= s; r++)
    i += n[r].blank(r < s ? ra(e.text, 4, n[r + 1].from) - i.length : null, r < s);
  return D0(i, t);
}
c(k5, "kO");
m(k5, "blankLine");
function mE(n, t) {
  let e = n.resolveInner(t, -1), i = t;
  x5(e) && (i = e.from, e = e.parent);
  for (let r; r = e.childBefore(i); )
    if (x5(r))
      i = r.from;
    else if (r.name == "OrderedList" || r.name == "BulletList")
      e = r.lastChild, i = e.to;
    else
      break;
  return e;
}
c(mE, "$b$1");
m(mE, "contextNodeForDelete");
const WX = /* @__PURE__ */ m(({ state: n, dispatch: t }) => {
  let e = ae(n), i = null, r = n.changeByRange((s) => {
    let a = s.from, { doc: o } = n;
    if (s.empty && QO.isActiveAt(n, s.from)) {
      let l = o.lineAt(a), d = GC(mE(e, a), o);
      if (d.length) {
        let u = d[d.length - 1], p = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
        if (a - l.from > p && !/\S/.test(l.text.slice(p, a - l.from)))
          return {
            range: it.cursor(l.from + p),
            changes: { from: l.from + p, to: a }
          };
        if (a - l.from == p && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!u.item || l.from <= u.item.from || !/\S/.test(l.text.slice(0, u.to)))) {
          let f = l.from + u.from;
          if (u.item && u.node.from < u.item.from && /\S/.test(l.text.slice(u.from, u.to))) {
            let y = u.blank(ra(l.text, 4, u.to) - ra(l.text, 4, u.from));
            return f == l.from && (y = D0(y, n)), {
              range: it.cursor(f + y.length),
              changes: { from: f, to: l.from + u.to, insert: y }
            };
          }
          if (f < a)
            return { range: it.cursor(f), changes: { from: f, to: a } };
        }
      }
    }
    return i = { range: s };
  });
  return i ? !1 : (t(n.update(r, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, "deleteMarkupBackward"), qX = [
  { key: "Enter", run: DX },
  { key: "Backspace", run: WX }
], yE = /* @__PURE__ */ aE({ matchClosingTags: !1 });
function FX(n = {}) {
  let { codeLanguages: t, defaultCodeLanguage: e, addKeymap: i = !0, base: { parser: r } = LX, completeHTMLTags: s = !0, pasteURLAsLink: a = !0, htmlTagLanguage: o = yE } = n;
  if (!(r instanceof zA))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let l = n.extensions ? [n.extensions] : [], d = [o.support, zX], u;
  a && d.push(XX), e instanceof qm ? (d.push(e.support), u = e.language) : e && (u = e);
  let p = t || u ? uE(t, u) : void 0;
  l.push(BA({ codeParser: p, htmlParser: o.language.parser })), i && d.push(Cl.high($0.of(qX)));
  let f = V0(r.configure(l));
  return s && d.push(f.data.of({ autocomplete: gE })), new qm(f, d);
}
c(FX, "Wm$1");
m(FX, "markdown");
function gE(n) {
  let { state: t, pos: e } = n, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(e - 25, e));
  if (!i)
    return null;
  let r = ae(t).resolveInner(e, -1);
  for (; r && !r.type.isTop; ) {
    if (r.name == "CodeBlock" || r.name == "FencedCode" || r.name == "ProcessingInstructionBlock" || r.name == "CommentBlock" || r.name == "Link" || r.name == "Image")
      return null;
    r = r.parent;
  }
  return {
    from: e - i[0].length,
    to: e,
    options: wE(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
c(gE, "Rb$1");
m(gE, "htmlTagCompletion");
let c2 = null;
function wE() {
  if (c2)
    return c2;
  let n = eE(new OC(Le.create({ extensions: yE }), 0, !0));
  return c2 = n ? n.options : [];
}
c(wE, "vb$1");
m(wE, "htmlTagCompletions");
const ZX = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i, XX = /* @__PURE__ */ Ct.domEventHandlers({
  paste: /* @__PURE__ */ m((n, t) => {
    var e;
    let { main: i } = t.state.selection;
    if (i.empty)
      return !1;
    let r = (e = n.clipboardData) === null || e === void 0 ? void 0 : e.getData("text/plain");
    if (!r || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(r) || (/^www\./.test(r) && (r = "https://" + r), !QO.isActiveAt(t.state, i.from, 1)))
      return !1;
    let s = ae(t.state), a = !1;
    return s.iterate({
      from: i.from,
      to: i.to,
      enter: /* @__PURE__ */ m((o) => {
        (o.from > i.from || ZX.test(o.name)) && (a = !0);
      }, "enter"),
      leave: /* @__PURE__ */ m((o) => {
        o.to < i.to && (a = !0);
      }, "leave")
    }), a ? !1 : (t.dispatch({
      changes: [{ from: i.from, insert: "[" }, { from: i.to, insert: `](${r})` }],
      userEvent: "input.paste",
      scrollIntoView: !0
    }), !0);
  }, "paste")
});
function NX(n) {
  return new qm(vq.define(n));
}
c(NX, "w");
m(NX, "legacy");
function jX(n) {
  return import(
    /* webpackIgnore: true */
    /* @vite-ignore */
    new URL("./@codemirror/lang-sql/dist/index-CCDZYbZY.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
  ).then((t) => t.sql({ dialect: t[n] }));
}
c(jX, "pt$1");
m(jX, "sql");
function BX(n) {
  const t = new CustomEvent("wy-submit", { bubbles: !0 });
  return n.dom.dispatchEvent(t);
}
c(BX, "Im$1");
m(BX, "softSubmit");
const TQ = new XW({
  regexp: /(\[(.+?)\])(\(@u(\d+)\))/g,
  decoration: /* @__PURE__ */ m((n) => Jt.replace({
    // NOTE: can't use backspace to go "up one row" when inclusive is false
    inclusive: !0,
    widget: new UX(n)
  }), "decoration")
});
var yu;
const vE = (yu = class extends uy {
  constructor(t) {
    super(), this.match = t;
  }
  eq(t) {
    return t.match[1] === this.match[1];
  }
  toDOM() {
    we();
    const t = document.createElement("span");
    return t.className = "wy-mention", t.part = "wy-mention", t.innerHTML = "@" + (typeof this.match[5] < "u" ? this.match[5] : this.match[2]), t;
  }
  ignoreEvent() {
    return !1;
  }
}, c(yu, "vc"), yu);
m(vE, "MentionWidget");
let UX = vE;
Br.fromClass(
  class {
    constructor(n) {
      this.mentions = TQ.createDeco(n);
    }
    update(n) {
      this.mentions = TQ.updateDeco(n, this.mentions);
    }
  },
  {
    decorations: /* @__PURE__ */ m((n) => n.mentions, "decorations"),
    provide: /* @__PURE__ */ m((n) => Ct.atomicRanges.of((t) => t.plugin(n)?.mentions || Jt.none), "provide")
  }
);
function HX(n, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let r = n(t, e);
    return r ? (i(e.update(r)), !0) : !1;
  };
}
c(HX, "Zh");
m(HX, "command");
function JC(n, t) {
  let e = n.languageDataAt("commentTokens", t, 1);
  return e.length ? e[0] : {};
}
c(JC, "Ch$1");
m(JC, "getConfig");
const zy = 50;
function OE(n, { open: t, close: e }, i, r) {
  let s = n.sliceDoc(i - zy, i), a = n.sliceDoc(r, r + zy), o = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(a)[0].length, d = s.length - o;
  if (s.slice(d - t.length, d) == t && a.slice(l, l + e.length) == e)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: r + l, margin: l && 1 }
    };
  let u, p;
  r - i <= 2 * zy ? u = p = n.sliceDoc(i, r) : (u = n.sliceDoc(i, i + zy), p = n.sliceDoc(r - zy, r));
  let f = /^\s*/.exec(u)[0].length, y = /\s*$/.exec(p)[0].length, g = p.length - y - e.length;
  return u.slice(f, f + t.length) == t && p.slice(g, g + e.length) == e ? {
    open: {
      pos: i + f + t.length,
      margin: /\s/.test(u.charAt(f + t.length)) ? 1 : 0
    },
    close: {
      pos: r - y - e.length,
      margin: /\s/.test(p.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
c(OE, "Wb$1");
m(OE, "findBlockComment");
function YX(n) {
  let t = [];
  for (let e of n.selection.ranges) {
    let i = n.doc.lineAt(e.from), r = e.to <= i.to ? i : n.doc.lineAt(e.to);
    r.from > i.from && r.from == e.to && (r = e.to == i.to + 1 ? i : n.doc.lineAt(e.to - 1));
    let s = t.length - 1;
    s >= 0 && t[s].to > i.from ? t[s].to = r.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return t;
}
c(YX, "Ub$1");
m(YX, "selectedLineRanges");
function GX(n, t, e = t.selection.ranges) {
  let i = e.map((s) => JC(t, s.from).block);
  if (!i.every((s) => s))
    return null;
  let r = e.map((s, a) => OE(t, i[a], s.from, s.to));
  if (n != 2 && !r.every((s) => s))
    return { changes: t.changes(e.map((s, a) => r[a] ? [] : [{ from: s.from, insert: i[a].open + " " }, { from: s.to, insert: " " + i[a].close }])) };
  if (n != 1 && r.some((s) => s)) {
    let s = [];
    for (let a = 0, o; a < r.length; a++)
      if (o = r[a]) {
        let l = i[a], { open: d, close: u } = o;
        s.push({ from: d.pos - l.open.length, to: d.pos + d.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
c(GX, "zm$1");
m(GX, "changeBlockComment");
function KX(n, t, e = t.selection.ranges) {
  let i = [], r = -1;
  for (let { from: s, to: a } of e) {
    let o = i.length, l = 1e9, d = JC(t, s).line;
    if (d) {
      for (let u = s; u <= a; ) {
        let p = t.doc.lineAt(u);
        if (p.from > r && (s == a || a > p.from)) {
          r = p.from;
          let f = /^\s*/.exec(p.text)[0].length, y = f == p.length, g = p.text.slice(f, f + d.length) == d ? f : -1;
          f < p.text.length && f < l && (l = f), i.push({ line: p, comment: g, token: d, indent: f, empty: y, single: !1 });
        }
        u = p.to + 1;
      }
      if (l < 1e9)
        for (let u = o; u < i.length; u++)
          i[u].indent < i[u].line.text.length && (i[u].indent = l);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (n != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: o, token: l, indent: d, empty: u, single: p } of i)
      (p || !u) && s.push({ from: o.from + d, insert: l + " " });
    let a = t.changes(s);
    return { changes: a, selection: t.selection.map(a, 1) };
  } else if (n != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: a, comment: o, token: l } of i)
      if (o >= 0) {
        let d = a.from + o, u = d + l.length;
        a.text[u - a.from] == " " && u++, s.push({ from: d, to: u });
      }
    return { changes: s };
  }
  return null;
}
c(KX, "Ib$1");
m(KX, "changeLineComment");
const S5 = /* @__PURE__ */ as.define(), JX = /* @__PURE__ */ as.define(), tN = /* @__PURE__ */ $t.define(), bE = /* @__PURE__ */ $t.define({
  combine(n) {
    return kS(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: /* @__PURE__ */ m((t, e) => e, "joinToEvent")
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: /* @__PURE__ */ m((t, e) => (i, r) => t(i, r) || e(i, r), "joinToEvent")
    });
  }
}), $E = /* @__PURE__ */ ss.define({
  create() {
    return tw.empty;
  },
  update(n, t) {
    let e = t.state.facet(bE), i = t.annotation(S5);
    if (i) {
      let l = zr.fromTransaction(t, i.selection), d = i.side, u = d == 0 ? n.undone : n.done;
      return l ? u = $w(u, u.length, e.minDepth, l) : u = iP(u, t.startState.selection), new tw(d == 0 ? i.rest : u, d == 0 ? u : i.rest);
    }
    let r = t.annotation(JX);
    if ((r == "full" || r == "before") && (n = n.isolate()), t.annotation(Oi.addToHistory) === !1)
      return t.changes.empty ? n : n.addMapping(t.changes.desc);
    let s = zr.fromTransaction(t), a = t.annotation(Oi.time), o = t.annotation(Oi.userEvent);
    return s ? n = n.addChanges(s, a, o, e, t) : t.selection && (n = n.addSelection(t.startState.selection, a, o, e.newGroupDelay)), (r == "full" || r == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((t) => t.toJSON()), undone: n.undone.map((t) => t.toJSON()) };
  },
  fromJSON(n) {
    return new tw(n.done.map(zr.fromJSON), n.undone.map(zr.fromJSON));
  }
});
function eN(n = {}) {
  return [
    $E,
    bE.of(n),
    Ct.domEventHandlers({
      beforeinput(t, e) {
        let i = t.inputType == "historyUndo" ? iN : t.inputType == "historyRedo" ? nN : null;
        return i ? (t.preventDefault(), i(e)) : !1;
      }
    })
  ];
}
c(eN, "qb$1");
m(eN, "history");
function tP(n, t) {
  return function({ state: e, dispatch: i }) {
    if (!t && e.readOnly)
      return !1;
    let r = e.field($E, !1);
    if (!r)
      return !1;
    let s = r.pop(n, e, t);
    return s ? (i(s), !0) : !1;
  };
}
c(tP, "wo$1");
m(tP, "cmd");
const iN = /* @__PURE__ */ tP(0, !1), nN = /* @__PURE__ */ tP(1, !1);
var er;
const xE = (er = class {
  constructor(t, e, i, r, s) {
    this.changes = t, this.effects = e, this.mapped = i, this.startSelection = r, this.selectionsAfter = s;
  }
  setSelAfter(t) {
    return new er(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, e, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (e = this.mapped) === null || e === void 0 ? void 0 : e.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(t) {
    return new er(t.changes && Tn.fromJSON(t.changes), [], t.mapped && ah.fromJSON(t.mapped), t.startSelection && it.fromJSON(t.startSelection), t.selectionsAfter.map(it.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, e) {
    let i = ln;
    for (let r of t.startState.facet(tN)) {
      let s = r(t);
      s.length && (i = i.concat(s));
    }
    return !i.length && t.changes.empty ? null : new er(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, ln);
  }
  static selection(t) {
    return new er(void 0, ln, void 0, void 0, t);
  }
}, c(er, "Ft"), er);
m(xE, "HistEvent");
let zr = xE;
function $w(n, t, e, i) {
  let r = t + 1 > e + 20 ? t - e - 1 : 0, s = n.slice(r, t);
  return s.push(i), s;
}
c($w, "Vs$1");
m($w, "updateBranch");
function kE(n, t) {
  let e = [], i = !1;
  return n.iterChangedRanges((r, s) => e.push(r, s)), t.iterChangedRanges((r, s, a, o) => {
    for (let l = 0; l < e.length; ) {
      let d = e[l++], u = e[l++];
      o >= d && a <= u && (i = !0);
    }
  }), i;
}
c(kE, "Nb$1");
m(kE, "isAdjacent");
function SE(n, t) {
  return n.ranges.length == t.ranges.length && n.ranges.filter((e, i) => e.empty != t.ranges[i].empty).length === 0;
}
c(SE, "Gb$1");
m(SE, "eqSelectionShape");
function eP(n, t) {
  return n.length ? t.length ? n.concat(t) : n : t;
}
c(eP, "Bm$1");
m(eP, "conc");
const ln = [], rN = 200;
function iP(n, t) {
  if (n.length) {
    let e = n[n.length - 1], i = e.selectionsAfter.slice(Math.max(0, e.selectionsAfter.length - rN));
    return i.length && i[i.length - 1].eq(t) ? n : (i.push(t), $w(n, n.length - 1, 1e9, e.setSelAfter(i)));
  } else
    return [zr.selection([t])];
}
c(iP, "Nm$1");
m(iP, "addSelection");
function CE(n) {
  let t = n[n.length - 1], e = n.slice();
  return e[n.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), e;
}
c(CE, "Hb$1");
m(CE, "popSelection");
function kv(n, t) {
  if (!n.length)
    return n;
  let e = n.length, i = ln;
  for (; e; ) {
    let r = PE(n[e - 1], t, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let s = n.slice(0, e);
      return s[e - 1] = r, s;
    } else
      t = r.mapped, e--, i = r.selectionsAfter;
  }
  return i.length ? [zr.selection(i)] : ln;
}
c(kv, "il$1");
m(kv, "addMappingToBranch");
function PE(n, t, e) {
  let i = eP(n.selectionsAfter.length ? n.selectionsAfter.map((o) => o.map(t)) : ln, e);
  if (!n.changes)
    return zr.selection(i);
  let r = n.changes.map(t), s = t.mapDesc(n.changes, !0), a = n.mapped ? n.mapped.composeDesc(s) : s;
  return new zr(r, jt.mapEffects(n.effects, t), a, n.startSelection.map(s), i);
}
c(PE, "Kb$1");
m(PE, "mapEvent");
const sN = /^(input\.type|delete)($|\.)/;
var ir;
const QE = (ir = class {
  constructor(t, e, i = 0, r = void 0) {
    this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new ir(this.done, this.undone) : this;
  }
  addChanges(t, e, i, r, s) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && t.changes && (!i || sN.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < r.newGroupDelay && r.joinToEvent(s, kE(o.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = $w(a, a.length - 1, r.minDepth, new zr(t.changes.compose(o.changes), eP(jt.mapEffects(t.effects, o.changes), o.effects), o.mapped, o.startSelection, ln)) : a = $w(a, a.length, r.minDepth, t), new ir(a, ln, e, i);
  }
  addSelection(t, e, i, r) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ln;
    return s.length > 0 && e - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && SE(s[s.length - 1], t) ? this : new ir(iP(this.done, t), this.undone, e, i);
  }
  addMapping(t) {
    return new ir(kv(this.done, t), kv(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, e, i) {
    let r = t == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let s = r[r.length - 1], a = s.selectionsAfter[0] || e.selection;
    if (i && s.selectionsAfter.length)
      return e.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: S5.of({ side: t, rest: CE(r), selection: a }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let o = r.length == 1 ? ln : r.slice(0, r.length - 1);
      return s.mapped && (o = kv(o, s.mapped)), e.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: S5.of({ side: t, rest: o, selection: a }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}, c(ir, "Ht"), ir);
m(QE, "HistoryState");
let tw = QE;
tw.empty = /* @__PURE__ */ new tw(ln, ln);
function n1(n, t) {
  return it.create(n.ranges.map(t), n.mainIndex);
}
c(n1, "tr$1");
m(n1, "updateSel");
function fy(n, t) {
  return n.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
c(fy, "qe$2");
m(fy, "setSel");
function W0({ state: n, dispatch: t }, e) {
  let i = n1(n.selection, e);
  return i.eq(n.selection, !0) ? !1 : (t(fy(n, i)), !0);
}
c(W0, "De$2");
m(W0, "moveSel");
function r1(n, t) {
  return it.cursor(t ? n.to : n.from);
}
c(r1, "xo$1");
m(r1, "rangeEnd");
function aN(n, t) {
  return W0(n, (e) => e.empty ? n.moveByChar(e, t) : r1(e, t));
}
c(aN, "Gm$1");
m(aN, "cursorByChar");
function oN(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Pe.LTR;
}
c(oN, "he$1");
m(oN, "ltrAtCursor");
function lN(n, t) {
  return W0(n, (e) => e.empty ? n.moveByGroup(e, t) : r1(e, t));
}
c(lN, "Km$1");
m(lN, "cursorByGroup");
function TE(n, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(t.from, t.to))) || t.firstChild;
}
c(TE, "rw$1");
m(TE, "interestingNode");
function cN(n, t, e) {
  let i = ae(n).resolveInner(t.head), r = e ? Pt.closedBy : Pt.openedBy;
  for (let l = t.head; ; ) {
    let d = e ? i.childAfter(l) : i.childBefore(l);
    if (!d)
      break;
    TE(n, d, r) ? i = d : l = e ? d.to : d.from;
  }
  let s = i.type.prop(r), a, o;
  return s && (a = e ? io(n, i.from, 1) : io(n, i.to, -1)) && a.matched ? o = e ? a.end.to : a.end.from : o = e ? i.to : i.from, it.cursor(o, e ? -1 : 1);
}
c(cN, "Po$1");
m(cN, "moveBySyntax");
function hN(n, t) {
  return W0(n, (e) => {
    if (!e.empty)
      return r1(e, t);
    let i = n.moveVertically(e, t);
    return i.head != e.head ? i : n.moveToLineBoundary(e, t);
  });
}
c(hN, "Jm$1");
m(hN, "cursorByLine");
function nP(n) {
  let t = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, e = 0, i = 0, r;
  if (t) {
    for (let s of n.state.facet(Ct.scrollMargins)) {
      let a = s(n);
      a?.top && (e = Math.max(a?.top, e)), a?.bottom && (i = Math.max(a?.bottom, i));
    }
    r = n.scrollDOM.clientHeight - e - i;
  } else
    r = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: e,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(n.defaultLineHeight, r - 5)
  };
}
c(nP, "ig$1");
m(nP, "pageInfo");
function dN(n, t) {
  let e = nP(n), { state: i } = n, r = n1(i.selection, (a) => a.empty ? n.moveVertically(a, t, e.height) : r1(a, t));
  if (r.eq(i.selection))
    return !1;
  let s;
  if (e.selfScroll) {
    let a = n.coordsAtPos(i.selection.main.head), o = n.scrollDOM.getBoundingClientRect(), l = o.top + e.marginTop, d = o.bottom - e.marginBottom;
    a && a.top > l && a.bottom < d && (s = Ct.scrollIntoView(r.main.head, { y: "start", yMargin: a.top - l }));
  }
  return n.dispatch(fy(i, r), { effects: s }), !0;
}
c(dN, "rg$1");
m(dN, "cursorByPage");
function uN(n, t, e) {
  let i = n.lineBlockAt(t.head), r = n.moveToLineBoundary(t, e);
  if (r.head == t.head && r.head != (e ? i.to : i.from) && (r = n.moveToLineBoundary(t, e, !1)), !e && r.head == i.from && i.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && t.head != i.from + s && (r = it.cursor(i.from + s));
  }
  return r;
}
c(uN, "Zt$2");
m(uN, "moveByLineBoundary");
function pN(n, t, e) {
  let i = !1, r = n1(n.selection, (s) => {
    let a = io(n, s.head, -1) || io(n, s.head, 1) || s.head > 0 && io(n, s.head - 1, 1) || s.head < n.doc.length && io(n, s.head + 1, -1);
    if (!a || !a.end)
      return s;
    i = !0;
    let o = a.start.from == s.head ? a.end.to : a.end.from;
    return it.cursor(o);
  });
  return i ? (t(fy(n, r)), !0) : !1;
}
c(pN, "uw$1");
m(pN, "toMatchingBracket");
function s1(n, t) {
  let e = n1(n.state.selection, (i) => {
    let r = t(i);
    return it.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return e.eq(n.state.selection) ? !1 : (n.dispatch(fy(n.state, e)), !0);
}
c(s1, "Ye$1");
m(s1, "extendSel");
function fN(n, t) {
  return s1(n, (e) => n.moveByChar(e, t));
}
c(fN, "ng$1");
m(fN, "selectByChar");
function mN(n, t) {
  return s1(n, (e) => n.moveByGroup(e, t));
}
c(mN, "lg$1");
m(mN, "selectByGroup");
function yN(n, t) {
  return s1(n, (e) => n.moveVertically(e, t));
}
c(yN, "ag$1");
m(yN, "selectByLine");
function gN(n, t) {
  return s1(n, (e) => n.moveVertically(e, t, nP(n).height));
}
c(gN, "cg$1");
m(gN, "selectByPage");
function wN(n, t) {
  let { state: e } = n, i = e.selection, r = e.selection.ranges.slice();
  for (let s of e.selection.ranges) {
    let a = e.doc.lineAt(s.head);
    if (t ? a.to < n.state.doc.length : a.from > 0)
      for (let o = s; ; ) {
        let l = n.moveVertically(o, t);
        if (l.head < a.from || l.head > a.to) {
          r.some((d) => d.head == l.head) || r.push(l);
          break;
        } else {
          if (l.head == o.head)
            break;
          o = l;
        }
      }
  }
  return r.length == i.ranges.length ? !1 : (n.dispatch(fy(e, it.create(r, r.length - 1))), !0);
}
c(wN, "ug$1");
m(wN, "addCursorVertically");
function vN(n, t) {
  if (n.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = n, r = i.changeByRange((s) => {
    let { from: a, to: o } = s;
    if (a == o) {
      let l = t(s);
      l < a ? (e = "delete.backward", l = fg(n, l, !1)) : l > a && (e = "delete.forward", l = fg(n, l, !0)), a = Math.min(a, l), o = Math.max(o, l);
    } else
      a = fg(n, a, !1), o = fg(n, o, !0);
    return a == o ? { range: s } : { changes: { from: a, to: o }, range: it.cursor(a, a < s.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (n.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? Ct.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
c(vN, "kn$1");
m(vN, "deleteBy");
function fg(n, t, e) {
  if (n instanceof Ct)
    for (let i of n.state.facet(Ct.atomicRanges).map((r) => r(n)))
      i.between(t, t, (r, s) => {
        r < t && s > t && (t = e ? s : r);
      });
  return t;
}
c(fg, "Nn$1");
m(fg, "skipAtomic");
function rP(n) {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let r = n.doc.lineAt(i.from), s = n.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = n.doc.lineAt(i.to - 1)), e >= r.number) {
      let a = t[t.length - 1];
      a.to = s.to, a.ranges.push(i);
    } else
      t.push({ from: r.from, to: s.to, ranges: [i] });
    e = s.number + 1;
  }
  return t;
}
c(rP, "ko$1");
m(rP, "selectedLineBlocks");
function ON(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [], r = [];
  for (let s of rP(n)) {
    if (e ? s.to == n.doc.length : s.from == 0)
      continue;
    let a = n.doc.lineAt(e ? s.to + 1 : s.from - 1), o = a.length + 1;
    if (e) {
      i.push({ from: s.to, to: a.to }, { from: s.from, insert: a.text + n.lineBreak });
      for (let l of s.ranges)
        r.push(it.range(Math.min(n.doc.length, l.anchor + o), Math.min(n.doc.length, l.head + o)));
    } else {
      i.push({ from: a.from, to: s.from }, { from: s.to, insert: n.lineBreak + a.text });
      for (let l of s.ranges)
        r.push(it.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (t(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: it.create(r, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
c(ON, "gg$1");
m(ON, "moveLine");
function bN(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let s of rP(n))
    e ? i.push({ from: s.from, insert: n.doc.slice(s.from, s.to) + n.lineBreak }) : i.push({ from: s.to, insert: n.lineBreak + n.doc.slice(s.from, s.to) });
  let r = n.changes(i);
  return t(n.update({
    changes: r,
    selection: n.selection.map(r, e ? 1 : -1),
    scrollIntoView: !0,
    userEvent: "input.copyline"
  })), !0;
}
c(bN, "Qg$1");
m(bN, "copyLine");
function ME(n, t) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = ae(n).resolveInner(t), i = e.childBefore(t), r = e.childAfter(t), s;
  return i && r && i.to <= t && r.from >= t && (s = i.type.prop(Pt.closedBy)) && s.indexOf(r.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(r.from).from && !/\S/.test(n.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
c(ME, "Uw");
m(ME, "isBetweenBrackets");
function $N(n) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((r) => {
      let { from: s, to: a } = r, o = t.doc.lineAt(s), l = !n && s == a && ME(t, s);
      n && (s = a = (a <= o.to ? o : t.doc.lineAt(a)).to);
      let d = new uC(t, { simulateBreak: s, simulateDoubleBreak: !!l }), u = bM(d, s);
      for (u == null && (u = ra(/^\s*/.exec(t.doc.lineAt(s).text)[0], t.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      l ? { from: s, to: a } = l : s > o.from && s < o.from + 100 && !/\S/.test(o.text.slice(0, s)) && (s = o.from);
      let p = ["", Uk(t, u)];
      return l && p.push(Uk(t, d.lineIndent(o.from, -1))), {
        changes: { from: s, to: a, insert: Dt.of(p) },
        range: it.cursor(s + 1 + p[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
c($N, "yg$1");
m($N, "newlineAndIndent");
function xN(n, t) {
  let e = -1;
  return n.changeByRange((i) => {
    let r = [];
    for (let a = i.from; a <= i.to; ) {
      let o = n.doc.lineAt(a);
      o.number > e && (i.empty || i.to > o.from) && (t(o, r, i), e = o.number), a = o.to + 1;
    }
    let s = n.changes(r);
    return {
      changes: r,
      range: it.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
c(xN, "Xh");
m(xN, "changeBySelectedLine");
RM.define([
  { tag: T.meta, class: "code" },
  { tag: T.link, class: "wy-link" },
  { tag: T.heading, textDecoration: "underline", fontWeight: "bold" },
  { tag: T.emphasis, fontStyle: "italic" },
  { tag: T.strong, fontWeight: "bold" },
  { tag: T.strikethrough, textDecoration: "line-through" },
  { tag: T.keyword, class: "code token keyword" },
  { tag: [T.atom, T.bool], class: "code token builtin" },
  { tag: [T.url, T.contentSeparator, T.labelName], class: "code token prolog" },
  { tag: T.literal, class: "code token char" },
  { tag: T.inserted, class: "code token inserted" },
  { tag: T.deleted, class: "code token deleted" },
  { tag: T.string, class: "code token string" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "code token regex" },
  { tag: T.definition(T.variableName), class: "code token constant" },
  { tag: T.local(T.variableName), class: "code token variable" },
  { tag: [T.typeName, T.namespace], class: "code token keyword" },
  { tag: T.className, class: "code token class-name" },
  { tag: [T.special(T.variableName), T.macroName], class: "code token function" },
  { tag: T.propertyName, class: "code token property" },
  { tag: T.comment, class: "code token comment" },
  { tag: T.invalid, color: "#f00", class: "code token" }
]);
function kN(n) {
  sP(n, "start");
  var t = {}, e = n.languageData || {}, i = !1;
  for (var r in n) if (r != e && n.hasOwnProperty(r))
    for (var s = t[r] = [], a = n[r], o = 0; o < a.length; o++) {
      var l = a[o];
      s.push(new EE(l, n)), (l.indent || l.dedent) && (i = !0);
    }
  return {
    name: e.name,
    startState: /* @__PURE__ */ m(function() {
      return { state: "start", pending: null, indent: i ? [] : null };
    }, "startState"),
    copyState: /* @__PURE__ */ m(function(d) {
      var u = { state: d.state, pending: d.pending, indent: d.indent && d.indent.slice(0) };
      return d.stack && (u.stack = d.stack.slice(0)), u;
    }, "copyState"),
    token: _E(t),
    indent: zE(t, e),
    mergeTokens: e.mergeTokens,
    languageData: e
  };
}
c(kN, "dx$1");
m(kN, "simpleMode");
function sP(n, t) {
  if (!n.hasOwnProperty(t))
    throw new Error("Undefined state " + t + " in simple mode");
}
c(sP, "Sg$1");
m(sP, "ensureState");
function AE(n, t) {
  if (!n) return /(?:)/;
  var e = "";
  return n instanceof RegExp ? (n.ignoreCase && (e = "i"), n.unicode && (e += "u"), n = n.source) : n = String(n), new RegExp("^(?:" + n + ")", e);
}
c(AE, "Hw$1");
m(AE, "toRegex");
function RE(n) {
  if (!n) return null;
  if (n.apply) return n;
  if (typeof n == "string") return n.replace(/\./g, " ");
  for (var t = [], e = 0; e < n.length; e++)
    t.push(n[e] && n[e].replace(/\./g, " "));
  return t;
}
c(RE, "Kw$1");
m(RE, "asToken");
function EE(n, t) {
  (n.next || n.push) && sP(t, n.next || n.push), this.regex = AE(n.regex), this.token = RE(n.token), this.data = n;
}
c(EE, "Jw$1");
m(EE, "Rule");
function _E(n) {
  return function(t, e) {
    if (e.pending) {
      var i = e.pending.shift();
      return e.pending.length == 0 && (e.pending = null), t.pos += i.text.length, i.token;
    }
    for (var r = n[e.state], s = 0; s < r.length; s++) {
      var a = r[s], o = (!a.data.sol || t.sol()) && t.match(a.regex);
      if (o) {
        a.data.next ? e.state = a.data.next : a.data.push ? ((e.stack || (e.stack = [])).push(e.state), e.state = a.data.push) : a.data.pop && e.stack && e.stack.length && (e.state = e.stack.pop()), a.data.indent && e.indent.push(t.indentation() + t.indentUnit), a.data.dedent && e.indent.pop();
        var l = a.token;
        if (l && l.apply && (l = l(o)), o.length > 2 && a.token && typeof a.token != "string") {
          e.pending = [];
          for (var d = 2; d < o.length; d++)
            o[d] && e.pending.push({ text: o[d], token: a.token[d - 1] });
          return t.backUp(o[0].length - (o[1] ? o[1].length : 0)), l[0];
        } else return l && l.join ? l[0] : l;
      }
    }
    return t.next(), null;
  };
}
c(_E, "ex$1");
m(_E, "tokenFunction");
function zE(n, t) {
  return function(e, i) {
    if (e.indent == null || t.dontIndentStates && t.dontIndentStates.indexOf(e.state) > -1)
      return null;
    var r = e.indent.length - 1, s = n[e.state];
    t: for (; ; ) {
      for (var a = 0; a < s.length; a++) {
        var o = s[a];
        if (o.data.dedent && o.data.dedentIfLineStart !== !1) {
          var l = o.regex.exec(i);
          if (l && l[0]) {
            r--, (o.next || o.push) && (s = n[o.next || o.push]), i = i.slice(l[0].length);
            continue t;
          }
        }
      }
      break;
    }
    return r < 0 ? 0 : e.indent[r];
  };
}
c(zE, "tx$1");
m(zE, "indentFunction");
var SN = Object.defineProperty, dt = /* @__PURE__ */ c((n, t) => SN(n, "name", { value: t, configurable: !0 }), "o$1");
const C5 = "lit-localize-status", CN = /* @__PURE__ */ dt((n, ...t) => ({
  strTag: !0,
  strings: n,
  values: t
}), "_str"), rt = CN, PN = /* @__PURE__ */ dt((n) => typeof n != "string" && "strTag" in n, "isStrTagged"), LE = /* @__PURE__ */ dt((n, t, e) => {
  let i = n[0];
  for (let r = 1; r < n.length; r++)
    i += t[e ? e[r - 1] : r - 1], i += n[r];
  return i;
}, "joinStringsAndValues"), IE = /* @__PURE__ */ dt(((n) => PN(n) ? LE(n.strings, n.values) : n), "defaultMsg");
let P = IE, MQ = !1;
function VE(n) {
  if (MQ)
    throw new Error("lit-localize can only be configured once");
  P = n, MQ = !0;
}
c(VE, "xt$1");
dt(VE, "_installMsgImplementation");
var gu;
const DE = (gu = class {
  constructor(t) {
    this.__litLocalizeEventHandler = (e) => {
      e.detail.status === "ready" && this.host.requestUpdate();
    }, this.host = t;
  }
  hostConnected() {
    window.addEventListener(C5, this.__litLocalizeEventHandler);
  }
  hostDisconnected() {
    window.removeEventListener(C5, this.__litLocalizeEventHandler);
  }
}, c(gu, "Be"), gu);
dt(DE, "LocalizeController");
let QN = DE;
const TN = /* @__PURE__ */ dt((n) => n.addController(new QN(n)), "_updateWhenLocaleChanges"), MN = TN, kt = /* @__PURE__ */ dt(() => (n, t) => (n.addInitializer(MN), n), "localized");
var wu;
const WE = (wu = class {
  constructor() {
    this.settled = !1, this.promise = new Promise((t, e) => {
      this._resolve = t, this._reject = e;
    });
  }
  resolve(t) {
    this.settled = !0, this._resolve(t);
  }
  reject(t) {
    this.settled = !0, this._reject(t);
  }
}, c(wu, "Ve"), wu);
dt(WE, "Deferred");
let qE = WE;
const Qr = [];
for (let n = 0; n < 256; n++)
  Qr[n] = (n >> 4 & 15).toString(16) + (n & 15).toString(16);
function FE(n) {
  let t = 0, e = 8997, i = 0, r = 33826, s = 0, a = 40164, o = 0, l = 52210;
  for (let d = 0; d < n.length; d++)
    e ^= n.charCodeAt(d), t = e * 435, i = r * 435, s = a * 435, o = l * 435, s += e << 8, o += r << 8, i += t >>> 16, e = t & 65535, s += i >>> 16, r = i & 65535, l = o + (s >>> 16) & 65535, a = s & 65535;
  return Qr[l >> 8] + Qr[l & 255] + Qr[a >> 8] + Qr[a & 255] + Qr[r >> 8] + Qr[r & 255] + Qr[e >> 8] + Qr[e & 255];
}
c(FE, "Ut$1");
dt(FE, "fnv1a64");
const AN = "", RN = "h", EN = "s";
function ZE(n, t) {
  return (t ? RN : EN) + FE(typeof n == "string" ? n : n.join(AN));
}
c(ZE, "jt$1");
dt(ZE, "generateMsgId");
const AQ = /* @__PURE__ */ new WeakMap(), RQ = /* @__PURE__ */ new Map();
function XE(n, t, e) {
  if (n) {
    const i = e?.id ?? NE(t), r = n[i];
    if (r) {
      if (typeof r == "string")
        return r;
      if ("strTag" in r)
        return LE(
          r.strings,
          // Cast `template` because its type wasn't automatically narrowed (but
          // we know it must be the same type as `localized`).
          t.values,
          r.values
        );
      {
        let s = AQ.get(r);
        return s === void 0 && (s = r.values, AQ.set(r, s)), {
          ...r,
          values: s.map((a) => t.values[a])
        };
      }
    }
  }
  return IE(t);
}
c(XE, "Wt$1");
dt(XE, "runtimeMsg");
function NE(n) {
  const t = typeof n == "string" ? n : n.strings;
  let e = RQ.get(t);
  return e === void 0 && (e = ZE(t, typeof n != "string" && !("strTag" in n)), RQ.set(t, e)), e;
}
c(NE, "Bt$1");
dt(NE, "generateId");
function Sv(n) {
  window.dispatchEvent(new CustomEvent(C5, { detail: n }));
}
c(Sv, "ve$1");
dt(Sv, "dispatchStatusEvent");
let TO = "", h2, jE, MO, P5, BE, Ya = new qE();
Ya.resolve();
let N1 = 0;
const _N = /* @__PURE__ */ dt((n) => (VE(((t, e) => XE(BE, t, e))), TO = jE = n.sourceLocale, MO = new Set(n.targetLocales), MO.add(n.sourceLocale), P5 = n.loadLocale, { getLocale: zN, setLocale: LN }), "configureLocalization"), zN = /* @__PURE__ */ dt(() => TO, "getLocale"), LN = /* @__PURE__ */ dt((n) => {
  if (n === (h2 ?? TO))
    return Ya.promise;
  if (!MO || !P5)
    throw new Error("Internal error");
  if (!MO.has(n))
    throw new Error("Invalid locale code");
  N1++;
  const t = N1;
  return h2 = n, Ya.settled && (Ya = new qE()), Sv({ status: "loading", loadingLocale: n }), (n === jE ? (
    // We could switch to the source locale synchronously, but we prefer to
    // queue it on a microtask so that switching locales is consistently
    // asynchronous.
    Promise.resolve({ templates: void 0 })
  ) : P5(n)).then((e) => {
    N1 === t && (TO = n, h2 = void 0, BE = e.templates, Sv({ status: "ready", readyLocale: n }), Ya.resolve());
  }, (e) => {
    N1 === t && (Sv({
      status: "error",
      errorLocale: n,
      errorMessage: e.toString()
    }), Ya.reject(e));
  }), Ya.promise;
}, "setLocale");
var d2, vu;
const IN = (d2 = (vu = class {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(t) {
    this.ariaAtomic = "", this.ariaAutoComplete = "", this.ariaBrailleLabel = "", this.ariaBrailleRoleDescription = "", this.ariaBusy = "", this.ariaChecked = "", this.ariaColCount = "", this.ariaColIndex = "", this.ariaColSpan = "", this.ariaCurrent = "", this.ariaDescription = "", this.ariaDisabled = "", this.ariaExpanded = "", this.ariaHasPopup = "", this.ariaHidden = "", this.ariaInvalid = "", this.ariaKeyShortcuts = "", this.ariaLabel = "", this.ariaLevel = "", this.ariaLive = "", this.ariaModal = "", this.ariaMultiLine = "", this.ariaMultiSelectable = "", this.ariaOrientation = "", this.ariaPlaceholder = "", this.ariaPosInSet = "", this.ariaPressed = "", this.ariaReadOnly = "", this.ariaRequired = "", this.ariaRoleDescription = "", this.ariaRowCount = "", this.ariaRowIndex = "", this.ariaRowSpan = "", this.ariaSelected = "", this.ariaSetSize = "", this.ariaSort = "", this.ariaValueMax = "", this.ariaValueMin = "", this.ariaValueNow = "", this.ariaValueText = "", this.role = "", this.form = null, this.labels = [], this.states = /* @__PURE__ */ new Set(), this.validationMessage = "", this.validity = {}, this.willValidate = !0, this.__host = t;
  }
  checkValidity() {
    return console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true."), !0;
  }
  reportValidity() {
    return !0;
  }
  setFormValue() {
  }
  setValidity() {
  }
}, c(vu, "O$1"), vu), dt(d2, "ElementInternals"), d2);
var Xn = /* @__PURE__ */ c(function(n, t, e, i, r) {
  if (typeof t == "function" ? n !== t || !0 : !t.has(n)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(n, e), e;
}, "E"), Ye = /* @__PURE__ */ c(function(n, t, e, i) {
  if (typeof t == "function" ? n !== t || !i : !t.has(n)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(n) : i ? i.value : t.get(n);
}, "_"), Cc, j1, B1, Ly, u2, Iy, U1, La, Vy, ds, H1, EQ;
const _Q = /* @__PURE__ */ dt((n) => typeof n == "boolean" ? n : n?.capture ?? !1, "isCaptureEventListener"), AO = 0, Q5 = 1, RO = 2, T5 = 3;
var Ou;
const UE = (Ou = class {
  constructor() {
    this.__eventListeners = /* @__PURE__ */ new Map(), this.__captureEventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(t, e, i) {
    if (e == null)
      return;
    const r = _Q(i) ? this.__captureEventListeners : this.__eventListeners;
    let s = r.get(t);
    if (s === void 0)
      s = /* @__PURE__ */ new Map(), r.set(t, s);
    else if (s.has(e))
      return;
    const a = typeof i == "object" && i ? i : {};
    a.signal?.addEventListener("abort", () => this.removeEventListener(t, e, i)), s.set(e, a ?? {});
  }
  removeEventListener(t, e, i) {
    if (e == null)
      return;
    const r = _Q(i) ? this.__captureEventListeners : this.__eventListeners, s = r.get(t);
    s !== void 0 && (s.delete(e), s.size || r.delete(t));
  }
  dispatchEvent(t) {
    const e = [this];
    let i = this.__eventTargetParent;
    if (t.composed)
      for (; i; )
        e.push(i), i = i.__eventTargetParent;
    else
      for (; i && i !== this.__host; )
        e.push(i), i = i.__eventTargetParent;
    let r = !1, s = !1, a = AO, o = null, l = null, d = null;
    const u = t.stopPropagation, p = t.stopImmediatePropagation;
    Object.defineProperties(t, {
      target: {
        get() {
          return o ?? l;
        },
        ...Xt
      },
      srcElement: {
        get() {
          return t.target;
        },
        ...Xt
      },
      currentTarget: {
        get() {
          return d;
        },
        ...Xt
      },
      eventPhase: {
        get() {
          return a;
        },
        ...Xt
      },
      composedPath: {
        value: /* @__PURE__ */ dt(() => e, "value"),
        ...Xt
      },
      stopPropagation: {
        value: /* @__PURE__ */ dt(() => {
          r = !0, u.call(t);
        }, "value"),
        ...Xt
      },
      stopImmediatePropagation: {
        value: /* @__PURE__ */ dt(() => {
          s = !0, p.call(t);
        }, "value"),
        ...Xt
      }
    });
    const f = /* @__PURE__ */ dt(($, Q, E) => {
      typeof $ == "function" ? $(t) : typeof $?.handleEvent == "function" && $.handleEvent(t), Q.once && E.delete($);
    }, "invokeEventListener"), y = /* @__PURE__ */ dt(() => (d = null, a = AO, !t.defaultPrevented), "finishDispatch"), g = e.slice().reverse();
    o = !this.__host || !t.composed ? this : null;
    const b = /* @__PURE__ */ dt(($) => {
      for (l = this; l.__host && $.includes(l.__host); )
        l = l.__host;
    }, "retarget");
    for (const $ of g) {
      !o && (!l || l === $.__host) && b(g.slice(g.indexOf($))), d = $, a = $ === t.target ? RO : Q5;
      const Q = $.__captureEventListeners.get(t.type);
      if (Q) {
        for (const [E, z] of Q)
          if (f(E, z, Q), s)
            return y();
      }
      if (r)
        return y();
    }
    const S = t.bubbles ? e : [this];
    l = null;
    for (const $ of S) {
      !o && (!l || $ === l.__host) && b(S.slice(0, S.indexOf($) + 1)), d = $, a = $ === t.target ? RO : T5;
      const Q = $.__eventListeners.get(t.type);
      if (Q) {
        for (const [E, z] of Q)
          if (f(E, z, Q), s)
            return y();
      }
      if (r)
        return y();
    }
    return y();
  }
}, c(Ou, "ze"), Ou);
dt(UE, "EventTarget");
let VN = UE;
const DN = VN, Xt = { __proto__: null };
Xt.enumerable = !0;
Object.freeze(Xt);
var p2, bu;
const aP = (ds = (p2 = (bu = class {
  constructor(t, e = {}) {
    if (Cc.set(this, !1), j1.set(this, !1), B1.set(this, !1), Ly.set(this, !1), u2.set(this, Date.now()), Iy.set(this, !1), U1.set(this, void 0), La.set(this, void 0), Vy.set(this, void 0), this.NONE = AO, this.CAPTURING_PHASE = Q5, this.AT_TARGET = RO, this.BUBBLING_PHASE = T5, arguments.length === 0)
      throw new Error("The type argument must be specified");
    if (typeof e != "object" || !e)
      throw new Error('The "options" argument must be an object');
    const { bubbles: i, cancelable: r, composed: s } = e;
    Xn(this, Cc, !!r), Xn(this, j1, !!i), Xn(this, B1, !!s), Xn(this, U1, `${t}`), Xn(this, La, null), Xn(this, Vy, !1);
  }
  initEvent(t, e, i) {
    throw new Error("Method not implemented.");
  }
  stopImmediatePropagation() {
    this.stopPropagation();
  }
  preventDefault() {
    Xn(this, Ly, !0);
  }
  get target() {
    return Ye(this, La, "f");
  }
  get currentTarget() {
    return Ye(this, La, "f");
  }
  get srcElement() {
    return Ye(this, La, "f");
  }
  get type() {
    return Ye(this, U1, "f");
  }
  get cancelable() {
    return Ye(this, Cc, "f");
  }
  get defaultPrevented() {
    return Ye(this, Cc, "f") && Ye(this, Ly, "f");
  }
  get timeStamp() {
    return Ye(this, u2, "f");
  }
  composedPath() {
    return Ye(this, Vy, "f") ? [Ye(this, La, "f")] : [];
  }
  get returnValue() {
    return !Ye(this, Cc, "f") || !Ye(this, Ly, "f");
  }
  get bubbles() {
    return Ye(this, j1, "f");
  }
  get composed() {
    return Ye(this, B1, "f");
  }
  get eventPhase() {
    return Ye(this, Vy, "f") ? ds.AT_TARGET : ds.NONE;
  }
  get cancelBubble() {
    return Ye(this, Iy, "f");
  }
  set cancelBubble(t) {
    t && Xn(this, Iy, !0);
  }
  stopPropagation() {
    Xn(this, Iy, !0);
  }
  get isTrusted() {
    return !1;
  }
}, c(bu, "U$1"), bu), dt(p2, "Event"), p2), Cc = /* @__PURE__ */ new WeakMap(), j1 = /* @__PURE__ */ new WeakMap(), B1 = /* @__PURE__ */ new WeakMap(), Ly = /* @__PURE__ */ new WeakMap(), u2 = /* @__PURE__ */ new WeakMap(), Iy = /* @__PURE__ */ new WeakMap(), U1 = /* @__PURE__ */ new WeakMap(), La = /* @__PURE__ */ new WeakMap(), Vy = /* @__PURE__ */ new WeakMap(), ds.NONE = AO, ds.CAPTURING_PHASE = Q5, ds.AT_TARGET = RO, ds.BUBBLING_PHASE = T5, ds);
Object.defineProperties(aP.prototype, {
  initEvent: Xt,
  stopImmediatePropagation: Xt,
  preventDefault: Xt,
  target: Xt,
  currentTarget: Xt,
  srcElement: Xt,
  type: Xt,
  cancelable: Xt,
  defaultPrevented: Xt,
  timeStamp: Xt,
  composedPath: Xt,
  returnValue: Xt,
  bubbles: Xt,
  composed: Xt,
  eventPhase: Xt,
  cancelBubble: Xt,
  stopPropagation: Xt,
  isTrusted: Xt
});
var f2, $u;
const HE = (EQ = (f2 = ($u = class extends aP {
  constructor(t, e = {}) {
    super(t, e), H1.set(this, void 0), Xn(this, H1, e?.detail ?? null);
  }
  initCustomEvent(t, e, i, r) {
    throw new Error("Method not implemented.");
  }
  get detail() {
    return Ye(this, H1, "f");
  }
}, c($u, "H$1"), $u), dt(f2, "CustomEvent"), f2), H1 = /* @__PURE__ */ new WeakMap(), EQ);
Object.defineProperties(HE.prototype, {
  detail: Xt
});
const WN = aP, qN = HE;
globalThis.Event ??= WN;
globalThis.CustomEvent ??= qN;
const zQ = /* @__PURE__ */ new WeakMap(), Dy = /* @__PURE__ */ dt((n) => {
  let t = zQ.get(n);
  return t === void 0 && zQ.set(n, t = /* @__PURE__ */ new Map()), t;
}, "attributesForElement");
var m2, xu;
const FN = (m2 = (xu = class extends DN {
  constructor() {
    super(...arguments), this.__shadowRootMode = null, this.__shadowRoot = null, this.__internals = null;
  }
  get attributes() {
    return Array.from(Dy(this)).map(([t, e]) => ({
      name: t,
      value: e
    }));
  }
  get shadowRoot() {
    return this.__shadowRootMode === "closed" ? null : this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(t, e) {
    Dy(this).set(t, String(e));
  }
  removeAttribute(t) {
    Dy(this).delete(t);
  }
  toggleAttribute(t, e) {
    if (this.hasAttribute(t)) {
      if (e === void 0 || !e)
        return this.removeAttribute(t), !1;
    } else
      return e === void 0 || e ? (this.setAttribute(t, ""), !0) : !1;
    return !0;
  }
  hasAttribute(t) {
    return Dy(this).has(t);
  }
  attachShadow(t) {
    const e = { host: this };
    return this.__shadowRootMode = t.mode, t && t.mode === "open" && (this.__shadowRoot = e), e;
  }
  attachInternals() {
    if (this.__internals !== null)
      throw new Error("Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.");
    const t = new IN(this);
    return this.__internals = t, t;
  }
  getAttribute(t) {
    return Dy(this).get(t) ?? null;
  }
}, c(xu, "I"), xu), dt(m2, "Element"), m2);
var y2, ku;
const ZN = (y2 = (ku = class extends FN {
}, c(ku, "D"), ku), dt(y2, "HTMLElement"), y2), YE = ZN;
globalThis.litServerRoot ??= Object.defineProperty(new YE(), "localName", {
  // Patch localName (and tagName) to return a unique name.
  get() {
    return "lit-server-root";
  }
});
function GE() {
  let n, t;
  return { promise: new Promise((e, i) => {
    n = e, t = i;
  }), resolve: n, reject: t };
}
c(GE, "Xt$1");
dt(GE, "promiseWithResolvers");
var Su;
const KE = (Su = class {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map(), this.__reverseDefinitions = /* @__PURE__ */ new Map(), this.__pendingWhenDefineds = /* @__PURE__ */ new Map();
  }
  define(t, e) {
    if (this.__definitions.has(t))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${t}" has already been used with this registry`);
    if (this.__reverseDefinitions.has(e))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the constructor has already been used with this registry for the tag name ${this.__reverseDefinitions.get(e)}`);
    e.__localName = t, this.__definitions.set(t, {
      ctor: e,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: e.observedAttributes ?? []
    }), this.__reverseDefinitions.set(e, t), this.__pendingWhenDefineds.get(t)?.resolve(e), this.__pendingWhenDefineds.delete(t);
  }
  get(t) {
    return this.__definitions.get(t)?.ctor;
  }
  getName(t) {
    return this.__reverseDefinitions.get(t) ?? null;
  }
  upgrade(t) {
    throw new Error("customElements.upgrade is not currently supported in SSR. Please file a bug if you need it.");
  }
  async whenDefined(t) {
    const e = this.__definitions.get(t);
    if (e)
      return e.ctor;
    let i = this.__pendingWhenDefineds.get(t);
    return i || (i = GE(), this.__pendingWhenDefineds.set(t, i)), i.promise;
  }
}, c(Su, "Fe"), Su);
dt(KE, "CustomElementRegistry");
let XN = KE;
const NN = XN, jN = new NN(), ew = globalThis, q0 = ew.ShadowRoot && (ew.ShadyCSS === void 0 || ew.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, oP = Symbol(), LQ = /* @__PURE__ */ new WeakMap();
var g2, Cu;
let JE = (g2 = (Cu = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== oP) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (q0 && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = LQ.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && LQ.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}, c(Cu, "j$1"), Cu), dt(g2, "n"), g2);
const t_ = /* @__PURE__ */ dt((n) => new JE(typeof n == "string" ? n : n + "", void 0, oP), "r$2"), tt = /* @__PURE__ */ dt((n, ...t) => {
  const e = n.length === 1 ? n[0] : t.reduce(((i, r, s) => i + ((a) => {
    if (a._$cssResult$ === !0) return a.cssText;
    if (typeof a == "number") return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + n[s + 1]), n[0]);
  return new JE(e, n, oP);
}, "i$2"), e_ = /* @__PURE__ */ dt((n, t) => {
  if (q0) n.adoptedStyleSheets = t.map(((e) => e instanceof CSSStyleSheet ? e : e.styleSheet));
  else for (const e of t) {
    const i = document.createElement("style"), r = ew.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, n.appendChild(i);
  }
}, "S$1"), IQ = q0 || ew.CSSStyleSheet === void 0 ? (n) => n : (n) => n instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return t_(e);
})(n) : n, { is: BN, defineProperty: UN, getOwnPropertyDescriptor: HN, getOwnPropertyNames: YN, getOwnPropertySymbols: GN, getPrototypeOf: KN } = Object, a1 = globalThis;
a1.customElements ??= jN;
const VQ = a1.trustedTypes, JN = VQ ? VQ.emptyScript : "", tj = a1.reactiveElementPolyfillSupport, iw = /* @__PURE__ */ dt((n, t) => n, "f$1"), EO = { toAttribute(n, t) {
  switch (t) {
    case Boolean:
      n = n ? JN : null;
      break;
    case Object:
    case Array:
      n = n == null ? n : JSON.stringify(n);
  }
  return n;
}, fromAttribute(n, t) {
  let e = n;
  switch (t) {
    case Boolean:
      e = n !== null;
      break;
    case Number:
      e = n === null ? null : Number(n);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(n);
      } catch {
        e = null;
      }
  }
  return e;
} }, lP = /* @__PURE__ */ dt((n, t) => !BN(n, t), "m$1"), DQ = { attribute: !0, type: String, converter: EO, reflect: !1, useDefault: !1, hasChanged: lP };
Symbol.metadata ??= Symbol("metadata"), a1.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var w2, Pu;
let Dc = (w2 = (Pu = class extends (globalThis.HTMLElement ?? YE) {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = DQ) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && UN(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: r, set: s } = HN(this.prototype, t) ?? { get() {
      return this[e];
    }, set(a) {
      this[e] = a;
    } };
    return { get: r, set(a) {
      const o = r?.call(this);
      s?.call(this, a), this.requestUpdate(t, o, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? DQ;
  }
  static _$Ei() {
    if (this.hasOwnProperty(iw("elementProperties"))) return;
    const t = KN(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(iw("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(iw("properties"))) {
      const e = this.properties, i = [...YN(e), ...GN(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, r] of e) this.elementProperties.set(i, r);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const r = this._$Eu(e, i);
      r !== void 0 && this._$Eh.set(r, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(IQ(r));
    } else t !== void 0 && e.push(IQ(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t) => t(this)));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return e_(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((t) => t.hostConnected?.()));
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t) => t.hostDisconnected?.()));
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    const i = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, i);
    if (r !== void 0 && i.reflect === !0) {
      const s = (i.converter?.toAttribute !== void 0 ? i.converter : EO).toAttribute(e, i.type);
      this._$Em = t, s == null ? this.removeAttribute(r) : this.setAttribute(r, s), this._$Em = null;
    }
  }
  _$AK(t, e) {
    const i = this.constructor, r = i._$Eh.get(t);
    if (r !== void 0 && this._$Em !== r) {
      const s = i.getPropertyOptions(r), a = typeof s.converter == "function" ? { fromAttribute: s.converter } : s.converter?.fromAttribute !== void 0 ? s.converter : EO;
      this._$Em = r;
      const o = a.fromAttribute(e, s.type);
      this[r] = o ?? this._$Ej?.get(r) ?? o, this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    if (t !== void 0) {
      const r = this.constructor, s = this[t];
      if (i ??= r.getPropertyOptions(t), !((i.hasChanged ?? lP)(s, e) || i.useDefault && i.reflect && s === this._$Ej?.get(t) && !this.hasAttribute(r._$Eu(t, i)))) return;
      this.C(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: r, wrapped: s }, a) {
    i && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t) && (this._$Ej.set(t, a ?? e ?? this[t]), s !== !0 || a !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), r === !0 && this._$Em !== t && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [r, s] of this._$Ep) this[r] = s;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [r, s] of i) {
        const { wrapped: a } = s, o = this[r];
        a !== !0 || this._$AL.has(r) || o === void 0 || this.C(r, void 0, s, o);
      }
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), this._$EO?.forEach(((i) => i.hostUpdate?.())), this.update(e)) : this._$EM();
    } catch (i) {
      throw t = !1, this._$EM(), i;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach(((e) => e.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq &&= this._$Eq.forEach(((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}, c(Pu, "W"), Pu), dt(w2, "g"), w2);
Dc.elementStyles = [], Dc.shadowRootOptions = { mode: "open" }, Dc[iw("elementProperties")] = /* @__PURE__ */ new Map(), Dc[iw("finalized")] = /* @__PURE__ */ new Map(), tj?.({ ReactiveElement: Dc }), (a1.reactiveElementVersions ??= []).push("2.1.1");
const F0 = globalThis, _O = F0.trustedTypes, WQ = _O ? _O.createPolicy("lit-html", { createHTML: /* @__PURE__ */ dt((n) => n, "createHTML") }) : void 0, i_ = "$lit$", Ps = `lit$${Math.random().toFixed(9).slice(2)}$`, n_ = "?" + Ps, ej = `<${n_}>`, nl = F0.document === void 0 ? { createTreeWalker: /* @__PURE__ */ dt(() => ({}), "createTreeWalker") } : document, xw = /* @__PURE__ */ dt(() => nl.createComment(""), "l"), kw = /* @__PURE__ */ dt((n) => n === null || typeof n != "object" && typeof n != "function", "c"), cP = Array.isArray, ij = /* @__PURE__ */ dt((n) => cP(n) || typeof n?.[Symbol.iterator] == "function", "u"), v2 = `[ 	
\f\r]`, Wy = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, qQ = /-->/g, FQ = />/g, Ia = RegExp(`>|${v2}(?:([^\\s"'>=/]+)(${v2}*=${v2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), ZQ = /'/g, XQ = /"/g, r_ = /^(?:script|style|textarea|title)$/i, s_ = /* @__PURE__ */ dt((n) => (t, ...e) => ({ _$litType$: n, strings: t, values: e }), "y"), v = s_(1), zO = s_(2), lr = Symbol.for("lit-noChange"), C = Symbol.for("lit-nothing"), NQ = /* @__PURE__ */ new WeakMap(), ro = nl.createTreeWalker(nl, 129);
function hP(n, t) {
  if (!cP(n) || !n.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return WQ !== void 0 ? WQ.createHTML(t) : t;
}
c(hP, "Mt$1");
dt(hP, "P");
const nj = /* @__PURE__ */ dt((n, t) => {
  const e = n.length - 1, i = [];
  let r, s = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = Wy;
  for (let o = 0; o < e; o++) {
    const l = n[o];
    let d, u, p = -1, f = 0;
    for (; f < l.length && (a.lastIndex = f, u = a.exec(l), u !== null); ) f = a.lastIndex, a === Wy ? u[1] === "!--" ? a = qQ : u[1] !== void 0 ? a = FQ : u[2] !== void 0 ? (r_.test(u[2]) && (r = RegExp("</" + u[2], "g")), a = Ia) : u[3] !== void 0 && (a = Ia) : a === Ia ? u[0] === ">" ? (a = r ?? Wy, p = -1) : u[1] === void 0 ? p = -2 : (p = a.lastIndex - u[2].length, d = u[1], a = u[3] === void 0 ? Ia : u[3] === '"' ? XQ : ZQ) : a === XQ || a === ZQ ? a = Ia : a === qQ || a === FQ ? a = Wy : (a = Ia, r = void 0);
    const y = a === Ia && n[o + 1].startsWith("/>") ? " " : "";
    s += a === Wy ? l + ej : p >= 0 ? (i.push(d), l.slice(0, p) + i_ + l.slice(p) + Ps + y) : l + Ps + (p === -2 ? o : y);
  }
  return [hP(n, s + (n[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
}, "V");
var jo;
const a_ = (jo = class {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let s = 0, a = 0;
    const o = t.length - 1, l = this.parts, [d, u] = nj(t, e);
    if (this.el = jo.createElement(d, i), ro.currentNode = this.el.content, e === 2 || e === 3) {
      const p = this.el.content.firstChild;
      p.replaceWith(...p.childNodes);
    }
    for (; (r = ro.nextNode()) !== null && l.length < o; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) for (const p of r.getAttributeNames()) if (p.endsWith(i_)) {
          const f = u[a++], y = r.getAttribute(p).split(Ps), g = /([.?@])?(.*)/.exec(f);
          l.push({ type: 1, index: s, name: g[2], strings: y, ctor: g[1] === "." ? sj : g[1] === "?" ? aj : g[1] === "@" ? oj : X0 }), r.removeAttribute(p);
        } else p.startsWith(Ps) && (l.push({ type: 6, index: s }), r.removeAttribute(p));
        if (r_.test(r.tagName)) {
          const p = r.textContent.split(Ps), f = p.length - 1;
          if (f > 0) {
            r.textContent = _O ? _O.emptyScript : "";
            for (let y = 0; y < f; y++) r.append(p[y], xw()), ro.nextNode(), l.push({ type: 2, index: ++s });
            r.append(p[f], xw());
          }
        }
      } else if (r.nodeType === 8) if (r.data === n_) l.push({ type: 2, index: s });
      else {
        let p = -1;
        for (; (p = r.data.indexOf(Ps, p + 1)) !== -1; ) l.push({ type: 7, index: s }), p += Ps.length - 1;
      }
      s++;
    }
  }
  static createElement(t, e) {
    const i = nl.createElement("template");
    return i.innerHTML = t, i;
  }
}, c(jo, "ge"), jo);
dt(a_, "N");
let M5 = a_;
function rl(n, t, e = n, i) {
  if (t === lr) return t;
  let r = i !== void 0 ? e._$Co?.[i] : e._$Cl;
  const s = kw(t) ? void 0 : t._$litDirective$;
  return r?.constructor !== s && (r?._$AO?.(!1), s === void 0 ? r = void 0 : (r = new s(n), r._$AT(n, e, i)), i !== void 0 ? (e._$Co ??= [])[i] = r : e._$Cl = r), r !== void 0 && (t = rl(n, r._$AS(n, t.values), r, i)), t;
}
c(rl, "V");
dt(rl, "S");
var Qu;
const o_ = (Qu = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, r = (t?.creationScope ?? nl).importNode(e, !0);
    ro.currentNode = r;
    let s = ro.nextNode(), a = 0, o = 0, l = i[0];
    for (; l !== void 0; ) {
      if (a === l.index) {
        let d;
        l.type === 2 ? d = new Z0(s, s.nextSibling, this, t) : l.type === 1 ? d = new l.ctor(s, l.name, l.strings, this, t) : l.type === 6 && (d = new lj(s, this, t)), this._$AV.push(d), l = i[++o];
      }
      a !== l?.index && (s = ro.nextNode(), a++);
    }
    return ro.currentNode = nl, r;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, c(Qu, "Ge"), Qu);
dt(o_, "M");
let rj = o_;
var Bo;
const l_ = (Bo = class {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, e, i, r) {
    this.type = 2, this._$AH = C, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cv = r?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && t?.nodeType === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = rl(this, t, e), kw(t) ? t === C || t == null || t === "" ? (this._$AH !== C && this._$AR(), this._$AH = C) : t !== this._$AH && t !== lr && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : ij(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== C && kw(this._$AH) ? this._$AA.nextSibling.data = t : this.T(nl.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: e, _$litType$: i } = t, r = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = M5.createElement(hP(i.h, i.h[0]), this.options)), i);
    if (this._$AH?._$AD === r) this._$AH.p(e);
    else {
      const s = new rj(r, this), a = s.u(this.options);
      s.p(e), this.T(a), this._$AH = s;
    }
  }
  _$AC(t) {
    let e = NQ.get(t.strings);
    return e === void 0 && NQ.set(t.strings, e = new M5(t)), e;
  }
  k(t) {
    cP(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const s of t) r === e.length ? e.push(i = new Bo(this.O(xw()), this.O(xw()), this, this.options)) : i = e[r], i._$AI(s), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
}, c(Bo, "me"), Bo);
dt(l_, "k");
let Z0 = l_;
var Tu;
const c_ = (Tu = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, r, s) {
    this.type = 1, this._$AH = C, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = s, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = C;
  }
  _$AI(t, e = this, i, r) {
    const s = this.strings;
    let a = !1;
    if (s === void 0) t = rl(this, t, e, 0), a = !kw(t) || t !== this._$AH && t !== lr, a && (this._$AH = t);
    else {
      const o = t;
      let l, d;
      for (t = s[0], l = 0; l < s.length - 1; l++) d = rl(this, o[i + l], e, l), d === lr && (d = this._$AH[l]), a ||= !kw(d) || d !== this._$AH[l], d === C ? t = C : t !== C && (t += (d ?? "") + s[l + 1]), this._$AH[l] = d;
    }
    a && !r && this.j(t);
  }
  j(t) {
    t === C ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, c(Tu, "qe"), Tu);
dt(c_, "R");
let X0 = c_;
var Mu;
const h_ = (Mu = class extends X0 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === C ? void 0 : t;
  }
}, c(Mu, "Ke"), Mu);
dt(h_, "H");
let sj = h_;
var Au;
const d_ = (Au = class extends X0 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== C);
  }
}, c(Au, "Ze"), Au);
dt(d_, "I");
let aj = d_;
var Ru;
const u_ = (Ru = class extends X0 {
  constructor(t, e, i, r, s) {
    super(t, e, i, r, s), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = rl(this, t, e, 0) ?? C) === lr) return;
    const i = this._$AH, r = t === C && i !== C || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, s = t !== C && (i === C || r);
    r && this.element.removeEventListener(this.name, this, i), s && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, c(Ru, "Je"), Ru);
dt(u_, "L");
let oj = u_;
var Eu;
const p_ = (Eu = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    rl(this, t);
  }
}, c(Eu, "Xe"), Eu);
dt(p_, "z");
let lj = p_;
const cj = { I: Z0 }, hj = F0.litHtmlPolyfillSupport;
hj?.(M5, Z0), (F0.litHtmlVersions ??= []).push("3.3.1");
const dj = /* @__PURE__ */ dt((n, t, e) => {
  const i = e?.renderBefore ?? t;
  let r = i._$litPart$;
  if (r === void 0) {
    const s = e?.renderBefore ?? null;
    i._$litPart$ = r = new Z0(t.insertBefore(xw(), s), s, void 0, e ?? {});
  }
  return r._$AI(n), r;
}, "j"), dP = globalThis;
var _u;
const f_ = (_u = class extends Dc {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = dj(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return lr;
  }
}, c(_u, "Qe"), _u);
dt(f_, "i");
let pt = f_;
pt._$litElement$ = !0, pt.finalized = !0, dP.litElementHydrateSupport?.({ LitElement: pt });
const uj = dP.litElementPolyfillSupport;
uj?.({ LitElement: pt });
(dP.litElementVersions ??= []).push("4.2.1");
v`<strong>${0}</strong> redigerade <em>${1}</em>`, v`<strong>${0}</strong> nämnde dig i ett inlägg`, v`<strong>${0}</strong> kommenterade på <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på <em>${2}</em>`, v`<strong>${0}</strong> svarade på ett inlägg`, v`<strong>${0}</strong> redigerade ett inlägg`, v`<strong>${0}</strong> nämnde dig i ett meddelande`, v`<strong>${0}</strong> nämnde dig i en kommentar`, v`<strong>${0}</strong> och <strong>${1}</strong> röstade i din omröstning`, v`<strong>${0}</strong> reagerade med ${1} på ditt inlägg`, v`<strong>${0}</strong> reagerade med ${1} på din kommentar`, v`Nytt meddelande från <strong>${0}</strong>`, v`<strong>${0}</strong> svarade på ditt inlägg`, v`<strong>${0}</strong> röstade i din omröstning`, v`<strong>${0}</strong> publicerade ett inlägg i <strong>${1}</strong>`, v`<strong>${0}</strong> gillade ditt meddelande`, v`<strong>${0}</strong>, <strong>${1}</strong> och <strong>${2}</strong> röstade i din omröstning`, v`<strong>${0}</strong> lade till <em>${1}</em> till <strong>${2}</strong>`, v`<strong>${0}</strong> skickade ett meddelande i <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på ditt meddelande`, v`<strong>${0}</strong> gillade <em>${1}</em>`, v`<strong>${0}</strong> gillade ditt inlägg`, v`<strong>${0}</strong> gillade din kommentar`, v`<strong>${0}</strong> och ${1} andra röstade i din omröstning`, v`<strong>${0}</strong> kommenterade på <em>${1}</em>`, rt`${0} svarade på ditt inlägg`, rt`${0} röstade i din omröstning`, rt`${0} skriver${1}`, rt`${0} och ${1} röstade i din omröstning`, rt`${0} kommenterade på ${1}`, rt`${0} gillade ${1}`, rt`${0} skickade ett meddelande i ${1}`, rt`${0} redigerade ett inlägg`, rt`Röster på ${0}`, rt`${0} kommentarer`, rt`Sedd av ${0} vid ${1}`, rt`${0} och ${1} andra röstade i din omröstning`, rt`Nytt meddelande från ${0}`, rt`${0} reagerade med ${1} på ditt inlägg`, rt`${0} nämnde dig i ett inlägg`, rt`${0} nämnde dig i en kommentar`, rt`${0} publicerade ett inlägg i ${1}`, rt`${0} gillade ditt inlägg`, rt`${0} nämnde dig i ett meddelande`, rt`${0} reagerade med ${1} på din kommentar`, rt`Öppna i ${0}`, rt`${0} svarade på ett inlägg`, rt`${0} lade till ${1} till ${2}`, rt`${0} redigerade ${1}`, rt`${0} gillade ditt meddelande`, rt`${0}, ${1} och ${2} röstade i din omröstning`, rt`Alternativ ${0}`, rt`${0} reagerade med ${1} på ${2}`, rt`${0} reagerade med ${1} på ditt meddelande`, rt`${0} gillade din kommentar`, rt`${0} skriver${1}`;
var pj = Object.defineProperty, m_ = /* @__PURE__ */ c((n) => {
  throw TypeError(n);
}, "bw"), h = /* @__PURE__ */ c((n, t) => pj(n, "name", { value: t, configurable: !0 }), "a"), uP = /* @__PURE__ */ c((n, t, e) => t.has(n) || m_("Cannot " + e), "Pp"), x = /* @__PURE__ */ c((n, t, e) => (uP(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "y"), F = /* @__PURE__ */ c((n, t, e) => t.has(n) ? m_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "O"), L = /* @__PURE__ */ c((n, t, e, i) => (uP(n, t, "write to private field"), t.set(n, e), e), "P"), vt = /* @__PURE__ */ c((n, t, e) => (uP(n, t, "access private method"), e), "st"), A5 = /* @__PURE__ */ c((n, t, e, i) => ({
  set _(r) {
    L(n, t, r);
  },
  get _() {
    return x(n, t, i);
  }
}), "kd");
function Sw(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
c(Sw, "Td");
h(Sw, "isObject");
function Ur(n) {
  if (Sw(n) === !1) return !1;
  const t = n.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(Sw(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
c(Ur, "Mr");
h(Ur, "isPlainObject$1");
function LO(n) {
  return typeof n.toJSON == "function";
}
c(LO, "qp");
h(LO, "hasToJSON");
function y_(n) {
  return typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n === null || Ur(n) || Array.isArray(n);
}
c(y_, "d1");
h(y_, "isJSONSerializable");
function oo(n, t, e = !1) {
  n = n || {}, t = t || {};
  const i = {};
  for (const r in n)
    Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  for (const r in t)
    Object.prototype.hasOwnProperty.call(t, r) && (e && i[r] && Ur(i[r]) && Ur(t[r]) ? i[r] = oo(i[r], t[r], e) : i[r] = t[r]);
  return i;
}
c(oo, "yn");
h(oo, "assign");
function g_(n) {
  return n ? Array.isArray(n) ? n : [n] : [];
}
c(g_, "h1");
h(g_, "asArray");
async function w_(n, t) {
  for (const e of n)
    if (await t(e))
      return e;
}
c(w_, "p1");
h(w_, "findAsyncSequential");
function lo(n, t, e = !1, i = !1) {
  if (!i && (!Ur(n) || !Ur(t)) || i && (!Sw(n) || !Sw(t)))
    return !1;
  const r = Object.getOwnPropertyNames(n), s = Object.getOwnPropertyNames(t);
  if (!e && r.length !== s.length)
    return !1;
  for (let a = 0; a < r.length; a++) {
    const o = r[a], l = n[o], d = t[o];
    if (l !== d && !lo(l, d, e))
      return !1;
  }
  return !0;
}
c(lo, "wn");
h(lo, "eqObjects");
function pP(n) {
  return Object.entries(n);
}
c(pP, "Ff");
h(pP, "objectAsIterable");
function fP(n) {
  return n.charAt(0).toUpperCase() + n.substring(1).toLowerCase();
}
c(fP, "Df");
h(fP, "toUpperCaseFirst");
const fj = '\\s,.:;"', mj = new RegExp(`^|[${fj}]|$`, "g"), yj = ".!?", gj = new RegExp(`^|(?<=[${yj}])|$`);
function mP(n) {
  return n.length > 0 ? n.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : n;
}
c(mP, "Hf");
h(mP, "toKebabCase");
function v_(n, t = 2) {
  if (!n)
    return null;
  let e = "";
  const i = n.split(mj).filter((r) => r);
  return i.length == 1 ? e = i[0] : i.forEach((r) => {
    e += r.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
c(v_, "m1");
h(v_, "getInitials");
function yP(n) {
  let t;
  const e = n.split(gj).filter((i) => i);
  return e.length ? t = e[0] : t = n, t;
}
c(yP, "Vf");
h(yP, "getTitleFromText");
function gP(n, t = 256) {
  return n.length > t && (n = n.substring(0, t - 1) + "…"), n;
}
c(gP, "Uf");
h(gP, "truncateText");
const wj = /^[\p{Extended_Pictographic}\p{Emoji_Presentation}]+$/u;
function O_(n) {
  return !!n?.match(wj)?.length;
}
c(O_, "g1");
h(O_, "checkOnlyEmojis");
const vj = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function b_() {
  const n = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ h(function(e, i) {
    if (LO(i) && (i = i.toJSON()), !(i !== null && typeof i == "object"))
      return i;
    if (n.has(i))
      return "[Circular]";
    let r;
    if (n.add(i), Ur(i)) {
      const s = {};
      Object.keys(i).forEach((a) => {
        s[a] = t(a, i[a]);
      }), r = s;
    } else Array.isArray(i) && (r = i.map((s, a) => t(a, s)));
    return n.delete(i), r;
  }, "replacer");
  return t;
}
c(b_, "x1");
h(b_, "getCircularReferenceReplacer");
function Xm() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
c(Xm, "nl");
h(Xm, "S4");
function $_(n) {
  if (n && n.ok && n.body) {
    const t = n.body.getReader();
    return new ReadableStream({
      start(e) {
        const i = /* @__PURE__ */ h(() => t.read().then(({ done: r, value: s }) => {
          if (r) {
            e.close();
            return;
          }
          return e.enqueue(s), i();
        }), "pump");
        return i();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
c($_, "$1");
h($_, "getTextStreamFromResponse");
function wP(n) {
  let t;
  try {
    if (t = window[n], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", n);
  }
  return t;
}
c(wP, "Bf");
h(wP, "getStorage");
var zu;
const x_ = (zu = class extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
}, c(zu, "zy"), zu);
h(x_, "DestroyError");
let Ce = x_;
const Oj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._whenTokenFactory = new Promise((s) => {
        this._resolveTokenFactory = s;
      }), this._whenUrlAndTokenFactory = new Promise((s) => {
        this._resolveUrlAndTokenFactory = (a) => {
          s(a), this.configurationState = "configured";
        };
      }), this._whenTokenIsValid = new Promise((s) => {
        this._resolveTokenIsValid = s;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (s = !1) => {
        const a = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0 && a.push(new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay))), await Promise.race(a);
        const o = await this.tokenFactory?.(s) ?? "";
        if (this._validateToken(o)) {
          if (s && o === this._token && this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0)
            return await new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((l) => {
          this._resolveTokenFactory = l;
        }), !s)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return this._resolveTokenFactory?.(!0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        this.url && this.tokenFactory && this._resolveUrlAndTokenFactory?.(!0);
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(r) {
      if (this.isDestroyed)
        throw new Ce();
      this._tokenFactory && this._tokenFactory !== r && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = r ?? void 0, this._tokenFactory && queueMicrotask(() => {
        this._resolveTokenFactory?.(!0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(r) {
      if (this.isDestroyed)
        throw new Ce();
      try {
        if (typeof r == "string")
          r && (this._tokenUrl = new URL(r, window.location.toString()));
        else if (r instanceof URL)
          this._tokenUrl = r;
        else if (r == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (s) {
        throw new Error("Invalid url", s);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (s) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const a = new URL(this.tokenUrl);
        s ? a.searchParams.set("refresh", "true") : a.searchParams.delete("refresh");
        const o = await fetch(a);
        if (o.ok) {
          const l = await o.json();
          if (l.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return l.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(r) {
      if (!r)
        return !1;
      if (typeof r != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof r}.`);
      if (typeof r == "string" && !r.startsWith("wyu_"))
        throw r.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return this._resolveTokenIsValid?.(r), !0;
    }
    async getToken(r = !1) {
      if (this.isDestroyed)
        throw new Ce();
      if (this._token && !r)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((s, a) => {
        this._validTokenFromFactory(r).then(s).catch(a), this.tokenFactoryTimeout >= 0 && this.tokenFactoryTimeout < 1 / 0 && setTimeout(() => a(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => a(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => a(new Error("Network changed.")), { once: !0 });
      });
      try {
        const s = await this._tokenPromise;
        return this._tokenPromise = null, this._token = s, this._token;
      } catch (s) {
        throw this._tokenPromise = null, s;
      }
    }
  }, c(e, "t"), e), h(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var Y1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function k_(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
c(k_, "k1");
h(k_, "getDefaultExportFromCjs");
function Cv(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
c(Cv, "Mp");
h(Cv, "commonjsRequire");
var jQ = { exports: {} }, BQ;
function S_() {
  return BQ || (BQ = 1, (function(n, t) {
    var e;
    e = /* @__PURE__ */ h(() => (() => {
      var Bl, Ul, Hl, Yl, Gl, Kl, Jl, tc, ec, ic, nc, rc, br, sc, ac, oc, lc, cc, $r, hc, dc, uc, pc, Ea, fc, mc, yc, gc, wc, vc, Oc, bc, _a, $c, xc, kc;
      var i = { d: /* @__PURE__ */ h((B, w) => {
        for (var k in w) i.o(w, k) && !i.o(B, k) && Object.defineProperty(B, k, { enumerable: !0, get: w[k] });
      }, "d") };
      i.g = (function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      })(), i.o = (B, w) => Object.prototype.hasOwnProperty.call(B, w), i.r = (B) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(B, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(B, "t", { value: !0 });
      };
      var r, s = {};
      i.r(s), i.d(s, { AbortError: /* @__PURE__ */ h(() => p, "AbortError"), DefaultHttpClient: /* @__PURE__ */ h(() => Y4, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ h(() => Y, "HttpClient"), HttpError: /* @__PURE__ */ h(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ h(() => D, "HttpResponse"), HttpTransportType: /* @__PURE__ */ h(() => ke, "HttpTransportType"), HubConnection: /* @__PURE__ */ h(() => r3, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ h(() => GD, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ h(() => Yt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ h(() => w3, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ h(() => r, "LogLevel"), MessageType: /* @__PURE__ */ h(() => Mt, "MessageType"), NullLogger: /* @__PURE__ */ h(() => ct, "NullLogger"), Subject: /* @__PURE__ */ h(() => t3, "Subject"), TimeoutError: /* @__PURE__ */ h(() => d, "TimeoutError"), TransferFormat: /* @__PURE__ */ h(() => Ue, "TransferFormat"), VERSION: /* @__PURE__ */ h(() => et, "VERSION") });
      const a = (Bl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(`${w}: Status code '${k}'`), this.statusCode = k, this.__proto__ = M;
        }
      }, c(Bl, "Kh"), Bl);
      h(a, "i");
      let o = a;
      const l = (Ul = class extends Error {
        constructor(w = "A timeout occurred.") {
          const k = new.target.prototype;
          super(w), this.__proto__ = k;
        }
      }, c(Ul, "Gh"), Ul);
      h(l, "n");
      let d = l;
      const u = (Hl = class extends Error {
        constructor(w = "An abort occurred.") {
          const k = new.target.prototype;
          super(w), this.__proto__ = k;
        }
      }, c(Hl, "Zh"), Hl);
      h(u, "r");
      let p = u;
      const f = (Yl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.transport = k, this.errorType = "UnsupportedTransportError", this.__proto__ = M;
        }
      }, c(Yl, "Yh"), Yl);
      h(f, "o");
      let y = f;
      const g = (Gl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.transport = k, this.errorType = "DisabledTransportError", this.__proto__ = M;
        }
      }, c(Gl, "Xh"), Gl);
      h(g, "h");
      let b = g;
      const S = (Kl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.transport = k, this.errorType = "FailedToStartTransportError", this.__proto__ = M;
        }
      }, c(Kl, "Jh"), Kl);
      h(S, "c");
      let $ = S;
      const Q = (Jl = class extends Error {
        constructor(w) {
          const k = new.target.prototype;
          super(w), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = k;
        }
      }, c(Jl, "tp"), Jl);
      h(Q, "a");
      let E = Q;
      const z = (tc = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.innerErrors = k, this.__proto__ = M;
        }
      }, c(tc, "ep"), tc);
      h(z, "l");
      let A = z;
      const V = (ec = class {
        constructor(w, k, M) {
          this.statusCode = w, this.statusText = k, this.content = M;
        }
      }, c(ec, "ip"), ec);
      h(V, "u");
      let D = V;
      const X = (ic = class {
        get(w, k) {
          return this.send({ ...k, method: "GET", url: w });
        }
        post(w, k) {
          return this.send({ ...k, method: "POST", url: w });
        }
        delete(w, k) {
          return this.send({ ...k, method: "DELETE", url: w });
        }
        getCookieString(w) {
          return "";
        }
      }, c(ic, "rp"), ic);
      h(X, "d");
      let Y = X;
      (function(B) {
        B[B.Trace = 0] = "Trace", B[B.Debug = 1] = "Debug", B[B.Information = 2] = "Information", B[B.Warning = 3] = "Warning", B[B.Error = 4] = "Error", B[B.Critical = 5] = "Critical", B[B.None = 6] = "None";
      })(r || (r = {}));
      const mt = (nc = class {
        constructor() {
        }
        log(w, k) {
        }
      }, c(nc, "sp"), nc);
      h(mt, "f");
      let ct = mt;
      ct.instance = new ct();
      const et = "9.0.6", bt = (rc = class {
        static isRequired(w, k) {
          if (w == null) throw new Error(`The '${k}' argument is required.`);
        }
        static isNotEmpty(w, k) {
          if (!w || w.match(/^\s*$/)) throw new Error(`The '${k}' argument should not be empty.`);
        }
        static isIn(w, k, M) {
          if (!(w in k)) throw new Error(`Unknown ${M} value: ${w}.`);
        }
      }, c(rc, "np"), rc);
      h(bt, "w");
      let st = bt;
      const Rt = (br = class {
        static get isBrowser() {
          return !br.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !br.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !br.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      }, c(br, "Ys"), br);
      h(Rt, "g");
      let Qt = Rt;
      function It(B, w) {
        let k = "";
        return Wt(B) ? (k = `Binary data of length ${B.byteLength}`, w && (k += `. Content: '${(function(M) {
          const _ = new Uint8Array(M);
          let W = "";
          return _.forEach(((q) => {
            W += `0x${q < 16 ? "0" : ""}${q.toString(16)} `;
          })), W.substr(0, W.length - 1);
        })(B)}'`)) : typeof B == "string" && (k = `String data of length ${B.length}`, w && (k += `. Content: '${B}'`)), k;
      }
      c(It, "q"), h(It, "m");
      function Wt(B) {
        return B && typeof ArrayBuffer < "u" && (B instanceof ArrayBuffer || B.constructor && B.constructor.name === "ArrayBuffer");
      }
      c(Wt, "R"), h(Wt, "y");
      async function qt(B, w, k, M, _, W) {
        const q = {}, [ot, lt] = fe();
        q[ot] = lt, B.log(r.Trace, `(${w} transport) sending data. ${It(_, W.logMessageContent)}.`);
        const At = Wt(_) ? "arraybuffer" : "text", Ut = await k.post(M, { content: _, headers: { ...q, ...W.headers }, responseType: At, timeout: W.timeout, withCredentials: W.withCredentials });
        B.log(r.Trace, `(${w} transport) request complete. Response status: ${Ut.statusCode}.`);
      }
      c(qt, "V"), h(qt, "b");
      const xi = (sc = class {
        constructor(w, k) {
          this.i = w, this.h = k;
        }
        dispose() {
          const w = this.i.observers.indexOf(this.h);
          w > -1 && this.i.observers.splice(w, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch(((k) => {
          }));
        }
      }, c(sc, "ap"), sc);
      h(xi, "v");
      let Ee = xi;
      const le = (ac = class {
        constructor(w) {
          this.l = w, this.out = console;
        }
        log(w, k) {
          if (w >= this.l) {
            const M = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${r[w]}: ${k}`;
            switch (w) {
              case r.Critical:
              case r.Error:
                this.out.error(M);
                break;
              case r.Warning:
                this.out.warn(M);
                break;
              case r.Information:
                this.out.info(M);
                break;
              default:
                this.out.log(M);
            }
          }
        }
      }, c(ac, "op"), ac);
      h(le, "E");
      let ee = le;
      function fe() {
        let B = "X-SignalR-User-Agent";
        return Qt.isNode && (B = "User-Agent"), [B, ki(et, Wi(), Qt.isNode ? "NodeJS" : "Browser", rn())];
      }
      c(fe, "J"), h(fe, "$");
      function ki(B, w, k, M) {
        let _ = "Microsoft SignalR/";
        const W = B.split(".");
        return _ += `${W[0]}.${W[1]}`, _ += ` (${B}; `, _ += w && w !== "" ? `${w}; ` : "Unknown OS; ", _ += `${k}`, _ += M ? `; ${M}` : "; Unknown Runtime Version", _ += ")", _;
      }
      c(ki, "tt"), h(ki, "C");
      function Wi() {
        if (!Qt.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      c(Wi, "St"), h(Wi, "S");
      function rn() {
        if (Qt.isNode) return process.versions.node;
      }
      c(rn, "kt"), h(rn, "k");
      function Bt(B) {
        return B.stack ? B.stack : B.message ? B.message : `${B}`;
      }
      c(Bt, "yt"), h(Bt, "P");
      const wn = (oc = class extends Y {
        constructor(w) {
          if (super(), this.u = w, typeof fetch > "u" || Qt.isNode) {
            const k = Cv;
            this.p = new (k("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = k("node-fetch") : this.m = fetch, this.m = k("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind((function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (i.g !== void 0) return i.g;
            throw new Error("could not find global");
          })());
          if (typeof AbortController > "u") {
            const k = Cv;
            this.v = k("abort-controller");
          } else this.v = AbortController;
        }
        async send(w) {
          if (w.abortSignal && w.abortSignal.aborted) throw new p();
          if (!w.method) throw new Error("No method defined.");
          if (!w.url) throw new Error("No url defined.");
          const k = new this.v();
          let M;
          w.abortSignal && (w.abortSignal.onabort = () => {
            k.abort(), M = new p();
          });
          let _, W = null;
          if (w.timeout) {
            const lt = w.timeout;
            W = setTimeout((() => {
              k.abort(), this.u.log(r.Warning, "Timeout from HTTP request."), M = new d();
            }), lt);
          }
          w.content === "" && (w.content = void 0), w.content && (w.headers = w.headers || {}, Wt(w.content) ? w.headers["Content-Type"] = "application/octet-stream" : w.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            _ = await this.m(w.url, { body: w.content, cache: "no-cache", credentials: w.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...w.headers }, method: w.method, mode: "cors", redirect: "follow", signal: k.signal });
          } catch (lt) {
            throw M || (this.u.log(r.Warning, `Error from HTTP request. ${lt}.`), lt);
          } finally {
            W && clearTimeout(W), w.abortSignal && (w.abortSignal.onabort = null);
          }
          if (!_.ok) {
            const lt = await jl(_, "text");
            throw new o(lt || _.statusText, _.status);
          }
          const q = jl(_, w.responseType), ot = await q;
          return new D(_.status, _.statusText, ot);
        }
        getCookieString(w) {
          let k = "";
          return Qt.isNode && this.p && this.p.getCookies(w, ((M, _) => k = _.join("; "))), k;
        }
      }, c(oc, "cp"), oc);
      h(wn, "T");
      let Aa = wn;
      function jl(B, w) {
        let k;
        switch (w) {
          case "arraybuffer":
            k = B.arrayBuffer();
            break;
          case "text":
          default:
            k = B.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${w} is not supported.`);
        }
        return k;
      }
      c(jl, "he"), h(jl, "I");
      const U4 = (lc = class extends Y {
        constructor(w) {
          super(), this.u = w;
        }
        send(w) {
          return w.abortSignal && w.abortSignal.aborted ? Promise.reject(new p()) : w.method ? w.url ? new Promise(((k, M) => {
            const _ = new XMLHttpRequest();
            _.open(w.method, w.url, !0), _.withCredentials = w.withCredentials === void 0 || w.withCredentials, _.setRequestHeader("X-Requested-With", "XMLHttpRequest"), w.content === "" && (w.content = void 0), w.content && (Wt(w.content) ? _.setRequestHeader("Content-Type", "application/octet-stream") : _.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const W = w.headers;
            W && Object.keys(W).forEach(((q) => {
              _.setRequestHeader(q, W[q]);
            })), w.responseType && (_.responseType = w.responseType), w.abortSignal && (w.abortSignal.onabort = () => {
              _.abort(), M(new p());
            }), w.timeout && (_.timeout = w.timeout), _.onload = () => {
              w.abortSignal && (w.abortSignal.onabort = null), _.status >= 200 && _.status < 300 ? k(new D(_.status, _.statusText, _.response || _.responseText)) : M(new o(_.response || _.responseText || _.statusText, _.status));
            }, _.onerror = () => {
              this.u.log(r.Warning, `Error from HTTP request. ${_.status}: ${_.statusText}.`), M(new o(_.statusText, _.status));
            }, _.ontimeout = () => {
              this.u.log(r.Warning, "Timeout from HTTP request."), M(new d());
            }, _.send(w.content);
          })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      }, c(lc, "lp"), lc);
      h(U4, "_");
      let DD = U4;
      const H4 = (cc = class extends Y {
        constructor(w) {
          if (super(), typeof fetch < "u" || Qt.isNode) this.$ = new Aa(w);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new DD(w);
          }
        }
        send(w) {
          return w.abortSignal && w.abortSignal.aborted ? Promise.reject(new p()) : w.method ? w.url ? this.$.send(w) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(w) {
          return this.$.getCookieString(w);
        }
      }, c(cc, "dp"), cc);
      h(H4, "H");
      let Y4 = H4;
      const G4 = ($r = class {
        static write(w) {
          return `${w}${$r.RecordSeparator}`;
        }
        static parse(w) {
          if (w[w.length - 1] !== $r.RecordSeparator) throw new Error("Message is incomplete.");
          const k = w.split($r.RecordSeparator);
          return k.pop(), k;
        }
      }, c($r, "Xs"), $r);
      h(G4, "D");
      let Or = G4;
      Or.RecordSeparatorCode = 30, Or.RecordSeparator = String.fromCharCode(Or.RecordSeparatorCode);
      const K4 = (hc = class {
        writeHandshakeRequest(w) {
          return Or.write(JSON.stringify(w));
        }
        parseHandshakeResponse(w) {
          let k, M;
          if (Wt(w)) {
            const q = new Uint8Array(w), ot = q.indexOf(Or.RecordSeparatorCode);
            if (ot === -1) throw new Error("Message is incomplete.");
            const lt = ot + 1;
            k = String.fromCharCode.apply(null, Array.prototype.slice.call(q.slice(0, lt))), M = q.byteLength > lt ? q.slice(lt).buffer : null;
          } else {
            const q = w, ot = q.indexOf(Or.RecordSeparator);
            if (ot === -1) throw new Error("Message is incomplete.");
            const lt = ot + 1;
            k = q.substring(0, lt), M = q.length > lt ? q.substring(lt) : null;
          }
          const _ = Or.parse(k), W = JSON.parse(_[0]);
          if (W.type) throw new Error("Expected a handshake response from the server.");
          return [M, W];
        }
      }, c(hc, "hp"), hc);
      h(K4, "R");
      let WD = K4;
      var Mt, Yt;
      (function(B) {
        B[B.Invocation = 1] = "Invocation", B[B.StreamItem = 2] = "StreamItem", B[B.Completion = 3] = "Completion", B[B.StreamInvocation = 4] = "StreamInvocation", B[B.CancelInvocation = 5] = "CancelInvocation", B[B.Ping = 6] = "Ping", B[B.Close = 7] = "Close", B[B.Ack = 8] = "Ack", B[B.Sequence = 9] = "Sequence";
      })(Mt || (Mt = {}));
      const J4 = (dc = class {
        constructor() {
          this.observers = [];
        }
        next(w) {
          for (const k of this.observers) k.next(w);
        }
        error(w) {
          for (const k of this.observers) k.error && k.error(w);
        }
        complete() {
          for (const w of this.observers) w.complete && w.complete();
        }
        subscribe(w) {
          return this.observers.push(w), new Ee(this, w);
        }
      }, c(dc, "pp"), dc);
      h(J4, "U");
      let t3 = J4;
      const e3 = (uc = class {
        constructor(w, k, M) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = w, this.R = k, this.C = M;
        }
        async A(w) {
          const k = this.D.writeMessage(w);
          let M = Promise.resolve();
          if (this.U(w)) {
            this.k++;
            let _ = /* @__PURE__ */ h(() => {
            }, "t"), W = /* @__PURE__ */ h(() => {
            }, "i");
            Wt(k) ? this._ += k.byteLength : this._ += k.length, this._ >= this.C && (M = new Promise(((q, ot) => {
              _ = q, W = ot;
            }))), this.S.push(new FD(k, this.k, _, W));
          }
          try {
            this.H || await this.R.send(k);
          } catch {
            this.L();
          }
          await M;
        }
        N(w) {
          let k = -1;
          for (let M = 0; M < this.S.length; M++) {
            const _ = this.S[M];
            if (_.q <= w.sequenceId) k = M, Wt(_.M) ? this._ -= _.M.byteLength : this._ -= _.M.length, _.j();
            else {
              if (!(this._ < this.C)) break;
              _.j();
            }
          }
          k !== -1 && (this.S = this.S.slice(k + 1));
        }
        W(w) {
          if (this.P) return w.type === Mt.Sequence && (this.P = !1, !0);
          if (!this.U(w)) return !0;
          const k = this.T;
          return this.T++, k <= this.I ? (k === this.I && this.O(), !1) : (this.I = k, this.O(), !0);
        }
        F(w) {
          w.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = w.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const w = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: Mt.Sequence, sequenceId: w }));
          const k = this.S;
          for (const M of k) await this.R.send(M.M);
          this.H = !1;
        }
        X(w) {
          w != null || (w = new Error("Unable to reconnect to server."));
          for (const k of this.S) k.J(w);
        }
        U(w) {
          switch (w.type) {
            case Mt.Invocation:
            case Mt.StreamItem:
            case Mt.Completion:
            case Mt.StreamInvocation:
            case Mt.CancelInvocation:
              return !0;
            case Mt.Close:
            case Mt.Sequence:
            case Mt.Ping:
            case Mt.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout((async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: Mt.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }), 1e3));
        }
      }, c(uc, "up"), uc);
      h(e3, "L");
      let qD = e3;
      const i3 = (pc = class {
        constructor(w, k, M, _) {
          this.M = w, this.q = k, this.j = M, this.J = _;
        }
      }, c(pc, "yp"), pc);
      h(i3, "N");
      let FD = i3;
      (function(B) {
        B.Disconnected = "Disconnected", B.Connecting = "Connecting", B.Connected = "Connected", B.Disconnecting = "Disconnecting", B.Reconnecting = "Reconnecting";
      })(Yt || (Yt = {}));
      const n3 = (Ea = class {
        static create(w, k, M, _, W, q, ot) {
          return new Ea(w, k, M, _, W, q, ot);
        }
        constructor(w, k, M, _, W, q, ot) {
          this.K = 0, this.G = () => {
            this.u.log(r.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, st.isRequired(w, "connection"), st.isRequired(k, "logger"), st.isRequired(M, "protocol"), this.serverTimeoutInMilliseconds = W ?? 3e4, this.keepAliveIntervalInMilliseconds = q ?? 15e3, this.Y = ot ?? 1e5, this.u = k, this.D = M, this.connection = w, this.Z = _, this.tt = new WD(), this.connection.onreceive = (lt) => this.et(lt), this.connection.onclose = (lt) => this.st(lt), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = Yt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: Mt.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(w) {
          if (this.ut !== Yt.Disconnected && this.ut !== Yt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!w) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = w;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== Yt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = Yt.Connecting, this.u.log(r.Debug, "Starting HubConnection.");
          try {
            await this.yt(), Qt.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = Yt.Connected, this.dt = !0, this.u.log(r.Debug, "HubConnection connected successfully.");
          } catch (w) {
            return this.ut = Yt.Disconnected, this.u.log(r.Debug, `HubConnection failed to start successfully because of error '${w}'.`), Promise.reject(w);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const w = new Promise(((k, M) => {
            this.vt = k, this.Et = M;
          }));
          await this.connection.start(this.D.transferFormat);
          try {
            let k = this.D.version;
            this.connection.features.reconnect || (k = 1);
            const M = { protocol: this.D.name, version: k };
            if (this.u.log(r.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(M)), this.u.log(r.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await w, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new qD(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (k) {
            throw this.u.log(r.Debug, `Hub handshake failed with error '${k}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(k), k;
          }
        }
        async stop() {
          const w = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await w;
          } catch {
          }
        }
        _t(w) {
          if (this.ut === Yt.Disconnected) return this.u.log(r.Debug, `Call to HubConnection.stop(${w}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === Yt.Disconnecting) return this.u.log(r.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnecting state.`), this.It;
          const k = this.ut;
          return this.ut = Yt.Disconnecting, this.u.log(r.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(r.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (k === Yt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = w || new p("The connection was stopped before the hub handshake could complete."), this.connection.stop(w));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(w, ...k) {
          const [M, _] = this.Ut(k), W = this.Lt(w, k, _);
          let q;
          const ot = new t3();
          return ot.cancelCallback = () => {
            const lt = this.Nt(W.invocationId);
            return delete this.it[W.invocationId], q.then((() => this.xt(lt)));
          }, this.it[W.invocationId] = (lt, At) => {
            At ? ot.error(At) : lt && (lt.type === Mt.Completion ? lt.error ? ot.error(new Error(lt.error)) : ot.complete() : ot.next(lt.item));
          }, q = this.xt(W).catch(((lt) => {
            ot.error(lt), delete this.it[W.invocationId];
          })), this.qt(M, q), ot;
        }
        $t(w) {
          return this.kt(), this.connection.send(w);
        }
        xt(w) {
          return this.Pt ? this.Pt.A(w) : this.$t(this.D.writeMessage(w));
        }
        send(w, ...k) {
          const [M, _] = this.Ut(k), W = this.xt(this.Mt(w, k, !0, _));
          return this.qt(M, W), W;
        }
        invoke(w, ...k) {
          const [M, _] = this.Ut(k), W = this.Mt(w, k, !1, _);
          return new Promise(((q, ot) => {
            this.it[W.invocationId] = (At, Ut) => {
              Ut ? ot(Ut) : At && (At.type === Mt.Completion ? At.error ? ot(new Error(At.error)) : q(At.result) : ot(new Error(`Unexpected message type: ${At.type}`)));
            };
            const lt = this.xt(W).catch(((At) => {
              ot(At), delete this.it[W.invocationId];
            }));
            this.qt(M, lt);
          }));
        }
        on(w, k) {
          w && k && (w = w.toLowerCase(), this.nt[w] || (this.nt[w] = []), this.nt[w].indexOf(k) === -1 && this.nt[w].push(k));
        }
        off(w, k) {
          if (!w) return;
          w = w.toLowerCase();
          const M = this.nt[w];
          if (M) if (k) {
            const _ = M.indexOf(k);
            _ !== -1 && (M.splice(_, 1), M.length === 0 && delete this.nt[w]);
          } else delete this.nt[w];
        }
        onclose(w) {
          w && this.rt.push(w);
        }
        onreconnecting(w) {
          w && this.ot.push(w);
        }
        onreconnected(w) {
          w && this.ht.push(w);
        }
        et(w) {
          if (this.Ct(), this.lt || (w = this.jt(w), this.lt = !0), w) {
            const k = this.D.parseMessages(w, this.u);
            for (const M of k) if (!this.Pt || this.Pt.W(M)) switch (M.type) {
              case Mt.Invocation:
                this.Wt(M).catch(((_) => {
                  this.u.log(r.Error, `Invoke client method threw error: ${Bt(_)}`);
                }));
                break;
              case Mt.StreamItem:
              case Mt.Completion: {
                const _ = this.it[M.invocationId];
                if (_) {
                  M.type === Mt.Completion && delete this.it[M.invocationId];
                  try {
                    _(M);
                  } catch (W) {
                    this.u.log(r.Error, `Stream callback threw error: ${Bt(W)}`);
                  }
                }
                break;
              }
              case Mt.Ping:
                break;
              case Mt.Close: {
                this.u.log(r.Information, "Close message received from server.");
                const _ = M.error ? new Error("Server returned an error on close: " + M.error) : void 0;
                M.allowReconnect === !0 ? this.connection.stop(_) : this.It = this._t(_);
                break;
              }
              case Mt.Ack:
                this.Pt && this.Pt.N(M);
                break;
              case Mt.Sequence:
                this.Pt && this.Pt.F(M);
                break;
              default:
                this.u.log(r.Warning, `Invalid message type: ${M.type}.`);
            }
          }
          this.St();
        }
        jt(w) {
          let k, M;
          try {
            [M, k] = this.tt.parseHandshakeResponse(w);
          } catch (_) {
            const W = "Error parsing handshake response: " + _;
            this.u.log(r.Error, W);
            const q = new Error(W);
            throw this.Et(q), q;
          }
          if (k.error) {
            const _ = "Server returned handshake error: " + k.error;
            this.u.log(r.Error, _);
            const W = new Error(_);
            throw this.Et(W), W;
          }
          return this.u.log(r.Debug, "Server handshake complete."), this.vt(), M;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let w = this.K - (/* @__PURE__ */ new Date()).getTime();
            w < 0 && (w = 0), this.Ft = setTimeout((async () => {
              if (this.ut === Yt.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }), w);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(w) {
          const k = w.target.toLowerCase(), M = this.nt[k];
          if (!M) return this.u.log(r.Warning, `No client method with the name '${k}' found.`), void (w.invocationId && (this.u.log(r.Warning, `No result given for '${k}' method and invocation ID '${w.invocationId}'.`), await this.xt(this.Bt(w.invocationId, "Client didn't provide a result.", null))));
          const _ = M.slice(), W = !!w.invocationId;
          let q, ot, lt;
          for (const At of _) try {
            const Ut = q;
            q = await At.apply(this, w.arguments), W && q && Ut && (this.u.log(r.Error, `Multiple results provided for '${k}'. Sending error to server.`), lt = this.Bt(w.invocationId, "Client provided multiple results.", null)), ot = void 0;
          } catch (Ut) {
            ot = Ut, this.u.log(r.Error, `A callback for the method '${k}' threw error '${Ut}'.`);
          }
          lt ? await this.xt(lt) : W ? (ot ? lt = this.Bt(w.invocationId, `${ot}`, null) : q !== void 0 ? lt = this.Bt(w.invocationId, null, q) : (this.u.log(r.Warning, `No result given for '${k}' method and invocation ID '${w.invocationId}'.`), lt = this.Bt(w.invocationId, "Client didn't provide a result.", null)), await this.xt(lt)) : q && this.u.log(r.Error, `Result given for '${k}' method but server is not expecting a result.`);
        }
        st(w) {
          this.u.log(r.Debug, `HubConnection.connectionClosed(${w}) called while in state ${this.ut}.`), this.bt = this.bt || w || new p("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(w || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === Yt.Disconnecting ? this.Dt(w) : this.ut === Yt.Connected && this.Z ? this.Jt(w) : this.ut === Yt.Connected && this.Dt(w);
        }
        Dt(w) {
          if (this.dt) {
            this.ut = Yt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(w ?? new Error("Connection closed.")), this.Pt = void 0), Qt.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach(((k) => k.apply(this, [w])));
            } catch (k) {
              this.u.log(r.Error, `An onclose callback called with error '${w}' threw error '${k}'.`);
            }
          }
        }
        async Jt(w) {
          const k = Date.now();
          let M = 0, _ = w !== void 0 ? w : new Error("Attempting to reconnect due to a unknown error."), W = this.zt(M++, 0, _);
          if (W === null) return this.u.log(r.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(w);
          if (this.ut = Yt.Reconnecting, w ? this.u.log(r.Information, `Connection reconnecting because of error '${w}'.`) : this.u.log(r.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach(((q) => q.apply(this, [w])));
            } catch (q) {
              this.u.log(r.Error, `An onreconnecting callback called with error '${w}' threw error '${q}'.`);
            }
            if (this.ut !== Yt.Reconnecting) return void this.u.log(r.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; W !== null; ) {
            if (this.u.log(r.Information, `Reconnect attempt number ${M} will start in ${W} ms.`), await new Promise(((q) => {
              this.Ht = setTimeout(q, W);
            })), this.Ht = void 0, this.ut !== Yt.Reconnecting) return void this.u.log(r.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = Yt.Connected, this.u.log(r.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach(((q) => q.apply(this, [this.connection.connectionId])));
              } catch (q) {
                this.u.log(r.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${q}'.`);
              }
              return;
            } catch (q) {
              if (this.u.log(r.Information, `Reconnect attempt failed because of error '${q}'.`), this.ut !== Yt.Reconnecting) return this.u.log(r.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === Yt.Disconnecting && this.Dt());
              _ = q instanceof Error ? q : new Error(q.toString()), W = this.zt(M++, Date.now() - k, _);
            }
          }
          this.u.log(r.Information, `Reconnect retries have been exhausted after ${Date.now() - k} ms and ${M} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(w, k, M) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: k, previousRetryCount: w, retryReason: M });
          } catch (_) {
            return this.u.log(r.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${w}, ${k}) threw error '${_}'.`), null;
          }
        }
        Xt(w) {
          const k = this.it;
          this.it = {}, Object.keys(k).forEach(((M) => {
            const _ = k[M];
            try {
              _(null, w);
            } catch (W) {
              this.u.log(r.Error, `Stream 'error' callback called with '${w}' threw error: ${Bt(W)}`);
            }
          }));
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(w, k, M, _) {
          if (M) return _.length !== 0 ? { target: w, arguments: k, streamIds: _, type: Mt.Invocation } : { target: w, arguments: k, type: Mt.Invocation };
          {
            const W = this.ct;
            return this.ct++, _.length !== 0 ? { target: w, arguments: k, invocationId: W.toString(), streamIds: _, type: Mt.Invocation } : { target: w, arguments: k, invocationId: W.toString(), type: Mt.Invocation };
          }
        }
        qt(w, k) {
          if (w.length !== 0) {
            k || (k = Promise.resolve());
            for (const M in w) w[M].subscribe({ complete: /* @__PURE__ */ h(() => {
              k = k.then((() => this.xt(this.Bt(M))));
            }, "complete"), error: /* @__PURE__ */ h((_) => {
              let W;
              W = _ instanceof Error ? _.message : _ && _.toString ? _.toString() : "Unknown error", k = k.then((() => this.xt(this.Bt(M, W))));
            }, "error"), next: /* @__PURE__ */ h((_) => {
              k = k.then((() => this.xt(this.Vt(M, _))));
            }, "next") });
          }
        }
        Ut(w) {
          const k = [], M = [];
          for (let _ = 0; _ < w.length; _++) {
            const W = w[_];
            if (this.Kt(W)) {
              const q = this.ct;
              this.ct++, k[q] = W, M.push(q.toString()), w.splice(_, 1);
            }
          }
          return [k, M];
        }
        Kt(w) {
          return w && w.subscribe && typeof w.subscribe == "function";
        }
        Lt(w, k, M) {
          const _ = this.ct;
          return this.ct++, M.length !== 0 ? { target: w, arguments: k, invocationId: _.toString(), streamIds: M, type: Mt.StreamInvocation } : { target: w, arguments: k, invocationId: _.toString(), type: Mt.StreamInvocation };
        }
        Nt(w) {
          return { invocationId: w, type: Mt.CancelInvocation };
        }
        Vt(w, k) {
          return { invocationId: w, item: k, type: Mt.StreamItem };
        }
        Bt(w, k, M) {
          return k ? { error: k, invocationId: w, type: Mt.Completion } : { invocationId: w, result: M, type: Mt.Completion };
        }
        At() {
          return { type: Mt.Close };
        }
      }, c(Ea, "$d"), Ea);
      h(n3, "q");
      let r3 = n3;
      const ZD = [0, 2e3, 1e4, 3e4, null], s3 = (fc = class {
        constructor(w) {
          this.Gt = w !== void 0 ? [...w, null] : ZD;
        }
        nextRetryDelayInMilliseconds(w) {
          return this.Gt[w.previousRetryCount];
        }
      }, c(fc, "wp"), fc);
      h(s3, "j");
      let a3 = s3;
      const o3 = (mc = class {
      }, c(mc, "fp"), mc);
      h(o3, "W");
      let Ra = o3;
      Ra.Authorization = "Authorization", Ra.Cookie = "Cookie";
      const l3 = (yc = class extends Y {
        constructor(w, k) {
          super(), this.Qt = w, this.Yt = k;
        }
        async send(w) {
          let k = !0;
          this.Yt && (!this.Zt || w.url && w.url.indexOf("/negotiate?") > 0) && (k = !1, this.Zt = await this.Yt()), this.te(w);
          const M = await this.Qt.send(w);
          return k && M.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(w), await this.Qt.send(w)) : M;
        }
        te(w) {
          w.headers || (w.headers = {}), this.Zt ? w.headers[Ra.Authorization] = `Bearer ${this.Zt}` : this.Yt && w.headers[Ra.Authorization] && delete w.headers[Ra.Authorization];
        }
        getCookieString(w) {
          return this.Qt.getCookieString(w);
        }
      }, c(yc, "mp"), yc);
      h(l3, "O");
      let XD = l3;
      var ke, Ue;
      (function(B) {
        B[B.None = 0] = "None", B[B.WebSockets = 1] = "WebSockets", B[B.ServerSentEvents = 2] = "ServerSentEvents", B[B.LongPolling = 4] = "LongPolling";
      })(ke || (ke = {})), (function(B) {
        B[B.Text = 1] = "Text", B[B.Binary = 2] = "Binary";
      })(Ue || (Ue = {}));
      const c3 = (gc = class {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      }, c(gc, "vp"), gc);
      h(c3, "X");
      let ND = c3;
      const h3 = (wc = class {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(w, k, M) {
          this.$ = w, this.u = k, this.se = new ND(), this.ie = M, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(w, k) {
          if (st.isRequired(w, "url"), st.isRequired(k, "transferFormat"), st.isIn(k, Ue, "transferFormat"), this.re = w, this.u.log(r.Trace, "(LongPolling transport) Connecting."), k === Ue.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [M, _] = fe(), W = { [M]: _, ...this.ie.headers }, q = { abortSignal: this.se.signal, headers: W, timeout: 1e5, withCredentials: this.ie.withCredentials };
          k === Ue.Binary && (q.responseType = "arraybuffer");
          const ot = `${w}&_=${Date.now()}`;
          this.u.log(r.Trace, `(LongPolling transport) polling: ${ot}.`);
          const lt = await this.$.get(ot, q);
          lt.statusCode !== 200 ? (this.u.log(r.Error, `(LongPolling transport) Unexpected response code: ${lt.statusCode}.`), this.oe = new o(lt.statusText || "", lt.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, q);
        }
        async ce(w, k) {
          try {
            for (; this.ne; ) try {
              const M = `${w}&_=${Date.now()}`;
              this.u.log(r.Trace, `(LongPolling transport) polling: ${M}.`);
              const _ = await this.$.get(M, k);
              _.statusCode === 204 ? (this.u.log(r.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : _.statusCode !== 200 ? (this.u.log(r.Error, `(LongPolling transport) Unexpected response code: ${_.statusCode}.`), this.oe = new o(_.statusText || "", _.statusCode), this.ne = !1) : _.content ? (this.u.log(r.Trace, `(LongPolling transport) data received. ${It(_.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(_.content)) : this.u.log(r.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (M) {
              this.ne ? M instanceof d ? this.u.log(r.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = M, this.ne = !1) : this.u.log(r.Trace, `(LongPolling transport) Poll errored after shutdown: ${M.message}`);
            }
          } finally {
            this.u.log(r.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(w) {
          return this.ne ? qt(this.u, "LongPolling", this.$, this.re, w, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(r.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(r.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const w = {}, [k, M] = fe();
            w[k] = M;
            const _ = { headers: { ...w, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let W;
            try {
              await this.$.delete(this.re, _);
            } catch (q) {
              W = q;
            }
            W ? W instanceof o && (W.statusCode === 404 ? this.u.log(r.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(r.Trace, `(LongPolling transport) Error sending a DELETE request: ${W}`)) : this.u.log(r.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(r.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let w = "(LongPolling transport) Firing onclose event.";
            this.oe && (w += " Error: " + this.oe), this.u.log(r.Trace, w), this.onclose(this.oe);
          }
        }
      }, c(wc, "gp"), wc);
      h(h3, "J");
      let d3 = h3;
      const u3 = (vc = class {
        constructor(w, k, M, _) {
          this.$ = w, this.Zt = k, this.u = M, this.ie = _, this.onreceive = null, this.onclose = null;
        }
        async connect(w, k) {
          return st.isRequired(w, "url"), st.isRequired(k, "transferFormat"), st.isIn(k, Ue, "transferFormat"), this.u.log(r.Trace, "(SSE transport) Connecting."), this.re = w, this.Zt && (w += (w.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise(((M, _) => {
            let W, q = !1;
            if (k === Ue.Text) {
              if (Qt.isBrowser || Qt.isWebWorker) W = new this.ie.EventSource(w, { withCredentials: this.ie.withCredentials });
              else {
                const ot = this.$.getCookieString(w), lt = {};
                lt.Cookie = ot;
                const [At, Ut] = fe();
                lt[At] = Ut, W = new this.ie.EventSource(w, { withCredentials: this.ie.withCredentials, headers: { ...lt, ...this.ie.headers } });
              }
              try {
                W.onmessage = (ot) => {
                  if (this.onreceive) try {
                    this.u.log(r.Trace, `(SSE transport) data received. ${It(ot.data, this.ie.logMessageContent)}.`), this.onreceive(ot.data);
                  } catch (lt) {
                    return void this.le(lt);
                  }
                }, W.onerror = (ot) => {
                  q ? this.le() : _(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, W.onopen = () => {
                  this.u.log(r.Information, `SSE connected to ${this.re}`), this.ue = W, q = !0, M();
                };
              } catch (ot) {
                return void _(ot);
              }
            } else _(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          }));
        }
        async send(w) {
          return this.ue ? qt(this.u, "SSE", this.$, this.re, w, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(w) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(w));
        }
      }, c(vc, "bp"), vc);
      h(u3, "z");
      let jD = u3;
      const p3 = (Oc = class {
        constructor(w, k, M, _, W, q) {
          this.u = M, this.Yt = k, this.de = _, this.fe = W, this.$ = w, this.onreceive = null, this.onclose = null, this.pe = q;
        }
        async connect(w, k) {
          let M;
          return st.isRequired(w, "url"), st.isRequired(k, "transferFormat"), st.isIn(k, Ue, "transferFormat"), this.u.log(r.Trace, "(WebSockets transport) Connecting."), this.Yt && (M = await this.Yt()), new Promise(((_, W) => {
            let q;
            w = w.replace(/^http/, "ws");
            const ot = this.$.getCookieString(w);
            let lt = !1;
            if (Qt.isNode || Qt.isReactNative) {
              const At = {}, [Ut, Sc] = fe();
              At[Ut] = Sc, M && (At[Ra.Authorization] = `Bearer ${M}`), ot && (At[Ra.Cookie] = ot), q = new this.fe(w, void 0, { headers: { ...At, ...this.pe } });
            } else M && (w += (w.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(M)}`);
            q || (q = new this.fe(w)), k === Ue.Binary && (q.binaryType = "arraybuffer"), q.onopen = (At) => {
              this.u.log(r.Information, `WebSocket connected to ${w}.`), this.we = q, lt = !0, _();
            }, q.onerror = (At) => {
              let Ut = null;
              Ut = typeof ErrorEvent < "u" && At instanceof ErrorEvent ? At.error : "There was an error with the transport", this.u.log(r.Information, `(WebSockets transport) ${Ut}.`);
            }, q.onmessage = (At) => {
              if (this.u.log(r.Trace, `(WebSockets transport) data received. ${It(At.data, this.de)}.`), this.onreceive) try {
                this.onreceive(At.data);
              } catch (Ut) {
                return void this.le(Ut);
              }
            }, q.onclose = (At) => {
              if (lt) this.le(At);
              else {
                let Ut = null;
                Ut = typeof ErrorEvent < "u" && At instanceof ErrorEvent ? At.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", W(new Error(Ut));
              }
            };
          }));
        }
        send(w) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(r.Trace, `(WebSockets transport) sending data. ${It(w, this.de)}.`), this.we.send(w), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(w) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(r.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(w) || w.wasClean !== !1 && w.code === 1e3 ? w instanceof Error ? this.onclose(w) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${w.code} (${w.reason || "no reason given"}).`)));
        }
        ge(w) {
          return w && typeof w.wasClean == "boolean" && typeof w.code == "number";
        }
      }, c(Oc, "xp"), Oc);
      h(p3, "V");
      let BD = p3;
      const f3 = (bc = class {
        constructor(w, k = {}) {
          var M;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, st.isRequired(w, "url"), this.u = (M = k.logger) === void 0 ? new ee(r.Information) : M === null ? ct.instance : M.log !== void 0 ? M : new ee(M), this.baseUrl = this.be(w), (k = k || {}).logMessageContent = k.logMessageContent !== void 0 && k.logMessageContent, typeof k.withCredentials != "boolean" && k.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          k.withCredentials = k.withCredentials === void 0 || k.withCredentials, k.timeout = k.timeout === void 0 ? 1e5 : k.timeout;
          let _ = null, W = null;
          if (Qt.isNode) {
            const q = Cv;
            _ = q("ws"), W = q("eventsource");
          }
          Qt.isNode || typeof WebSocket > "u" || k.WebSocket ? Qt.isNode && !k.WebSocket && _ && (k.WebSocket = _) : k.WebSocket = WebSocket, Qt.isNode || typeof EventSource > "u" || k.EventSource ? Qt.isNode && !k.EventSource && W !== void 0 && (k.EventSource = W) : k.EventSource = EventSource, this.$ = new XD(k.httpClient || new Y4(this.u), k.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = k, this.onreceive = null, this.onclose = null;
        }
        async start(w) {
          if (w = w || Ue.Binary, st.isIn(w, Ue, "transferFormat"), this.u.log(r.Debug, `Starting connection with transfer format '${Ue[w]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(w), await this.ve, this.ut === "Disconnecting") {
            const k = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(r.Error, k), await this.It, Promise.reject(new p(k));
          }
          if (this.ut !== "Connected") {
            const k = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(r.Error, k), Promise.reject(new p(k));
          }
          this.dt = !0;
        }
        send(w) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new HD(this.transport)), this.Ee.send(w));
        }
        async stop(w) {
          return this.ut === "Disconnected" ? (this.u.log(r.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(r.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise(((k) => {
            this.me = k;
          })), await this._t(w), void await this.It);
        }
        async _t(w) {
          this.$e = w;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (k) {
              this.u.log(r.Error, `HttpConnection.transport.stop() threw error '${k}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(r.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(w) {
          let k = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== ke.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(ke.WebSockets), await this.ke(k, w);
            } else {
              let M = null, _ = 0;
              do {
                if (M = await this.Pe(k), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new p("The connection was stopped during negotiation.");
                if (M.error) throw new Error(M.error);
                if (M.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (M.url && (k = M.url), M.accessToken) {
                  const W = M.accessToken;
                  this.Yt = () => W, this.$.Zt = W, this.$.Yt = void 0;
                }
                _++;
              } while (M.url && _ < 100);
              if (_ === 100 && M.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(k, this.ie.transport, M, w);
            }
            this.transport instanceof d3 && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(r.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (M) {
            return this.u.log(r.Error, "Failed to start the connection: " + M), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(M);
          }
        }
        async Pe(w) {
          const k = {}, [M, _] = fe();
          k[M] = _;
          const W = this.Ie(w);
          this.u.log(r.Debug, `Sending negotiation request: ${W}.`);
          try {
            const q = await this.$.post(W, { content: "", headers: { ...k, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (q.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${q.statusCode}'`));
            const ot = JSON.parse(q.content);
            return (!ot.negotiateVersion || ot.negotiateVersion < 1) && (ot.connectionToken = ot.connectionId), ot.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new E("Client didn't negotiate Stateful Reconnect but the server did.")) : ot;
          } catch (q) {
            let ot = "Failed to complete negotiation with the server: " + q;
            return q instanceof o && q.statusCode === 404 && (ot += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(r.Error, ot), Promise.reject(new E(ot));
          }
        }
        He(w, k) {
          return k ? w + (w.indexOf("?") === -1 ? "?" : "&") + `id=${k}` : w;
        }
        async Te(w, k, M, _) {
          let W = this.He(w, M.connectionToken);
          if (this.De(k)) return this.u.log(r.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = k, await this.ke(W, _), void (this.connectionId = M.connectionId);
          const q = [], ot = M.availableTransports || [];
          let lt = M;
          for (const At of ot) {
            const Ut = this.Re(At, k, _, lt?.useStatefulReconnect === !0);
            if (Ut instanceof Error) q.push(`${At.transport} failed:`), q.push(Ut);
            else if (this.De(Ut)) {
              if (this.transport = Ut, !lt) {
                try {
                  lt = await this.Pe(w);
                } catch (Sc) {
                  return Promise.reject(Sc);
                }
                W = this.He(w, lt.connectionToken);
              }
              try {
                return await this.ke(W, _), void (this.connectionId = lt.connectionId);
              } catch (Sc) {
                if (this.u.log(r.Error, `Failed to start the transport '${At.transport}': ${Sc}`), lt = void 0, q.push(new $(`${At.transport} failed: ${Sc}`, ke[At.transport])), this.ut !== "Connecting") {
                  const O3 = "Failed to select transport before stop() was called.";
                  return this.u.log(r.Debug, O3), Promise.reject(new p(O3));
                }
              }
            }
          }
          return q.length > 0 ? Promise.reject(new A(`Unable to connect to the server with any of the available transports. ${q.join(" ")}`, q)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(w) {
          switch (w) {
            case ke.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new BD(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case ke.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new jD(this.$, this.$.Zt, this.u, this.ie);
            case ke.LongPolling:
              return new d3(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${w}.`);
          }
        }
        ke(w, k) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (M) => {
            let _ = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(w, k), await this.features.resend();
              } catch {
                _ = !0;
              }
              _ && this.Ce(M);
            } else this.Ce(M);
          } : this.transport.onclose = (M) => this.Ce(M), this.transport.connect(w, k);
        }
        Re(w, k, M, _) {
          const W = ke[w.transport];
          if (W == null) return this.u.log(r.Debug, `Skipping transport '${w.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${w.transport}' because it is not supported by this client.`);
          if (!(function(q, ot) {
            return !q || !!(ot & q);
          })(k, W)) return this.u.log(r.Debug, `Skipping transport '${ke[W]}' because it was disabled by the client.`), new b(`'${ke[W]}' is disabled by the client.`, W);
          if (!(w.transferFormats.map(((q) => Ue[q])).indexOf(M) >= 0)) return this.u.log(r.Debug, `Skipping transport '${ke[W]}' because it does not support the requested transfer format '${Ue[M]}'.`), new Error(`'${ke[W]}' does not support ${Ue[M]}.`);
          if (W === ke.WebSockets && !this.ie.WebSocket || W === ke.ServerSentEvents && !this.ie.EventSource) return this.u.log(r.Debug, `Skipping transport '${ke[W]}' because it is not supported in your environment.'`), new y(`'${ke[W]}' is not supported in your environment.`, W);
          this.u.log(r.Debug, `Selecting transport '${ke[W]}'.`);
          try {
            return this.features.reconnect = W === ke.WebSockets ? _ : void 0, this.Se(W);
          } catch (q) {
            return q;
          }
        }
        De(w) {
          return w && typeof w == "object" && "connect" in w;
        }
        Ce(w) {
          if (this.u.log(r.Debug, `HttpConnection.stopConnection(${w}) called while in state ${this.ut}.`), this.transport = void 0, w = this.$e || w, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(r.Warning, `Call to HttpConnection.stopConnection(${w}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${w}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), w ? this.u.log(r.Error, `Connection disconnected with error '${w}'.`) : this.u.log(r.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch(((k) => {
              this.u.log(r.Error, `TransportSendQueue.stop() threw error '${k}'.`);
            })), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(w);
              } catch (k) {
                this.u.log(r.Error, `HttpConnection.onclose(${w}) threw error '${k}'.`);
              }
            }
          } else this.u.log(r.Debug, `Call to HttpConnection.stopConnection(${w}) was ignored because the connection is already in the disconnected state.`);
        }
        be(w) {
          if (w.lastIndexOf("https://", 0) === 0 || w.lastIndexOf("http://", 0) === 0) return w;
          if (!Qt.isBrowser) throw new Error(`Cannot resolve '${w}'.`);
          const k = window.document.createElement("a");
          return k.href = w, this.u.log(r.Information, `Normalizing '${w}' to '${k.href}'.`), k.href;
        }
        Ie(w) {
          const k = new URL(w);
          k.pathname.endsWith("/") ? k.pathname += "negotiate" : k.pathname += "/negotiate";
          const M = new URLSearchParams(k.searchParams);
          return M.has("negotiateVersion") || M.append("negotiateVersion", this.ye.toString()), M.has("useStatefulReconnect") ? M.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && M.append("useStatefulReconnect", "true"), k.search = M.toString(), k.toString();
        }
      }, c(bc, "$p"), bc);
      h(f3, "K");
      let UD = f3;
      const m3 = (_a = class {
        constructor(w) {
          this.xe = w, this.Ae = [], this.Ue = !0, this.Le = new A1(), this.Ne = new A1(), this.qe = this.Me();
        }
        send(w) {
          return this.je(w), this.Ne || (this.Ne = new A1()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(w) {
          if (this.Ae.length && typeof this.Ae[0] != typeof w) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof w}`);
          this.Ae.push(w), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new A1();
            const w = this.Ne;
            this.Ne = void 0;
            const k = typeof this.Ae[0] == "string" ? this.Ae.join("") : _a.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(k), w.resolve();
            } catch (M) {
              w.reject(M);
            }
          }
        }
        static We(w) {
          const k = w.map(((W) => W.byteLength)).reduce(((W, q) => W + q)), M = new Uint8Array(k);
          let _ = 0;
          for (const W of w) M.set(new Uint8Array(W), _), _ += W.byteLength;
          return M.buffer;
        }
      }, c(_a, "Cd"), _a);
      h(m3, "G");
      let HD = m3;
      const y3 = ($c = class {
        constructor() {
          this.promise = new Promise(((w, k) => [this.j, this.Oe] = [w, k]));
        }
        resolve() {
          this.j();
        }
        reject(w) {
          this.Oe(w);
        }
      }, c($c, "Cp"), $c);
      h(y3, "Q");
      let A1 = y3;
      const g3 = (xc = class {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = Ue.Text;
        }
        parseMessages(w, k) {
          if (typeof w != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!w) return [];
          k === null && (k = ct.instance);
          const M = Or.parse(w), _ = [];
          for (const W of M) {
            const q = JSON.parse(W);
            if (typeof q.type != "number") throw new Error("Invalid payload.");
            switch (q.type) {
              case Mt.Invocation:
                this.U(q);
                break;
              case Mt.StreamItem:
                this.Fe(q);
                break;
              case Mt.Completion:
                this.Be(q);
                break;
              case Mt.Ping:
              case Mt.Close:
                break;
              case Mt.Ack:
                this.Xe(q);
                break;
              case Mt.Sequence:
                this.Je(q);
                break;
              default:
                k.log(r.Information, "Unknown message type '" + q.type + "' ignored.");
                continue;
            }
            _.push(q);
          }
          return _;
        }
        writeMessage(w) {
          return Or.write(JSON.stringify(w));
        }
        U(w) {
          this.ze(w.target, "Invalid payload for Invocation message."), w.invocationId !== void 0 && this.ze(w.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(w) {
          if (this.ze(w.invocationId, "Invalid payload for StreamItem message."), w.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(w) {
          if (w.result && w.error) throw new Error("Invalid payload for Completion message.");
          !w.result && w.error && this.ze(w.error, "Invalid payload for Completion message."), this.ze(w.invocationId, "Invalid payload for Completion message.");
        }
        Xe(w) {
          if (typeof w.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(w) {
          if (typeof w.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(w, k) {
          if (typeof w != "string" || w === "") throw new Error(k);
        }
      }, c(xc, "kp"), xc);
      h(g3, "Y");
      let w3 = g3;
      const YD = { trace: r.Trace, debug: r.Debug, info: r.Information, information: r.Information, warn: r.Warning, warning: r.Warning, error: r.Error, critical: r.Critical, none: r.None }, v3 = (kc = class {
        configureLogging(w) {
          if (st.isRequired(w, "logging"), w.log !== void 0) this.logger = w;
          else if (typeof w == "string") {
            const k = (function(M) {
              const _ = YD[M.toLowerCase()];
              if (_ !== void 0) return _;
              throw new Error(`Unknown log level: ${M}`);
            })(w);
            this.logger = new ee(k);
          } else this.logger = new ee(w);
          return this;
        }
        withUrl(w, k) {
          return st.isRequired(w, "url"), st.isNotEmpty(w, "url"), this.url = w, this.httpConnectionOptions = typeof k == "object" ? { ...this.httpConnectionOptions, ...k } : { ...this.httpConnectionOptions, transport: k }, this;
        }
        withHubProtocol(w) {
          return st.isRequired(w, "protocol"), this.protocol = w, this;
        }
        withAutomaticReconnect(w) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return w ? Array.isArray(w) ? this.reconnectPolicy = new a3(w) : this.reconnectPolicy = w : this.reconnectPolicy = new a3(), this;
        }
        withServerTimeout(w) {
          return st.isRequired(w, "milliseconds"), this.Ve = w, this;
        }
        withKeepAliveInterval(w) {
          return st.isRequired(w, "milliseconds"), this.Ke = w, this;
        }
        withStatefulReconnect(w) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = w?.bufferSize, this;
        }
        build() {
          const w = this.httpConnectionOptions || {};
          if (w.logger === void 0 && (w.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const k = new UD(this.url, w);
          return r3.create(k, this.logger || ct.instance, this.protocol || new w3(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      }, c(kc, "_p"), kc);
      h(v3, "tt");
      let GD = v3;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ h(function(B, w) {
        return new Uint8Array(Array.prototype.slice.call(this, B, w));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), s;
    })(), "e"), n.exports = e();
  })(jQ)), jQ.exports;
}
c(S_, "_1");
h(S_, "requireSignalr_min");
var UQ = /* @__PURE__ */ S_();
const bj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._whenConnectionRequested = new Promise((s) => {
        this._resolveConnectionRequested = s;
      }), this._whenConnectionCreated = new Promise((s) => {
        this._resolveConnectionCreated = s;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((s, a) => {
        this._whenConnectionStartedResolve = s, this._whenConnectionStartedReject = a;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      if (this.isDestroyed)
        throw new Ce();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const r = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== r.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          r.toString()
        ), await this.disconnect(), this._connection.baseUrl = r.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const r = new URL("/hubs/rtm", this.url);
        this._connection = new UQ.HubConnectionBuilder().configureLogging(UQ.LogLevel.None).withUrl(r.toString(), {
          accessTokenFactory: /* @__PURE__ */ h(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const s = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, s;
              } else
                return await this.getToken();
            } catch (s) {
              throw console.error(s), s;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ h((s) => !this.isDestroyed && window.navigator.onLine && document?.visibilityState !== "hidden" && s.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][s.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((s, a) => {
            this._whenConnectionStartedResolve = s, this._whenConnectionStartedReject = a;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((s) => {
          console.info(this.weavyId, `SignalR reconnected ${s}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let a = 0; a < this._connectionEventListeners.length; a++)
            this._connection?.invoke("Subscribe", this._connectionEventListeners[a].name);
        }), this._resolveConnectionCreated?.(this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      if (this.isDestroyed)
        throw new Ce();
      let r;
      this._connection ? r = this._connection : r = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([r.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", this._whenConnectionStartedResolve?.(r), console.info(this.weavyId, `SignalR connected ${r.connectionId}`);
      } catch (s) {
        if (s instanceof Ce)
          return console.warn(this.weavyId, "SignalR connection aborted."), r;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && s.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((a) => {
          setTimeout(a, 5e3), window.addEventListener("visibilitychange", a, { once: !0 }), window.addEventListener("offline", a, { once: !0 }), window.addEventListener("online", a, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((a) => {
          window.addEventListener("online", a, { once: !0 });
        })), window.navigator.onLine && document?.visibilityState !== "hidden" && await new Promise((a) => setTimeout(a, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return r;
    }
    async subscribe(r, s, a) {
      if (this.isDestroyed)
        throw new Ce();
      this._resolveConnectionRequested?.(!0);
      const o = r ? r + ":" + s : s;
      try {
        if (this._connectionEventListeners || await new Promise((l) => queueMicrotask(() => l(!0))), this._connectionEventListeners.some((l) => l.name === o && l.callback === a))
          throw new Error("Duplicate subscribe: " + o);
        if (this._connectionEventListeners.push({ name: o, callback: a }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(o, a), await this._connection.invoke("Subscribe", o) === !1)
          throw new Error("Could not subscribe to " + o);
        return !0;
      } catch (l) {
        l instanceof Ce || console.error(this.weavyId, "Error in Subscribe:", l);
        const d = this._connectionEventListeners.findIndex((u) => u.name === o && u.callback === a);
        return d !== -1 && (this._connectionEventListeners.splice(d, 1), this._connection?.off(o, a)), !1;
      }
    }
    async unsubscribe(r, s, a) {
      if (this.isDestroyed)
        throw new Ce();
      try {
        const o = r ? r + ":" + s : s, l = this._connectionEventListeners.findIndex((d) => d.name === o && d.callback === a);
        if (l !== -1) {
          if (this._connectionEventListeners.splice(l, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          this._connection?.off(o, a), this._connectionEventListeners.some((d) => d.name === o) || await this._connection.invoke("Unsubscribe", o);
        }
      } catch (o) {
        o instanceof Ce || console.error(this.weavyId, "Error in Unsubscribe:", o);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Ce()));
    }
  }, c(e, "t"), e), h(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var IO = /* @__PURE__ */ ((n) => (n.JSON = "application/json;charset=utf-8", n.FormData = "multipart/form-data;charset=utf-8", n.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", n.Text = "text/plain;charset=utf-8", n.Auto = "", n))(IO || {});
const $j = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // FETCH
    async fetchOptions(r = {}, s = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const a = {
        headers: {
          "X-Weavy-Source": `${_e.sourceName}@${_e.version}`,
          "Content-Type": IO.JSON
        },
        method: "GET"
      }, o = oo(oo(vj, a, !0), r, !0);
      return s ? oo(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(r, s, a = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const o = await this.fetchOptions(s);
      this.networkStateIsPending = !0;
      const l = await fetch(new URL(r, this.url), o);
      if (l.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (l.status === 401 || l.status === 403) {
        if (a)
          return await this.getToken(!0), await this.fetch(r, s, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return l;
    }
    async upload(r, s, a, o = IO.JSON, l, d, u = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const p = await this.getToken();
      return await new Promise((f, y) => {
        const g = new XMLHttpRequest();
        g.open(s, new URL(r, this.url), !0), g.setRequestHeader("Authorization", "Bearer " + p), g.setRequestHeader("X-Weavy-Source", `${_e.sourceName}@${_e.version}`), o && g.setRequestHeader("Content-Type", o), l && g.upload.addEventListener("progress", (b) => {
          l(b.loaded / b.total * 100 || 100);
        }), g.onload = (b) => {
          u && (g.status === 401 || g.status === 401) ? this.getToken(!0).then(() => this.upload(r, s, a, o, l, d, !1)).then(f).catch(y) : f(new Response(g.response, { status: g.status, statusText: g.statusText }));
        }, g.onerror = y, g.onabort = y, d?.addEventListener("abort", () => {
          g.abort();
        }), g.send(a);
      });
    }
    // DEPRECATED
    async get(r) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${r}") instead.`), this.fetch(r);
    }
    // DEPRECATED
    async post(r, s, a, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${r}", { method: "${s}"}) instead.`
      );
      const l = o ? { "Content-Type": o } : void 0;
      return this.fetch(r, { method: s, body: a, headers: l });
    }
  }, c(e, "t"), e), h(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), C_ = "en", xj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE-DNn-JJCG.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((r) => r.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return C_;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(r) {
      if (this.isDestroyed)
        throw new Ce();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (r) {
        if (!Array.isArray(r))
          throw new TypeError("Provided locales have invalid format.");
        r.forEach((s) => {
          if (!Array.isArray(s) || s.length !== 2 || typeof s[0] != "string")
            throw new TypeError("Invalid locale provided: " + s[0]);
          this._locales.set(...s);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(r) {
      if (this.isDestroyed)
        throw new Ce();
      !this._locale && !r || (r ||= t.sourceLocale, this._locale = r, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${r}'.`
        ));
      }));
    }
    async loadLocale(r) {
      if (this.isDestroyed)
        throw new Ce();
      if (this._locales?.has(r)) {
        const s = this._locales.get(r);
        return console.info(
          this.weavyId,
          typeof s == "function" ? "loading locale" : "preloaded locale",
          r
        ), await (typeof s == "function" ? s() : s);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      if (this.isDestroyed)
        throw new Ce();
      if (this._locales?.size && !this.localization) {
        const r = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", r);
        const { getLocale: s, setLocale: a } = _N({
          sourceLocale: t.sourceLocale,
          targetLocales: r,
          loadLocale: /* @__PURE__ */ h((o) => this.loadLocale(o), "loadLocale")
        });
        this._localization = {
          getLocale: s,
          setLocale: a
        };
      }
    }
  }, c(e, "t"), e), h(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), kj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._configurationState = "pending", this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      }), queueMicrotask(() => this.requestConfigurationCheck());
    }
    get configurationState() {
      return this._configurationState;
    }
    set configurationState(r) {
      this._configurationState = r, this._configurationTimer && r === "configured" && (window.clearTimeout(this._configurationTimer), this._configurationTimer = null), this.triggerNetworkChange();
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(r) {
      this._networkState = r, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(r) {
      this._serverState = r, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(r) {
      this._connectionState = r, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(r) {
      this._networkStateIsPending = r, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? (this._connectionState === "connected" || this._serverState === "ok") && this.configurationState !== "uninitialized" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    requestConfigurationCheck() {
      !this._configurationTimer && this.configurationTimeout >= 0 && this.configurationTimeout < 1 / 0 && (this._configurationTimer = window.setTimeout(() => {
        this.configurationState === "pending" && (this.configurationState = "uninitialized", console.error("Weavy was not configured with required url and tokenFactory/tokenUrl within a reasonable time. Please check your configuration!")), this._configurationTimer = null;
      }, this.configurationTimeout));
    }
    triggerNetworkChange() {
      const r = this.network;
      this._networkEvents.forEach((s) => {
        s(r);
      });
    }
    addNetworkListener(r) {
      this._networkEvents.add(r);
    }
    removeNetworkListener(r) {
      this._networkEvents.delete(r);
    }
  }, c(e, "t"), e), h(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
var O2, Lu, my = (O2 = (Lu = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, c(Lu, "vn"), Lu), h(O2, "Subscribable"), O2), Sj = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: /* @__PURE__ */ h((n, t) => setTimeout(n, t), "setTimeout"),
  clearTimeout: /* @__PURE__ */ h((n) => clearTimeout(n), "clearTimeout"),
  setInterval: /* @__PURE__ */ h((n, t) => setInterval(n, t), "setInterval"),
  clearInterval: /* @__PURE__ */ h((n) => clearInterval(n), "clearInterval")
}, Va, HQ, b2, Iu, Cj = (b2 = (Iu = class {
  constructor() {
    F(this, Va, Sj), F(this, HQ, !1);
  }
  setTimeoutProvider(t) {
    L(this, Va, t);
  }
  setTimeout(t, e) {
    return x(this, Va).setTimeout(t, e);
  }
  clearTimeout(t) {
    x(this, Va).clearTimeout(t);
  }
  setInterval(t, e) {
    return x(this, Va).setInterval(t, e);
  }
  clearInterval(t) {
    x(this, Va).clearInterval(t);
  }
}, c(Iu, "gn"), Iu), Va = /* @__PURE__ */ new WeakMap(), HQ = /* @__PURE__ */ new WeakMap(), h(b2, "TimeoutManager"), b2), Ms = new Cj();
function P_(n) {
  setTimeout(n, 0);
}
c(P_, "E1");
h(P_, "systemSetTimeoutZero");
var Nm = typeof window > "u" || "Deno" in globalThis;
function Ke() {
}
c(Ke, "me");
h(Ke, "noop$1");
function Q_(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(Q_, "L1");
h(Q_, "functionalUpdate");
function VO(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
c(VO, "Np");
h(VO, "isValidTimeout");
function vP(n, t) {
  return Math.max(n + (t || 0) - Date.now(), 0);
}
c(vP, "Nf");
h(vP, "timeUntilStale");
function jr(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(jr, "_r");
h(jr, "resolveStaleTime");
function Ui(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(Ui, "Ye");
h(Ui, "resolveEnabled");
function R5(n, t) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: r,
    predicate: s,
    queryKey: a,
    stale: o
  } = n;
  if (a) {
    if (i) {
      if (t.queryHash !== N0(a, t.options))
        return !1;
    } else if (!jm(t.queryKey, a))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof o == "boolean" && t.isStale() !== o || r && r !== t.state.fetchStatus || s && !s(t));
}
c(R5, "kw");
h(R5, "matchQuery");
function E5(n, t) {
  const { exact: e, status: i, predicate: r, mutationKey: s } = n;
  if (s) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (ha(t.options.mutationKey) !== ha(s))
        return !1;
    } else if (!jm(t.options.mutationKey, s))
      return !1;
  }
  return !(i && t.state.status !== i || r && !r(t));
}
c(E5, "_w");
h(E5, "matchMutation");
function N0(n, t) {
  return (t?.queryKeyHashFn || ha)(n);
}
c(N0, "Bu");
h(N0, "hashQueryKeyByOptions");
function ha(n) {
  return JSON.stringify(
    n,
    (t, e) => DO(e) ? Object.keys(e).sort().reduce((i, r) => (i[r] = e[r], i), {}) : e
  );
}
c(ha, "ys");
h(ha, "hashKey");
function jm(n, t) {
  return n === t ? !0 : typeof n != typeof t ? !1 : n && t && typeof n == "object" && typeof t == "object" ? Object.keys(t).every((e) => jm(n[e], t[e])) : !1;
}
c(jm, "al");
h(jm, "partialMatchKey");
var Pj = Object.prototype.hasOwnProperty;
function yy(n, t) {
  if (n === t)
    return n;
  const e = _5(n) && _5(t);
  if (!e && !(DO(n) && DO(t))) return t;
  const i = (e ? n : Object.keys(n)).length, r = e ? t : Object.keys(t), s = r.length, a = e ? new Array(s) : {};
  let o = 0;
  for (let l = 0; l < s; l++) {
    const d = e ? l : r[l], u = n[d], p = t[d];
    if (u === p) {
      a[d] = u, (e ? l < i : Pj.call(n, d)) && o++;
      continue;
    }
    if (u === null || p === null || typeof u != "object" || typeof p != "object") {
      a[d] = p;
      continue;
    }
    const f = yy(u, p);
    a[d] = f, f === u && o++;
  }
  return i === s && o === i ? n : a;
}
c(yy, "id");
h(yy, "replaceEqualDeep");
function Cw(n, t) {
  if (!t || Object.keys(n).length !== Object.keys(t).length)
    return !1;
  for (const e in n)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
c(Cw, "Dd");
h(Cw, "shallowEqualObjects");
function _5(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
c(_5, "Pw");
h(_5, "isPlainArray");
function DO(n) {
  if (!z5(n))
    return !1;
  const t = n.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!z5(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(n) !== Object.prototype);
}
c(DO, "jp");
h(DO, "isPlainObject");
function z5(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
c(z5, "Mw");
h(z5, "hasObjectPrototype");
function T_(n) {
  return new Promise((t) => {
    Ms.setTimeout(t, n);
  });
}
c(T_, "I1");
h(T_, "sleep");
function WO(n, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(n, t) : e.structuralSharing !== !1 ? yy(n, t) : t;
}
c(WO, "Wp");
h(WO, "replaceData");
function M_(n, t, e = 0) {
  const i = [...n, t];
  return e && i.length > e ? i.slice(1) : i;
}
c(M_, "T1");
h(M_, "addToEnd");
function A_(n, t, e = 0) {
  const i = [t, ...n];
  return e && i.length > e ? i.slice(0, -1) : i;
}
c(A_, "F1");
h(A_, "addToStart");
var OP = Symbol();
function bP(n, t) {
  return !n.queryFn && t?.initialPromise ? () => t.initialPromise : !n.queryFn || n.queryFn === OP ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`)) : n.queryFn;
}
c(bP, "jf");
h(bP, "ensureQueryFn");
var Pc, Da, qy, $2, Vu, Qj = ($2 = (Vu = class extends my {
  constructor() {
    super(), F(this, Pc), F(this, Da), F(this, qy), L(this, qy, (t) => {
      if (!Nm && window.addEventListener) {
        const e = /* @__PURE__ */ h(() => t(), "listener");
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    });
  }
  onSubscribe() {
    x(this, Da) || this.setEventListener(x(this, qy));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = x(this, Da)) == null || t.call(this), L(this, Da, void 0));
  }
  setEventListener(t) {
    var e;
    L(this, qy, t), (e = x(this, Da)) == null || e.call(this), L(this, Da, t((i) => {
      typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
    }));
  }
  setFocused(t) {
    x(this, Pc) !== t && (L(this, Pc, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof x(this, Pc) == "boolean" ? x(this, Pc) : globalThis.document?.visibilityState !== "hidden";
  }
}, c(Vu, "xn"), Vu), Pc = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), qy = /* @__PURE__ */ new WeakMap(), h($2, "FocusManager"), $2), $P = new Qj();
function qO() {
  let n, t;
  const e = new Promise((r, s) => {
    n = r, t = s;
  });
  e.status = "pending", e.catch(() => {
  });
  function i(r) {
    Object.assign(e, r), delete e.resolve, delete e.reject;
  }
  return c(i, "r"), h(i, "finalize"), e.resolve = (r) => {
    i({
      status: "fulfilled",
      value: r
    }), n(r);
  }, e.reject = (r) => {
    i({
      status: "rejected",
      reason: r
    }), t(r);
  }, e;
}
c(qO, "Qp");
h(qO, "pendingThenable");
function R_(n) {
  let t;
  if (n.then((e) => (t = e, e), Ke)?.catch(Ke), t !== void 0)
    return { data: t };
}
c(R_, "H1");
h(R_, "tryResolveSync");
function xP(n) {
  return n;
}
c(xP, "Wf");
h(xP, "defaultTransformerFn");
function E_(n) {
  return {
    mutationKey: n.options.mutationKey,
    state: n.state,
    ...n.options.scope && { scope: n.options.scope },
    ...n.meta && { meta: n.meta }
  };
}
c(E_, "V1");
h(E_, "dehydrateMutation");
function __(n, t, e) {
  const i = /* @__PURE__ */ h(() => {
    const r = n.promise?.then(t).catch((s) => e(s) ? Promise.reject(new Error("redacted")) : Promise.reject(s));
    return r?.catch(Ke), r;
  }, "dehydratePromise");
  return {
    dehydratedAt: Date.now(),
    state: {
      ...n.state,
      ...n.state.data !== void 0 && {
        data: t(n.state.data)
      }
    },
    queryKey: n.queryKey,
    queryHash: n.queryHash,
    ...n.state.status === "pending" && {
      promise: i()
    },
    ...n.meta && { meta: n.meta }
  };
}
c(__, "U1");
h(__, "dehydrateQuery");
function z_(n) {
  return n.state.isPaused;
}
c(z_, "B1");
h(z_, "defaultShouldDehydrateMutation");
function L_(n) {
  return n.state.status === "success";
}
c(L_, "q1");
h(L_, "defaultShouldDehydrateQuery");
function I_(n) {
  return !0;
}
c(I_, "N1");
h(I_, "defaultShouldRedactErrors");
function V_(n, t = {}) {
  const e = t.shouldDehydrateMutation ?? n.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? z_, i = n.getMutationCache().getAll().flatMap(
    (l) => e(l) ? [E_(l)] : []
  ), r = t.shouldDehydrateQuery ?? n.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? L_, s = t.shouldRedactErrors ?? n.getDefaultOptions().dehydrate?.shouldRedactErrors ?? I_, a = t.serializeData ?? n.getDefaultOptions().dehydrate?.serializeData ?? xP, o = n.getQueryCache().getAll().flatMap(
    (l) => r(l) ? [__(l, a, s)] : []
  );
  return { mutations: i, queries: o };
}
c(V_, "j1");
h(V_, "dehydrate");
function D_(n, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const i = n.getMutationCache(), r = n.getQueryCache(), s = n.getDefaultOptions().hydrate?.deserializeData ?? xP, a = t.mutations || [], o = t.queries || [];
  a.forEach(({ state: l, ...d }) => {
    i.build(
      n,
      {
        ...n.getDefaultOptions().hydrate?.mutations,
        ...e?.defaultOptions?.mutations,
        ...d
      },
      l
    );
  }), o.forEach(
    ({ queryKey: l, state: d, queryHash: u, meta: p, promise: f, dehydratedAt: y }) => {
      const g = f ? R_(f) : void 0, b = d.data === void 0 ? g?.data : d.data, S = b === void 0 ? b : s(b);
      let $ = r.get(u);
      const Q = $?.state.status === "pending", E = $?.state.fetchStatus === "fetching";
      if ($) {
        const z = g && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        y !== void 0 && y > $.state.dataUpdatedAt;
        if (d.dataUpdatedAt > $.state.dataUpdatedAt || z) {
          const { fetchStatus: A, ...V } = d;
          $.setState({
            ...V,
            data: S
          });
        }
      } else
        $ = r.build(
          n,
          {
            ...n.getDefaultOptions().hydrate?.queries,
            ...e?.defaultOptions?.queries,
            queryKey: l,
            queryHash: u,
            meta: p
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...d,
            data: S,
            fetchStatus: "idle",
            status: S !== void 0 ? "success" : d.status
          }
        );
      f && !Q && !E && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (y === void 0 || y > $.state.dataUpdatedAt) && $.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(f).then(s)
      }).catch(Ke);
    }
  );
}
c(D_, "W1");
h(D_, "hydrate");
var Tj = P_;
function W_() {
  let n = [], t = 0, e = /* @__PURE__ */ h((o) => {
    o();
  }, "notifyFn"), i = /* @__PURE__ */ h((o) => {
    o();
  }, "batchNotifyFn"), r = Tj;
  const s = /* @__PURE__ */ h((o) => {
    t ? n.push(o) : r(() => {
      e(o);
    });
  }, "schedule"), a = /* @__PURE__ */ h(() => {
    const o = n;
    n = [], o.length && r(() => {
      i(() => {
        o.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ h((o) => {
      let l;
      t++;
      try {
        l = o();
      } finally {
        t--, t || a();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ h((o) => (...l) => {
      s(() => {
        o(...l);
      });
    }, "batchCalls"),
    schedule: s,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ h((o) => {
      e = o;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ h((o) => {
      i = o;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ h((o) => {
      r = o;
    }, "setScheduler")
  };
}
c(W_, "K1");
h(W_, "createNotifyManager");
var ei = W_(), Fy, Wa, Zy, x2, Du, Mj = (x2 = (Du = class extends my {
  constructor() {
    super(), F(this, Fy, !0), F(this, Wa), F(this, Zy), L(this, Zy, (t) => {
      if (!Nm && window.addEventListener) {
        const e = /* @__PURE__ */ h(() => t(!0), "onlineListener"), i = /* @__PURE__ */ h(() => t(!1), "offlineListener");
        return window.addEventListener("online", e, !1), window.addEventListener("offline", i, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", i);
        };
      }
    });
  }
  onSubscribe() {
    x(this, Wa) || this.setEventListener(x(this, Zy));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = x(this, Wa)) == null || t.call(this), L(this, Wa, void 0));
  }
  setEventListener(t) {
    var e;
    L(this, Zy, t), (e = x(this, Wa)) == null || e.call(this), L(this, Wa, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    x(this, Fy) !== t && (L(this, Fy, t), this.listeners.forEach((e) => {
      e(t);
    }));
  }
  isOnline() {
    return x(this, Fy);
  }
}, c(Du, "kn"), Du), Fy = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new WeakMap(), Zy = /* @__PURE__ */ new WeakMap(), h(x2, "OnlineManager"), x2), FO = new Mj();
function q_(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
c(q_, "Z1");
h(q_, "defaultRetryDelay");
function kP(n) {
  return (n ?? "online") === "online" ? FO.isOnline() : !0;
}
c(kP, "Qf");
h(kP, "canFetch");
var k2, Wu, L5 = (k2 = (Wu = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
}, c(Wu, "_n"), Wu), h(k2, "CancelledError"), k2);
function SP(n) {
  let t = !1, e = 0, i;
  const r = qO(), s = /* @__PURE__ */ h(() => r.status !== "pending", "isResolved"), a = /* @__PURE__ */ h((b) => {
    if (!s()) {
      const S = new L5(b);
      f(S), n.onCancel?.(S);
    }
  }, "cancel"), o = /* @__PURE__ */ h(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ h(() => {
    t = !1;
  }, "continueRetry"), d = /* @__PURE__ */ h(() => $P.isFocused() && (n.networkMode === "always" || FO.isOnline()) && n.canRun(), "canContinue"), u = /* @__PURE__ */ h(() => kP(n.networkMode) && n.canRun(), "canStart"), p = /* @__PURE__ */ h((b) => {
    s() || (i?.(), r.resolve(b));
  }, "resolve"), f = /* @__PURE__ */ h((b) => {
    s() || (i?.(), r.reject(b));
  }, "reject"), y = /* @__PURE__ */ h(() => new Promise((b) => {
    i = /* @__PURE__ */ h((S) => {
      (s() || d()) && b(S);
    }, "continueFn"), n.onPause?.();
  }).then(() => {
    i = void 0, s() || n.onContinue?.();
  }), "pause"), g = /* @__PURE__ */ h(() => {
    if (s())
      return;
    let b;
    const S = e === 0 ? n.initialPromise : void 0;
    try {
      b = S ?? n.fn();
    } catch ($) {
      b = Promise.reject($);
    }
    Promise.resolve(b).then(p).catch(($) => {
      if (s())
        return;
      const Q = n.retry ?? (Nm ? 0 : 3), E = n.retryDelay ?? q_, z = typeof E == "function" ? E(e, $) : E, A = Q === !0 || typeof Q == "number" && e < Q || typeof Q == "function" && Q(e, $);
      if (t || !A) {
        f($);
        return;
      }
      e++, n.onFail?.(e, $), T_(z).then(() => d() ? void 0 : y()).then(() => {
        t ? f($) : g();
      });
    });
  }, "run");
  return {
    promise: r,
    status: /* @__PURE__ */ h(() => r.status, "status"),
    cancel: a,
    continue: /* @__PURE__ */ h(() => (i?.(), r), "continue"),
    cancelRetry: o,
    continueRetry: l,
    canStart: u,
    start: /* @__PURE__ */ h(() => (u() ? g() : y().then(g), r), "start")
  };
}
c(SP, "Kf");
h(SP, "createRetryer");
var Qc, S2, qu, F_ = (S2 = (qu = class {
  constructor() {
    F(this, Qc);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), VO(this.gcTime) && L(this, Qc, Ms.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (Nm ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    x(this, Qc) && (Ms.clearTimeout(x(this, Qc)), L(this, Qc, void 0));
  }
}, c(qu, "Pn"), qu), Qc = /* @__PURE__ */ new WeakMap(), h(S2, "Removable"), S2), Tc, Xy, vn, Mc, He, G1, Ac, qn, kr, C2, Fu, Aj = (C2 = (Fu = class extends F_ {
  constructor(t) {
    super(), F(this, qn), F(this, Tc), F(this, Xy), F(this, vn), F(this, Mc), F(this, He), F(this, G1), F(this, Ac), L(this, Ac, !1), L(this, G1, t.defaultOptions), this.setOptions(t.options), this.observers = [], L(this, Mc, t.client), L(this, vn, x(this, Mc).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, L(this, Tc, V5(this.options)), this.state = t.state ?? x(this, Tc), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return x(this, He)?.promise;
  }
  setOptions(t) {
    if (this.options = { ...x(this, G1), ...t }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const e = V5(this.options);
      e.data !== void 0 && (this.setState(
        I5(e.data, e.dataUpdatedAt)
      ), L(this, Tc, e));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && x(this, vn).remove(this);
  }
  setData(t, e) {
    const i = WO(this.state.data, t, this.options);
    return vt(this, qn, kr).call(this, {
      data: i,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), i;
  }
  setState(t, e) {
    vt(this, qn, kr).call(this, { type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = x(this, He)?.promise;
    return x(this, He)?.cancel(t), e ? e.then(Ke).catch(Ke) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(x(this, Tc));
  }
  isActive() {
    return this.observers.some(
      (t) => Ui(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === OP || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => jr(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !vP(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), x(this, He)?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), x(this, He)?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), x(this, vn).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (x(this, He) && (x(this, Ac) ? x(this, He).cancel({ revert: !0 }) : x(this, He).cancelRetry()), this.scheduleGc()), x(this, vn).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || vt(this, qn, kr).call(this, { type: "invalidate" });
  }
  async fetch(t, e) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    x(this, He)?.status() !== "rejected") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (x(this, He))
        return x(this, He).continueRetry(), x(this, He).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const o = this.observers.find((l) => l.options.queryFn);
      o && this.setOptions(o.options);
    }
    const i = new AbortController(), r = /* @__PURE__ */ h((o) => {
      Object.defineProperty(o, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ h(() => (L(this, Ac, !0), i.signal), "get")
      });
    }, "addSignalProperty"), s = /* @__PURE__ */ h(() => {
      const o = bP(this.options, e), l = (/* @__PURE__ */ h(() => {
        const d = {
          client: x(this, Mc),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return r(d), d;
      }, "createQueryFnContext"))();
      return L(this, Ac, !1), this.options.persister ? this.options.persister(
        o,
        l,
        this
      ) : o(l);
    }, "fetchFn"), a = (/* @__PURE__ */ h(() => {
      const o = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: x(this, Mc),
        state: this.state,
        fetchFn: s
      };
      return r(o), o;
    }, "createFetchContext"))();
    this.options.behavior?.onFetch(a, this), L(this, Xy, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && vt(this, qn, kr).call(this, { type: "fetch", meta: a.fetchOptions?.meta }), L(this, He, SP({
      initialPromise: e?.initialPromise,
      fn: a.fetchFn,
      onCancel: /* @__PURE__ */ h((o) => {
        o instanceof L5 && o.revert && this.setState({
          ...x(this, Xy),
          fetchStatus: "idle"
        }), i.abort();
      }, "onCancel"),
      onFail: /* @__PURE__ */ h((o, l) => {
        vt(this, qn, kr).call(this, { type: "failed", failureCount: o, error: l });
      }, "onFail"),
      onPause: /* @__PURE__ */ h(() => {
        vt(this, qn, kr).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ h(() => {
        vt(this, qn, kr).call(this, { type: "continue" });
      }, "onContinue"),
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: /* @__PURE__ */ h(() => !0, "canRun")
    }));
    try {
      const o = await x(this, He).start();
      if (o === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(o), x(this, vn).config.onSuccess?.(o, this), x(this, vn).config.onSettled?.(
        o,
        this.state.error,
        this
      ), o;
    } catch (o) {
      if (o instanceof L5) {
        if (o.silent)
          return x(this, He).promise;
        if (o.revert) {
          if (this.state.data === void 0)
            throw o;
          return this.state.data;
        }
      }
      throw vt(this, qn, kr).call(this, {
        type: "error",
        error: o
      }), x(this, vn).config.onError?.(
        o,
        this
      ), x(this, vn).config.onSettled?.(
        this.state.data,
        o,
        this
      ), o;
    } finally {
      this.scheduleGc();
    }
  }
}, c(Fu, "Sn"), Fu), Tc = /* @__PURE__ */ new WeakMap(), Xy = /* @__PURE__ */ new WeakMap(), vn = /* @__PURE__ */ new WeakMap(), Mc = /* @__PURE__ */ new WeakMap(), He = /* @__PURE__ */ new WeakMap(), G1 = /* @__PURE__ */ new WeakMap(), Ac = /* @__PURE__ */ new WeakMap(), qn = /* @__PURE__ */ new WeakSet(), kr = /* @__PURE__ */ h(function(n) {
  const t = /* @__PURE__ */ h((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          fetchFailureCount: n.failureCount,
          fetchFailureReason: n.error
        };
      case "pause":
        return {
          ...e,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...e,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...e,
          ...CP(e.data, this.options),
          fetchMeta: n.meta ?? null
        };
      case "success":
        const i = {
          ...e,
          ...I5(n.data, n.dataUpdatedAt),
          dataUpdateCount: e.dataUpdateCount + 1,
          ...!n.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return L(this, Xy, n.manual ? i : void 0), i;
      case "error":
        const r = n.error;
        return {
          ...e,
          error: r,
          errorUpdateCount: e.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: e.fetchFailureCount + 1,
          fetchFailureReason: r,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...e,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...e,
          ...n.state
        };
    }
  }, "reducer");
  this.state = t(this.state), ei.batch(() => {
    this.observers.forEach((e) => {
      e.onQueryUpdate();
    }), x(this, vn).notify({ query: this, type: "updated", action: n });
  });
}, "#dispatch"), h(C2, "Query"), C2);
function CP(n, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: kP(t.networkMode) ? "fetching" : "paused",
    ...n === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
c(CP, "Zf");
h(CP, "fetchState");
function I5(n, t) {
  return {
    data: n,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
c(I5, "Sw");
h(I5, "successState");
function V5(n) {
  const t = typeof n.initialData == "function" ? n.initialData() : n.initialData, e = t !== void 0, i = e ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
c(V5, "Aw");
h(V5, "getDefaultState$1");
var Zi, zt, K1, Si, Rc, Ny, us, qa, J1, jy, By, Ec, _c, Fa, Uy, me, Hy, P2, Q2, T2, M2, A2, R2, E2, YQ, _2, Zu, Z_ = (_2 = (Zu = class extends my {
  constructor(t, e) {
    super(), F(this, me), F(this, Zi), F(this, zt), F(this, K1), F(this, Si), F(this, Rc), F(this, Ny), F(this, us), F(this, qa), F(this, J1), F(this, jy), F(this, By), F(this, Ec), F(this, _c), F(this, Fa), F(this, Uy, /* @__PURE__ */ new Set()), this.options = e, L(this, Zi, t), L(this, qa, null), L(this, us, qO()), this.bindMethods(), this.setOptions(e);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (x(this, zt).addObserver(this), D5(x(this, zt), this.options) ? vt(this, me, Hy).call(this) : this.updateResult(), vt(this, me, M2).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return ZO(
      x(this, zt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return ZO(
      x(this, zt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), vt(this, me, A2).call(this), vt(this, me, R2).call(this), x(this, zt).removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, i = x(this, zt);
    if (this.options = x(this, Zi).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Ui(this.options.enabled, x(this, zt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    vt(this, me, E2).call(this), x(this, zt).setOptions(this.options), e._defaulted && !Cw(this.options, e) && x(this, Zi).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: x(this, zt),
      observer: this
    });
    const r = this.hasListeners();
    r && W5(
      x(this, zt),
      i,
      this.options,
      e
    ) && vt(this, me, Hy).call(this), this.updateResult(), r && (x(this, zt) !== i || Ui(this.options.enabled, x(this, zt)) !== Ui(e.enabled, x(this, zt)) || jr(this.options.staleTime, x(this, zt)) !== jr(e.staleTime, x(this, zt))) && vt(this, me, P2).call(this);
    const s = vt(this, me, Q2).call(this);
    r && (x(this, zt) !== i || Ui(this.options.enabled, x(this, zt)) !== Ui(e.enabled, x(this, zt)) || s !== x(this, Fa)) && vt(this, me, T2).call(this, s);
  }
  getOptimisticResult(t) {
    const e = x(this, Zi).getQueryCache().build(x(this, Zi), t), i = this.createResult(e, t);
    return N_(this, i) && (L(this, Si, i), L(this, Ny, this.options), L(this, Rc, x(this, zt).state)), i;
  }
  getCurrentResult() {
    return x(this, Si);
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: /* @__PURE__ */ h((i, r) => (this.trackProp(r), e?.(r), r === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && x(this, us).status === "pending" && x(this, us).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(i, r)), "get")
    });
  }
  trackProp(t) {
    x(this, Uy).add(t);
  }
  getCurrentQuery() {
    return x(this, zt);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = x(this, Zi).defaultQueryOptions(t), i = x(this, Zi).getQueryCache().build(x(this, Zi), e);
    return i.fetch().then(() => this.createResult(i, e));
  }
  fetch(t) {
    return vt(this, me, Hy).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), x(this, Si)));
  }
  createResult(t, e) {
    const i = x(this, zt), r = this.options, s = x(this, Si), a = x(this, Rc), o = x(this, Ny), l = t !== i ? t.state : x(this, K1), { state: d } = t;
    let u = { ...d }, p = !1, f;
    if (e._optimisticResults) {
      const D = this.hasListeners(), X = !D && D5(t, e), Y = D && W5(t, i, e, r);
      (X || Y) && (u = {
        ...u,
        ...CP(d.data, t.options)
      }), e._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: y, errorUpdatedAt: g, status: b } = u;
    f = u.data;
    let S = !1;
    if (e.placeholderData !== void 0 && f === void 0 && b === "pending") {
      let D;
      s?.isPlaceholderData && e.placeholderData === o?.placeholderData ? (D = s.data, S = !0) : D = typeof e.placeholderData == "function" ? e.placeholderData(
        x(this, By)?.state.data,
        x(this, By)
      ) : e.placeholderData, D !== void 0 && (b = "success", f = WO(
        s?.data,
        D,
        e
      ), p = !0);
    }
    if (e.select && f !== void 0 && !S)
      if (s && f === a?.data && e.select === x(this, J1))
        f = x(this, jy);
      else
        try {
          L(this, J1, e.select), f = e.select(f), f = WO(s?.data, f, e), L(this, jy, f), L(this, qa, null);
        } catch (D) {
          L(this, qa, D);
        }
    x(this, qa) && (y = x(this, qa), f = x(this, jy), g = Date.now(), b = "error");
    const $ = u.fetchStatus === "fetching", Q = b === "pending", E = b === "error", z = Q && $, A = f !== void 0, V = {
      status: b,
      fetchStatus: u.fetchStatus,
      isPending: Q,
      isSuccess: b === "success",
      isError: E,
      isInitialLoading: z,
      isLoading: z,
      data: f,
      dataUpdatedAt: u.dataUpdatedAt,
      error: y,
      errorUpdatedAt: g,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > l.dataUpdateCount || u.errorUpdateCount > l.errorUpdateCount,
      isFetching: $,
      isRefetching: $ && !Q,
      isLoadingError: E && !A,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: p,
      isRefetchError: E && A,
      isStale: j0(t, e),
      refetch: this.refetch,
      promise: x(this, us),
      isEnabled: Ui(e.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const D = /* @__PURE__ */ h((mt) => {
        V.status === "error" ? mt.reject(V.error) : V.data !== void 0 && mt.resolve(V.data);
      }, "finalizeThenableIfPossible"), X = /* @__PURE__ */ h(() => {
        const mt = L(this, us, V.promise = qO());
        D(mt);
      }, "recreateThenable"), Y = x(this, us);
      switch (Y.status) {
        case "pending":
          t.queryHash === i.queryHash && D(Y);
          break;
        case "fulfilled":
          (V.status === "error" || V.data !== Y.value) && X();
          break;
        case "rejected":
          (V.status !== "error" || V.error !== Y.reason) && X();
          break;
      }
    }
    return V;
  }
  updateResult() {
    const t = x(this, Si), e = this.createResult(x(this, zt), this.options);
    if (L(this, Rc, x(this, zt).state), L(this, Ny, this.options), x(this, Rc).data !== void 0 && L(this, By, x(this, zt)), Cw(e, t))
      return;
    L(this, Si, e);
    const i = /* @__PURE__ */ h(() => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: r } = this.options, s = typeof r == "function" ? r() : r;
      if (s === "all" || !s && !x(this, Uy).size)
        return !0;
      const a = new Set(
        s ?? x(this, Uy)
      );
      return this.options.throwOnError && a.add("error"), Object.keys(x(this, Si)).some((o) => {
        const l = o;
        return x(this, Si)[l] !== t[l] && a.has(l);
      });
    }, "shouldNotifyListeners");
    vt(this, me, YQ).call(this, { listeners: i() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && vt(this, me, M2).call(this);
  }
}, c(Zu, "Ln"), Zu), Zi = /* @__PURE__ */ new WeakMap(), zt = /* @__PURE__ */ new WeakMap(), K1 = /* @__PURE__ */ new WeakMap(), Si = /* @__PURE__ */ new WeakMap(), Rc = /* @__PURE__ */ new WeakMap(), Ny = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap(), J1 = /* @__PURE__ */ new WeakMap(), jy = /* @__PURE__ */ new WeakMap(), By = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap(), _c = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Uy = /* @__PURE__ */ new WeakMap(), me = /* @__PURE__ */ new WeakSet(), Hy = /* @__PURE__ */ h(function(n) {
  vt(this, me, E2).call(this);
  let t = x(this, zt).fetch(
    this.options,
    n
  );
  return n?.throwOnError || (t = t.catch(Ke)), t;
}, "#executeFetch"), P2 = /* @__PURE__ */ h(function() {
  vt(this, me, A2).call(this);
  const n = jr(
    this.options.staleTime,
    x(this, zt)
  );
  if (Nm || x(this, Si).isStale || !VO(n))
    return;
  const t = vP(x(this, Si).dataUpdatedAt, n) + 1;
  L(this, Ec, Ms.setTimeout(() => {
    x(this, Si).isStale || this.updateResult();
  }, t));
}, "#updateStaleTimeout"), Q2 = /* @__PURE__ */ h(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(x(this, zt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), T2 = /* @__PURE__ */ h(function(n) {
  vt(this, me, R2).call(this), L(this, Fa, n), !(Nm || Ui(this.options.enabled, x(this, zt)) === !1 || !VO(x(this, Fa)) || x(this, Fa) === 0) && L(this, _c, Ms.setInterval(() => {
    (this.options.refetchIntervalInBackground || $P.isFocused()) && vt(this, me, Hy).call(this);
  }, x(this, Fa)));
}, "#updateRefetchInterval"), M2 = /* @__PURE__ */ h(function() {
  vt(this, me, P2).call(this), vt(this, me, T2).call(this, vt(this, me, Q2).call(this));
}, "#updateTimers"), A2 = /* @__PURE__ */ h(function() {
  x(this, Ec) && (Ms.clearTimeout(x(this, Ec)), L(this, Ec, void 0));
}, "#clearStaleTimeout"), R2 = /* @__PURE__ */ h(function() {
  x(this, _c) && (Ms.clearInterval(x(this, _c)), L(this, _c, void 0));
}, "#clearRefetchInterval"), E2 = /* @__PURE__ */ h(function() {
  const n = x(this, Zi).getQueryCache().build(x(this, Zi), this.options);
  if (n === x(this, zt))
    return;
  const t = x(this, zt);
  L(this, zt, n), L(this, K1, n.state), this.hasListeners() && (t?.removeObserver(this), n.addObserver(this));
}, "#updateQuery"), YQ = /* @__PURE__ */ h(function(n) {
  ei.batch(() => {
    n.listeners && this.listeners.forEach((t) => {
      t(x(this, Si));
    }), x(this, Zi).getQueryCache().notify({
      query: x(this, zt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), h(_2, "QueryObserver"), _2);
function X_(n, t) {
  return Ui(t.enabled, n) !== !1 && n.state.data === void 0 && !(n.state.status === "error" && t.retryOnMount === !1);
}
c(X_, "X1");
h(X_, "shouldLoadOnMount");
function D5(n, t) {
  return X_(n, t) || n.state.data !== void 0 && ZO(n, t, t.refetchOnMount);
}
c(D5, "zw");
h(D5, "shouldFetchOnMount");
function ZO(n, t, e) {
  if (Ui(t.enabled, n) !== !1 && jr(t.staleTime, n) !== "static") {
    const i = typeof e == "function" ? e(n) : e;
    return i === "always" || i !== !1 && j0(n, t);
  }
  return !1;
}
c(ZO, "iu");
h(ZO, "shouldFetchOn");
function W5(n, t, e, i) {
  return (n !== t || Ui(i.enabled, n) === !1) && (!e.suspense || n.state.status !== "error") && j0(n, e);
}
c(W5, "Rw");
h(W5, "shouldFetchOptionally");
function j0(n, t) {
  return Ui(t.enabled, n) !== !1 && n.isStaleByTime(jr(t.staleTime, n));
}
c(j0, "ju");
h(j0, "isStale");
function N_(n, t) {
  return !Cw(n.getCurrentResult(), t);
}
c(N_, "J1");
h(N_, "shouldAssignObserverCurrentProperties");
function Pw(n) {
  return {
    onFetch: /* @__PURE__ */ h((t, e) => {
      const i = t.options, r = t.fetchOptions?.meta?.fetchMore?.direction, s = t.state.data?.pages || [], a = t.state.data?.pageParams || [];
      let o = { pages: [], pageParams: [] }, l = 0;
      const d = /* @__PURE__ */ h(async () => {
        let u = !1;
        const p = /* @__PURE__ */ h((g) => {
          Object.defineProperty(g, "signal", {
            enumerable: !0,
            get: /* @__PURE__ */ h(() => (t.signal.aborted ? u = !0 : t.signal.addEventListener("abort", () => {
              u = !0;
            }), t.signal), "get")
          });
        }, "addSignalProperty"), f = bP(t.options, t.fetchOptions), y = /* @__PURE__ */ h(async (g, b, S) => {
          if (u)
            return Promise.reject();
          if (b == null && g.pages.length)
            return Promise.resolve(g);
          const $ = (/* @__PURE__ */ h(() => {
            const A = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: b,
              direction: S ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(A), A;
          }, "createQueryFnContext"))(), Q = await f($), { maxPages: E } = t.options, z = S ? A_ : M_;
          return {
            pages: z(g.pages, Q, E),
            pageParams: z(g.pageParams, b, E)
          };
        }, "fetchPage");
        if (r && s.length) {
          const g = r === "backward", b = g ? PP : XO, S = {
            pages: s,
            pageParams: a
          }, $ = b(i, S);
          o = await y(S, $, g);
        } else {
          const g = n ?? s.length;
          do {
            const b = l === 0 ? a[0] ?? i.initialPageParam : XO(i, o);
            if (l > 0 && b == null)
              break;
            o = await y(o, b), l++;
          } while (l < g);
        }
        return o;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        d,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        e
      ) : t.fetchFn = d;
    }, "onFetch")
  };
}
c(Pw, "Vd");
h(Pw, "infiniteQueryBehavior");
function XO(n, { pages: t, pageParams: e }) {
  const i = t.length - 1;
  return t.length > 0 ? n.getNextPageParam(
    t[i],
    t,
    e[i],
    e
  ) : void 0;
}
c(XO, "ru");
h(XO, "getNextPageParam");
function PP(n, { pages: t, pageParams: e }) {
  return t.length > 0 ? n.getPreviousPageParam?.(t[0], t, e[0], e) : void 0;
}
c(PP, "Jf");
h(PP, "getPreviousPageParam");
function j_(n, t) {
  return t ? XO(n, t) != null : !1;
}
c(j_, "tg");
h(j_, "hasNextPage");
function B_(n, t) {
  return !t || !n.getPreviousPageParam ? !1 : PP(n, t) != null;
}
c(B_, "eg");
h(B_, "hasPreviousPage");
var z2, Xu, Rj = (z2 = (Xu = class extends Z_ {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Pw()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Pw(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    const { state: i } = t, r = super.createResult(t, e), { isFetching: s, isRefetching: a, isError: o, isRefetchError: l } = r, d = i.fetchMeta?.fetchMore?.direction, u = o && d === "forward", p = s && d === "forward", f = o && d === "backward", y = s && d === "backward";
    return {
      ...r,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: j_(e, i.data),
      hasPreviousPage: B_(e, i.data),
      isFetchNextPageError: u,
      isFetchingNextPage: p,
      isFetchPreviousPageError: f,
      isFetchingPreviousPage: y,
      isRefetchError: l && !u && !f,
      isRefetching: a && !p && !y
    };
  }
}, c(Xu, "On"), Xu), h(z2, "InfiniteQueryObserver"), z2), tv, Sr, Ci, zc, Cr, ps, L2, Nu, Ej = (L2 = (Nu = class extends F_ {
  constructor(t) {
    super(), F(this, Cr), F(this, tv), F(this, Sr), F(this, Ci), F(this, zc), L(this, tv, t.client), this.mutationId = t.mutationId, L(this, Ci, t.mutationCache), L(this, Sr, []), this.state = t.state || QP(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    x(this, Sr).includes(t) || (x(this, Sr).push(t), this.clearGcTimeout(), x(this, Ci).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    L(this, Sr, x(this, Sr).filter((e) => e !== t)), this.scheduleGc(), x(this, Ci).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    x(this, Sr).length || (this.state.status === "pending" ? this.scheduleGc() : x(this, Ci).remove(this));
  }
  continue() {
    return x(this, zc)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    const e = /* @__PURE__ */ h(() => {
      vt(this, Cr, ps).call(this, { type: "continue" });
    }, "onContinue"), i = {
      client: x(this, tv),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    L(this, zc, SP({
      fn: /* @__PURE__ */ h(() => this.options.mutationFn ? this.options.mutationFn(t, i) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ h((a, o) => {
        vt(this, Cr, ps).call(this, { type: "failed", failureCount: a, error: o });
      }, "onFail"),
      onPause: /* @__PURE__ */ h(() => {
        vt(this, Cr, ps).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: e,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ h(() => x(this, Ci).canRun(this), "canRun")
    }));
    const r = this.state.status === "pending", s = !x(this, zc).canStart();
    try {
      if (r)
        e();
      else {
        vt(this, Cr, ps).call(this, { type: "pending", variables: t, isPaused: s }), await x(this, Ci).config.onMutate?.(
          t,
          this,
          i
        );
        const o = await this.options.onMutate?.(
          t,
          i
        );
        o !== this.state.context && vt(this, Cr, ps).call(this, {
          type: "pending",
          context: o,
          variables: t,
          isPaused: s
        });
      }
      const a = await x(this, zc).start();
      return await x(this, Ci).config.onSuccess?.(
        a,
        t,
        this.state.context,
        this,
        i
      ), await this.options.onSuccess?.(
        a,
        t,
        this.state.context,
        i
      ), await x(this, Ci).config.onSettled?.(
        a,
        null,
        this.state.variables,
        this.state.context,
        this,
        i
      ), await this.options.onSettled?.(
        a,
        null,
        t,
        this.state.context,
        i
      ), vt(this, Cr, ps).call(this, { type: "success", data: a }), a;
    } catch (a) {
      try {
        throw await x(this, Ci).config.onError?.(
          a,
          t,
          this.state.context,
          this,
          i
        ), await this.options.onError?.(
          a,
          t,
          this.state.context,
          i
        ), await x(this, Ci).config.onSettled?.(
          void 0,
          a,
          this.state.variables,
          this.state.context,
          this,
          i
        ), await this.options.onSettled?.(
          void 0,
          a,
          t,
          this.state.context,
          i
        ), a;
      } finally {
        vt(this, Cr, ps).call(this, { type: "error", error: a });
      }
    } finally {
      x(this, Ci).runNext(this);
    }
  }
}, c(Nu, "In"), Nu), tv = /* @__PURE__ */ new WeakMap(), Sr = /* @__PURE__ */ new WeakMap(), Ci = /* @__PURE__ */ new WeakMap(), zc = /* @__PURE__ */ new WeakMap(), Cr = /* @__PURE__ */ new WeakSet(), ps = /* @__PURE__ */ h(function(n) {
  const t = /* @__PURE__ */ h((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          failureCount: n.failureCount,
          failureReason: n.error
        };
      case "pause":
        return {
          ...e,
          isPaused: !0
        };
      case "continue":
        return {
          ...e,
          isPaused: !1
        };
      case "pending":
        return {
          ...e,
          context: n.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: n.isPaused,
          status: "pending",
          variables: n.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...e,
          data: n.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...e,
          data: void 0,
          error: n.error,
          failureCount: e.failureCount + 1,
          failureReason: n.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = t(this.state), ei.batch(() => {
    x(this, Sr).forEach((e) => {
      e.onMutationUpdate(n);
    }), x(this, Ci).notify({
      mutation: this,
      type: "updated",
      action: n
    });
  });
}, "#dispatch"), h(L2, "Mutation"), L2);
function QP() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
c(QP, "tm");
h(QP, "getDefaultState");
var fs, Fn, ev, I2, ju, _j = (I2 = (ju = class extends my {
  constructor(t = {}) {
    super(), F(this, fs), F(this, Fn), F(this, ev), this.config = t, L(this, fs, /* @__PURE__ */ new Set()), L(this, Fn, /* @__PURE__ */ new Map()), L(this, ev, 0);
  }
  build(t, e, i) {
    const r = new Ej({
      client: t,
      mutationCache: this,
      mutationId: ++A5(this, ev)._,
      options: t.defaultMutationOptions(e),
      state: i
    });
    return this.add(r), r;
  }
  add(t) {
    x(this, fs).add(t);
    const e = mg(t);
    if (typeof e == "string") {
      const i = x(this, Fn).get(e);
      i ? i.push(t) : x(this, Fn).set(e, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if (x(this, fs).delete(t)) {
      const e = mg(t);
      if (typeof e == "string") {
        const i = x(this, Fn).get(e);
        if (i)
          if (i.length > 1) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          } else i[0] === t && x(this, Fn).delete(e);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const e = mg(t);
    if (typeof e == "string") {
      const i = x(this, Fn).get(e)?.find(
        (r) => r.state.status === "pending"
      );
      return !i || i === t;
    } else
      return !0;
  }
  runNext(t) {
    const e = mg(t);
    return typeof e == "string" ? x(this, Fn).get(e)?.find((i) => i !== t && i.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ei.batch(() => {
      x(this, fs).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), x(this, fs).clear(), x(this, Fn).clear();
    });
  }
  getAll() {
    return Array.from(x(this, fs));
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => E5(e, i)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((e) => E5(t, e));
  }
  notify(t) {
    ei.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((e) => e.state.isPaused);
    return ei.batch(
      () => Promise.all(
        t.map((e) => e.continue().catch(Ke))
      )
    );
  }
}, c(ju, "Tn"), ju), fs = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakMap(), ev = /* @__PURE__ */ new WeakMap(), h(I2, "MutationCache"), I2);
function mg(n) {
  return n.options.scope?.id;
}
c(mg, "Pd");
h(mg, "scopeFor");
var ms, Za, Xi, ys, Xa, iv, V2, D2, Bu, Zt = (D2 = (Bu = class extends my {
  constructor(t, e) {
    super(), F(this, Xa), F(this, ms), F(this, Za), F(this, Xi), F(this, ys), L(this, ms, t), this.setOptions(e), this.bindMethods(), vt(this, Xa, iv).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    const e = this.options;
    this.options = x(this, ms).defaultMutationOptions(t), Cw(this.options, e) || x(this, ms).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: x(this, Xi),
      observer: this
    }), e?.mutationKey && this.options.mutationKey && ha(e.mutationKey) !== ha(this.options.mutationKey) ? this.reset() : x(this, Xi)?.state.status === "pending" && x(this, Xi).setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || x(this, Xi)?.removeObserver(this);
  }
  onMutationUpdate(t) {
    vt(this, Xa, iv).call(this), vt(this, Xa, V2).call(this, t);
  }
  getCurrentResult() {
    return x(this, Za);
  }
  reset() {
    x(this, Xi)?.removeObserver(this), L(this, Xi, void 0), vt(this, Xa, iv).call(this), vt(this, Xa, V2).call(this);
  }
  mutate(t, e) {
    return L(this, ys, e), x(this, Xi)?.removeObserver(this), L(this, Xi, x(this, ms).getMutationCache().build(x(this, ms), this.options)), x(this, Xi).addObserver(this), x(this, Xi).execute(t);
  }
}, c(Bu, "Fn"), Bu), ms = /* @__PURE__ */ new WeakMap(), Za = /* @__PURE__ */ new WeakMap(), Xi = /* @__PURE__ */ new WeakMap(), ys = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakSet(), iv = /* @__PURE__ */ h(function() {
  const n = x(this, Xi)?.state ?? QP();
  L(this, Za, {
    ...n,
    isPending: n.status === "pending",
    isSuccess: n.status === "success",
    isError: n.status === "error",
    isIdle: n.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), V2 = /* @__PURE__ */ h(function(n) {
  ei.batch(() => {
    if (x(this, ys) && this.hasListeners()) {
      const t = x(this, Za).variables, e = x(this, Za).context, i = {
        client: x(this, ms),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      n?.type === "success" ? (x(this, ys).onSuccess?.(
        n.data,
        t,
        e,
        i
      ), x(this, ys).onSettled?.(
        n.data,
        null,
        t,
        e,
        i
      )) : n?.type === "error" && (x(this, ys).onError?.(
        n.error,
        t,
        e,
        i
      ), x(this, ys).onSettled?.(
        void 0,
        n.error,
        t,
        e,
        i
      ));
    }
    this.listeners.forEach((t) => {
      t(x(this, Za));
    });
  });
}, "#notify"), h(D2, "MutationObserver"), D2), Pr, W2, Uu, zj = (W2 = (Uu = class extends my {
  constructor(t = {}) {
    super(), F(this, Pr), this.config = t, L(this, Pr, /* @__PURE__ */ new Map());
  }
  build(t, e, i) {
    const r = e.queryKey, s = e.queryHash ?? N0(r, e);
    let a = this.get(s);
    return a || (a = new Aj({
      client: t,
      queryKey: r,
      queryHash: s,
      options: t.defaultQueryOptions(e),
      state: i,
      defaultOptions: t.getQueryDefaults(r)
    }), this.add(a)), a;
  }
  add(t) {
    x(this, Pr).has(t.queryHash) || (x(this, Pr).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = x(this, Pr).get(t.queryHash);
    e && (t.destroy(), e === t && x(this, Pr).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    ei.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return x(this, Pr).get(t);
  }
  getAll() {
    return [...x(this, Pr).values()];
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => R5(e, i)
    );
  }
  findAll(t = {}) {
    const e = this.getAll();
    return Object.keys(t).length > 0 ? e.filter((i) => R5(t, i)) : e;
  }
  notify(t) {
    ei.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  onFocus() {
    ei.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    ei.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, c(Uu, "Dn"), Uu), Pr = /* @__PURE__ */ new WeakMap(), h(W2, "QueryCache"), W2), ye, Na, ja, Yy, Gy, Ba, Ky, Jy, q2, Hu, Lj = (q2 = (Hu = class {
  constructor(t = {}) {
    F(this, ye), F(this, Na), F(this, ja), F(this, Yy), F(this, Gy), F(this, Ba), F(this, Ky), F(this, Jy), L(this, ye, t.queryCache || new zj()), L(this, Na, t.mutationCache || new _j()), L(this, ja, t.defaultOptions || {}), L(this, Yy, /* @__PURE__ */ new Map()), L(this, Gy, /* @__PURE__ */ new Map()), L(this, Ba, 0);
  }
  mount() {
    A5(this, Ba)._++, x(this, Ba) === 1 && (L(this, Ky, $P.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), x(this, ye).onFocus());
    })), L(this, Jy, FO.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), x(this, ye).onOnline());
    })));
  }
  unmount() {
    var t, e;
    A5(this, Ba)._--, x(this, Ba) === 0 && ((t = x(this, Ky)) == null || t.call(this), L(this, Ky, void 0), (e = x(this, Jy)) == null || e.call(this), L(this, Jy, void 0));
  }
  isFetching(t) {
    return x(this, ye).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return x(this, Na).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return x(this, ye).get(e.queryHash)?.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), i = x(this, ye).build(this, e), r = i.state.data;
    return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && i.isStaleByTime(jr(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(r));
  }
  getQueriesData(t) {
    return x(this, ye).findAll(t).map(({ queryKey: e, state: i }) => {
      const r = i.data;
      return [e, r];
    });
  }
  setQueryData(t, e, i) {
    const r = this.defaultQueryOptions({ queryKey: t }), s = x(this, ye).get(
      r.queryHash
    )?.state.data, a = Q_(e, s);
    if (a !== void 0)
      return x(this, ye).build(this, r).setData(a, { ...i, manual: !0 });
  }
  setQueriesData(t, e, i) {
    return ei.batch(
      () => x(this, ye).findAll(t).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, e, i)
      ])
    );
  }
  getQueryState(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return x(this, ye).get(
      e.queryHash
    )?.state;
  }
  removeQueries(t) {
    const e = x(this, ye);
    ei.batch(() => {
      e.findAll(t).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(t, e) {
    const i = x(this, ye);
    return ei.batch(() => (i.findAll(t).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const i = { revert: !0, ...e }, r = ei.batch(
      () => x(this, ye).findAll(t).map((s) => s.cancel(i))
    );
    return Promise.all(r).then(Ke).catch(Ke);
  }
  invalidateQueries(t, e = {}) {
    return ei.batch(() => (x(this, ye).findAll(t).forEach((i) => {
      i.invalidate();
    }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: t?.refetchType ?? t?.type ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, r = ei.batch(
      () => x(this, ye).findAll(t).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(Ke)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(r).then(Ke);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const i = x(this, ye).build(this, e);
    return i.isStaleByTime(
      jr(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(Ke).catch(Ke);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Pw(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(Ke).catch(Ke);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Pw(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return FO.isOnline() ? x(this, Na).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return x(this, ye);
  }
  getMutationCache() {
    return x(this, Na);
  }
  getDefaultOptions() {
    return x(this, ja);
  }
  setDefaultOptions(t) {
    L(this, ja, t);
  }
  setQueryDefaults(t, e) {
    x(this, Yy).set(ha(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...x(this, Yy).values()], i = {};
    return e.forEach((r) => {
      jm(t, r.queryKey) && Object.assign(i, r.defaultOptions);
    }), i;
  }
  setMutationDefaults(t, e) {
    x(this, Gy).set(ha(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...x(this, Gy).values()], i = {};
    return e.forEach((r) => {
      jm(t, r.mutationKey) && Object.assign(i, r.defaultOptions);
    }), i;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...x(this, ja).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = N0(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === OP && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t?._defaulted ? t : {
      ...x(this, ja).mutations,
      ...t?.mutationKey && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    x(this, ye).clear(), x(this, Na).clear();
  }
}, c(Hu, "qn"), Hu), ye = /* @__PURE__ */ new WeakMap(), Na = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap(), Yy = /* @__PURE__ */ new WeakMap(), Gy = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap(), Ky = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new WeakMap(), h(q2, "QueryClient"), q2);
function Pv() {
}
c(Pv, "Ap");
h(Pv, "noop");
function U_({
  storage: n,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: i = JSON.stringify,
  deserialize: r = JSON.parse,
  retry: s
}) {
  if (n) {
    const a = /* @__PURE__ */ h((o) => {
      try {
        n.setItem(t, i(o));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: H_((o) => {
        let l = o, d = a(l), u = 0;
        for (; d && l; )
          u++, l = s?.({
            persistedClient: l,
            error: d,
            errorCount: u
          }), l && (d = a(l));
      }, e),
      restoreClient: /* @__PURE__ */ h(() => {
        const o = n.getItem(t);
        if (o)
          return r(o);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ h(() => {
        n.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: Pv,
    restoreClient: Pv,
    removeClient: Pv
  };
}
c(U_, "og");
h(U_, "createSyncStoragePersister");
function H_(n, t = 100) {
  let e = null, i;
  return function(...r) {
    i = r, e === null && (e = Ms.setTimeout(() => {
      n(...i), e = null;
    }, t));
  };
}
c(H_, "cg");
h(H_, "throttle$1");
var Ij = ["added", "removed", "updated"];
function q5(n) {
  return Ij.includes(n);
}
c(q5, "Ew");
h(q5, "isCacheEventType");
async function Y_({
  queryClient: n,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: i = "",
  hydrateOptions: r
}) {
  try {
    const s = await t.restoreClient();
    if (s)
      if (s.timestamp) {
        const a = Date.now() - s.timestamp > e, o = s.buster !== i;
        if (a || o)
          return t.removeClient();
        D_(n, s.clientState, r);
      } else
        return t.removeClient();
  } catch (s) {
    throw await t.removeClient(), s;
  }
}
c(Y_, "dg");
h(Y_, "persistQueryClientRestore");
async function F5({
  queryClient: n,
  persister: t,
  buster: e = "",
  dehydrateOptions: i
}) {
  const r = {
    buster: e,
    timestamp: Date.now(),
    clientState: V_(n, i)
  };
  await t.persistClient(r);
}
c(F5, "Lw");
h(F5, "persistQueryClientSave");
function G_(n) {
  const t = n.queryClient.getQueryCache().subscribe((i) => {
    q5(i.type) && F5(n);
  }), e = n.queryClient.getMutationCache().subscribe((i) => {
    q5(i.type) && F5(n);
  });
  return () => {
    t(), e();
  };
}
c(G_, "hg");
h(G_, "persistQueryClientSubscribe");
const Vj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._queryClient = new Lj({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Ce();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = U_({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const r = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ h((s) => {
              const a = s.state.context?.status?.state === "pending";
              return !!(s.state.context && !a || s.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await Y_(r), this._unsubscribeQueryClient = G_(r);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = L9(this.host, (r) => {
        this.isDestroyed || (r ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      await super.reset(), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), this._unsubscribeQueryClient?.(), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      super.destroy(), this._hostIsConnectedObserver?.disconnect(), this.disconnectQueryClient();
    }
  }, c(e, "t"), e), h(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), Dj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r);
    }
    set annotations(r) {
      this._annotations = r, this.updateContext();
    }
    get annotations() {
      return this._annotations ?? _e.defaults.annotations;
    }
    set enterToSend(r) {
      this._enterToSend = r, this.updateContext();
    }
    get enterToSend() {
      return this._enterToSend ?? _e.defaults.enterToSend;
    }
    set reactions(r) {
      this._reactions = r, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? _e.defaults.reactions;
    }
  }, c(e, "t"), e), h(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function pi(n) {
  return n < 0 ? -1 : n === 0 ? 0 : 1;
}
c(pi, "Re");
h(pi, "signum");
function mh(n, t, e) {
  return (1 - e) * n + e * t;
}
c(mh, "el");
h(mh, "lerp");
function K_(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
c(K_, "yg");
h(K_, "clampInt");
function Qw(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
c(Qw, "Ud");
h(Qw, "clampDouble");
function Bm(n) {
  return n = n % 360, n < 0 && (n = n + 360), n;
}
c(Bm, "ol");
h(Bm, "sanitizeDegreesDouble");
function NO(n, t) {
  const e = n[0] * t[0][0] + n[1] * t[0][1] + n[2] * t[0][2], i = n[0] * t[1][0] + n[1] * t[1][1] + n[2] * t[1][2], r = n[0] * t[2][0] + n[1] * t[2][1] + n[2] * t[2][2];
  return [e, i, r];
}
c(NO, "nu");
h(NO, "matrixMultiply");
const Wj = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], qj = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], Fj = [95.047, 100, 108.883];
function B0(n, t, e) {
  return (255 << 24 | (n & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
c(B0, "Wu");
h(B0, "argbFromRgb");
function Z5(n) {
  const t = zs(n[0]), e = zs(n[1]), i = zs(n[2]);
  return B0(t, e, i);
}
c(Z5, "Ow");
h(Z5, "argbFromLinrgb");
function J_(n) {
  return n >> 24 & 255;
}
c(J_, "vg");
h(J_, "alphaFromArgb");
function TP(n) {
  return n >> 16 & 255;
}
c(TP, "em");
h(TP, "redFromArgb");
function MP(n) {
  return n >> 8 & 255;
}
c(MP, "im");
h(MP, "greenFromArgb");
function AP(n) {
  return n & 255;
}
c(AP, "rm");
h(AP, "blueFromArgb");
function tz(n, t, e) {
  const i = qj, r = i[0][0] * n + i[0][1] * t + i[0][2] * e, s = i[1][0] * n + i[1][1] * t + i[1][2] * e, a = i[2][0] * n + i[2][1] * t + i[2][2] * e, o = zs(r), l = zs(s), d = zs(a);
  return B0(o, l, d);
}
c(tz, "gg");
h(tz, "argbFromXyz");
function ez(n) {
  const t = co(TP(n)), e = co(MP(n)), i = co(AP(n));
  return NO([t, e, i], Wj);
}
c(ez, "bg");
h(ez, "xyzFromArgb");
function iz(n) {
  const t = Lr(n), e = zs(t);
  return B0(e, e, e);
}
c(iz, "xg");
h(iz, "argbFromLstar");
function X5(n) {
  const t = ez(n)[1];
  return 116 * RP(t / 100) - 16;
}
c(X5, "Iw");
h(X5, "lstarFromArgb");
function Lr(n) {
  return 100 * rz((n + 16) / 116);
}
c(Lr, "Cr");
h(Lr, "yFromLstar");
function jO(n) {
  return RP(n / 100) * 116 - 16;
}
c(jO, "au");
h(jO, "lstarFromY");
function co(n) {
  const t = n / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
c(co, "fn");
h(co, "linearized");
function zs(n) {
  const t = n / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, K_(0, 255, Math.round(e * 255));
}
c(zs, "ps");
h(zs, "delinearized");
function nz() {
  return Fj;
}
c(nz, "$g");
h(nz, "whitePointD65");
function RP(n) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return n > t ? Math.pow(n, 1 / 3) : (e * n + 16) / 116;
}
c(RP, "sm");
h(RP, "labF");
function rz(n) {
  const t = 0.008856451679035631, e = 24389 / 27, i = n * n * n;
  return i > t ? i : (116 * n - 16) / e;
}
c(rz, "Cg");
h(rz, "labInvf");
var Uo;
const sz = (Uo = class {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = nz(), e = 200 / Math.PI * Lr(50) / 100, i = 50, r = 2, s = !1) {
    const a = t, o = a[0] * 0.401288 + a[1] * 0.650173 + a[2] * -0.051461, l = a[0] * -0.250268 + a[1] * 1.204414 + a[2] * 0.045854, d = a[0] * -2079e-6 + a[1] * 0.048952 + a[2] * 0.953127, u = 0.8 + r / 10, p = u >= 0.9 ? mh(0.59, 0.69, (u - 0.9) * 10) : mh(0.525, 0.59, (u - 0.8) * 10);
    let f = s ? 1 : u * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    f = f > 1 ? 1 : f < 0 ? 0 : f;
    const y = u, g = [
      f * (100 / o) + 1 - f,
      f * (100 / l) + 1 - f,
      f * (100 / d) + 1 - f
    ], b = 1 / (5 * e + 1), S = b * b * b * b, $ = 1 - S, Q = S * e + 0.1 * $ * $ * Math.cbrt(5 * e), E = Lr(i) / t[1], z = 1.48 + Math.sqrt(E), A = 0.725 / Math.pow(E, 0.2), V = A, D = [
      Math.pow(Q * g[0] * o / 100, 0.42),
      Math.pow(Q * g[1] * l / 100, 0.42),
      Math.pow(Q * g[2] * d / 100, 0.42)
    ], X = [
      400 * D[0] / (D[0] + 27.13),
      400 * D[1] / (D[1] + 27.13),
      400 * D[2] / (D[2] + 27.13)
    ], Y = (2 * X[0] + X[1] + 0.05 * X[2]) * A;
    return new Uo(E, Y, A, V, p, y, g, Q, Math.pow(Q, 0.25), z);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, i, r, s, a, o, l, d, u) {
    this.n = t, this.aw = e, this.nbb = i, this.ncb = r, this.c = s, this.nc = a, this.rgbD = o, this.fl = l, this.fLRoot = d, this.z = u;
  }
}, c(Uo, "oh"), Uo);
h(sz, "ViewingConditions");
let As = sz;
As.DEFAULT = As.make();
var Bi;
const az = (Bi = class {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, i, r, s, a, o, l, d) {
    this.hue = t, this.chroma = e, this.j = i, this.q = r, this.m = s, this.s = a, this.jstar = o, this.astar = l, this.bstar = d;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, i = this.astar - t.astar, r = this.bstar - t.bstar, s = Math.sqrt(e * e + i * i + r * r);
    return 1.41 * Math.pow(s, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return Bi.fromIntInViewingConditions(t, As.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const i = (t & 16711680) >> 16, r = (t & 65280) >> 8, s = t & 255, a = co(i), o = co(r), l = co(s), d = 0.41233895 * a + 0.35762064 * o + 0.18051042 * l, u = 0.2126 * a + 0.7152 * o + 0.0722 * l, p = 0.01932141 * a + 0.11916382 * o + 0.95034478 * l, f = 0.401288 * d + 0.650173 * u - 0.051461 * p, y = -0.250268 * d + 1.204414 * u + 0.045854 * p, g = -2079e-6 * d + 0.048952 * u + 0.953127 * p, b = e.rgbD[0] * f, S = e.rgbD[1] * y, $ = e.rgbD[2] * g, Q = Math.pow(e.fl * Math.abs(b) / 100, 0.42), E = Math.pow(e.fl * Math.abs(S) / 100, 0.42), z = Math.pow(e.fl * Math.abs($) / 100, 0.42), A = pi(b) * 400 * Q / (Q + 27.13), V = pi(S) * 400 * E / (E + 27.13), D = pi($) * 400 * z / (z + 27.13), X = (11 * A + -12 * V + D) / 11, Y = (A + V - 2 * D) / 9, mt = (20 * A + 20 * V + 21 * D) / 20, ct = (40 * A + 20 * V + D) / 20, et = Math.atan2(Y, X) * 180 / Math.PI, bt = et < 0 ? et + 360 : et >= 360 ? et - 360 : et, st = bt * Math.PI / 180, Rt = ct * e.nbb, Qt = 100 * Math.pow(Rt / e.aw, e.c * e.z), It = 4 / e.c * Math.sqrt(Qt / 100) * (e.aw + 4) * e.fLRoot, Wt = bt < 20.14 ? bt + 360 : bt, qt = 0.25 * (Math.cos(Wt * Math.PI / 180 + 2) + 3.8), xi = 5e4 / 13 * qt * e.nc * e.ncb * Math.sqrt(X * X + Y * Y) / (mt + 0.305), Ee = Math.pow(xi, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), le = Ee * Math.sqrt(Qt / 100), ee = le * e.fLRoot, fe = 50 * Math.sqrt(Ee * e.c / (e.aw + 4)), ki = (1 + 100 * 7e-3) * Qt / (1 + 7e-3 * Qt), Wi = 1 / 0.0228 * Math.log(1 + 0.0228 * ee), rn = Wi * Math.cos(st), Bt = Wi * Math.sin(st);
    return new Bi(bt, le, Qt, It, ee, fe, ki, rn, Bt);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, i) {
    return Bi.fromJchInViewingConditions(t, e, i, As.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, i, r) {
    const s = 4 / r.c * Math.sqrt(t / 100) * (r.aw + 4) * r.fLRoot, a = e * r.fLRoot, o = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(o * r.c / (r.aw + 4)), d = i * Math.PI / 180, u = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), p = 1 / 0.0228 * Math.log(1 + 0.0228 * a), f = p * Math.cos(d), y = p * Math.sin(d);
    return new Bi(i, e, t, s, a, l, u, f, y);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, i) {
    return Bi.fromUcsInViewingConditions(t, e, i, As.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, i, r) {
    const s = e, a = i, o = Math.sqrt(s * s + a * a), l = (Math.exp(o * 0.0228) - 1) / 0.0228 / r.fLRoot;
    let d = Math.atan2(a, s) * (180 / Math.PI);
    d < 0 && (d += 360);
    const u = t / (1 - (t - 100) * 7e-3);
    return Bi.fromJchInViewingConditions(u, l, d, r);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(As.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), r = this.hue * Math.PI / 180, s = 0.25 * (Math.cos(r + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = s * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, d = Math.sin(r), u = Math.cos(r), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * d), f = p * u, y = p * d, g = (460 * l + 451 * f + 288 * y) / 1403, b = (460 * l - 891 * f - 261 * y) / 1403, S = (460 * l - 220 * f - 6300 * y) / 1403, $ = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), Q = pi(g) * (100 / t.fl) * Math.pow($, 1 / 0.42), E = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), z = pi(b) * (100 / t.fl) * Math.pow(E, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), V = pi(S) * (100 / t.fl) * Math.pow(A, 1 / 0.42), D = Q / t.rgbD[0], X = z / t.rgbD[1], Y = V / t.rgbD[2], mt = 1.86206786 * D - 1.01125463 * X + 0.14918677 * Y, ct = 0.38752654 * D + 0.62144744 * X - 897398e-8 * Y, et = -0.0158415 * D - 0.03412294 * X + 1.04996444 * Y;
    return tz(mt, ct, et);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, i, r) {
    const s = 0.401288 * t + 0.650173 * e - 0.051461 * i, a = -0.250268 * t + 1.204414 * e + 0.045854 * i, o = -2079e-6 * t + 0.048952 * e + 0.953127 * i, l = r.rgbD[0] * s, d = r.rgbD[1] * a, u = r.rgbD[2] * o, p = Math.pow(r.fl * Math.abs(l) / 100, 0.42), f = Math.pow(r.fl * Math.abs(d) / 100, 0.42), y = Math.pow(r.fl * Math.abs(u) / 100, 0.42), g = pi(l) * 400 * p / (p + 27.13), b = pi(d) * 400 * f / (f + 27.13), S = pi(u) * 400 * y / (y + 27.13), $ = (11 * g + -12 * b + S) / 11, Q = (g + b - 2 * S) / 9, E = (20 * g + 20 * b + 21 * S) / 20, z = (40 * g + 20 * b + S) / 20, A = Math.atan2(Q, $) * 180 / Math.PI, V = A < 0 ? A + 360 : A >= 360 ? A - 360 : A, D = V * Math.PI / 180, X = z * r.nbb, Y = 100 * Math.pow(X / r.aw, r.c * r.z), mt = 4 / r.c * Math.sqrt(Y / 100) * (r.aw + 4) * r.fLRoot, ct = V < 20.14 ? V + 360 : V, et = 1 / 4 * (Math.cos(ct * Math.PI / 180 + 2) + 3.8), bt = 5e4 / 13 * et * r.nc * r.ncb * Math.sqrt($ * $ + Q * Q) / (E + 0.305), st = Math.pow(bt, 0.9) * Math.pow(1.64 - Math.pow(0.29, r.n), 0.73), Rt = st * Math.sqrt(Y / 100), Qt = Rt * r.fLRoot, It = 50 * Math.sqrt(st * r.c / (r.aw + 4)), Wt = (1 + 100 * 7e-3) * Y / (1 + 7e-3 * Y), qt = Math.log(1 + 0.0228 * Qt) / 0.0228, xi = qt * Math.cos(D), Ee = qt * Math.sin(D);
    return new Bi(V, Rt, Y, mt, Qt, It, Wt, xi, Ee);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), r = this.hue * Math.PI / 180, s = 0.25 * (Math.cos(r + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = s * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, d = Math.sin(r), u = Math.cos(r), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * d), f = p * u, y = p * d, g = (460 * l + 451 * f + 288 * y) / 1403, b = (460 * l - 891 * f - 261 * y) / 1403, S = (460 * l - 220 * f - 6300 * y) / 1403, $ = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), Q = pi(g) * (100 / t.fl) * Math.pow($, 1 / 0.42), E = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), z = pi(b) * (100 / t.fl) * Math.pow(E, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), V = pi(S) * (100 / t.fl) * Math.pow(A, 1 / 0.42), D = Q / t.rgbD[0], X = z / t.rgbD[1], Y = V / t.rgbD[2], mt = 1.86206786 * D - 1.01125463 * X + 0.14918677 * Y, ct = 0.38752654 * D + 0.62144744 * X - 897398e-8 * Y, et = -0.0158415 * D - 0.03412294 * X + 1.04996444 * Y;
    return [mt, ct, et];
  }
}, c(Bi, "yi"), Bi);
h(az, "Cam16");
let yg = az;
var xt;
const oz = (xt = class {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let i = 0;
    return e <= 31308e-7 ? i = e * 12.92 : i = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, i * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return pi(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = NO(t, xt.SCALED_DISCOUNT_FROM_LINRGB), i = xt.chromaticAdaptation(e[0]), r = xt.chromaticAdaptation(e[1]), s = xt.chromaticAdaptation(e[2]), a = (11 * i + -12 * r + s) / 11, o = (i + r - 2 * s) / 9;
    return Math.atan2(o, a);
  }
  static areInCyclicOrder(t, e, i) {
    const r = xt.sanitizeRadians(e - t), s = xt.sanitizeRadians(i - t);
    return r < s;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, i) {
    return (e - t) / (i - t);
  }
  static lerpPoint(t, e, i) {
    return [
      t[0] + (i[0] - t[0]) * e,
      t[1] + (i[1] - t[1]) * e,
      t[2] + (i[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, i, r) {
    const s = xt.intercept(t[r], e, i[r]);
    return xt.lerpPoint(t, s, i);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const i = xt.Y_FROM_LINRGB[0], r = xt.Y_FROM_LINRGB[1], s = xt.Y_FROM_LINRGB[2], a = e % 4 <= 1 ? 0 : 100, o = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = a, d = o, u = (t - l * r - d * s) / i;
      return xt.isBounded(u) ? [u, l, d] : [-1, -1, -1];
    } else if (e < 8) {
      const l = a, d = o, u = (t - d * i - l * s) / r;
      return xt.isBounded(u) ? [d, u, l] : [-1, -1, -1];
    } else {
      const l = a, d = o, u = (t - l * i - d * r) / s;
      return xt.isBounded(u) ? [l, d, u] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let i = [-1, -1, -1], r = i, s = 0, a = 0, o = !1, l = !0;
    for (let d = 0; d < 12; d++) {
      const u = xt.nthVertex(t, d);
      if (u[0] < 0)
        continue;
      const p = xt.hueOf(u);
      if (!o) {
        i = u, r = u, s = p, a = p, o = !0;
        continue;
      }
      (l || xt.areInCyclicOrder(s, p, a)) && (l = !1, xt.areInCyclicOrder(s, e, p) ? (r = u, a = p) : (i = u, s = p));
    }
    return [i, r];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const i = xt.bisectToSegment(t, e);
    let r = i[0], s = xt.hueOf(r), a = i[1];
    for (let o = 0; o < 3; o++)
      if (r[o] !== a[o]) {
        let l = -1, d = 255;
        r[o] < a[o] ? (l = xt.criticalPlaneBelow(xt.trueDelinearized(r[o])), d = xt.criticalPlaneAbove(xt.trueDelinearized(a[o]))) : (l = xt.criticalPlaneAbove(xt.trueDelinearized(r[o])), d = xt.criticalPlaneBelow(xt.trueDelinearized(a[o])));
        for (let u = 0; u < 8 && !(Math.abs(d - l) <= 1); u++) {
          const p = Math.floor((l + d) / 2), f = xt.CRITICAL_PLANES[p], y = xt.setCoordinate(r, f, a, o), g = xt.hueOf(y);
          xt.areInCyclicOrder(s, e, g) ? (a = y, d = p) : (r = y, s = g, l = p);
        }
      }
    return xt.midpoint(r, a);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), i = Math.max(0, 27.13 * e / (400 - e));
    return pi(t) * Math.pow(i, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, i) {
    let r = Math.sqrt(i) * 11;
    const s = As.DEFAULT, a = 1 / Math.pow(1.64 - Math.pow(0.29, s.n), 0.73), o = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * s.nc * s.ncb, l = Math.sin(t), d = Math.cos(t);
    for (let u = 0; u < 5; u++) {
      const p = r / 100, f = e === 0 || r === 0 ? 0 : e / Math.sqrt(p), y = Math.pow(f * a, 1 / 0.9), g = s.aw * Math.pow(p, 1 / s.c / s.z) / s.nbb, b = 23 * (g + 0.305) * y / (23 * o + 11 * y * d + 108 * y * l), S = b * d, $ = b * l, Q = (460 * g + 451 * S + 288 * $) / 1403, E = (460 * g - 891 * S - 261 * $) / 1403, z = (460 * g - 220 * S - 6300 * $) / 1403, A = xt.inverseChromaticAdaptation(Q), V = xt.inverseChromaticAdaptation(E), D = xt.inverseChromaticAdaptation(z), X = NO([A, V, D], xt.LINRGB_FROM_SCALED_DISCOUNT);
      if (X[0] < 0 || X[1] < 0 || X[2] < 0)
        return 0;
      const Y = xt.Y_FROM_LINRGB[0], mt = xt.Y_FROM_LINRGB[1], ct = xt.Y_FROM_LINRGB[2], et = Y * X[0] + mt * X[1] + ct * X[2];
      if (et <= 0)
        return 0;
      if (u === 4 || Math.abs(et - i) < 2e-3)
        return X[0] > 100.01 || X[1] > 100.01 || X[2] > 100.01 ? 0 : Z5(X);
      r = r - (et - i) * r / (2 * et);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, i) {
    if (e < 1e-4 || i < 1e-4 || i > 99.9999)
      return iz(i);
    t = Bm(t);
    const r = t / 180 * Math.PI, s = Lr(i), a = xt.findResultByJ(r, e, s);
    if (a !== 0)
      return a;
    const o = xt.bisectToLimit(s, r);
    return Z5(o);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, i) {
    return yg.fromInt(xt.solveToInt(t, e, i));
  }
}, c(xt, "lt"), xt);
h(oz, "HctSolver");
let Rs = oz;
Rs.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
Rs.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
Rs.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
Rs.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
var Xr;
const lz = (Xr = class {
  static from(t, e, i) {
    return new Xr(Rs.solveToInt(t, e, i));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new Xr(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(Rs.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(Rs.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(Rs.solveToInt(this.internalHue, this.internalChroma, t));
  }
  constructor(t) {
    this.argb = t;
    const e = yg.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = X5(t), this.argb = t;
  }
  setInternalState(t) {
    const e = yg.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = X5(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const e = yg.fromInt(this.toInt()).xyzInViewingConditions(t), i = yg.fromXyzInViewingConditions(e[0], e[1], e[2], As.make());
    return Xr.from(i.hue, i.chroma, jO(e[1]));
  }
}, c(Xr, "pn"), Xr);
h(lz, "Hct");
let Qn = lz;
var $n;
const cz = ($n = class {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = Qw(0, 100, t), e = Qw(0, 100, e), $n.ratioOfYs(Lr(t), Lr(e));
  }
  static ratioOfYs(t, e) {
    const i = t > e ? t : e, r = i === e ? t : e;
    return (i + 5) / (r + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Lr(t), r = e * (i + 5) - 5, s = $n.ratioOfYs(r, i), a = Math.abs(s - e);
    if (s < e && a > 0.04)
      return -1;
    const o = jO(r) + 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Lr(t), r = (i + 5) / e - 5, s = $n.ratioOfYs(i, r), a = Math.abs(s - e);
    if (s < e && a > 0.04)
      return -1;
    const o = jO(r) - 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const i = $n.lighter(t, e);
    return i < 0 ? 100 : i;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const i = $n.darker(t, e);
    return i < 0 ? 0 : i;
  }
}, c($n, "dr"), $n);
h(cz, "Contrast");
let sn = cz;
var Ho;
const hz = (Ho = class {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, i = Math.round(t.chroma) > 16, r = Math.round(t.tone) < 65;
    return e && i && r;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return Ho.isDisliked(t) ? Qn.from(t.hue, t.chroma, 70) : t;
  }
}, c(Ho, "ch"), Ho);
h(hz, "DislikeAnalyzer");
let Zj = hz;
var Ze;
const dz = (Ze = class {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(t) {
    return new Ze(t.name ?? "", t.palette, t.tone, t.isBackground ?? !1, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(t, e, i, r, s, a, o, l) {
    if (this.name = t, this.palette = e, this.tone = i, this.isBackground = r, this.background = s, this.secondBackground = a, this.contrastCurve = o, this.toneDeltaPair = l, this.hctCache = /* @__PURE__ */ new Map(), !s && a)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!s && o)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (s && !o)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const i = this.getTone(t), r = this.palette(t).getHct(i);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, r), r;
  }
  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(t) {
    const e = t.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const i = this.toneDeltaPair(t), r = i.roleA, s = i.roleB, a = i.delta, o = i.polarity, l = i.stayTogether, d = this.background(t).getTone(t), u = o === "nearer" || o === "lighter" && !t.isDark || o === "darker" && t.isDark, p = u ? r : s, f = u ? s : r, y = this.name === p.name, g = t.isDark ? 1 : -1, b = p.contrastCurve.get(t.contrastLevel), S = f.contrastCurve.get(t.contrastLevel), $ = p.tone(t);
      let Q = sn.ratioOfTones(d, $) >= b ? $ : Ze.foregroundTone(d, b);
      const E = f.tone(t);
      let z = sn.ratioOfTones(d, E) >= S ? E : Ze.foregroundTone(d, S);
      return e && (Q = Ze.foregroundTone(d, b), z = Ze.foregroundTone(d, S)), (z - Q) * g >= a || (z = Qw(0, 100, Q + a * g), (z - Q) * g >= a || (Q = Qw(0, 100, z - a * g))), 50 <= Q && Q < 60 ? g > 0 ? (Q = 60, z = Math.max(z, Q + a * g)) : (Q = 49, z = Math.min(z, Q + a * g)) : 50 <= z && z < 60 && (l ? g > 0 ? (Q = 60, z = Math.max(z, Q + a * g)) : (Q = 49, z = Math.min(z, Q + a * g)) : g > 0 ? z = 60 : z = 49), y ? Q : z;
    } else {
      let i = this.tone(t);
      if (this.background == null)
        return i;
      const r = this.background(t).getTone(t), s = this.contrastCurve.get(t.contrastLevel);
      if (sn.ratioOfTones(r, i) >= s || (i = Ze.foregroundTone(r, s)), e && (i = Ze.foregroundTone(r, s)), this.isBackground && 50 <= i && i < 60 && (sn.ratioOfTones(49, r) >= s ? i = 49 : i = 60), this.secondBackground) {
        const [a, o] = [this.background, this.secondBackground], [l, d] = [a(t).getTone(t), o(t).getTone(t)], [u, p] = [Math.max(l, d), Math.min(l, d)];
        if (sn.ratioOfTones(u, i) >= s && sn.ratioOfTones(p, i) >= s)
          return i;
        const f = sn.lighter(u, s), y = sn.darker(p, s), g = [];
        return f !== -1 && g.push(f), y !== -1 && g.push(y), Ze.tonePrefersLightForeground(l) || Ze.tonePrefersLightForeground(d) ? f < 0 ? 100 : f : g.length === 1 ? g[0] : y < 0 ? 0 : y;
      }
      return i;
    }
  }
  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const i = sn.lighterUnsafe(t, e), r = sn.darkerUnsafe(t, e), s = sn.ratioOfTones(i, t), a = sn.ratioOfTones(r, t);
    if (Ze.tonePrefersLightForeground(t)) {
      const o = Math.abs(s - a) < 0.1 && s < e && a < e;
      return s >= e || s >= a || o ? i : r;
    } else
      return a >= e || a >= s ? r : i;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return Ze.tonePrefersLightForeground(t) && !Ze.toneAllowsLightForeground(t) ? 49 : t;
  }
}, c(Ze, "ke"), Ze);
h(dz, "DynamicColor");
let yt = dz;
var Nr;
const uz = (Nr = class {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = Qn.fromInt(t);
    return Nr.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new Nr(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    const i = new Xj(t, e).create();
    return new Nr(t, e, i);
  }
  constructor(t, e, i) {
    this.hue = t, this.chroma = e, this.keyColor = i, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (e = Qn.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return Qn.fromInt(this.tone(t));
  }
}, c(Nr, "un"), Nr);
h(uz, "TonalPalette");
let Et = uz;
var Yu;
const pz = (Yu = class {
  constructor(t, e) {
    this.hue = t, this.requestedChroma = e, this.chromaCache = /* @__PURE__ */ new Map(), this.maxChromaValue = 200;
  }
  /**
   * Creates a key color from a [hue] and a [chroma].
   * The key color is the first tone, starting from T50, matching the given hue
   * and chroma.
   *
   * @return Key color [Hct]
   */
  create() {
    let t = 0, e = 100;
    for (; t < e; ) {
      const i = Math.floor((t + e) / 2), r = this.maxChroma(i) < this.maxChroma(i + 1);
      if (this.maxChroma(i) >= this.requestedChroma - 0.01)
        if (Math.abs(t - 50) < Math.abs(e - 50))
          e = i;
        else {
          if (t === i)
            return Qn.from(this.hue, this.requestedChroma, t);
          t = i;
        }
      else
        r ? t = i + 1 : e = i;
    }
    return Qn.from(this.hue, this.requestedChroma, t);
  }
  // Find the maximum chroma for a given tone
  maxChroma(t) {
    if (this.chromaCache.has(t))
      return this.chromaCache.get(t);
    const e = Qn.from(this.hue, this.maxChromaValue, t).chroma;
    return this.chromaCache.set(t, e), e;
  }
}, c(Yu, "Ry"), Yu);
h(pz, "KeyColor");
let Xj = pz;
var Gu;
const fz = (Gu = class {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Value for contrast level -1.0
   * @param normal Value for contrast level 0.0
   * @param medium Value for contrast level 0.5
   * @param high Value for contrast level 1.0
   */
  constructor(t, e, i, r) {
    this.low = t, this.normal = e, this.medium = i, this.high = r;
  }
  /**
   * Returns the value at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0
   *     is the lowest; 1.0 is the highest.
   * @return The value. For contrast ratios, a number between 1.0 and 21.0.
   */
  get(t) {
    return t <= -1 ? this.low : t < 0 ? mh(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? mh(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? mh(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
}, c(Gu, "Ey"), Gu);
h(fz, "ContrastCurve");
let Tt = fz;
var Ku;
const mz = (Ku = class {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, i, r, s) {
    this.roleA = t, this.roleB = e, this.delta = i, this.polarity = r, this.stayTogether = s;
  }
}, c(Ku, "Ly"), Ku);
h(mz, "ToneDeltaPair");
let Ei = mz;
var sl;
(function(n) {
  n[n.MONOCHROME = 0] = "MONOCHROME", n[n.NEUTRAL = 1] = "NEUTRAL", n[n.TONAL_SPOT = 2] = "TONAL_SPOT", n[n.VIBRANT = 3] = "VIBRANT", n[n.EXPRESSIVE = 4] = "EXPRESSIVE", n[n.FIDELITY = 5] = "FIDELITY", n[n.CONTENT = 6] = "CONTENT", n[n.RAINBOW = 7] = "RAINBOW", n[n.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(sl || (sl = {}));
function Ql(n) {
  return n.variant === sl.FIDELITY || n.variant === sl.CONTENT;
}
c(Ql, "Fc");
h(Ql, "isFidelity");
function ne(n) {
  return n.variant === sl.MONOCHROME;
}
c(ne, "Lt");
h(ne, "isMonochrome");
function yz(n, t, e, i) {
  let r = e, s = Qn.from(n, t, e);
  if (s.chroma < t) {
    let a = s.chroma;
    for (; s.chroma < t; ) {
      r += i ? -1 : 1;
      const o = Qn.from(n, t, r);
      if (a > o.chroma || Math.abs(o.chroma - t) < 0.4)
        break;
      const l = Math.abs(o.chroma - t), d = Math.abs(s.chroma - t);
      l < d && (s = o), a = Math.max(a, o.chroma);
    }
  }
  return r;
}
c(yz, "kg");
h(yz, "findDesiredChromaByTone");
var na;
const gz = (na = class {
  static highestSurface(t) {
    return t.isDark ? na.surfaceBright : na.surfaceDim;
  }
}, c(na, "sl"), na);
h(gz, "MaterialDynamicColors");
let R = gz;
R.contentAccentToneDelta = 15;
R.primaryPaletteKeyColor = yt.fromPalette({
  name: "primary_palette_key_color",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.primaryPalette.keyColor.tone, "tone")
});
R.secondaryPaletteKeyColor = yt.fromPalette({
  name: "secondary_palette_key_color",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.secondaryPalette.keyColor.tone, "tone")
});
R.tertiaryPaletteKeyColor = yt.fromPalette({
  name: "tertiary_palette_key_color",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.tertiaryPalette.keyColor.tone, "tone")
});
R.neutralPaletteKeyColor = yt.fromPalette({
  name: "neutral_palette_key_color",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.neutralPalette.keyColor.tone, "tone")
});
R.neutralVariantPaletteKeyColor = yt.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: /* @__PURE__ */ h((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.neutralVariantPalette.keyColor.tone, "tone")
});
R.background = yt.fromPalette({
  name: "background",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
R.onBackground = yt.fromPalette({
  name: "on_background",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ h((n) => R.background, "background"),
  contrastCurve: new Tt(3, 3, 4.5, 7)
});
R.surface = yt.fromPalette({
  name: "surface",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
R.surfaceDim = yt.fromPalette({
  name: "surface_dim",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 6 : new Tt(87, 87, 80, 75).get(n.contrastLevel), "tone"),
  isBackground: !0
});
R.surfaceBright = yt.fromPalette({
  name: "surface_bright",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? new Tt(24, 24, 29, 34).get(n.contrastLevel) : 98, "tone"),
  isBackground: !0
});
R.surfaceContainerLowest = yt.fromPalette({
  name: "surface_container_lowest",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? new Tt(4, 4, 2, 0).get(n.contrastLevel) : 100, "tone"),
  isBackground: !0
});
R.surfaceContainerLow = yt.fromPalette({
  name: "surface_container_low",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? new Tt(10, 10, 11, 12).get(n.contrastLevel) : new Tt(96, 96, 96, 95).get(n.contrastLevel), "tone"),
  isBackground: !0
});
R.surfaceContainer = yt.fromPalette({
  name: "surface_container",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? new Tt(12, 12, 16, 20).get(n.contrastLevel) : new Tt(94, 94, 92, 90).get(n.contrastLevel), "tone"),
  isBackground: !0
});
R.surfaceContainerHigh = yt.fromPalette({
  name: "surface_container_high",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? new Tt(17, 17, 21, 25).get(n.contrastLevel) : new Tt(92, 92, 88, 85).get(n.contrastLevel), "tone"),
  isBackground: !0
});
R.surfaceContainerHighest = yt.fromPalette({
  name: "surface_container_highest",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? new Tt(22, 22, 26, 30).get(n.contrastLevel) : new Tt(90, 90, 84, 80).get(n.contrastLevel), "tone"),
  isBackground: !0
});
R.onSurface = yt.fromPalette({
  name: "on_surface",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.surfaceVariant = yt.fromPalette({
  name: "surface_variant",
  palette: /* @__PURE__ */ h((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0
});
R.onSurfaceVariant = yt.fromPalette({
  name: "on_surface_variant",
  palette: /* @__PURE__ */ h((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 80 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.inverseSurface = yt.fromPalette({
  name: "inverse_surface",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 90 : 20, "tone")
});
R.inverseOnSurface = yt.fromPalette({
  name: "inverse_on_surface",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 20 : 95, "tone"),
  background: /* @__PURE__ */ h((n) => R.inverseSurface, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.outline = yt.fromPalette({
  name: "outline",
  palette: /* @__PURE__ */ h((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 60 : 50, "tone"),
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1.5, 3, 4.5, 7)
});
R.outlineVariant = yt.fromPalette({
  name: "outline_variant",
  palette: /* @__PURE__ */ h((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 30 : 80, "tone"),
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5)
});
R.shadow = yt.fromPalette({
  name: "shadow",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => 0, "tone")
});
R.scrim = yt.fromPalette({
  name: "scrim",
  palette: /* @__PURE__ */ h((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => 0, "tone")
});
R.surfaceTint = yt.fromPalette({
  name: "surface_tint",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0
});
R.primary = yt.fromPalette({
  name: "primary",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 100 : 0 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.primaryContainer, R.primary, 10, "nearer", !1), "toneDeltaPair")
});
R.onPrimary = yt.fromPalette({
  name: "on_primary",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ h((n) => R.primary, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.primaryContainer = yt.fromPalette({
  name: "primary_container",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => Ql(n) ? n.sourceColorHct.tone : ne(n) ? n.isDark ? 85 : 25 : n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.primaryContainer, R.primary, 10, "nearer", !1), "toneDeltaPair")
});
R.onPrimaryContainer = yt.fromPalette({
  name: "on_primary_container",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => Ql(n) ? yt.foregroundTone(R.primaryContainer.tone(n), 4.5) : ne(n) ? n.isDark ? 0 : 100 : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.primaryContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.inversePrimary = yt.fromPalette({
  name: "inverse_primary",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 40 : 80, "tone"),
  background: /* @__PURE__ */ h((n) => R.inverseSurface, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7)
});
R.secondary = yt.fromPalette({
  name: "secondary",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.secondaryContainer, R.secondary, 10, "nearer", !1), "toneDeltaPair")
});
R.onSecondary = yt.fromPalette({
  name: "on_secondary",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 10 : 100 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ h((n) => R.secondary, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.secondaryContainer = yt.fromPalette({
  name: "secondary_container",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => {
    const t = n.isDark ? 30 : 90;
    return ne(n) ? n.isDark ? 30 : 85 : Ql(n) ? yz(n.secondaryPalette.hue, n.secondaryPalette.chroma, t, !n.isDark) : t;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.secondaryContainer, R.secondary, 10, "nearer", !1), "toneDeltaPair")
});
R.onSecondaryContainer = yt.fromPalette({
  name: "on_secondary_container",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 90 : 10 : Ql(n) ? yt.foregroundTone(R.secondaryContainer.tone(n), 4.5) : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.secondaryContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.tertiary = yt.fromPalette({
  name: "tertiary",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 90 : 25 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.tertiaryContainer, R.tertiary, 10, "nearer", !1), "toneDeltaPair")
});
R.onTertiary = yt.fromPalette({
  name: "on_tertiary",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ h((n) => R.tertiary, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.tertiaryContainer = yt.fromPalette({
  name: "tertiary_container",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => {
    if (ne(n))
      return n.isDark ? 60 : 49;
    if (!Ql(n))
      return n.isDark ? 30 : 90;
    const t = n.tertiaryPalette.getHct(n.sourceColorHct.tone);
    return Zj.fixIfDisliked(t).tone;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.tertiaryContainer, R.tertiary, 10, "nearer", !1), "toneDeltaPair")
});
R.onTertiaryContainer = yt.fromPalette({
  name: "on_tertiary_container",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 0 : 100 : Ql(n) ? yt.foregroundTone(R.tertiaryContainer.tone(n), 4.5) : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.tertiaryContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.error = yt.fromPalette({
  name: "error",
  palette: /* @__PURE__ */ h((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.errorContainer, R.error, 10, "nearer", !1), "toneDeltaPair")
});
R.onError = yt.fromPalette({
  name: "on_error",
  palette: /* @__PURE__ */ h((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ h((n) => R.error, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.errorContainer = yt.fromPalette({
  name: "error_container",
  palette: /* @__PURE__ */ h((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.errorContainer, R.error, 10, "nearer", !1), "toneDeltaPair")
});
R.onErrorContainer = yt.fromPalette({
  name: "on_error_container",
  palette: /* @__PURE__ */ h((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? n.isDark ? 90 : 10 : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.errorContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.primaryFixed = yt.fromPalette({
  name: "primary_fixed",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.primaryFixed, R.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
R.primaryFixedDim = yt.fromPalette({
  name: "primary_fixed_dim",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.primaryFixed, R.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
R.onPrimaryFixed = yt.fromPalette({
  name: "on_primary_fixed",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ h((n) => R.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ h((n) => R.primaryFixed, "secondBackground"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.onPrimaryFixedVariant = yt.fromPalette({
  name: "on_primary_fixed_variant",
  palette: /* @__PURE__ */ h((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ h((n) => R.primaryFixed, "secondBackground"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.secondaryFixed = yt.fromPalette({
  name: "secondary_fixed",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 80 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.secondaryFixed, R.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
R.secondaryFixedDim = yt.fromPalette({
  name: "secondary_fixed_dim",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 70 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.secondaryFixed, R.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
R.onSecondaryFixed = yt.fromPalette({
  name: "on_secondary_fixed",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => 10, "tone"),
  background: /* @__PURE__ */ h((n) => R.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ h((n) => R.secondaryFixed, "secondBackground"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.onSecondaryFixedVariant = yt.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: /* @__PURE__ */ h((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 25 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ h((n) => R.secondaryFixed, "secondBackground"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
R.tertiaryFixed = yt.fromPalette({
  name: "tertiary_fixed",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.tertiaryFixed, R.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
R.tertiaryFixedDim = yt.fromPalette({
  name: "tertiary_fixed_dim",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ h((n) => R.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ h((n) => new Ei(R.tertiaryFixed, R.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
R.onTertiaryFixed = yt.fromPalette({
  name: "on_tertiary_fixed",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ h((n) => R.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ h((n) => R.tertiaryFixed, "secondBackground"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
R.onTertiaryFixedVariant = yt.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: /* @__PURE__ */ h((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ h((n) => ne(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ h((n) => R.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ h((n) => R.tertiaryFixed, "secondBackground"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
var Ju;
const wz = (Ju = class {
  constructor(t) {
    this.sourceColorArgb = t.sourceColorArgb, this.variant = t.variant, this.contrastLevel = t.contrastLevel, this.isDark = t.isDark, this.sourceColorHct = Qn.fromInt(t.sourceColorArgb), this.primaryPalette = t.primaryPalette, this.secondaryPalette = t.secondaryPalette, this.tertiaryPalette = t.tertiaryPalette, this.neutralPalette = t.neutralPalette, this.neutralVariantPalette = t.neutralVariantPalette, this.errorPalette = Et.fromHueAndChroma(25, 84);
  }
  /**
   * Support design spec'ing Dynamic Color by schemes that specify hue
   * rotations that should be applied at certain breakpoints.
   * @param sourceColor the source color of the theme, in HCT.
   * @param hues The "breakpoints", i.e. the hues at which a rotation should
   * be apply.
   * @param rotations The rotation that should be applied when source color's
   * hue is >= the same index in hues array, and <= the hue at the next index
   * in hues array.
   */
  static getRotatedHue(t, e, i) {
    const r = t.hue;
    if (e.length !== i.length)
      throw new Error(`mismatch between hue length ${e.length} & rotations ${i.length}`);
    if (i.length === 1)
      return Bm(t.hue + i[0]);
    const s = e.length;
    for (let a = 0; a <= s - 2; a++) {
      const o = e[a], l = e[a + 1];
      if (o < r && r < l)
        return Bm(r + i[a]);
    }
    return r;
  }
  getArgb(t) {
    return t.getArgb(this);
  }
  getHct(t) {
    return t.getHct(this);
  }
  get primaryPaletteKeyColor() {
    return this.getArgb(R.primaryPaletteKeyColor);
  }
  get secondaryPaletteKeyColor() {
    return this.getArgb(R.secondaryPaletteKeyColor);
  }
  get tertiaryPaletteKeyColor() {
    return this.getArgb(R.tertiaryPaletteKeyColor);
  }
  get neutralPaletteKeyColor() {
    return this.getArgb(R.neutralPaletteKeyColor);
  }
  get neutralVariantPaletteKeyColor() {
    return this.getArgb(R.neutralVariantPaletteKeyColor);
  }
  get background() {
    return this.getArgb(R.background);
  }
  get onBackground() {
    return this.getArgb(R.onBackground);
  }
  get surface() {
    return this.getArgb(R.surface);
  }
  get surfaceDim() {
    return this.getArgb(R.surfaceDim);
  }
  get surfaceBright() {
    return this.getArgb(R.surfaceBright);
  }
  get surfaceContainerLowest() {
    return this.getArgb(R.surfaceContainerLowest);
  }
  get surfaceContainerLow() {
    return this.getArgb(R.surfaceContainerLow);
  }
  get surfaceContainer() {
    return this.getArgb(R.surfaceContainer);
  }
  get surfaceContainerHigh() {
    return this.getArgb(R.surfaceContainerHigh);
  }
  get surfaceContainerHighest() {
    return this.getArgb(R.surfaceContainerHighest);
  }
  get onSurface() {
    return this.getArgb(R.onSurface);
  }
  get surfaceVariant() {
    return this.getArgb(R.surfaceVariant);
  }
  get onSurfaceVariant() {
    return this.getArgb(R.onSurfaceVariant);
  }
  get inverseSurface() {
    return this.getArgb(R.inverseSurface);
  }
  get inverseOnSurface() {
    return this.getArgb(R.inverseOnSurface);
  }
  get outline() {
    return this.getArgb(R.outline);
  }
  get outlineVariant() {
    return this.getArgb(R.outlineVariant);
  }
  get shadow() {
    return this.getArgb(R.shadow);
  }
  get scrim() {
    return this.getArgb(R.scrim);
  }
  get surfaceTint() {
    return this.getArgb(R.surfaceTint);
  }
  get primary() {
    return this.getArgb(R.primary);
  }
  get onPrimary() {
    return this.getArgb(R.onPrimary);
  }
  get primaryContainer() {
    return this.getArgb(R.primaryContainer);
  }
  get onPrimaryContainer() {
    return this.getArgb(R.onPrimaryContainer);
  }
  get inversePrimary() {
    return this.getArgb(R.inversePrimary);
  }
  get secondary() {
    return this.getArgb(R.secondary);
  }
  get onSecondary() {
    return this.getArgb(R.onSecondary);
  }
  get secondaryContainer() {
    return this.getArgb(R.secondaryContainer);
  }
  get onSecondaryContainer() {
    return this.getArgb(R.onSecondaryContainer);
  }
  get tertiary() {
    return this.getArgb(R.tertiary);
  }
  get onTertiary() {
    return this.getArgb(R.onTertiary);
  }
  get tertiaryContainer() {
    return this.getArgb(R.tertiaryContainer);
  }
  get onTertiaryContainer() {
    return this.getArgb(R.onTertiaryContainer);
  }
  get error() {
    return this.getArgb(R.error);
  }
  get onError() {
    return this.getArgb(R.onError);
  }
  get errorContainer() {
    return this.getArgb(R.errorContainer);
  }
  get onErrorContainer() {
    return this.getArgb(R.onErrorContainer);
  }
  get primaryFixed() {
    return this.getArgb(R.primaryFixed);
  }
  get primaryFixedDim() {
    return this.getArgb(R.primaryFixedDim);
  }
  get onPrimaryFixed() {
    return this.getArgb(R.onPrimaryFixed);
  }
  get onPrimaryFixedVariant() {
    return this.getArgb(R.onPrimaryFixedVariant);
  }
  get secondaryFixed() {
    return this.getArgb(R.secondaryFixed);
  }
  get secondaryFixedDim() {
    return this.getArgb(R.secondaryFixedDim);
  }
  get onSecondaryFixed() {
    return this.getArgb(R.onSecondaryFixed);
  }
  get onSecondaryFixedVariant() {
    return this.getArgb(R.onSecondaryFixedVariant);
  }
  get tertiaryFixed() {
    return this.getArgb(R.tertiaryFixed);
  }
  get tertiaryFixedDim() {
    return this.getArgb(R.tertiaryFixedDim);
  }
  get onTertiaryFixed() {
    return this.getArgb(R.onTertiaryFixed);
  }
  get onTertiaryFixedVariant() {
    return this.getArgb(R.onTertiaryFixedVariant);
  }
}, c(Ju, "Oy"), Ju);
h(wz, "DynamicScheme");
let ho = wz;
var nr;
const vz = (nr = class extends ho {
  constructor(t, e, i) {
    super({
      sourceColorArgb: t.toInt(),
      variant: sl.EXPRESSIVE,
      contrastLevel: i,
      isDark: e,
      primaryPalette: Et.fromHueAndChroma(Bm(t.hue + 240), 40),
      secondaryPalette: Et.fromHueAndChroma(ho.getRotatedHue(t, nr.hues, nr.secondaryRotations), 24),
      tertiaryPalette: Et.fromHueAndChroma(ho.getRotatedHue(t, nr.hues, nr.tertiaryRotations), 32),
      neutralPalette: Et.fromHueAndChroma(t.hue + 15, 8),
      neutralVariantPalette: Et.fromHueAndChroma(t.hue + 15, 12)
    });
  }
}, c(nr, "Kr"), nr);
h(vz, "SchemeExpressive");
let EP = vz;
EP.hues = [
  0,
  21,
  51,
  121,
  151,
  191,
  271,
  321,
  360
];
EP.secondaryRotations = [
  45,
  95,
  45,
  20,
  45,
  90,
  45,
  45,
  45
];
EP.tertiaryRotations = [
  120,
  120,
  20,
  45,
  20,
  15,
  20,
  120,
  120
];
var rr;
const Oz = (rr = class extends ho {
  constructor(t, e, i) {
    super({
      sourceColorArgb: t.toInt(),
      variant: sl.VIBRANT,
      contrastLevel: i,
      isDark: e,
      primaryPalette: Et.fromHueAndChroma(t.hue, 200),
      secondaryPalette: Et.fromHueAndChroma(ho.getRotatedHue(t, rr.hues, rr.secondaryRotations), 24),
      tertiaryPalette: Et.fromHueAndChroma(ho.getRotatedHue(t, rr.hues, rr.tertiaryRotations), 32),
      neutralPalette: Et.fromHueAndChroma(t.hue, 10),
      neutralVariantPalette: Et.fromHueAndChroma(t.hue, 12)
    });
  }
}, c(rr, "Gr"), rr);
h(Oz, "SchemeVibrant");
let _P = Oz;
_P.hues = [
  0,
  41,
  61,
  101,
  131,
  181,
  251,
  301,
  360
];
_P.secondaryRotations = [
  18,
  15,
  10,
  12,
  15,
  18,
  15,
  12,
  12
];
_P.tertiaryRotations = [
  35,
  30,
  20,
  25,
  30,
  35,
  30,
  25,
  25
];
function bz(n) {
  n = n.replace("#", "");
  const t = n.length === 3, e = n.length === 6, i = n.length === 8;
  if (!t && !e && !i)
    throw new Error("unexpected hex " + n);
  let r = 0, s = 0, a = 0;
  return t ? (r = Nn(n.slice(0, 1).repeat(2)), s = Nn(n.slice(1, 2).repeat(2)), a = Nn(n.slice(2, 3).repeat(2))) : e ? (r = Nn(n.slice(0, 2)), s = Nn(n.slice(2, 4)), a = Nn(n.slice(4, 6))) : i && (r = Nn(n.slice(2, 4)), s = Nn(n.slice(4, 6)), a = Nn(n.slice(6, 8))), (255 << 24 | (r & 255) << 16 | (s & 255) << 8 | a & 255) >>> 0;
}
c(bz, "_g");
h(bz, "argbFromHex");
function Nn(n) {
  return parseInt(n, 16);
}
c(Nn, "Oi");
h(Nn, "parseIntHex");
function $z(n, t = !1) {
  const e = n.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)?.slice(1).map((o, l) => l === 3 ? Math.round(parseFloat(o) * 255) : parseFloat(o));
  if (!e)
    throw new Error("Could not parse rgba color.");
  const [i, r, s, a] = e;
  return ((t ? 255 : a & 255) << 24 | (i & 255) << 16 | (r & 255) << 8 | s & 255) >>> 0;
}
c($z, "Pg");
h($z, "argbFromRgba");
function On(n, t) {
  return Math.round(255 * t) << 24 | n & 16777215;
}
c(On, "ui");
h(On, "addAlphaToArgb");
function xz(n) {
  const t = TP(n), e = MP(n), i = AP(n), r = J_(n), s = [t.toString(16), e.toString(16), i.toString(16)];
  r !== 255 && s.push(r.toString(16));
  for (const [a, o] of s.entries())
    o.length === 1 && (s[a] = "0" + o);
  return "#" + s.join("");
}
c(xz, "Mg");
h(xz, "hexWithAlphaFromArgb");
function kz(n) {
  we();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${n} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
c(kz, "Sg");
h(kz, "getComputedColor");
var tp;
const Sz = (tp = class extends ho {
  constructor(t, e, i) {
    super({
      sourceColorArgb: t.toInt(),
      variant: 2,
      contrastLevel: i,
      isDark: e,
      primaryPalette: Et.fromHueAndChroma(t.hue, 36),
      secondaryPalette: Et.fromHueAndChroma(t.hue, 16),
      tertiaryPalette: Et.fromHueAndChroma(Bm(t.hue - 6 * 22.5), 16),
      neutralPalette: Et.fromHueAndChroma(t.hue, 6),
      neutralVariantPalette: Et.fromHueAndChroma(t.hue, 8)
    }), this.allTones = {
      //"100": 100,
      98: 98,
      // MD3
      95: 95,
      90: 90,
      80: 80,
      70: 70,
      60: 60,
      50: 50,
      40: 40,
      30: 30,
      20: 20,
      10: 10
      //"0": 0
    }, this.namedColorToneMap = {
      red: { light: 60, dark: 60 },
      "deep-orange": { light: 60, dark: 60 },
      orange: { light: 70, dark: 70 },
      amber: { light: 70, dark: 70 },
      yellow: { light: 70, dark: 80 },
      lime: { light: 70, dark: 70 },
      "light-green": { light: 70, dark: 70 },
      green: { light: 60, dark: 60 },
      teal: { light: 60, dark: 60 },
      cyan: { light: 50, dark: 60 },
      "light-blue": { light: 60, dark: 70 },
      blue: { light: 70, dark: 80 },
      indigo: { light: 60, dark: 60 },
      "deep-purple": { light: 60, dark: 70 },
      purple: { light: 60, dark: 70 },
      pink: { light: 60, dark: 70 },
      gray: { light: 50, dark: 60 }
    };
    const r = t.hue, s = t.chroma, a = Math.max(48, s), o = Math.min(a, 84), l = 360 / 16, d = 27.4, u = -8, p = (r + 360 - d - u + l / 2) % l + d + u - l / 2;
    this.errorPalette = Et.fromHueAndChroma(p, 84), this.warningPalette = Et.fromHueAndChroma(p + 4 * l, o), this.namedColorPalettes = {
      red: Et.fromHueAndChroma(p, o),
      "deep-orange": Et.fromHueAndChroma(p + 1 * l, o),
      orange: Et.fromHueAndChroma(p + 2 * l, o),
      amber: Et.fromHueAndChroma(p + 3 * l, o),
      yellow: Et.fromHueAndChroma(p + 4 * l, o),
      lime: Et.fromHueAndChroma(p + 5 * l, o),
      "light-green": Et.fromHueAndChroma(p + 6 * l, o),
      green: Et.fromHueAndChroma(p + 7 * l, o),
      teal: Et.fromHueAndChroma(p + 8 * l, o),
      cyan: Et.fromHueAndChroma(p + 9 * l, o),
      "light-blue": Et.fromHueAndChroma(p + 10 * l, o),
      blue: Et.fromHueAndChroma(p + 11 * l, o),
      indigo: Et.fromHueAndChroma(p + 12 * l, o),
      "deep-purple": Et.fromHueAndChroma(p + 13 * l, o),
      purple: Et.fromHueAndChroma(p + 14 * l, o),
      pink: Et.fromHueAndChroma(p + 15 * l, o),
      gray: Et.fromHueAndChroma(r, 4)
    };
  }
  // Solid base colors
  get black() {
    return 0;
  }
  get white() {
    return 16777215;
  }
  // Custom transparency based surface container colors
  get surfaceLayerLowest() {
    return this.isDark ? On(this.black, 0.5) : On(this.white, 0.75);
  }
  get surfaceLayerLow() {
    return this.isDark ? On(this.black, 0.25) : On(this.white, 0.5);
  }
  get surfaceLayer() {
    return this.isDark ? On(this.white, 0.05) : On(this.black, 0.05);
  }
  get surfaceLayerHigh() {
    return this.isDark ? On(this.white, 0.1) : On(this.black, 0.075);
  }
  get surfaceLayerHighest() {
    return this.isDark ? On(this.white, 0.15) : On(this.black, 0.1);
  }
  // Custom Tokens
  get warning() {
    return this.warningPalette.tone(this.isDark ? 90 : 70);
  }
  get onWarning() {
    return this.warningPalette.tone(this.isDark ? 30 : 0);
  }
  get warningContainer() {
    return this.warningPalette.tone(this.isDark ? 50 : 90);
  }
  get onWarningContainer() {
    return this.warningPalette.tone(this.isDark ? 95 : 10);
  }
  get highlight() {
    return this.primaryPalette.tone(this.isDark ? 20 : 95);
  }
  get onHighlight() {
    return this.primaryPalette.tone(this.isDark ? 90 : 10);
  }
  // Named colors
  namedColor(t) {
    return this.namedColorPalettes[t].tone(this.namedColorToneMap[t][this.isDark ? "dark" : "light"]);
  }
  get red() {
    return this.namedColor(
      "red"
      /* Red */
    );
  }
  get deepOrange() {
    return this.namedColor(
      "deep-orange"
      /* DeepOrange */
    );
  }
  get orange() {
    return this.namedColor(
      "orange"
      /* Orange */
    );
  }
  get amber() {
    return this.namedColor(
      "amber"
      /* Amber */
    );
  }
  get yellow() {
    return this.namedColor(
      "yellow"
      /* Yellow */
    );
  }
  get lime() {
    return this.namedColor(
      "lime"
      /* Lime */
    );
  }
  get lightGreen() {
    return this.namedColor(
      "light-green"
      /* LightGreen */
    );
  }
  get green() {
    return this.namedColor(
      "green"
      /* Green */
    );
  }
  get teal() {
    return this.namedColor(
      "teal"
      /* Teal */
    );
  }
  get cyan() {
    return this.namedColor(
      "cyan"
      /* Cyan */
    );
  }
  get lightBlue() {
    return this.namedColor(
      "light-blue"
      /* LightBlue */
    );
  }
  get blue() {
    return this.namedColor(
      "blue"
      /* Blue */
    );
  }
  get indigo() {
    return this.namedColor(
      "indigo"
      /* Indigo */
    );
  }
  get deepPurple() {
    return this.namedColor(
      "deep-purple"
      /* DeepPurple */
    );
  }
  get purple() {
    return this.namedColor(
      "purple"
      /* Purple */
    );
  }
  get pink() {
    return this.namedColor(
      "pink"
      /* Pink */
    );
  }
  get gray() {
    return this.namedColor(
      "gray"
      /* Gray */
    );
  }
}, c(tp, "Iy"), tp);
h(Sz, "SchemeWeavy");
let GQ = Sz;
function BO(n) {
  return getComputedStyle(n).getPropertyValue("--wy-theme-color") || void 0;
}
c(BO, "lu");
h(BO, "getCSSThemeColor");
function Cz(n, t) {
  let e = BO(n);
  const i = new MutationObserver(() => {
    const a = BO(n);
    a !== e && (e = a, t(a));
  }), r = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let s = n;
  for (; s && s !== document; )
    i.observe(s, r), s = s.parentNode;
  return () => i.disconnect();
}
c(Cz, "Ag");
h(Cz, "observeCSSThemeColor");
function UO() {
  return we(), Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((n) => {
    const t = n.getAttribute("media");
    return !t || window.matchMedia(t)?.matches;
  }).pop()?.getAttribute("content") || void 0;
}
c(UO, "du");
h(UO, "getMetaThemeColor");
function Pz(n) {
  we();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = UO();
  const i = /* @__PURE__ */ h(() => {
    const o = UO();
    o !== e && (e = o, n(o));
  }, "checkChangedColor"), r = new MutationObserver(i), s = {
    attributes: !0,
    attributeFilter: ["content"]
  }, a = [];
  return t.forEach((o) => {
    r.observe(o, s);
    const l = o.getAttribute("media");
    if (l) {
      const d = window.matchMedia(l);
      d.addEventListener("change", i), a.push(d);
    }
  }), () => {
    r.disconnect(), a.forEach((o) => o.removeEventListener("change", i));
  };
}
c(Pz, "zg");
h(Pz, "observeMetaThemeColor");
const tg = [], Nj = 16;
function Qz(n, t = !1) {
  if (tg.some((l) => l.seedColor === n)) {
    const l = tg.find((d) => d.seedColor === n)?.colors;
    if (l)
      return l;
  }
  const e = [];
  t && e.push(`--wy-theme-color:${n};`);
  let i = n;
  !n.startsWith("#") && !n.startsWith("rgb") && (i = kz(n));
  const r = n.startsWith("#") ? bz(i) : $z(i), s = Qn.fromInt(r), a = {
    light: new GQ(s, !1, 0),
    dark: new GQ(s, !0, 0)
  }, o = {
    primary: "primary",
    onPrimary: "on-primary",
    primaryContainer: "primary-container",
    onPrimaryContainer: "on-primary-container",
    secondary: "secondary",
    onSecondary: "on-secondary",
    secondaryContainer: "secondary-container",
    onSecondaryContainer: "on-secondary-container",
    tertiary: "tertiary",
    onTertiary: "on-tertiary",
    tertiaryContainer: "tertiary-container",
    onTertiaryContainer: "on-tertiary-container",
    error: "error",
    onError: "on-error",
    errorContainer: "error-container",
    onErrorContainer: "on-error-container",
    background: "background",
    onBackground: "on-background",
    surface: "surface",
    onSurface: "on-surface",
    surfaceVariant: "surface-variant",
    onSurfaceVariant: "on-surface-variant",
    surfaceContainerLowest: "surface-container-lowest",
    surfaceContainerLow: "surface-container-low",
    surfaceContainer: "surface-container",
    surfaceContainerHigh: "surface-container-high",
    surfaceContainerHighest: "surface-container-highest",
    outline: "outline",
    outlineVariant: "outline-variant",
    shadow: "shadow",
    scrim: "scrim",
    // Custom surface layers
    surfaceLayerLowest: "surface-layer-lowest",
    surfaceLayerLow: "surface-layer-low",
    surfaceLayer: "surface-layer",
    surfaceLayerHigh: "surface-layer-high",
    surfaceLayerHighest: "surface-layer-highest",
    // Custom tokens
    warning: "warning",
    onWarning: "on-warning",
    warningContainer: "warning-container",
    onWarningContainer: "on-warning-container",
    highlight: "highlight",
    onHighlight: "on-highlight",
    // Named colors
    red: "red",
    deepOrange: "deep-orange",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    lightGreen: "light-green",
    green: "green",
    teal: "teal",
    cyan: "cyan",
    lightBlue: "light-blue",
    blue: "blue",
    indigo: "indigo",
    deepPurple: "deep-purple",
    purple: "purple",
    pink: "pink",
    gray: "gray"
  };
  for (const l in a) {
    const d = a[l];
    for (const u in o) {
      const p = o[u], f = xz(d[u]);
      e.push(`--wy-${p}-${l}:${f};`);
    }
  }
  return tg.unshift({ seedColor: n, colors: e }), tg.length = Math.min(tg.length, Nj), e;
}
c(Qz, "Eg");
h(Qz, "generateThemeColors");
const jj = /* @__PURE__ */ h((n) => {
  if (we(), q0)
    document.adoptedStyleSheets = n.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of n) {
      const e = document.createElement("style"), i = global.litNonce;
      i !== void 0 && e.setAttribute("nonce", i), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), Qe = tt`@property --wy-color-scheme{syntax:\"normal | light | dark\";inherits:true;initial-value:normal}:is(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-light,[part~=wy-light])),:host :is(.wy-light,[part~=wy-light]),::slotted(:is(.wy-light,[part~=wy-light])){color-scheme:light;--wy-primary:var(--wy-primary-light, #2f628c);--wy-on-primary:var(--wy-on-primary-light, #ffffff);--wy-primary-container:var(--wy-primary-container-light, #cee5ff);--wy-on-primary-container:var(--wy-on-primary-container-light, #0d4a73);--wy-secondary:var(--wy-secondary-light, #51606f);--wy-on-secondary:var(--wy-on-secondary-light, #ffffff);--wy-secondary-container:var(--wy-secondary-container-light, #d5e4f7);--wy-on-secondary-container:var(--wy-on-secondary-container-light, #3a4857);--wy-tertiary:var(--wy-tertiary-light, #645f41);--wy-on-tertiary:var(--wy-on-tertiary-light, #ffffff);--wy-tertiary-container:var(--wy-tertiary-container-light, #ebe3bd);--wy-on-tertiary-container:var(--wy-on-tertiary-container-light, #4c472b);--wy-error:var(--wy-error-light, #ba1821);--wy-on-error:var(--wy-on-error-light, #ffffff);--wy-error-container:var(--wy-error-container-light, #ffdad6);--wy-on-error-container:var(--wy-on-error-container-light, #930012);--wy-background:var(--wy-background-light, #f7f9ff);--wy-on-background:var(--wy-on-background-light, #181c20);--wy-surface:var(--wy-surface-light, #f7f9ff);--wy-on-surface:var(--wy-on-surface-light, #181c20);--wy-surface-variant:var(--wy-surface-variant-light, #dee3eb);--wy-on-surface-variant:var(--wy-on-surface-variant-light, #42474e);--wy-outline:var(--wy-outline-light, #72777f);--wy-outline-variant:var(--wy-outline-variant-light, #c2c7cf);--wy-surface-container-highest:var(--wy-surface-container-highest-light, #e0e2e8);--wy-surface-container-high:var(--wy-surface-container-high-light, #e6e8ee);--wy-surface-container:var(--wy-surface-container-light, #eceef3);--wy-surface-container-low:var(--wy-surface-container-low-light, #f1f3f9);--wy-surface-container-lowest:var(--wy-surface-container-lowest-light, #ffffff);--wy-surface-layer-highest:var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843));--wy-surface-layer-high:var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039));--wy-surface-layer:var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078));--wy-warning:var(--wy-warning-light, #adb140);--wy-on-warning:var(--wy-on-warning-light, #000000);--wy-warning-container:var(--wy-warning-container-light, #e5e972);--wy-on-warning-container:var(--wy-on-warning-container-light, #1c1d00);--wy-highlight:var(--wy-highlight-light, #e8f2ff);--wy-on-highlight:var(--wy-on-highlight-light, #001d32);--wy-link:var(--wy-primary-light, #2f628c);--wy-presence-active:var(--wy-green-light, #00a38d);--wy-shade:var(--wy-shade-light, rgba(0, 0, 0, .3));--wy-shade-invert:var(--wy-shade-invert-light, rgba(255, 255, 255, .15));--wy-shade-opaque:var(--wy-shade-opaque-light, white);--wy-blue:var(--wy-blue-light, #8aa9fc);--wy-indigo:var(--wy-indigo-light, #9285de);--wy-purple:var(--wy-purple-light, #c675b6);--wy-pink:var(--wy-pink-light, #d57193);--wy-red:var(--wy-red-light, #db726b);--wy-orange:var(--wy-orange-light, #e79b3a);--wy-yellow:var(--wy-yellow-light, #adb140);--wy-green:var(--wy-green-light, #00a38d);--wy-teal:var(--wy-teal-light, #00a0a9);--wy-cyan:var(--wy-cyan-light, #0081a2);--wy-gray:var(--wy-gray-light, #76777a);--wy-code-text:var(--wy-code-text-light, #3b3b3b);--wy-code-variable:var(--wy-code-variable-light, #001080);--wy-code-operator:var(--wy-code-operator-light, #000000);--wy-code-prolog:var(--wy-code-prolog-light, #000080);--wy-code-comment:var(--wy-code-comment-light, #008000);--wy-code-builtin:var(--wy-code-builtin-light, #0070C1);--wy-code-number:var(--wy-code-number-light, #098658);--wy-code-inserted:var(--wy-code-inserted-light, #098658);--wy-code-constant:var(--wy-code-constant-light, #811F3F);--wy-code-hexcode:var(--wy-code-hexcode-light, #811F3F);--wy-code-regex:var(--wy-code-regex-light, #811F3F);--wy-code-char:var(--wy-code-char-light, #811F3F);--wy-code-tag:var(--wy-code-tag-light, #800000);--wy-code-attr-name:var(--wy-code-attr-name-light, #E50000);--wy-code-selector:var(--wy-code-selector-light, #E50000);--wy-code-property:var(--wy-code-property-light, #E50000);--wy-code-deleted:var(--wy-code-deleted-light, #A31515);--wy-code-string:var(--wy-code-string-light, #A31515);--wy-code-changed:var(--wy-code-changed-light, #0451A5);--wy-code-punctuation:var(--wy-code-punctuation-light, #000000);--wy-code-function:var(--wy-code-function-light, #0000FF);--wy-code-keyword:var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name:var(--wy-code-class-name-light, #267F99)}:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])),:host :is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]),::slotted(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}@container style(--wy-color-scheme: dark){:not(.wy-light):not([part~=wy-light]) :where(wy-chat),:not(.wy-light):not([part~=wy-light]) :where(wy-comments),:not(.wy-light):not([part~=wy-light]) :where(wy-component),:not(.wy-light):not([part~=wy-light]) :where(wy-copilot),:not(.wy-light):not([part~=wy-light]) :where(wy-files),:not(.wy-light):not([part~=wy-light]) :where(wy-messenger),:not(.wy-light):not([part~=wy-light]) :where(wy-notification-toasts),:not(.wy-light):not([part~=wy-light]) :where(wy-notifications),:not(.wy-light):not([part~=wy-light]) :where(wy-posts),:host(:not(.wy-light):not([part~=wy-light])),:host :not(.wy-light):not([part~=wy-light]),::slotted(:not(.wy-light):not([part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}}`, Bj = tt`@property --wy-component-color{syntax:\"<color>\";inherits:true;initial-value:currentColor}@property --wy-component-background-color{syntax:\"<color>\";inherits:true;initial-value:rgba(0,0,0,0)}`, Uj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), jj([Bj, Qe]);
    }
  }, c(e, "t"), e), h(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), Hj = /* @__PURE__ */ h((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this.version = _e.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     * @param {string} [version] - Optional version to check against the environment version.
     */
    async checkVersion(r = this.version) {
      await this.whenUrl(), this.networkStateIsPending = !0;
      let s;
      try {
        if (s = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !s.ok)
          throw new Error("Could not verify environment version.");
        this.networkStateIsPending = !1, this.serverState = "ok";
      } catch (o) {
        this.networkStateIsPending = !1, this.serverState = "unreachable", console.warn("Could not check version: " + o.toString());
        return;
      }
      const a = await s.text();
      if (a.startsWith("v") && (!r || !a || r !== a))
        try {
          const o = r.split(".").slice(0, 2), l = a.split(".").slice(0, 2);
          if (o[0] !== l[0])
            throw new Error();
          o[1] !== l[1] && console.error(
            `Version inconsistency: ${_e.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a} - This may cause unexpected errors!`
          );
        } catch {
          throw new Error(
            `Version mismatch! ${_e.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a} - This will likely cause errors!`
          );
        }
    }
  }, c(e, "t"), e), h(t, "WeavyVersion"), t;
}, "WeavyVersionMixin");
var F2, ep;
let Tz = (F2 = (ep = class extends Event {
  constructor(t, e, i, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = r ?? !1;
  }
}, c(ep, "Nn"), ep), h(F2, "s"), F2);
var Z2, ip;
let dn = (Z2 = (ip = class {
  constructor(t, e, i, r) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (s, a) => {
      this.unsubscribe && (this.unsubscribe !== a && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = s, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(s, a)), this.unsubscribe = a;
    }, this.host = t, e.context !== void 0) {
      const s = e;
      this.context = s.context, this.callback = s.callback, this.subscribe = s.subscribe ?? !1;
    } else this.context = e, this.callback = i, this.subscribe = r ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new Tz(this.context, this.host, this.t, this.subscribe));
  }
}, c(ip, "jn"), ip), h(Z2, "s"), Z2);
var X2, np;
let Yj = (X2 = (np = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const i = e || !Object.is(t, this.o);
    this.o = t, i && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: i }] of this.subscriptions) e(this.o, i);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, i) {
    if (!i) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ h(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: r } = this.subscriptions.get(t);
    t(this.value, r);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, c(np, "Wn"), np), h(X2, "s"), X2);
var N2, rp;
let Gj = (N2 = (rp = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, c(rp, "Qn"), rp), h(N2, "e"), N2);
var j2, sp;
let N5 = (j2 = (sp = class extends Yj {
  constructor(t, e, i) {
    super(e.context !== void 0 ? e.initialValue : i), this.onContextRequest = (r) => {
      if (r.context !== this.context) return;
      const s = r.contextTarget ?? r.composedPath()[0];
      s !== this.host && (r.stopPropagation(), this.addCallback(r.callback, s, r.subscribe));
    }, this.onProviderRequest = (r) => {
      if (r.context !== this.context || (r.contextTarget ?? r.composedPath()[0]) === this.host) return;
      const s = /* @__PURE__ */ new Set();
      for (const [a, { consumerHost: o }] of this.subscriptions) s.has(a) || (s.add(a), o.dispatchEvent(new Tz(this.context, o, a, !0)));
      r.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new Gj(this.context, this.host));
  }
}, c(sp, "Kn"), sp), h(j2, "i"), j2);
function os({ context: n }) {
  return (t, e) => {
    const i = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(r) {
      return i.get(this).setValue(r), t.set.call(this, r);
    }, init(r) {
      return i.set(this, new N5(this, { context: n, initialValue: r })), r;
    } };
    {
      t.constructor.addInitializer(((a) => {
        i.set(a, new N5(a, { context: n }));
      }));
      const r = Object.getOwnPropertyDescriptor(t, e);
      let s;
      if (r === void 0) {
        const a = /* @__PURE__ */ new WeakMap();
        s = { get() {
          return a.get(this);
        }, set(o) {
          i.get(this).setValue(o), a.set(this, o);
        }, configurable: !0, enumerable: !0 };
      } else {
        const a = r.set;
        s = { ...r, set(o) {
          i.get(this).setValue(o), a?.call(this, o);
        } };
      }
      return void Object.defineProperty(t, e, s);
    }
  };
}
c(os, "Vr");
h(os, "e$4");
function Ve({ context: n, subscribe: t }) {
  return (e, i) => {
    typeof i == "object" ? i.addInitializer((function() {
      new dn(this, { context: n, callback: /* @__PURE__ */ h((r) => {
        e.set.call(this, r);
      }, "callback"), subscribe: t });
    })) : e.constructor.addInitializer(((r) => {
      new dn(r, { context: n, callback: /* @__PURE__ */ h((s) => {
        r[i] = s;
      }, "callback"), subscribe: t });
    }));
  };
}
c(Ve, "de");
h(Ve, "c$2");
var ap;
const Mz = (ap = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, i, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = r ?? !1;
  }
}, c(ap, "Ty"), ap);
h(Mz, "ContextRequestEvent");
let Kj = Mz;
var op;
const Az = (op = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, c(op, "Fy"), op);
h(Az, "ContextProviderEvent");
let Jj = Az;
var lp;
const Rz = (lp = class extends N5 {
  constructor(t, e, i) {
    e.context !== void 0 ? super(t, e) : super(t, e, i), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof pt || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new Jj(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
}, c(lp, "Dy"), lp);
h(Rz, "WyContextProvider");
let Ez = Rz;
const Te = Symbol.for("weavy-client");
function _z(n, t) {
  return we(), new Ez(n, { context: Te, initialValue: t });
}
c(_z, "Hg");
h(_z, "createWeavyContextProvider");
const Wc = g0() ? _z(document.documentElement) : void 0, tB = /* @__PURE__ */ h((n) => {
  var i;
  var t, e;
  return e = (i = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), F(this, t), this.host !== document.documentElement ? (Wc?.detachListeners(), L(this, t, new Ez(this.host, {
        context: Te,
        initialValue: this
      }))) : Wc?.setValue(this);
    }
    updateContext() {
      this.host !== document.documentElement ? x(this, t)?.updateObservers() : Wc?.updateObservers();
    }
    destroy() {
      super.destroy(), this.host !== document.documentElement ? x(this, t)?.detachListeners() : Wc?.value === this && Wc?.setValue(void 0);
    }
  }, c(i, "e"), i), t = /* @__PURE__ */ new WeakMap(), h(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var Qv, Tv, ws, gg, Xe;
const wg = (Xe = class {
  // CONSTRUCTOR
  constructor(t) {
    F(this, Qv), F(this, Tv), F(this, ws), F(this, gg), this.weavySid = Xm(), this.weavyId = `${Xe.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = Xe.defaults.cloudFilePickerUrl, this.configurationTimeout = Xe.defaults.configurationTimeout, this.disableEnvironmentImports = Xe.defaults.disableEnvironmentImports, this.gcTime = Xe.defaults.gcTime, this.scrollBehavior = Xe.defaults.scrollBehavior, this.staleTime = Xe.defaults.staleTime, this.tokenFactoryRetryDelay = Xe.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Xe.defaults.tokenFactoryTimeout, L(this, Tv, new Promise((i) => {
      L(this, Qv, i);
    })), L(this, gg, !1), console.info(`${Xe.sourceName}@${Xe.version} #${this.weavySid}`), we(), this.host = document.documentElement;
    const e = {};
    for (const i in t) {
      const r = i;
      t[r] !== void 0 && Object.assign(e, { [r]: t[r] });
    }
    e?.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await x(this, Tv);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return x(this, ws);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Ce();
    try {
      if (typeof t == "string")
        t && L(this, ws, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        L(this, ws, t || void 0);
      else if (t == null)
        L(this, ws, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), x(this, ws) && ((e = x(this, Qv)) == null || e.call(this, x(this, ws)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${Xe.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return x(this, gg);
  }
  destroy() {
    L(this, gg, !0), console.info(this.weavyId, "was destroyed");
  }
}, c(Xe, "ae"), Xe);
Qv = /* @__PURE__ */ new WeakMap(), Tv = /* @__PURE__ */ new WeakMap(), ws = /* @__PURE__ */ new WeakMap(), gg = /* @__PURE__ */ new WeakMap(), h(wg, "WeavyClient"), wg.version = "30.0.0", wg.sourceName = "@weavy/uikit-web", wg.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  configurationTimeout: 5e3,
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: C_,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  annotations: "buttons-inline",
  enterToSend: "auto",
  reactions: "😍 😎 😉 😜 👍"
};
let _e = wg;
var cp;
const zz = (cp = class extends tB(
  xj(
    bj(
      kj(
        Oj(
          Vj(Hj($j(Uj(Dj(_e)))))
        )
      )
    )
  )
) {
}, c(cp, "Hy"), cp);
h(zz, "Weavy");
let Se = zz;
const zP = Symbol.for("weavy-app"), Lz = Symbol.for("weavy-context-id"), Iz = Symbol.for("weavy-data-blobs");
var I = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(I || {});
const U0 = Symbol.for("weavy-features");
var Ga, qc, Tr, Yo;
const Vz = (Yo = class {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    F(this, Ga), F(this, qc), F(this, Tr), L(this, Ga, Object.keys(t)), L(this, qc, Object.entries(t).reduce(
      (i, [r, s]) => (s && i.push(r), i),
      []
    )), L(this, Tr, e ?? x(this, qc));
  }
  features() {
    return x(this, Ga);
  }
  supportedFeature(...t) {
    return t.every((e) => x(this, Ga).includes(e));
  }
  allowedFeatures() {
    return x(this, Tr);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? x(this, Tr).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? x(this, Tr).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return L(this, Tr, typeof t == "string" ? LP(t, x(this, Ga)) : x(this, qc)), x(this, Tr);
  }
  immutable() {
    const t = H0(x(this, Ga), x(this, qc));
    return new Yo(t, x(this, Tr));
  }
}, c(Yo, "lh"), Yo);
Ga = /* @__PURE__ */ new WeakMap(), qc = /* @__PURE__ */ new WeakMap(), Tr = /* @__PURE__ */ new WeakMap(), h(Vz, "ComponentFeatures");
let ii = Vz;
function LP(n, t) {
  return n.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
c(LP, "cm");
h(LP, "featureListFromString");
function H0(n, t) {
  return t ??= n, Object.fromEntries(
    n.map((e) => [e, t.includes(e)])
  );
}
c(H0, "Ku");
h(H0, "featureConfigFromList");
const j5 = Object.values(I), Dz = Symbol.for("weavy-link");
var Mv, hp;
const Wz = (hp = class {
  // PROPERTY INIT
  constructor(t) {
    F(this, Mv), this.enterToSend = _e.defaults.enterToSend, this.reactions = _e.defaults.reactions, this.annotations = _e.defaults.annotations, L(this, Mv, t), Object.keys(this).forEach((e) => {
      e in t && Object.assign(this, { [e]: t[e] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return x(this, Mv);
  }
}, c(hp, "Vy"), hp);
Mv = /* @__PURE__ */ new WeakMap(), h(Wz, "WeavyComponentSettings");
let KQ = Wz;
const qz = Symbol.for("weavy-component-settings"), Y0 = Symbol.for("weavy-user");
var dp;
const Fz = (dp = class {
  constructor(t, e, i, r, s) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (a, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = a, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(a, o)), this.unsubscribe = o;
    }, this.host = t, e.context !== void 0) {
      const a = e;
      this.context = a.context, this.callback = a.callback, this.subscribe = a.subscribe ?? !1, this.ref = a.ref ?? t;
    } else
      this.context = e, this.callback = i, this.subscribe = r ?? !1, this.ref = s ?? t;
    this.host.addController?.(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new Kj(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
}, c(dp, "Uy"), dp);
h(Fz, "ContextConsumer");
let eB = Fz;
var up;
const Zz = (up = class {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, i) {
    this.whenRef = new Promise((r) => this.resolveRef = r), t.addController(this), this.host = t, this.setRef(i), this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t, t && this.resolveRef?.(t);
  }
  /** 
   * Set the DOM connected element that can subscribe to a context.
   * Wrapper function for React linting compatibility. 
   */
  setRef(t) {
    this.ref = t;
  }
  async setContext(t) {
    this.whenContext = new Promise((i) => this.resolveContext = i);
    const e = await this.whenRef;
    this.context = new eB(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ h((i, r) => {
        this.resolveContext?.(i), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await pS(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.(this.context.value);
  }
}, c(up, "By"), up);
h(Zz, "ContextController");
let iB = Zz;
var gt = /* @__PURE__ */ ((n) => (n.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", n.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(gt || {}), Sn = /* @__PURE__ */ ((n) => (n.Chat = "chat", n.Comments = "comments", n.Files = "files", n.Posts = "posts", n.ChatRoom = "chat_room", n.PrivateChat = "private_chat", n.AgentChat = "agent_chat", n))(Sn || {}), Xz = /* @__PURE__ */ ((n) => (n["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", n["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", n["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", n["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", n["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", n["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(Xz || {}), Nz = /* @__PURE__ */ ((n) => (n.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(Nz || {}), jz = /* @__PURE__ */ ((n) => (n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(jz || {}), Bz = /* @__PURE__ */ ((n) => (n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(Bz || {}), ks = /* @__PURE__ */ ((n) => (n.None = "none", n.Read = "read", n.Write = "write", n.Admin = "admin", n))(ks || {}), al = /* @__PURE__ */ ((n) => (n.List = "list", n.Read = "read", n.Create = "create", n.Update = "update", n.Delete = "delete", n.Admin = "admin", n))(al || {}), li = /* @__PURE__ */ ((n) => (n.App = "app", n.File = "file", n.Message = "message", n.User = "user", n.Comment = "comment", n.Post = "post", n))(li || {});
function gy(n, t, e, i, r, s = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ h(async () => {
      const a = await n.fetch(e || "/api/" + t.join("/"), { method: s, body: r });
      if (a.ok)
        return await a.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...i
  };
}
c(gy, "rd");
h(gy, "getApiOptions");
const Uz = /* @__PURE__ */ h((n) => (t, e) => {
  e !== void 0 ? e.addInitializer((() => {
    customElements.define(n, t);
  })) : customElements.define(n, t);
}, "t$3"), nB = { attribute: !0, type: String, converter: EO, reflect: !1, hasChanged: lP }, rB = /* @__PURE__ */ h((n = nB, t, e) => {
  const { kind: i, metadata: r } = e;
  let s = globalThis.litPropertyMetadata.get(r);
  if (s === void 0 && globalThis.litPropertyMetadata.set(r, s = /* @__PURE__ */ new Map()), i === "setter" && ((n = Object.create(n)).wrapped = !0), s.set(e.name, n), i === "accessor") {
    const { name: a } = e;
    return { set(o) {
      const l = t.get.call(this);
      t.set.call(this, o), this.requestUpdate(a, l, n);
    }, init(o) {
      return o !== void 0 && this.C(a, void 0, n, o), o;
    } };
  }
  if (i === "setter") {
    const { name: a } = e;
    return function(o) {
      const l = this[a];
      t.call(this, o), this.requestUpdate(a, l, n);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$3");
function O(n) {
  return (t, e) => typeof e == "object" ? rB(n, t, e) : ((i, r, s) => {
    const a = r.hasOwnProperty(s);
    return r.constructor.createProperty(s, i), a ? Object.getOwnPropertyDescriptor(r, s) : void 0;
  })(n, t, e);
}
c(O, "p");
h(O, "n$3");
function Z(n) {
  return O({ ...n, state: !0, attribute: !1 });
}
c(Z, "F");
h(Z, "r$2");
const sB = /* @__PURE__ */ h((n, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(n, t, e), e), "e$3");
function Tl(n) {
  return (t, e) => {
    const { slot: i, selector: r } = n ?? {}, s = "slot" + (i ? `[name=${i}]` : ":not([name])");
    return sB(t, e, { get() {
      const a = this.renderRoot?.querySelector(s), o = a?.assignedElements(n) ?? [];
      return r === void 0 ? o : o.filter(((l) => l.matches(r)));
    } });
  };
}
c(Tl, "Dc");
h(Tl, "o$6");
var pp;
const Hz = (pp = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await gr(this.host), this.context = new dn(this.host, {
      context: Te,
      subscribe: !0,
      callback: /* @__PURE__ */ h((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const r = new Z_(i, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = yy(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(pp, "qy"), pp);
h(Hz, "QueryController");
let yn = Hz;
function HO(n) {
  return n.signal instanceof AbortSignal || typeof n.abort == "function";
}
c(HO, "fu");
h(HO, "hasAbort");
var fp;
const Yz = (fp = class {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await gr(this.host), this.context = new dn(this.host, { context: Te, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutation(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.observerUnsubscribe?.(), this.observer && (this.whenObserver = new Promise((i) => this.resolveObserver = i)), this.observer = new Zt(e, { ...t }), this.observerSubscribe(), this.resolveObserver?.(this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ??= this.observer.subscribe(() => {
      if (this.observer) {
        const t = yy(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutation() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    const i = await this.whenObserver, r = new AbortController();
    return i.mutate(
      {
        ...t,
        signal: r.signal,
        abort: r.abort.bind(r)
      },
      e
    );
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(fp, "Ny"), fp);
h(Yz, "MutationController");
let Rn = Yz;
function IP(n) {
  if (n)
    return n.match(/^[0-9]+$/) ? parseInt(n) : n;
}
c(IP, "fm");
h(IP, "toIntOrString");
const Ge = [];
for (let n = 0; n < 256; ++n)
  Ge.push((n + 256).toString(16).slice(1));
function Gz(n, t = 0) {
  return (Ge[n[t + 0]] + Ge[n[t + 1]] + Ge[n[t + 2]] + Ge[n[t + 3]] + "-" + Ge[n[t + 4]] + Ge[n[t + 5]] + "-" + Ge[n[t + 6]] + Ge[n[t + 7]] + "-" + Ge[n[t + 8]] + Ge[n[t + 9]] + "-" + Ge[n[t + 10]] + Ge[n[t + 11]] + Ge[n[t + 12]] + Ge[n[t + 13]] + Ge[n[t + 14]] + Ge[n[t + 15]]).toLowerCase();
}
c(Gz, "Ng");
h(Gz, "unsafeStringify");
let B2;
const aB = new Uint8Array(16);
function Kz() {
  if (!B2) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    B2 = crypto.getRandomValues.bind(crypto);
  }
  return B2(aB);
}
c(Kz, "Wg");
h(Kz, "rng");
const oB = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), JQ = { randomUUID: oB };
function Jz(n, t, e) {
  n = n || {};
  const i = n.random ?? n.rng?.() ?? Kz();
  if (i.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, Gz(i);
}
c(Jz, "Kg");
h(Jz, "_v4");
function yh(n, t, e) {
  return JQ.randomUUID && !n ? JQ.randomUUID() : Jz(n);
}
c(yh, "il");
h(yh, "v4");
function tL(n) {
  let t;
  if (n instanceof URL)
    t = { type: "url", item: n };
  else if (n instanceof File)
    t = { type: "file", item: n };
  else if (n instanceof Blob)
    t = {
      type: "file",
      item: new File([n], `${yh()}`, { type: n.type })
    };
  else if (typeof n == "string")
    t = {
      type: "file",
      item: new File([n], `${yh()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (y_(n) || LO(n))
    try {
      const e = LO(n) ? n.toJSON() : JSON.stringify(n, b_(), 2);
      t = {
        type: "file",
        item: new File([e], `${yh()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
c(tL, "Gg");
h(tL, "getContextDataRef");
const G0 = /* @__PURE__ */ h((n, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let i = n, r = 0;
  for (; r < e.length - 1 && i >= 1024; )
    i = 100 * i / 1024 / 100, r++;
  return i.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[r];
}, "fileSizeAsString");
function en(n) {
  return n.lastIndexOf(".") === -1 ? "." : (n.substring(n.lastIndexOf("."), n.length) || n).toLowerCase();
}
c(en, "ii");
h(en, "getExtension");
function VP(n) {
  switch (n) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
c(VP, "mm");
h(VP, "isAudio");
function eL(n) {
  switch (n) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
c(eL, "Zg");
h(eL, "isImage");
function iL(n) {
  switch (en(n)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
c(iL, "Yg");
h(iL, "isWebImage");
function DP(n) {
  switch (n) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
c(DP, "vm");
h(DP, "isVideo");
function nL(n) {
  switch (n) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
c(nL, "Xg");
h(nL, "isMarkdown");
function WP(n) {
  switch (n) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
c(WP, "gm");
h(WP, "isMarkup");
function K0(n) {
  if (WP(n))
    return !0;
  switch (n) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
c(K0, "Gu");
h(K0, "isCode");
function qP(n) {
  if (K0(n) || nL(n))
    return !0;
  switch (n) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
c(qP, "bm");
h(qP, "isText");
function ls(n) {
  const t = en(n);
  if (t === "") return { icon: "file" };
  if (VP(t))
    return { icon: "file-music", color: "indigo" };
  if (eL(t))
    return { icon: "file-image", color: "cyan" };
  if (DP(t))
    return { icon: "file-video", color: "pink" };
  if (WP(t))
    return { icon: "file-xml", color: "purple" };
  if (K0(t))
    return { icon: "file-code", color: "purple" };
  if (qP(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
c(ls, "Ur");
h(ls, "getIcon");
function rL(n) {
  const t = en(n);
  return t === "" ? "none" : iL(t) ? "image" : K0(t) ? "code" : qP(t) ? "text" : VP(t) ? "audio" : DP(t) ? "video" : "none";
}
c(rL, "Jg");
h(rL, "getWebPreviewFormat");
function wy(n) {
  switch (n) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
c(wy, "sd");
h(wy, "getProvider");
function J0(n) {
  let t = "file";
  switch (en(n)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
c(J0, "Zu");
h(J0, "getKind");
function tb(n) {
  const t = n.target, e = t?.value.lastIndexOf(".");
  e === -1 ? t?.select() : e !== void 0 && t?.setSelectionRange(0, e);
}
c(tb, "Yu");
h(tb, "handleSelectFilename");
async function YO(n, t = "SHA-256") {
  return await new Promise((e) => {
    if (n) {
      const i = new FileReader();
      i.readAsArrayBuffer(n), i.onloadend = async () => {
        const r = await crypto.subtle.digest(t, i.result);
        let s = "";
        r && (s = Array.from(new Uint8Array(r)).map((a) => a.toString(16).padStart(2, "0")).join("")), e(s);
      };
    } else
      e("");
  });
}
c(YO, "mu");
h(YO, "getHash");
function Av(n, t) {
  return n.findAll(t.filters).map((e) => t.select ? t.select(e) : e.state);
}
c(Av, "Rp");
h(Av, "getResult");
var mp;
const sL = (mp = class {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await gr(this.host), this.context = new dn(this.host, { context: Te, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutationState(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.mutationCacheUnsubscribe?.(), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = Av(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = Av(this.mutationCache, this.options);
        this.result !== e && !lo(this.result, e) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    return !this.mutationCache || !this.options?.filters ? 0 : Av(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    this.mutationCacheUnsubscribe?.(), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    this.mutationCacheUnsubscribe?.();
  }
}, c(mp, "jy"), mp);
h(sL, "MutationStateController");
let eb = sL;
function se(n, t, e, i) {
  const r = n.getMutationCache(), s = r.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ h((a) => a.state.variables === e, "predicate")
  });
  if (s && s.state.context) {
    const a = { ...s.state.context };
    i(a);
    const o = { ...s.state, context: a };
    s.state = o, r.notify({
      mutation: s,
      type: "updated",
      action: {
        type: "pending",
        context: s.state.context,
        variables: s.state.variables,
        isPaused: !1
      }
    });
  }
}
c(se, "Tt");
h(se, "updateMutationContext");
function FP(n, t, e) {
  const i = n.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  i && n.getMutationCache().remove(i);
}
c(FP, "xm");
h(FP, "removeMutation");
function aL(n, t) {
  const e = n.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((i) => {
    e.remove(i);
  });
}
c(aL, "t0");
h(aL, "removeMutations");
const ZP = /* @__PURE__ */ h((n, t, e = 0, i = "application/octet-stream", r, s = Date.now()) => {
  const a = n && (n instanceof URL ? n.toString() : URL.createObjectURL(n));
  return {
    id: s,
    app: { id: -1 },
    name: t,
    kind: J0(t),
    size: e,
    media_type: i,
    embed_url: "",
    preview_format: rL(t),
    thumbnail_url: a,
    preview_url: a,
    download_url: a,
    rev: -1,
    created_by: r,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function XP(n) {
  const t = n ? n.reduce(
    (e, i) => {
      const r = i.context?.file;
      return r && i.context?.status.progress && r.size ? {
        loaded: e.loaded + Math.floor(i.context.status.progress / 100 * r.size),
        total: e.total + r.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    /** Loaded bytes */
    loaded: t.loaded,
    /** Total bytes */
    total: t.total,
    /** Progress of upload provided as 0-100 percent. */
    percent: t.total > 0 ? t.loaded / t.total * 100 : null
  };
}
c(XP, "$m");
h(XP, "getFileMutationsTotalProgress");
function GO(n) {
  return n ? n.some((t) => t.context?.status.state === "conflict") ? "conflict" : n.some((t) => t.status === "error") ? "error" : n.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
c(GO, "vu");
h(GO, "getFileMutationsTotalStatus");
function B5(n) {
  return n?.filter((t) => t.context?.status.state === "pending") || [];
}
c(B5, "Dw");
h(B5, "getPendingFileMutations");
function U5(n) {
  return n?.filter((t) => t.context?.status.state === "conflict" || t.status === "error") || [];
}
c(U5, "Hw");
h(U5, "getFileMutationsByConflictOrError");
function oL(n, t) {
  const e = n.queryClient;
  e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "error" && e.getMutationCache().remove(i);
  }), e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "conflict" && e.getMutationCache().remove(i);
  });
}
c(oL, "e0");
h(oL, "removeErroredFileMutations");
function KO(n, t, e) {
  const i = n.queryClient;
  i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0,
    predicate: /* @__PURE__ */ h((r) => /error|success/.test(r.state.status) && (!e || r.state.variables?.blob?.name === e), "predicate")
  }).forEach((r) => {
    i.getMutationCache().remove(r);
  }), i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ h((r) => /error|success/.test(r.state.status) && (!e || r.state.variables?.blob?.name === e), "predicate")
  }).forEach((r) => {
    i.getMutationCache().remove(r);
  });
}
c(KO, "gu");
h(KO, "removeSettledFileMutations");
function lL(n, t, e) {
  const i = n.queryClient, r = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ h(async ({ blob: s, replace: a = !1 }) => {
      const o = await n.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: s.id, replace: a })
      });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await o.json();
    }, "mutationFn"),
    mutationKey: r,
    onMutate: /* @__PURE__ */ h(async (s) => {
      await i.cancelQueries({ queryKey: r, exact: !0 }), cL(n, e, s.blob.name), KO(n, e, s.blob.name);
      let a;
      try {
        a = s.blob.thumbnail_url && new URL(s.blob.thumbnail_url) || void 0;
      } catch {
      }
      const o = ZP(a, s.blob.name, s.blob.size, s.blob.media_type, t);
      return {
        type: s.replace ? "replace" : "create",
        file: o,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((s, a, o) => (se(i, r, a, (l) => {
      l && (l.status.state = "ok", l.status.progress = void 0, l.status.text = void 0);
    }), i.invalidateQueries({ queryKey: r })), "onSuccess"),
    onError(s, a, o) {
      s?.cause?.status === 409 ? se(i, r, a, (l) => {
        l && (l.status.progress = void 0, l.status.state = "conflict", l.status.text = s.message);
      }) : se(i, r, a, (l) => {
        l && (l.status.state = "error", l.status.progress = void 0, l.status.text = s.message);
      });
    }
  };
}
c(lL, "i0");
h(lL, "getCreateFileMutationOptions");
function cL(n, t, e, i, r = "blobs") {
  const s = n.queryClient;
  s.getMutationCache().findAll({
    mutationKey: ["apps", t.id, r],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ h((a) => a.state.data?.name === e, "predicate")
  }).forEach((a) => {
    s.getMutationCache().remove(a);
  });
}
c(cL, "r0");
h(cL, "removeSuccessfulUploadBlobMutations");
async function NP(n, t, e, i) {
  const r = new FormData();
  r.append("blob", t);
  const s = await n.upload(
    "/api/blobs",
    "POST",
    r,
    IO.Auto,
    (a) => {
      e && e({ progress: a });
    },
    i
  );
  if (!s.ok) {
    const a = await s.json();
    throw new Error(a.detail || a.title, { cause: a });
  }
  return await s.json();
}
c(NP, "Cm");
h(NP, "uploadBlob");
function hL(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async (t) => await NP(n, t.file, t.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
c(hL, "s0");
h(hL, "getSimpleUploadBlobMutationOptions");
function ib(n, t, e, i, r = "blobs") {
  const s = n.queryClient, a = i ? ["apps", e, r, i] : ["apps", e, r];
  return {
    mutationFn: /* @__PURE__ */ h(async (o) => await NP(n, o.file, o.onProgress, o.signal), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ h(async (o) => {
      await s.cancelQueries({ queryKey: a, exact: !0 });
      const l = ZP(o.file, o.file.name, o.file.size, o.file.type, t);
      o.onProgress = ({ progress: u }) => {
        se(s, a, o, (p) => {
          p.status.state = "pending", p.status.progress = u;
        });
      };
      const d = await YO(o.file);
      return { type: "upload", file: l, status: { state: "pending" }, sha256: d };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((o, l, d) => {
      se(s, a, l, (u) => {
        u.status.state = "ok", u.status.progress = void 0, u.status.text = void 0;
      });
    }, "onSuccess"),
    onError(o, l, d) {
      const u = o.cause;
      u && u.status === 409 ? se(s, a, l, (p) => {
        p.status.state = "conflict", p.status.progress = void 0, p.status.text = u.detail || u.title;
      }) : se(s, a, l, (p) => {
        p && (p.status.state = "error", p.status.progress = void 0, p.status.text = u.detail || u.title);
      });
    }
  };
}
c(ib, "Ju");
h(ib, "getUploadBlobMutationOptions");
var lB = Object.defineProperty, jP = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(t, e, r) || r);
  return r && lB(t, e, r), r;
}, "__decorateClass$1j"), vg, Og, bg, $g, xg, kg, vs, yp;
const dL = (yp = class extends pt {
  constructor() {
    super(...arguments), F(this, vg), F(this, Og), F(this, bg), F(this, $g), F(this, xg), F(this, kg), F(this, vs), this.contextId = yh(), L(this, Og, new Promise((t) => {
      L(this, vg, t);
    })), L(this, $g, new Promise((t) => {
      L(this, bg, t);
    })), L(this, kg, new Promise((t) => {
      L(this, xg, t);
    })), L(this, vs, new yn(this));
  }
  // PROPERTIES
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await x(this, Og);
  }
  /**
   * Resolves when current user data is available.
   *
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await x(this, $g);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await x(this, kg);
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  async scheduleUpdate() {
    await gr(this), await super.scheduleUpdate();
  }
  async willUpdate(t) {
    var e, i, r;
    super.willUpdate(t), this.weavyContextConsumer ??= new dn(this, { context: Te, subscribe: !0 }), this.weavyContextConsumer?.value && this.weavy !== this.weavyContextConsumer?.value && (this.weavy = this.weavyContextConsumer?.value), t.has("weavy") && this.weavy && await x(this, vs).trackQuery(gy(this.weavy, ["user"])), x(this, vs).result?.isPending || (this.user && x(this, vs).result.data && this.user.id !== x(this, vs).result.data.id && (console.warn("User mismatch, resetting"), this.weavy?.reset()), this.user = x(this, vs).result?.data), t.has("contextId") && this.contextId && (t.get("contextId") && L(this, Og, new Promise((s) => {
      L(this, vg, s);
    })), (e = x(this, vg)) == null || e.call(this, this.contextId)), t.has("user") && this.user && (t.get("user") && L(this, $g, new Promise((s) => {
      L(this, bg, s);
    })), (i = x(this, bg)) == null || i.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && L(this, kg, new Promise((s) => {
      L(this, xg, s);
    })), (r = x(this, xg)) == null || r.call(this, this.weavy));
  }
}, c(yp, "Wy"), yp);
vg = /* @__PURE__ */ new WeakMap(), Og = /* @__PURE__ */ new WeakMap(), bg = /* @__PURE__ */ new WeakMap(), $g = /* @__PURE__ */ new WeakMap(), xg = /* @__PURE__ */ new WeakMap(), kg = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ new WeakMap(), h(dL, "WeavyComponent");
let nb = dL;
jP([
  Z()
], nb.prototype, "weavy");
jP([
  os({ context: Lz }),
  Z()
], nb.prototype, "contextId");
jP([
  os({ context: Y0 }),
  Z()
], nb.prototype, "user");
var cB = Object.defineProperty, hB = Object.getOwnPropertyDescriptor, _i = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? hB(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && cB(t, e, r), r;
}, "__decorateClass$1i"), Rv, Ev, _v, zv, Sg, Cg, Pg, Qg, Fc, Zc, Tg, Mg, Mr, Ag, Xc, gp;
const uL = (gp = class extends nb {
  constructor() {
    super(), F(this, Rv), F(this, Ev), F(this, _v), F(this, zv), F(this, Sg), F(this, Cg), F(this, Pg), F(this, Qg), F(this, Fc), F(this, Zc), F(this, Tg), F(this, Mg), F(this, Mr), F(this, Ag), F(this, Xc), this.storage = wP("localStorage"), this.storageLinkHandler = (t) => {
      t.storageArea === this.storage && t.key === "wy-link" && t.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (t) => {
      !t.defaultPrevented && t.detail.link && (this.link && this.link.id === t.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = t.detail.link, this.link || this.provideStorageLink(t.detail.link));
    }, this.notificationEventConsumer = (t) => {
      t.stopPropagation(), t.defaultPrevented || this.isConnected && this.checkVisibility(fS) && this.matchesLink(t.detail.link) && t.preventDefault();
    }, L(this, Cg, new Promise((t) => {
      L(this, Sg, t);
    })), L(this, Qg, new Promise((t) => {
      L(this, Pg, t);
    })), L(this, Zc, new Promise((t) => {
      L(this, Fc, t);
    })), L(this, Mg, new Promise((t) => {
      L(this, Tg, t);
    })), L(this, Mr, /* @__PURE__ */ new Map()), L(this, Ag, new Rn(this)), L(this, Xc, new eb(this)), this.settings = new KQ(this);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(t) {
    return (
      // Type app match, like the Messenger
      t?.app?.type && this.componentTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : !1
    );
  }
  set link(t) {
    const e = this._link;
    this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
  }
  get link() {
    return this._link;
  }
  /**
   * Clears the link and resets the promise.
   *
   * @internal
   */
  clearLink() {
    this.link && (L(this, Zc, new Promise((t) => {
      L(this, Fc, t);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param link - The entity to provide.
   * @internal
   */
  provideStorageLink(t) {
    this.storage?.setItem("wy-link", btoa(JSON.stringify(t)));
  }
  /**
   * Reads a link from storage and exposes it via the link property and context.
   *
   * @internal
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const t = this.storage.getItem("wy-link");
    if (t)
      try {
        const e = JSON.parse(atob(t));
        e && (this.link = e);
      } catch (e) {
        console.error("Error parsing link", e);
      }
  }
  /**
   * Consumes a link in storage. Make sure to consume it after it has been used.
   *
   * @internal
   */
  consumeStorageLink() {
    this.storage?.removeItem("wy-link");
  }
  set agent(t) {
    this._agentUid = t || void 0;
  }
  get agent() {
    return this._agentUid;
  }
  set data(t) {
    console.warn(".data property array is deprecated. Use .contextualData string instead."), L(this, Rv, t);
  }
  /**
   * DEPRECATED: Use `.contextualData` property instead.
   *
   * Array with contextual data.
   *
   * *Note: Only the first item in the array is currently used.*
   * @internal
   * @deprecated
   */
  get data() {
    return x(this, Rv);
  }
  set annotations(t) {
    L(this, Ev, t);
  }
  get annotations() {
    return x(this, Ev) ?? this.weavy?.annotations ?? _e.defaults.annotations;
  }
  set enterToSend(t) {
    L(this, _v, t);
  }
  get enterToSend() {
    return x(this, _v) ?? this.weavy?.enterToSend ?? _e.defaults.enterToSend;
  }
  set reactions(t) {
    L(this, zv, t);
  }
  get reactions() {
    return x(this, zv) ?? this.weavy?.reactions ?? _e.defaults.reactions;
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  // #resolveAgentUser?: (agent: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await x(this, Cg);
  }
  /**
   * Resolves when Weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await x(this, Qg);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @internal
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await x(this, Zc);
  }
  /**
   * Resolves when Weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await x(this, Mg);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), this.weavy?.host.removeEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
  async willUpdate(t) {
    var e, i, r, s;
    await super.willUpdate(t), t.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
    const a = Object.keys(this.settings);
    if ((t.has("weavy") || a.find((o) => t.has(o))) && (this.settings = new KQ(this)), t.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof ii && (this.componentFeatures = this.componentFeatures.immutable())), (t.has("weavy") || t.has("contextId") || t.has("user") || t.has("componentFeatures")) && this.weavy && this.contextId && this.user && this.componentFeatures?.allowsFeature(I.ContextData) && (await x(this, Ag).trackMutation(
      ib(this.weavy, this.user, this.contextId, void 0, "data")
    ), await x(this, Xc).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), t.has("contextualData") || t.has("data") || t.has("componentFeatures")) {
      const o = this.contextualData ? [this.contextualData] : this.data ? this.data : [], l = x(this, Mr);
      if (L(this, Mr, /* @__PURE__ */ new Map()), o.forEach((d) => {
        const u = l.get(d);
        if (u)
          x(this, Mr).set(d, u);
        else {
          const p = tL(d);
          p && x(this, Mr).set(d, p);
        }
      }), x(this, Mr) && this.componentFeatures?.allowsFeature(I.ContextData)) {
        for (const f of Array.from(x(this, Mr).values()))
          if (f.type === "file") {
            const y = await YO(f.item);
            await w_(
              x(this, Xc).result ?? [],
              async (g) => (g.context?.sha256 ?? await YO(g.variables?.file)) === y
            ) || await x(this, Ag).mutate({ file: f.item });
          }
        const d = x(this, Xc).result, u = d?.some((f) => f.status === "pending"), p = d?.map((f) => f.data?.id).filter((f) => f).reverse() ?? [];
        u || (this.contextDataBlobs = p);
      } else
        this.contextDataBlobs = [];
    }
    (t.has("componentTypes") || t.has("agent")) && this.componentTypes && this.readStorageLink(), t.has("link") && this.link && (console.info("Opening notification link"), this.consumeStorageLink()), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && L(this, Cg, new Promise((o) => {
      L(this, Sg, o);
    })), (e = x(this, Sg)) == null || e.call(this, this.contextDataBlobs)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && L(this, Qg, new Promise((o) => {
      L(this, Pg, o);
    })), (i = x(this, Pg)) == null || i.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && L(this, Zc, new Promise((o) => {
      L(this, Fc, o);
    })), (r = x(this, Fc)) == null || r.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && L(this, Mg, new Promise((o) => {
      L(this, Tg, o);
    })), (s = x(this, Tg)) == null || s.call(this, this.settings)), t.has("weavy") && this.weavy && this.weavy.host.addEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
}, c(gp, "Qy"), gp);
Rv = /* @__PURE__ */ new WeakMap(), Ev = /* @__PURE__ */ new WeakMap(), _v = /* @__PURE__ */ new WeakMap(), zv = /* @__PURE__ */ new WeakMap(), Sg = /* @__PURE__ */ new WeakMap(), Cg = /* @__PURE__ */ new WeakMap(), Pg = /* @__PURE__ */ new WeakMap(), Qg = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), Tg = /* @__PURE__ */ new WeakMap(), Mg = /* @__PURE__ */ new WeakMap(), Mr = /* @__PURE__ */ new WeakMap(), Ag = /* @__PURE__ */ new WeakMap(), Xc = /* @__PURE__ */ new WeakMap(), h(uL, "WeavyTypeComponent");
let Me = uL;
_i([
  os({ context: Iz }),
  Z()
], Me.prototype, "contextDataBlobs", 2);
_i([
  os({ context: U0 }),
  Z()
], Me.prototype, "componentFeatures", 2);
_i([
  os({ context: qz }),
  Z()
], Me.prototype, "settings", 2);
_i([
  os({ context: Dz })
], Me.prototype, "_link", 2);
_i([
  O({ type: Object })
], Me.prototype, "link", 1);
_i([
  Z()
], Me.prototype, "componentTypes", 2);
_i([
  O()
], Me.prototype, "features", 2);
_i([
  O({ type: String })
], Me.prototype, "agent", 1);
_i([
  O({
    attribute: !0,
    type: String
  })
], Me.prototype, "contextualData", 2);
_i([
  O({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(n) {
        return g_(n);
      }
    }
  })
], Me.prototype, "data", 1);
_i([
  O({ type: String })
], Me.prototype, "annotations", 1);
_i([
  O({ type: String })
], Me.prototype, "enterToSend", 1);
_i([
  O({ type: String })
], Me.prototype, "reactions", 1);
_i([
  O()
], Me.prototype, "bot", 2);
const dB = new Map(pP(Xz)), uB = new Map(pP(Nz)), JO = new Map(Object.entries(jz));
new Map(Object.entries(Bz));
var pB = Object.defineProperty, fB = Object.getOwnPropertyDescriptor, Ml = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? fB(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && pB(t, e, r), r;
}, "__decorateClass$1h");
const Ls = "unknown";
var Rg, Eg, Ka, wp;
const pL = (wp = class extends Me {
  constructor() {
    super(...arguments), F(this, Rg), F(this, Eg), F(this, Ka), this.appSubscribeMutation = new Rn(this), L(this, Eg, new Promise((t) => {
      L(this, Rg, t);
    })), L(this, Ka, new yn(this));
  }
  // @provide({ context: AgentContext })
  // @state()
  // agentUser: AgentType | undefined;
  /**
   * Sets the component to it's initial state and resets the app state.
   */
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(t) {
    return (
      // Messenger conversation
      t?.app?.type && !this.appType && this.componentTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : (
        // Normal contextual app
        !!(t && t.app && this.appType !== Ls && (typeof this.uid == "string" && t.app?.uid === this.uid || // Normal app with app uid
        typeof this.uid == "number" && t.app?.id === this.uid || // Normal app with app id
        this.agent && t.app.type === this.appType && t.agent === this.agent))
      )
    );
  }
  set link(t) {
    const e = this._link;
    !this.uid && this.appType && this.appType !== Ls ? this.whenApp().then(() => {
      this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
    }) : (this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e));
  }
  get link() {
    return this._link;
  }
  set name(t) {
    this._initialAppName = t, this._appName = t;
  }
  get name() {
    return this._appName;
  }
  /**
   * Subscribes or unsubscribes to notification updates from the app. Check `.app.is_subscribed` to see current state.
   *
   * @param subscribe - Set to `false` to unsubscribe from updates. Defaults to `true`.
   * @returns {Promise<void>}
   *
   * @example <caption>Toggle app subscription</caption>
   * ```js
   * // Wait for app data
   * await myWeavyComponent.whenApp();
   *
   * // Get current app subscription state
   * const isSubscribed = myWeavyComponent.app.is_subscribed;
   *
   * // Toggle the app subscription state
   * myWeavyComponent.subscribe(!isSubscribed);
   * ```
   */
  async subscribe(t = !0) {
    if (!this.uid)
      throw new Error(`Cannot ${t ? "subscribe" : "unsubscribe"} without a uid.`);
    await this.whenApp(), this.app?.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await x(this, Eg);
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app");
  }
  async willUpdate(t) {
    var e;
    if (await super.willUpdate(t), t.has("autoUid") && typeof this.autoUid == "string" && (console.error(`Using .autoUid property is deprecated. Use .generateUid = "${this.autoUid}"; instead`), this.generateUid = this.autoUid), (t.has("generateUid") || t.has("user") || t.has("agent")) && this.generateUid && this.user && (this.appType && JO.has(this.appType) && this.agent || this.appType && !JO.has(this.appType))) {
      const r = [this.generateUid];
      this.agent && r.push(this.agent), this.user && r.push(this.user.uid || this.user.id), this.uid = r.join("-");
    }
    const i = this.name;
    if ((t.has("appType") || t.has("uid") || t.has("agent") || t.has("weavy")) && this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", i)), t.has("appType") || t.has("uid") || t.has("agent") || t.has("name") || t.has("weavy"))
      if (this.appType && this.uid && this.weavy) {
        const r = this.name ? { name: this.name } : void 0, s = this.agent ? [this.agent] : void 0;
        await x(this, Ka).trackQuery(fL(this.weavy, this.uid, this.appType, s, r));
      } else
        x(this, Ka).untrackQuery();
    if (x(this, Ka).result?.isPending || (this.app = x(this, Ka).result?.data, this.app?.name && this._appName !== this.app.name && (this.name = this.app.name, this.requestUpdate("name", i))), t.has("uid") && (this.uid || t.get("uid")) && this.uid !== t.get("uid") && this.clearLink(), !this.link && (t.has("uid") && this.uid || t.has("app") && this.app) && this.appType && this.appType !== Ls && this.readStorageLink(), t.has("app") && this.app) {
      const r = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(r);
    }
    t.has("app") && this.app && (t.get("app") && L(this, Eg, new Promise((r) => {
      L(this, Rg, r);
    })), (e = x(this, Rg)) == null || e.call(this, this.app)), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.appSubscribeMutation.trackMutation(yL(this.weavy, this.app));
  }
}, c(wp, "Ky"), wp);
Rg = /* @__PURE__ */ new WeakMap(), Eg = /* @__PURE__ */ new WeakMap(), Ka = /* @__PURE__ */ new WeakMap(), h(pL, "WeavyAppComponent");
let zi = pL;
Ml([
  os({ context: zP }),
  Z()
], zi.prototype, "app", 2);
Ml([
  O({ type: Object })
], zi.prototype, "link", 1);
Ml([
  Z()
], zi.prototype, "appType", 2);
Ml([
  O()
], zi.prototype, "generateUid", 2);
Ml([
  O({ converter: IP })
], zi.prototype, "uid", 2);
Ml([
  O({ type: String })
], zi.prototype, "name", 1);
Ml([
  O()
], zi.prototype, "autoUid", 2);
function fL(n, t, e = Ls, i, r) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ h(async () => {
      const s = [];
      e === Ls || typeof t == "number" ? s.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ) : s.push(
        // Get, update or create app using app uid
        n.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, members: i, ...r }) })
      );
      const a = (await Promise.allSettled(s)).findLast(
        (l) => l.status === "fulfilled" && l.value?.ok
      ), o = a?.status === "fulfilled" && a.value;
      if (o)
        return await o.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
c(fL, "p0");
h(fL, "getOrCreateAppOptions");
function mL(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ name: t, members: e, type: i, uid: r }) => await (await n.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: t,
        members: e,
        type: i,
        uid: r
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ h(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(mL, "u0");
h(mL, "getCreateAppMutationOptions");
function BP(n) {
  return new Zt(n.queryClient, mL(n));
}
c(BP, "km");
h(BP, "getCreateAppMutation");
function yL(n, t) {
  const e = n.queryClient, i = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ h(async ({ subscribe: r }) => {
      if (t.id >= 1) {
        const s = await n.fetch(`/api/apps/${t.id}/${r ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!s.ok)
          throw await s.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => {
      let s;
      return e.setQueryData(i, (a) => (s = a.is_subscribed, { ...a, is_subscribed: r.subscribe })), {
        previousSubscribe: s,
        subscribe: r.subscribe
      };
    }, "onMutate"),
    onError(r, s, a) {
      a && a.previousSubscribe !== void 0 && e.setQueryData(i, (o) => ({ ...o, is_subscribed: a?.previousSubscribe }));
    }
  };
}
c(yL, "y0");
h(yL, "getAppSubscribeMutationOptions");
function gL(n, t = [gt.ChatRoom, gt.PrivateChat], e) {
  const i = new URLSearchParams({
    count_only: "true",
    unread: "true",
    uid: "false"
  });
  e && i.append("member", e), t?.forEach((s) => i.append("type", s));
  const r = `/api/apps?${i.toString()}`;
  return gy(n, ["apps", "unread", t, e], r);
}
c(gL, "w0");
h(gL, "getAppsUnreadOptions");
function wL(n, t = {}, e, i, r, s, a) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, i, s, a],
    queryFn: /* @__PURE__ */ h(async (o) => {
      const l = new URLSearchParams();
      i && l.append("member", i), o.pageParam && typeof o.pageParam == "number" && l.append("skip", o.pageParam?.toString()), e?.forEach((f) => l.append("type", f)), l.append("order_by", s);
      const d = r?.();
      d && l.append("q", d), l.append("uid", "false");
      const u = `/api/apps?${l.toString()}`, p = await (await n.fetch(u)).json();
      return p.data = p.data || [], p;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((o) => {
      if (o.end && o?.end < o?.count)
        return o.end;
    }, "getNextPageParam")
  };
}
c(wL, "f0");
h(wL, "getAppListOptions");
var ci = /* @__PURE__ */ ((n) => (n.Default = "", n.Select = "select", n.Star = "star", n.Unstar = "unstar", n.Subscribe = "subscribe", n.Unsubscribe = "unsubscribe", n.Pin = "pin", n.Unpin = "unpin", n.Download = "download", n.Preview = "preview", n))(ci || {}), vp;
const vL = (vp = class {
  get weavy() {
    return this.weavyContext?.value;
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts();
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await gr(this.host), this.weavyContext = new dn(this.host, { context: Te, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-action` event on the host.
   *
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  dispatchActionEvent(t) {
    const e = new CustomEvent("wy-action", {
      detail: { action: ci.Select, app: t },
      bubbles: !0,
      composed: !0
    });
    return this.host.dispatchEvent(e);
  }
  /**
   * Create mutation controller.
   */
  async initMutation() {
    if (!this.addConversationMutation) {
      const t = await this.whenWeavyContext;
      this.addConversationMutation = BP(t);
    }
    return this.addConversationMutation;
  }
  /**
   * Create a conversation and trigger a `select` event.
   *
   * @param members - Array of members by id/uid for a new conversation.
   * @returns Whether the event was successful.
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  async create(t = []) {
    const e = await this.initMutation(), i = this.agent ?? this.host.agent, r = i ? { members: [i], type: Sn.AgentChat } : { members: t, type: t.length === 1 ? Sn.PrivateChat : Sn.ChatRoom }, s = await e.mutate(r);
    return this.dispatchActionEvent(s), s;
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
  }
}, c(vp, "Gy"), vp);
h(vL, "CreateConversationController");
let rb = vL;
var _g, Op;
const OL = (Op = class {
  constructor(t) {
    F(this, _g, !1), t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return x(this, _g);
  }
  set isDragActive(t) {
    x(this, _g) !== t && (L(this, _g, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    t.preventDefault();
    const e = [];
    t.dataTransfer?.items ? [...t.dataTransfer.items].forEach((i) => {
      if (i.kind === "file") {
        const r = i.getAsFile();
        r ? e.push(r) : console.error("Could not add file");
      }
    }) : t.dataTransfer?.files && [...t.dataTransfer.files].forEach((i) => {
      e.push(i);
    }), e.length && this.dispatchUploadFiles(e), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
}, c(Op, "Zy"), Op);
_g = /* @__PURE__ */ new WeakMap(), h(OL, "DropZoneController");
let bL = OL;
function nw(n, t) {
  we();
  const e = oo({}, window.history.state, !0);
  if (!e.weavy || !e.weavy[n] || !Object.hasOwn(e.weavy[n], t))
    throw new Error("Property not found");
  return e.weavy[n][t];
}
c(nw, "zd");
h(nw, "getBrowserStateProperty");
function t0(n, t, e = "push", i) {
  if (we(), t) {
    const r = oo({}, window.history.state, !0);
    r.weavy ??= {}, r.weavy[n] = t, i = i && String(i) || window.location.href;
    try {
      e === "replace" ? window.history.replaceState(r, "", i) : window.history.pushState(r, "", i);
    } catch (s) {
      console.warn("history: Could not push history state.", s, t);
    }
  }
}
c(t0, "bu");
h(t0, "setBrowserState");
function $L(n, t, e) {
  we();
  const i = `${typeof n}:${t}`;
  e.forEach((r) => {
    try {
      const s = nw(i, r), a = n[r];
      UP(a, s) && (n[r] = s);
    } catch {
    }
  });
}
c($L, "m0");
h($L, "restoreHistoryProperties");
function e0(n, t, e, i = "push") {
  we();
  const r = `${typeof n}:${t}`, s = {};
  e.forEach((a) => {
    s[a] = n[a];
  }), t0(r, s, i);
}
c(e0, "xu");
h(e0, "pushHistoryProperties");
function xL(n, t, e) {
  e0(n, t, e, "replace");
}
c(xL, "v0");
h(xL, "updateHistoryProperties");
function UP(n, t) {
  return n && t && (Ur(n) || Ur(t)) ? n && Object.hasOwn(n, "id") || t && Object.hasOwn(t, "id") ? n.id !== t.id : !lo(n, t) : n !== t;
}
c(UP, "_m");
h(UP, "itemHasChanged");
var bp;
const mB = (bp = class {
  constructor(t, e, i) {
    if (this._backCount = 0, this.restoreHistory = (r) => {
      if (this.prefixKey && this.properties) {
        $L(this.host, this.prefixKey, this.properties);
        try {
          this._backCount = nw(this.prefixKey, "_backCount") || 0;
        } catch {
          this._backCount = 0;
        }
        this.updatePrevPropertyValues();
      }
    }, t.addController(this), this.host = t, i && (this.properties = i), e) {
      this.prefixKey = e;
      try {
        this._backCount = nw(this.prefixKey, "_backCount") || this._backCount;
      } catch {
      }
    }
  }
  get hasBackNavigation() {
    return this._backCount > 0;
  }
  back() {
    window.history.back();
  }
  backAll() {
    window.history.go(this._backCount * -1);
  }
  observe(t, e) {
    if (this.properties = t, e) {
      this.prefixKey = e;
      try {
        this._backCount = nw(this.prefixKey, "_hasBack") || this._backCount;
      } catch {
      }
    }
  }
  /**
   * Method to manually push history
   */
  pushCurrentState() {
    this.prefixKey && (e0(this.host, this.prefixKey, this.properties), this._backCount++, t0(this.prefixKey, { _backCount: this._backCount }, "replace"));
  }
  updatePrevPropertyValues() {
    this.properties && this.properties.forEach((t) => {
      this.prevPropertyValues ??= {};
      const e = this.host[t];
      this.prevPropertyValues[t] !== e && (this.prevPropertyValues[t] = e && JSON.parse(JSON.stringify(e)));
    });
  }
  hostConnected() {
    window.addEventListener("popstate", this.restoreHistory);
  }
  hostUpdated() {
    this.prefixKey && this.properties && (this.prevPropertyValues ? this.properties.some(
      (t) => {
        const e = this.prevPropertyValues?.[t], i = this.host[t];
        return UP(e, i);
      }
    ) && (e0(
      this.prevPropertyValues,
      this.prefixKey,
      this.properties
    ), this._backCount++, t0(this.prefixKey, { _backCount: this._backCount }, "replace")) : this.prevPropertyValues = {}, xL(this.host, this.prefixKey, this.properties), this.updatePrevPropertyValues());
  }
  hostDisconnected() {
    window.removeEventListener("popstate", this.restoreHistory);
  }
}, c(bp, "Yy"), bp);
h(mB, "HistoryController");
var $p;
const kL = ($p = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : this.observer?.getCurrentResult() ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await gr(this.host), this.context = new dn(this.host, {
      context: Te,
      subscribe: !0,
      callback: /* @__PURE__ */ h((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const r = new Rj(i, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = yy(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c($p, "Xy"), $p);
h(kL, "InfiniteQueryController");
let Al = kL;
function i0(n, t = !1) {
  for (n && !t && (n = n.nextElementSibling); n; ) {
    if (!(n instanceof HTMLElement))
      continue;
    const e = getComputedStyle(n);
    if (e.display !== "none") {
      if (e.display === "contents") {
        if (n.shadowRoot && n.shadowRoot.firstElementChild instanceof HTMLElement) {
          const i = i0(n.shadowRoot.firstElementChild, !0);
          if (i)
            return i;
        }
        if (n.firstElementChild instanceof HTMLElement) {
          const i = i0(n.firstElementChild, !0);
          if (i)
            return i;
        }
      }
      if (/absolute|sticky|fixed/.test(e.position) === !1)
        return n;
      n = n.nextElementSibling;
    }
  }
  return null;
}
c(i0, "$u");
h(i0, "getNextPositionedChild");
function o1(n, t = !1) {
  if (we(), n) {
    let e = getComputedStyle(n);
    const i = e.position === "absolute", r = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let s = n; s = s.parentElement || s.parentNode || s.host; )
      if (s instanceof Element && (e = getComputedStyle(s), !(i && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX)))
        return s;
  }
  return document.scrollingElement || n;
}
c(o1, "wh");
h(o1, "getScrollParent");
function SL(n) {
  if (n && n.isConnected) {
    const t = o1(n);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
c(SL, "g0");
h(SL, "hasScroll");
function CL(n, t = 32) {
  if (n) {
    const e = o1(n);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
c(CL, "b0");
h(CL, "isParentAtBottom");
async function PL(n, t = !1) {
  if (n) {
    const e = o1(n);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((i) => {
      let r = e.scrollTop;
      const s = /* @__PURE__ */ h(() => {
        t && e.scrollTop === r && (e.scrollTop = e.scrollHeight), r = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(s) : i(void 0);
      }, "scrollCheck");
      requestAnimationFrame(s);
    });
  }
}
c(PL, "x0");
h(PL, "scrollParentToBottom");
const yB = 0, gB = void 0;
function QL(n, t, e = !1) {
  we(), t ??= /* @__PURE__ */ h(() => Promise.reject(new Error("No scroll function defined")), "whenNext");
  const i = e ? o1(n) : document.documentElement, r = i === document.documentElement ? document : i;
  let s = !1;
  const a = new IntersectionObserver(
    (o) => {
      o.forEach((l) => {
        if (l.isIntersecting && !s)
          if (s = !0, e && i && r instanceof HTMLElement) {
            const d = i0(l.target) || l.target, u = i.scrollHeight, p = d.offsetTop, f = /* @__PURE__ */ h(() => {
              queueMicrotask(() => {
                if (u !== i.scrollHeight) {
                  if (d?.isConnected) {
                    const y = d.offsetTop - p;
                    i.scrollTop += y;
                  }
                  requestAnimationFrame(() => s = !1);
                } else
                  queueMicrotask(() => {
                    if (u !== i.scrollHeight) {
                      if (d?.isConnected) {
                        const y = d.offsetTop - p;
                        i.scrollTop += y;
                      }
                      requestAnimationFrame(() => s = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (a.takeRecords().length && d?.isConnected) {
                          const y = d.offsetTop - p;
                          i.scrollTop += y;
                        }
                        requestAnimationFrame(() => s = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(f);
          } else
            t().then(() => {
              requestAnimationFrame(() => s = !1);
            });
      });
    },
    { root: r, threshold: yB, rootMargin: gB }
  );
  return a.observe(n), a;
}
c(QL, "k0");
h(QL, "createScroller");
var xp;
const TL = (xp = class {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      this.loadMoreRefElement = e, this.scroller?.disconnect(), this.scroller = QL(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    this.loadMoreRefElement && this.scroller?.observe(this.loadMoreRefElement);
  }
  hostDisconnected() {
    this.scroller?.disconnect();
  }
}, c(xp, "Jy"), xp);
h(TL, "InfiniteScrollController");
let Rl = TL;
var kp;
const ML = (kp = class extends Rl {
  constructor(t) {
    super(t, !0);
  }
}, c(kp, "tw"), kp);
h(ML, "ReverseInfiniteScrollController");
let wB = ML;
var Os, Nc, Sp;
const AL = (Sp = class {
  constructor(t) {
    if (F(this, Os), F(this, Nc), L(this, Os, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      L(this, Nc, t);
    else
      try {
        we(), L(this, Nc, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    x(this, Os).clear();
  }
  getStorageItem(t, e) {
    const i = x(this, Nc)?.getItem(`${t}-${e.toString()}`);
    if (i)
      return JSON.parse(i);
  }
  setStorageItem(t, e, i) {
    const r = JSON.stringify(i);
    r && x(this, Nc)?.setItem(`${t}-${e.toString()}`, r);
  }
  persistProperties(t, e, i, r, s) {
    const a = `${this.keyPrefix}:${r ? `${r}:` : ""}${typeof t}:${e}`, o = /* @__PURE__ */ new Map();
    for (const l of i) {
      if (!x(this, Os).has(l.name)) {
        const d = this.getStorageItem(a, l.name);
        d && (l.override || !t[l.name]) && (o.set(l.name, t[l.name]), t[l.name] = d), x(this, Os).set(l.name, d);
      }
      if (s?.(o), t[l.name] !== x(this, Os).get(l.name)) {
        const d = t[l.name];
        x(this, Os).set(l.name, d), this.setStorageItem(a, l.name, d);
      }
    }
  }
}, c(Sp, "ew"), Sp);
Os = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakMap(), h(AL, "PersistStorageCache");
let vB = AL;
var jc, zg, Cp;
const RL = (Cp = class {
  constructor(t) {
    F(this, jc), F(this, zg), L(this, jc, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new vB(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return x(this, jc);
  }
  set prefixKey(t) {
    t !== x(this, jc) && (this.persistStorageCache.resetPersistPropertiesCache(), L(this, jc, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return x(this, zg);
  }
  set cachePrefix(t) {
    t !== x(this, zg) && (this.persistStorageCache.resetPersistPropertiesCache(), L(this, zg, t), this.host.requestUpdate());
  }
  observe(t, e, i, r) {
    this.properties = t, this.callback = r;
    const s = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== i);
    this.properties.forEach((a) => {
      s && this.initialProperties.has(a.name) ? this.host[a.name] = this.initialProperties.get(a.name) : this.initialProperties.has(a.name) || this.initialProperties.set(a.name, this.host[a.name]);
    }), e && (this.prefixKey = e), i && (this.cachePrefix = i);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix, this.callback);
  }
}, c(Cp, "iw"), Cp);
jc = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), h(RL, "PersistStateController");
let l1 = RL;
var Pp;
const OB = (Pp = class {
  constructor(t) {
    this.observers = [], this.conditions = {}, this.resizer = new ResizeObserver((e) => {
      let i = !1;
      for (const r of e)
        i = this.checkConditions(r) || i;
      i && this.host.requestUpdate();
    }), t.addController(this), this.host = t;
  }
  checkConditions(t) {
    let e = !1;
    return this.observers.forEach((i) => {
      if (t.target === i.target) {
        const r = this.conditions[i.name], s = i.condition(t);
        r !== s && (this.conditions[i.name] = s, e = !0);
      }
    }), e;
  }
  observe(t) {
    const e = t.target, i = e.getBoundingClientRect();
    this.observers.push(t), this.resizer.observe(e), this.checkConditions({
      contentBoxSize: [
        {
          inlineSize: e.clientWidth,
          blockSize: e.clientHeight
        }
      ],
      borderBoxSize: [
        {
          inlineSize: i.width,
          blockSize: i.height
        }
      ],
      devicePixelContentBoxSize: [
        {
          inlineSize: i.width * window.devicePixelRatio,
          blockSize: i.height * window.devicePixelRatio
        }
      ],
      contentRect: i,
      target: e
    });
  }
  reset() {
    this.conditions = {}, this.observers.length = 0, this.resizer.disconnect();
  }
  hostConnected() {
    this.observers.forEach((t) => {
      this.resizer.observe(t.target);
    });
  }
  hostDisconnected() {
    this.resizer.disconnect();
  }
}, c(Pp, "rw"), Pp);
h(OB, "ResizeController");
var Qp;
const EL = (Qp = class {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (i) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ??= /* @__PURE__ */ new Set(), i.forEach((r) => {
        r.part.forEach((s) => this.shadowParts?.add(s)), r.getAttribute("exportparts")?.split(", ").forEach((s) => this.shadowParts?.add(s));
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), this.observer?.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, Xx(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const i = e.flatMap((r) => r.type === "attributes" ? [r.target] : Array.from(r.addedNodes)).filter((r) => r instanceof Element);
        this.setExportParts(i);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        this.observer?.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    Xx(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    this.observer?.disconnect();
  }
}, c(Qp, "sw"), Qp);
h(EL, "ShadowPartsController");
let G = EL;
var Tp;
const _L = (Tp = class {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    this.scrollObserver?.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (e) => {
        e.forEach(async (i) => {
          i.isIntersecting && !this.sleep && i.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((r) => {
            setTimeout(r, this.delay);
          }), i.target === this.prevElement && this.whenPrev && await this.whenPrev(), i.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    this.prevElement && (this.scrollObserver?.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && (this.scrollObserver?.unobserve(this.nextElement), this.nextElement = void 0), t && (this.scrollObserver?.observe(t), this.prevElement = t), e && (this.scrollObserver?.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    this.prevElement = void 0, this.nextElement = void 0, this.scrollObserver?.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    this.scrollObserver?.disconnect();
  }
}, c(Tp, "nw"), Tp);
h(_L, "SwipeScrollController");
let bB = _L;
var Lg, Lv, Mp;
const zL = (Mp = class {
  constructor(t, e) {
    F(this, Lg), F(this, Lv), L(this, Lg, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return x(this, Lv);
  }
  set themeColor(t) {
    L(this, Lv, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || BO(this.host) || UO();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = Qz(this._resolvedThemeColor).join(""), i = tt`
        :host {
          ${t_(e)};
        }
      `, r = this.host.renderRoot;
      e_(r, [...this.styles, i]);
    }
  }
  hostUpdate() {
    x(this, Lg) && (this.checkThemeUpdate(), L(this, Lg, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = Cz(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = Pz(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    this.cssObserverDisconnect?.(), this.metaObserverDisconnect?.();
  }
}, c(Mp, "aw"), Mp);
Lg = /* @__PURE__ */ new WeakMap(), Lv = /* @__PURE__ */ new WeakMap(), h(zL, "ThemeController");
let gn = zL;
var Ap;
const LL = (Ap = class {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((i, r) => {
        i.id === e.actor.id && this.typingMembers.splice(r, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  get componentFeatures() {
    return this._componentFeatures;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await gr(this.host), this.weavyContext = new dn(this.host, { context: Te, subscribe: !0 }), this.componentFeaturesContext = new dn(this.host, {
      context: U0,
      subscribe: !0
    });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.componentFeaturesContext && this.componentFeaturesContext.value?.allowsFeature(I.Typing) !== this._componentFeatures?.allowsFeature(I.Typing);
    t && (this._componentFeatures = this.componentFeaturesContext?.value, this.componentFeaturesContext?.value && this.resolveComponentFeaturesContext?.(this.componentFeaturesContext.value), t && (this.unregisterRealtime(!0), this.registerRealtime()));
  }
  async registerRealtime() {
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), this.componentFeatures?.allowsFeature(I.Typing) && (this.weavy?.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime(t = !1) {
    !this.registrationRequested && this.appId && this.userId && (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, r) => {
      t - i.time > this.discardTime && this.typingMembers.splice(r, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), r = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((s) => s.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(r), this.names = this.typingMembers.map((s) => s.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((i, r) => {
      i.id === t.id && this.typingMembers.splice(r, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
  hostDisconnected() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null), this.typingMembers.length = 0, this.names.length = 0, this.weavy && this.unregisterRealtime(!0);
  }
}, c(Ap, "ow"), Ap);
h(LL, "TypingController");
let IL = LL;
var Ig, Rp;
const VL = (Rp = class {
  constructor(t) {
    F(this, Ig), this.appTypes = [], L(this, Ig, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new yn(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread items for the current scope
   */
  get unread() {
    return x(this, Ig);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await gr(this.host), this.weavyContext = new dn(this.host, { context: Te, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread items change.
   */
  dispatchUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "message_created", this.handleRefresh), this.weavy?.subscribe(null, "app_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "app_marked", this.handleRefresh));
  }
  async track(t, e) {
    this.appTypes = t, this.agent = e;
    const i = await this.whenWeavyContext;
    await this.unreadQuery.trackQuery(gL(i, t, this.agent), !0);
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (L(this, Ig, t), this.dispatchUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
}, c(Rp, "cw"), Rp);
Ig = /* @__PURE__ */ new WeakMap(), h(VL, "UnreadConversationsController");
let sb = VL;
var Ft = /* @__PURE__ */ ((n) => (n.All = "", n.Activity = "activity", n.Mention = "mention", n.Reaction = "reaction", n))(Ft || {});
function DL(n, t, e = {}, i) {
  if (n) {
    if (n = JSON.parse(JSON.stringify(n)), n?.pages) {
      let r = -1;
      return {
        pages: [...n.pages.map((s, a) => {
          if (r >= 0)
            return s;
          const o = s.data || [], l = o.filter(
            (d) => d.id !== t.id && !0
          );
          return e && e.by ? (r = l.findIndex((d) => {
            let u = e.by && d[e.by], p = e.by && t[e.by];
            if (e.by === "updated_at" && (u ??= d.created_at, p ??= t.created_at), typeof u == "string" && typeof p == "string") {
              const f = u.localeCompare(p, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? f < 0 : f > 0;
            }
            return u && p && (e.descending ? u < p : u > p);
          }), r >= 0 ? (l.splice(r, 0, t), s.data = [...l], s.end && (s.end += 1 + l.length - o.length)) : n && a == n.pages.length - 1 && s.end === s.count ? (s.data = [...l, t], s.end && (s.end += 1 + l.length - o.length)) : s.data = [...l]) : a === 0 && (e.descending ? s.data = [t, ...l] : s.data = [...l, t], s.end && (s.end += 1 + l.length - o.length)), s;
        }) ?? []],
        pageParams: [...n.pageParams]
      };
    } else if (n?.data?.length) {
      let r = -1;
      const s = [
        ...n.data?.filter(
          (o) => o.id !== t.id && !0
        ) || []
      ];
      let a = n.count;
      return e && e.by ? (r = s.findIndex((o) => {
        let l = o[e.by], d = t[e.by];
        if (e.by === "updated_at" && (l ??= o.created_at, d ??= t.created_at), typeof l == "string" && typeof d == "string") {
          const u = l.localeCompare(d, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? u < 0 : u > 0;
        }
        return l && d && (e.descending ? l < d : l > d);
      }), r >= 0 ? s.splice(r, 0, t) : (s.push(t), a++)) : (e.descending ? s.unshift(t) : s.push(t), a++), {
        data: s,
        count: a
      };
    }
  }
  return n;
}
c(DL, "_0");
h(DL, "addToQueryData");
function HP(n, t, e) {
  const i = t === void 0 ? () => !0 : t instanceof Function ? t : (r) => r.id === t;
  return n && (n = JSON.parse(JSON.stringify(n)), n.pages ? {
    pages: n.pages.map((r) => (r.data && (r.data = [
      ...r.data.map((s) => (i(s) && (s = { ...s }, e(s)), s))
    ]), r)) ?? [],
    pageParams: n.pageParams
  } : n.data?.length ? {
    ...n,
    data: [
      ...n.data?.map((r) => (i(r) && (r = { ...r }, e(r)), r)) || []
    ]
  } : n.data ? {
    data: [
      ...n.data.map((r) => (i(r) && (r = { ...r }, e(r)), r))
    ],
    count: n.count
  } : n);
}
c(HP, "Pm");
h(HP, "updateQueryData");
function YP(n, t) {
  if (t !== void 0) {
    const e = t instanceof Function ? t : (i) => i.id === t;
    if (n) {
      if (n = JSON.parse(JSON.stringify(n)), n.pages)
        return {
          pages: n.pages.map((i) => (i.data && (i.data = [...i.data.filter((r) => !e(r))]), i)) ?? [],
          pageParams: n.pageParams
        };
      if (n.data?.length) {
        const i = n.data?.length;
        let r = n.count;
        const s = [...n.data?.filter((a) => !e(a)) || []];
        return i !== s.length && r--, {
          data: s,
          count: r
        };
      }
    }
  }
  return n;
}
c(YP, "Mm");
h(YP, "removeQueryData");
const da = /* @__PURE__ */ h((n, t, e, i) => n.setQueryData(t, (r) => DL(r, e, i)), "addCacheItem"), ge = /* @__PURE__ */ h((n, t, e, i) => n.setQueryData(t, (r) => HP(
  r,
  e,
  i
)), "updateCacheItem"), St = /* @__PURE__ */ h((n, t, e, i) => {
  n.setQueriesData(t, (r) => HP(
    r,
    e,
    i
  ));
}, "updateCacheItems"), ab = /* @__PURE__ */ h((n, t, e) => n.setQueryData(t, (i) => YP(
  i,
  e
)), "removeCacheItem"), $B = /* @__PURE__ */ h((n, t, e) => {
  n.setQueriesData(t, (i) => YP(i, e));
}, "removeCacheItems"), Tw = /* @__PURE__ */ h((n, t, e) => {
  n.setQueriesData(t, (i) => {
    const { count: r } = i;
    return { count: e(r) };
  });
}, "updateCacheItemsCount");
function Iv(n, t, e, i = 1) {
  if (!n)
    return;
  const r = n.getQueryData(t);
  r?.pages?.length && r.pages.length > 1 && n.setQueryData(
    t,
    (s) => ({
      pages: s.pages.slice(0, i),
      pageParams: s.pageParams.slice(0, i)
    }),
    e
  );
}
c(Iv, "Ep");
h(Iv, "keepPages");
function ua(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  if (i && i.state.data) {
    const r = i.state.data.pages.flatMap((s) => s.data).filter((s) => s && s.id < 0).sort((s, a) => s && a ? s.id - a.id : 0);
    return r.length ? e ? r[r.length - 1] : r[0] : null;
  }
  return null;
}
c(ua, "vs");
h(ua, "getPendingCacheItem");
function c1(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  return i && i.state.data ? i.state.data.pages.flatMap((r) => r.data).find((r) => r?.id === e) : null;
}
c(c1, "mh");
h(c1, "getCacheItem");
function cr(n) {
  return (n?.pages.flatMap((t) => t.data) || []).filter((t) => t);
}
c(cr, "Gi");
h(cr, "getFlatInfiniteResultData");
function H5(n) {
  return !n || !n?.pages.some((t) => t.data?.length);
}
c(H5, "Bw");
h(H5, "isInfiniteResultDataEmpty");
function WL(n, t = Ft.All, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ h(async (r) => {
      const s = new URLSearchParams({
        skip: r.pageParam?.toString() || "0",
        type: t
      }), a = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${s.toString()}`, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
c(WL, "M0");
h(WL, "getNotificationsOptions");
function qL(n, t = Ft.All, e) {
  const i = n.queryClient.getQueryData(["notifications", "list", e, t])?.pages.flatMap((s) => s.data);
  let r;
  return i?.forEach((s) => {
    r = r && s && r.id > s.id ? r : s;
  }), r;
}
c(qL, "S0");
h(qL, "getLastNotification");
function FL(n, t) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ notificationId: e }) => {
      const i = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, n.url);
      e && i.searchParams.append("id", e.toString()), await n.fetch(i, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((e) => {
      const i = [];
      return St(
        n.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (r) => {
          i.push({ id: r.id, is_unread: r.is_unread }), r.is_unread = !1;
        }
      ), t && i.length && St(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (r) => !!i.find((s) => s.id === r.id && r.is_unread),
        (r) => {
          r.is_unread = !1;
        }
      ), t || Tw(
        n.queryClient,
        { queryKey: ["notifications", "unread"], exact: !1 },
        () => 0
      ), Tw(
        n.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "unread", t] : ["apps", "notifications", "unread"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: i };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h(async () => {
      t && await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ h(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ h((e, i, r) => {
      console.error(e.message);
    }, "onError")
  };
}
c(FL, "A0");
h(FL, "getMarkNotificationsMutationOptions");
function ZL(n, t) {
  return new Zt(n.queryClient, FL(n, t));
}
c(ZL, "z0");
h(ZL, "getMarkNotificationsMutation");
function XL(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ markAsRead: t, notificationId: e }) => {
      const i = `/api/notifications/${e}/mark`;
      await n.fetch(i, { method: t ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      const e = /* @__PURE__ */ new Map();
      St(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        t.notificationId,
        (i) => {
          !!i.is_unread === t.markAsRead && e.set(i.id, i), i.is_unread = !t.markAsRead;
        }
      ), e.size && (Tw(
        n.queryClient,
        {
          queryKey: ["notifications", "unread"],
          predicate: /* @__PURE__ */ h((i) => i.queryKey[3] === "" || i.queryKey[3] === e.values().next().value?.type, "predicate"),
          exact: !1
        },
        (i) => Math.max(0, i + (t.markAsRead ? -1 : 1))
      ), e.forEach((i) => {
        i.link?.app && Tw(
          n.queryClient,
          {
            queryKey: ["apps", "notifications", "unread"],
            predicate: /* @__PURE__ */ h((r) => {
              const s = r.queryKey[3] === i.link?.app?.id || r.queryKey[3] === i.link?.app?.uid, a = r.queryKey[4] === "" || r.queryKey[4] === i.type;
              return s && a;
            }, "predicate"),
            exact: !1
          },
          (r) => Math.max(0, r + (t.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ h(async (t, e) => {
      St(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (i) => {
          i.is_unread = e.markAsRead;
        }
      ), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onError")
  };
}
c(XL, "R0");
h(XL, "getMarkNotificationMutationOptions");
function GP(n) {
  return new Zt(n.queryClient, XL(n));
}
c(GP, "Sm");
h(GP, "getMarkNotificationMutation");
function NL(n, t = Ft.All, e, i = {}) {
  const r = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), s = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${r.toString()}`;
  return gy(n, e ? ["apps", "notifications", "unread", e, t] : ["notifications", "unread", t], s, i);
}
c(NL, "E0");
h(NL, "getUnreadOptions");
var Vg, Ep;
const jL = (Ep = class {
  constructor(t) {
    F(this, Vg), this.typeFilter = Ft.All, L(this, Vg, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new yn(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread notifications for the current scope
   */
  get unread() {
    return x(this, Vg);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await gr(this.host), this.weavyContext = new dn(this.host, { context: Te, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread notifications change.
   */
  dispatchNotificationUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "notification_created", this.handleRefresh), this.weavy?.subscribe(null, "notification_updated", this.handleRefresh), this.weavy?.subscribe(null, "notifications_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh));
  }
  /**
   * Tracks unread data. Initiates the query data with the given filtering scope.
   *
   * @param typeFilter - The notification types to track.
   * @param appId - Optional app id for the filtering scope.
   */
  async track(t, e) {
    this.appId = e, this.typeFilter = t;
    const i = await this.whenWeavyContext;
    this.markNotificationsMutation = ZL(i, this.appId), await this.unreadQuery.trackQuery(NL(i, this.typeFilter, this.appId), !0);
  }
  async markAllAsRead() {
    const t = await this.whenWeavyContext, e = qL(t, Ft.All, this.appId)?.id;
    await this.markNotificationsMutation?.mutate({ notificationId: e });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (L(this, Vg, t), this.dispatchNotificationUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
}, c(Ep, "lw"), Ep);
Vg = /* @__PURE__ */ new WeakMap(), h(jL, "UnreadNotificationsController");
let KP = jL;
var xB = Object.defineProperty, BL = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(t, e, r) || r);
  return r && xB(t, e, r), r;
}, "__decorateClass$1g"), _p;
const UL = (_p = class extends zi {
  constructor() {
    super(...arguments), this.appType = Ls;
  }
}, c(_p, "dw"), _p);
h(UL, "WeavyOptionalAppComponent");
let vy = UL;
BL([
  Z()
], vy.prototype, "appType");
BL([
  O({ converter: IP })
], vy.prototype, "uid");
var kB = Object.defineProperty, JP = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(t, e, r) || r);
  return r && kB(t, e, r), r;
}, "__decorateClass$1f"), Dg, Vv, Wg, Dv, qg, Wv, zp;
const HL = (zp = class extends pt {
  constructor() {
    super(...arguments), F(this, Dg), F(this, Vv, new Promise((t) => {
      L(this, Dg, t);
    })), F(this, Wg), F(this, Dv, new Promise((t) => {
      L(this, Wg, t);
    })), F(this, qg), F(this, Wv, new Promise((t) => {
      L(this, qg, t);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await x(this, Vv);
  }
  /**
   * Resolves when current user data is available.
   *
   * @internal
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await x(this, Dv);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @internal
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await x(this, Wv);
  }
  willUpdate(t) {
    var e, i, r;
    super.willUpdate(t), t.has("contextId") && this.contextId && (t.get("contextId") && L(this, Vv, new Promise((s) => {
      L(this, Dg, s);
    })), (e = x(this, Dg)) == null || e.call(this, this.contextId)), t.has("user") && this.user && (t.get("user") && L(this, Dv, new Promise((s) => {
      L(this, Wg, s);
    })), (i = x(this, Wg)) == null || i.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && L(this, Wv, new Promise((s) => {
      L(this, qg, s);
    })), (r = x(this, qg)) == null || r.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
}, c(zp, "hw"), zp);
Dg = /* @__PURE__ */ new WeakMap(), Vv = /* @__PURE__ */ new WeakMap(), Wg = /* @__PURE__ */ new WeakMap(), Dv = /* @__PURE__ */ new WeakMap(), qg = /* @__PURE__ */ new WeakMap(), Wv = /* @__PURE__ */ new WeakMap(), h(HL, "WeavySubComponent");
let Li = HL;
JP([
  Ve({ context: Lz, subscribe: !0 }),
  Z()
], Li.prototype, "contextId");
JP([
  Ve({ context: Y0, subscribe: !0 }),
  Z()
], Li.prototype, "user");
JP([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], Li.prototype, "weavy");
var SB = Object.defineProperty, h1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(t, e, r) || r);
  return r && SB(t, e, r), r;
}, "__decorateClass$1e"), Fg, qv, Zg, Fv, Xg, Zv, Ng, Xv, jg, Nv, Lp;
const YL = (Lp = class extends Li {
  constructor() {
    super(...arguments), F(this, Fg), F(this, qv, new Promise((t) => {
      L(this, Fg, t);
    })), F(this, Zg), F(this, Fv, new Promise((t) => {
      L(this, Zg, t);
    })), F(this, Xg), F(this, Zv, new Promise((t) => {
      L(this, Xg, t);
    })), F(this, Ng), F(this, Xv, new Promise((t) => {
      L(this, Ng, t);
    })), F(this, jg), F(this, Nv, new Promise((t) => {
      L(this, jg, t);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await x(this, qv);
  }
  // #resolveAgentUser?: (agentUser: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await x(this, Fv);
  }
  /**
   * Resolves when weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await x(this, Zv);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await x(this, Xv);
  }
  /**
   * Resolves when weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await x(this, Nv);
  }
  willUpdate(t) {
    var e, i, r, s, a;
    super.willUpdate(t), t.has("app") && this.app && (t.get("app") && L(this, qv, new Promise((o) => {
      L(this, Fg, o);
    })), (e = x(this, Fg)) == null || e.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && L(this, Fv, new Promise((o) => {
      L(this, Zg, o);
    })), (i = x(this, Zg)) == null || i.call(this, this.contextDataBlobs)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && L(this, Zv, new Promise((o) => {
      L(this, Xg, o);
    })), (r = x(this, Xg)) == null || r.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && L(this, Xv, new Promise((o) => {
      L(this, Ng, o);
    })), (s = x(this, Ng)) == null || s.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && L(this, Nv, new Promise((o) => {
      L(this, jg, o);
    })), (a = x(this, jg)) == null || a.call(this, this.settings));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
}, c(Lp, "pw"), Lp);
Fg = /* @__PURE__ */ new WeakMap(), qv = /* @__PURE__ */ new WeakMap(), Zg = /* @__PURE__ */ new WeakMap(), Fv = /* @__PURE__ */ new WeakMap(), Xg = /* @__PURE__ */ new WeakMap(), Zv = /* @__PURE__ */ new WeakMap(), Ng = /* @__PURE__ */ new WeakMap(), Xv = /* @__PURE__ */ new WeakMap(), jg = /* @__PURE__ */ new WeakMap(), Nv = /* @__PURE__ */ new WeakMap(), h(YL, "WeavySubAppComponent");
let Oe = YL;
h1([
  Ve({ context: zP, subscribe: !0 }),
  Z()
], Oe.prototype, "app");
h1([
  Ve({ context: Iz, subscribe: !0 }),
  Z()
], Oe.prototype, "contextDataBlobs");
h1([
  Ve({ context: U0, subscribe: !0 }),
  Z()
], Oe.prototype, "componentFeatures");
h1([
  Ve({ context: Dz, subscribe: !0 }),
  Z()
], Oe.prototype, "link");
h1([
  Ve({ context: qz, subscribe: !0 }),
  Z()
], Oe.prototype, "settings");
function GL(n) {
  return typeof n == "string" && n ? n = eval?.(`"use strict";(${n})`) : n = void 0, n;
}
c(GL, "T0");
h(GL, "indirectEvalObject");
function ob(n) {
  if (n)
    try {
      return new URL(n, window.location.toString());
    } catch {
      console.warn("Invalid url: ", n);
    }
}
c(ob, "iy");
h(ob, "toUrl");
const U = /* @__PURE__ */ h((n) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(n) && customElements.define(
      n,
      t
    );
  }) : !customElements.get(n) && customElements.define(n, t);
}, "customElement"), ft = tt`:host{display:contents}`;
var CB = Object.defineProperty, PB = Object.getOwnPropertyDescriptor, De = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? PB(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && CB(t, e, r), r;
}, "__decorateClass$1d");
function Y5(n) {
  return n != null && n !== !1;
}
c(Y5, "qw");
h(Y5, "acceptedValue");
var U2, Ip;
let ce = (U2 = (Ip = class extends pt {
  constructor() {
    super(), this.provider = !1, this.annotations = Se.defaults.annotations, this.cloudFilePickerUrl = Se.defaults.cloudFilePickerUrl, this.configurationTimeout = Se.defaults.configurationTimeout, this.disableEnvironmentImports = Se.defaults.disableEnvironmentImports, this.enterToSend = Se.defaults.enterToSend, this.locale = Se.defaults.locale, this.locales = Se.defaults.locales, this.gcTime = Se.defaults.gcTime, this.scrollBehavior = Se.defaults.scrollBehavior, this.staleTime = Se.defaults.staleTime, this.tokenFactory = Se.defaults.tokenFactory, this.tokenFactoryRetryDelay = Se.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Se.defaults.tokenFactoryTimeout, this.tokenUrl = Se.defaults.tokenUrl, this.url = Se.defaults.url, this.reactions = Se.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ??= new Se({ host: this.provider ? this : void 0 });
  }
  /** The semver version of the package. */
  get version() {
    return Se.version;
  }
  /** The Weavy source name; package name. */
  get sourceName() {
    return Se.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((i) => {
        i !== "weavy" && (Y5(this[i]) || Y5(t.get(i))) && Object.assign(e, { [i]: this[i] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return v` <slot></slot> `;
  }
}, c(Ip, "ka"), Ip), h(U2, "WyContext"), U2);
ce.styles = [Qe, ft];
De([
  O({ attribute: !0, type: Boolean })
], ce.prototype, "provider", 2);
De([
  O()
], ce.prototype, "annotations", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ h((n) => ob(n), "fromAttribute")
    }
  })
], ce.prototype, "cloudFilePickerUrl", 2);
De([
  O({ type: Number, attribute: !0 })
], ce.prototype, "configurationTimeout", 2);
De([
  O({ type: Boolean })
], ce.prototype, "disableEnvironmentImports", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "enterToSend", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "locale", 2);
De([
  O({ attribute: !0, type: Array })
], ce.prototype, "locales", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "gcTime", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "scrollBehavior", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "staleTime", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ h((n) => GL(n), "fromAttribute")
    }
  })
], ce.prototype, "tokenFactory", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "tokenFactoryRetryDelay", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "tokenFactoryTimeout", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ h((n) => ob(n), "fromAttribute")
    }
  })
], ce.prototype, "tokenUrl", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ h((n) => ob(n), "fromAttribute")
    }
  })
], ce.prototype, "url", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "reactions", 2);
De([
  Z()
], ce.prototype, "weavy", 2);
ce = De([
  U("wy-context")
], ce);
const bi = tt`:host{font-family:var(--wy-font-family, unset)}`;
var QB = Object.defineProperty, TB = Object.getOwnPropertyDescriptor, t4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? TB(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && QB(t, e, r), r;
}, "__decorateClass$1c"), H2, Vp;
let ol = (H2 = (Vp = class extends zi {
  constructor() {
    super(...arguments), this.appType = Ls, this.componentFeatures = new ii(H0(j5)), this.theme = new gn(this, ol.styles);
  }
  render() {
    return v`<slot></slot>`;
  }
}, c(Vp, "_a"), Vp), h(H2, "WyComponent"), H2);
ol.styles = [Qe, ft, bi];
t4([
  O({
    converter: {
      fromAttribute(n, t) {
        return uB.get(n) ?? n;
      }
    }
  })
], ol.prototype, "appType", 2);
t4([
  O({
    converter: {
      fromAttribute(n, t) {
        const e = typeof n == "string" ? LP(n, j5) : j5;
        return new ii(H0(e));
      }
    }
  })
], ol.prototype, "componentFeatures", 2);
ol = t4([
  U("wy-component")
], ol);
const wr = tt`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate;box-sizing:border-box;container-type:inline-size}`, El = tt`:host{padding:var(--wy-padding-outer, var(--wy-padding, 0));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}`, _l = tt`:host{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function KL(n, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ h(async (i) => {
      const r = i.pageParam, s = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + r, a = await (await n.fetch(s)).json();
      return a.data = a.data?.reverse() || [], a;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((i) => {
      if (i?.end && i?.end < i?.count)
        return i.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ h((i) => ({
      // reverse scroll
      pages: [...i.pages].reverse(),
      pageParams: [...i.pageParams].reverse()
    }), "select")
  };
}
c(KL, "U0");
h(KL, "getMessagesOptions");
function JL(n, t) {
  return {
    mutationFn: /* @__PURE__ */ h(async (e) => await (await n.fetch("/api/apps/" + e.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        embed_id: e.embed_id || null,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        metadata: e.metadata || null,
        context: e.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ h((e) => {
      const i = ["messages", e.app_id], r = ua(n.queryClient, i, !1), s = {
        id: r ? r.id - 1 : -1,
        app: { id: e.app_id },
        text: e.text,
        html: e.text,
        plain: e.text,
        created_by: e.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      da(n.queryClient, i, s);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((e) => {
      St(
        n.queryClient,
        { queryKey: ["members", e.app.id] },
        e.created_by.id,
        (l) => {
          l.marked_id = e.id, l.marked_at = e.created_at;
        }
      );
      const i = ["messages", e.app.id], { queryClient: r } = n, s = c1(r, i, e.id), a = s ? null : ua(r, i, !0), o = /* @__PURE__ */ h((l, d) => {
        ge(r, i, l, (u) => {
          u.id = d.id, u.app = d.app, u.text = d.text, u.plain = d.plain, u.html = d.html, u.embed = d.embed, u.meeting = d.meeting, u.attachments = d.attachments, u.options = d.options, u.created_at = d.created_at, u.created_by = d.created_by, u.updated_at = d.updated_at, u.updated_by = d.updated_by;
        });
      }, "replaceCacheItem");
      s ? o(s.id, e) : a ? o(a.id, e) : da(r, i, e);
    }, "onSuccess")
  };
}
c(JL, "B0");
h(JL, "getAddMessageMutationOptions");
const { I: MB } = cj, AB = /* @__PURE__ */ h((n) => n.strings === void 0, "f$1"), t9 = /* @__PURE__ */ h(() => document.createComment(""), "r$1"), eg = /* @__PURE__ */ h((n, t, e) => {
  const i = n._$AA.parentNode, r = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const s = i.insertBefore(t9(), r), a = i.insertBefore(t9(), r);
    e = new MB(s, a, n, n.options);
  } else {
    const s = e._$AB.nextSibling, a = e._$AM, o = a !== n;
    if (o) {
      let l;
      e._$AQ?.(n), e._$AM = n, e._$AP !== void 0 && (l = n._$AU) !== a._$AU && e._$AP(l);
    }
    if (s !== r || o) {
      let l = e._$AA;
      for (; l !== s; ) {
        const d = l.nextSibling;
        i.insertBefore(l, r), l = d;
      }
    }
  }
  return e;
}, "s$1"), Ua = /* @__PURE__ */ h((n, t, e = n) => (n._$AI(t, e), n), "v"), RB = {}, tI = /* @__PURE__ */ h((n, t = RB) => n._$AH = t, "m"), EB = /* @__PURE__ */ h((n) => n._$AH, "p"), Y2 = /* @__PURE__ */ h((n) => {
  n._$AR(), n._$AA.remove();
}, "M"), d1 = { ATTRIBUTE: 1, CHILD: 2 }, zl = /* @__PURE__ */ h((n) => (...t) => ({ _$litDirective$: n, values: t }), "e$2");
var G2, Dp;
let Oy = (G2 = (Dp = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, c(Dp, "Pa"), Dp), h(G2, "i"), G2);
const rw = /* @__PURE__ */ h((n, t) => {
  const e = n._$AN;
  if (e === void 0) return !1;
  for (const i of e) i._$AO?.(t, !1), rw(i, t);
  return !0;
}, "s"), n0 = /* @__PURE__ */ h((n) => {
  let t, e;
  do {
    if ((t = n._$AM) === void 0) break;
    e = t._$AN, e.delete(n), n = t;
  } while (e?.size === 0);
}, "o$5"), eI = /* @__PURE__ */ h((n) => {
  for (let t; t = n._$AM; n = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(n)) break;
    e.add(n), _B(t);
  }
}, "r");
function iI(n) {
  this._$AN !== void 0 ? (n0(this), this._$AM = n, eI(this)) : this._$AM = n;
}
c(iI, "Q0");
h(iI, "h$1");
function nI(n, t = !1, e = 0) {
  const i = this._$AH, r = this._$AN;
  if (r !== void 0 && r.size !== 0) if (t) if (Array.isArray(i)) for (let s = e; s < i.length; s++) rw(i[s], !1), n0(i[s]);
  else i != null && (rw(i, !1), n0(i));
  else rw(this, n);
}
c(nI, "K0");
h(nI, "n$2");
const _B = /* @__PURE__ */ h((n) => {
  n.type == d1.CHILD && (n._$AP ??= nI, n._$AQ ??= iI);
}, "c$1");
var Wp;
const rI = (Wp = class extends Oy {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), eI(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (rw(this, t), n0(this));
  }
  setValue(t) {
    if (AB(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}, c(Wp, "uw"), Wp);
h(rI, "f");
let zB = rI;
const wt = /* @__PURE__ */ h(() => new LB(), "e$1");
var qp;
const sI = (qp = class {
}, c(qp, "yw"), qp);
h(sI, "h");
let LB = sI;
const K2 = /* @__PURE__ */ new WeakMap(), at = zl(class extends zB {
  render(n) {
    return C;
  }
  update(n, [t]) {
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = n.options?.host, this.rt(this.ct = n.element)), C;
  }
  rt(n) {
    if (this.isConnected || (n = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = K2.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), K2.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, n), n !== void 0 && this.G.call(this.ht, n);
    } else this.G.value = n;
  }
  get lt() {
    return typeof this.G == "function" ? K2.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function aI(n, t, e) {
  const i = n.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ h(async ({ optionId: r }) => {
      const s = await n.fetch(`/api/options/${r}/vote`, { method: "POST" });
      if (!s.ok) {
        const a = await s.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
      return await s.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => (St(i, { queryKey: e }, r.parentId, (s) => {
      s.options?.data && (s.options.data = s.options.data?.map((a) => {
        if (a.has_voted) {
          a.has_voted = !1;
          const o = a.votes?.count || 1;
          a.votes ? a.votes.count = o - 1 : a.votes = { count: o - 1 };
        } else if (!a.has_voted && a.id === r.optionId) {
          a.has_voted = !0;
          const o = a.votes?.count || 0;
          a.votes ? a.votes.count = o + 1 : a.votes = { count: o + 1 };
        }
        return a;
      }));
    }), { id: r.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ h(async (r, s) => {
      const a = await (await n.fetch("/api/" + s.parentType + "/" + s.parentId)).json();
      St(
        i,
        { queryKey: e, exact: !1 },
        s.parentId,
        (o) => Object.assign(o, a)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
c(aI, "Z0");
h(aI, "getPollMutationOptions");
function lb(n, t, e) {
  return new Zt(n.queryClient, aI(n, t, e));
}
c(lb, "sy");
h(lb, "getPollMutation");
function oI(n, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ h(async () => await (await n.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
c(oI, "Y0");
h(oI, "getVotesOptions");
const Um = /* @__PURE__ */ h((n, t) => !!(n && t && t.indexOf(n) !== -1), "hasPermission");
function lI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ app: t, messageId: e }) => {
      const i = e ? `/api/apps/${t.id}/mark?messageId=${e}` : `/api/apps/${t.id}/mark`;
      await n.fetch(i, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h(async (t) => {
      await n.queryClient.cancelQueries({ queryKey: ["apps", t.app.id] }), await n.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["apps", "unread"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["members", t.app.id] }), n.queryClient.setQueryData(
        ["apps", t.app.id],
        (e) => e && { ...e, is_unread: !t.messageId || t.messageId < e.last_message.id }
      ), St(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.app.id,
        (e) => {
          e.is_unread = !t.messageId || t.messageId < e.last_message.id;
        }
      ), t.userId && St(n.queryClient, { queryKey: ["members", t.app.id] }, t.userId, (e) => {
        t.messageId ? (e.marked_at = (/* @__PURE__ */ new Date()).toISOString(), e.marked_id = t.messageId) : (e.marked_at = void 0, e.marked_id = void 0);
      }), Tw(
        n.queryClient,
        {
          queryKey: ["apps", "unread"],
          exact: !1,
          predicate: /* @__PURE__ */ h((e) => {
            const i = e.queryKey[2].includes(t.app.type), r = e.queryKey[2], s = !r || !!t.app.members.data?.find((a) => a.uid && a.uid === r);
            return i && s;
          }, "predicate")
        },
        (e) => Math.max(0, e + (t.messageId ? -1 : 1))
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ h((t, e) => {
      console.error(t.message), St(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.app.id,
        (i) => {
          i.is_unread = !i.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ h(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps", i.app.id] }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.app.id] });
    }, "onSettled")
  };
}
c(lI, "X0");
h(lI, "getMarkConversationMutationOptions");
function cI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t, star: e }) => {
      await n.fetch(`/api/apps/${t}/stars`, { method: e ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      St(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_starred = t.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ h((t, e) => {
      console.error(t.message), St(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_starred = !e.star;
        }
      );
    }, "onError")
  };
}
c(cI, "J0");
h(cI, "getStarConversationMutationOptions");
function hI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t, pin: e }) => {
      await n.fetch(`/api/apps/${t}/pin`, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      St(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_pinned = t.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ h(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(hI, "tb");
h(hI, "getPinConversationMutationOptions");
function dI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members/${e.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      ab(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((t, e) => {
      n.queryClient.removeQueries({ queryKey: ["apps", e.appId] }), n.queryClient.removeQueries({ queryKey: ["members", e.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ h(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
c(dI, "eb");
h(dI, "getLeaveConversationMutationOptions");
function uI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      ab(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ h(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(uI, "ib");
h(uI, "getRemoveConversationMutationOptions");
function pI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t, userId: e, access: i }) => {
      await n.fetch(`/api/apps/${t}/members/${e}`, { method: "PUT", body: JSON.stringify({ access: i }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ h(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(pI, "rb");
h(pI, "getUpdateMemberMutationOptions");
function fI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members`, {
        method: "PUT",
        body: JSON.stringify(
          e.map((i) => ({ id: i, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ h(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(fI, "sb");
h(fI, "getAddMembersToConversationMutationOptions");
function mI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t, name: e, blobId: i }) => await (await n.fetch(`/api/apps/${t}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: e,
        picture: i
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      const e = /* @__PURE__ */ h((i) => {
        typeof t.name == "string" && (i.name = t.name), typeof t?.thumbnailUrl == "string" && (i.avatar_url = t.thumbnailUrl);
      }, "modifyAppItem");
      ge(n.queryClient, ["apps", t.appId], void 0, e), St(n.queryClient, { queryKey: ["apps", "list"], exact: !1 }, t.appId, e);
    }, "onMutate")
  };
}
c(mI, "nb");
h(mI, "getUpdateConversationMutationOptions");
function yI(n) {
  return {
    mutationFn: /* @__PURE__ */ h(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((t) => {
      ab(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ h(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(yI, "ab");
h(yI, "getTrashConversationMutationOptions");
function e4(n) {
  return new Zt(n.queryClient, lI(n));
}
c(e4, "Em");
h(e4, "getMarkConversationMutation");
function gI(n) {
  return new Zt(n.queryClient, cI(n));
}
c(gI, "ob");
h(gI, "getStarConversationMutation");
function wI(n) {
  return new Zt(n.queryClient, hI(n));
}
c(wI, "cb");
h(wI, "getPinConversationMutation");
function i4(n) {
  return new Zt(n.queryClient, dI(n));
}
c(i4, "Lm");
h(i4, "getLeaveConversationMutation");
function vI(n) {
  return new Zt(n.queryClient, uI(n));
}
c(vI, "lb");
h(vI, "getRemoveConversationMutation");
function OI(n) {
  return new Zt(n.queryClient, pI(n));
}
c(OI, "db");
h(OI, "getUpdateMemberMutation");
function bI(n) {
  return new Zt(n.queryClient, fI(n));
}
c(bI, "hb");
h(bI, "getAddMembersToConversationMutation");
function n4(n) {
  return new Zt(n.queryClient, mI(n));
}
c(n4, "Om");
h(n4, "getUpdateConversationMutation");
function $I(n) {
  return new Zt(n.queryClient, yI(n));
}
c($I, "pb");
h($I, "getTrashConversationMutation");
function r4(n, t, e = [gt.ChatRoom, gt.PrivateChat], i) {
  return gy(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ h(() => n?.queryClient.getQueryData(["apps", "list", e, i])?.pages.flatMap((r) => r.data).find((r) => r?.id === t), "initialData")
  });
}
c(r4, "Im");
h(r4, "getConversationOptions");
function s4(n, t, e) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ h(async () => await (await n.fetch(`/api/apps/${t}/members`)).json(), "queryFn"),
    ...e
  };
}
c(s4, "Tm");
h(s4, "getMemberOptions");
function xI(n, t, e, i) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ h(async (r) => {
      const s = t(), a = r.pageParam;
      let o;
      e ? o = await n.fetch(`/api/apps/${e}/members?q=${s}${i() !== void 0 ? `&agent=${!!i()}` : ""}&member=false&system=false&skip=${a}`) : o = await n.fetch(`/api/users?q=${s}${i() !== void 0 ? `&agent=${!!i()}` : ""}&system=false&skip=${a}`);
      const l = await o.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
c(xI, "ub");
h(xI, "getInfiniteSearchMemberOptions");
const Ot = /* @__PURE__ */ h((n) => n ?? C, "o$3"), e9 = /* @__PURE__ */ h((n, t, e) => {
  const i = /* @__PURE__ */ new Map();
  for (let r = t; r <= e; r++) i.set(n[r], r);
  return i;
}, "u"), Mi = zl(class extends Oy {
  constructor(n) {
    if (super(n), n.type !== d1.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let i;
    e === void 0 ? e = t : t !== void 0 && (i = t);
    const r = [], s = [];
    let a = 0;
    for (const o of n) r[a] = i ? i(o, a) : a, s[a] = e(o, a), a++;
    return { values: s, keys: r };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, i]) {
    const r = EB(n), { values: s, keys: a } = this.dt(t, e, i);
    if (!Array.isArray(r)) return this.ut = a, s;
    const o = this.ut ??= [], l = [];
    let d, u, p = 0, f = r.length - 1, y = 0, g = s.length - 1;
    for (; p <= f && y <= g; ) if (r[p] === null) p++;
    else if (r[f] === null) f--;
    else if (o[p] === a[y]) l[y] = Ua(r[p], s[y]), p++, y++;
    else if (o[f] === a[g]) l[g] = Ua(r[f], s[g]), f--, g--;
    else if (o[p] === a[g]) l[g] = Ua(r[p], s[g]), eg(n, l[g + 1], r[p]), p++, g--;
    else if (o[f] === a[y]) l[y] = Ua(r[f], s[y]), eg(n, r[p], r[f]), f--, y++;
    else if (d === void 0 && (d = e9(a, y, g), u = e9(o, p, f)), d.has(o[p])) if (d.has(o[f])) {
      const b = u.get(a[y]), S = b !== void 0 ? r[b] : null;
      if (S === null) {
        const $ = eg(n, r[p]);
        Ua($, s[y]), l[y] = $;
      } else l[y] = Ua(S, s[y]), eg(n, r[p], S), r[b] = null;
      y++;
    } else Y2(r[f]), f--;
    else Y2(r[p]), p++;
    for (; y <= g; ) {
      const b = eg(n, l[g + 1]);
      Ua(b, s[y]), l[y++] = b;
    }
    for (; p <= f; ) {
      const b = r[p++];
      b !== null && Y2(b);
    }
    return this.ut = a, tI(n, l), lr;
  }
}), jv = zl(class extends Oy {
  constructor() {
    super(...arguments), this.key = C;
  }
  render(n, t) {
    return this.key = n, t;
  }
  update(n, [t, e]) {
    return t !== this.key && (tI(n), this.key = t), e;
  }
});
function Hr(n) {
  n.stopPropagation();
}
c(Hr, "zr");
h(Hr, "inputConsume");
function kI(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.value = "", n.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
c(kI, "yb");
h(kI, "inputClearOnEscape");
function Mw(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.blur());
}
c(Mw, "Gd");
h(Mw, "inputBlurOnEscape");
function SI(n) {
  n.key === "Enter" && n.target.blur();
}
c(SI, "wb");
h(SI, "inputBlurOnEnter");
function CI(n) {
  n.target.value ? kI(n) : Mw(n);
}
c(CI, "fb");
h(CI, "inputClearAndBlurOnEscape");
function a4(n) {
  n.key === "Enter" && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
c(a4, "Fm");
h(a4, "clickOnEnter");
function PI(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation());
}
c(PI, "mb");
h(PI, "consumeOnSpace");
function ze(n) {
  a4(n), PI(n);
}
c(ze, "ce");
h(ze, "clickOnEnterAndConsumeOnSpace");
function di(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
c(di, "Me");
h(di, "clickOnSpace");
function cb(n) {
  a4(n), di(n);
}
c(cb, "ny");
h(cb, "clickOnEnterAndSpace");
const hb = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-messages]{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}[part~=wy-message-placeholder]{opacity:.5}[part~=wy-message-date-separator]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;position:sticky;display:block;top:calc(var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) + var(--wy-component-offset-top, 0px));z-index:10;align-self:center;justify-self:center;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));background:var(--wy-surface-container-high, var(--wy-surface-container-high-light, #e6e8ee));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-message]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5*var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem}[part~=wy-message][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-message-meta]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-message-bubble]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32*var(--wy-size, 1rem),100% - 2*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-message-bubble-section]{flex:1 1 100%;display:block;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box}[part~=wy-message-author]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-size, 1rem)) 0 0}[part~=wy-message-content]{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}[part~=wy-message-agent]{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-container-light, #ebe3bd));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-on-tertiary-container-light, #4c472b))}[part~=wy-message-me]{margin-right:0;margin-left:calc(2.5*var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-message-me] [part~=wy-message-meta]{margin:0 calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}[part~=wy-message-me] [part~=wy-message-content]{align-items:flex-end}[part~=wy-message-bubble-emoji]{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-message-seenby]{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125*var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125*var(--wy-size, 1rem))}`, QI = tt`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}[part~=wy-footerbar-floating]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}[part~=wy-footerbar-floating]:after{border-radius:var(--wy-component-border-radius)}`, Ll = tt`[part~=wy-pane]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-pane-body]{display:flex;flex-direction:column;flex:1}[part~=wy-pane-group]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;flex:1}[part~=wy-pane-group-fixed-size]{flex:0}[part~=wy-pane-toolbar]{display:flex;flex:1;justify-content:space-between;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`, Sa = tt`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`, o4 = tt`[part~=wy-toasts]{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;box-sizing:border-box;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}[part~=wy-toasts][popover]{position:fixed;inset:0;z-index:1070}[part~=wy-toasts]>::slotted(*){pointer-events:auto}[part~=wy-toast]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(3*var(--wy-size, 1rem));max-width:calc(32*var(--wy-size, 1rem))}[part~=wy-toast][part~=wy-fade]{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}[part~=wy-toast][part~=wy-fade]:not([part~=wy-show]){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}[part~=wy-toast-action]{position:sticky;top:calc(4.5*var(--wy-size, 1rem));bottom:calc(4.5*var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));padding:calc(.5*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3*var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}[part~=wy-toast-primary]{background:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff))}`;
var l4 = /* @__PURE__ */ ((n) => (n.Active = "active", n.Away = "away", n))(l4 || {}), Fp;
const TI = (Fp = class extends Oy {
  constructor(t) {
    if (super(t), t.type !== d1.ATTRIBUTE || t.name !== "part" || t.strings?.length > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((r) => r !== "")
      ));
      for (const r in e)
        e[r] && !this._staticShadowParts?.has(r) && this._previousShadowParts.add(r);
      return this.render(e);
    }
    const i = t.element.part;
    for (const r of this._previousShadowParts)
      r in e || (i.remove(r), this._previousShadowParts.delete(r));
    for (const r in e) {
      const s = !!e[r];
      s !== this._previousShadowParts.has(r) && !this._staticShadowParts?.has(r) && (s ? (i.add(r), this._previousShadowParts.add(r)) : (i.remove(r), this._previousShadowParts.delete(r)));
    }
    return lr;
  }
}, c(Fp, "ww"), Fp);
h(TI, "ShadowPartMapDirective");
let IB = TI;
const ut = zl(IB), re = tt`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, c4 = tt`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius, 50%))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-on-primary-light, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:normal}[part~=wy-avatar-type-icon]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-tertiary, var(--wy-tertiary-light, #645f41));stroke:var(--wy-on-tertiary, var(--wy-on-tertiary-light, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, MI = tt`[part~=wy-presence]{width:calc(.75*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38d));background-clip:content-box;padding:calc(.125*var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-.5*var(--wy-size, 1rem))}`;
var VB = Object.defineProperty, DB = Object.getOwnPropertyDescriptor, h4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? DB(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && VB(t, e, r), r;
}, "__decorateClass$1b"), J2, Zp;
let Hm = (J2 = (Zp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === l4.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return v` <span part=${ut(t)} data-presence-id=${this.id}></span> `;
  }
}, c(Zp, "Ma"), Zp), h(J2, "WyPresence"), J2);
Hm.styles = [
  re,
  MI,
  ft
];
h4([
  O()
], Hm.prototype, "placement", 2);
h4([
  O()
], Hm.prototype, "status", 2);
Hm = h4([
  U("wy-presence")
], Hm);
var WB = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", qB = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", FB = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", ZB = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", XB = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", NB = "M19.5,3.09L15,7.59V4H13V11H20V9H16.41L20.91,4.5L19.5,3.09M4,13V15H7.59L3.09,19.5L4.5,20.91L9,16.41V20H11V13H4Z", jB = "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z", i9 = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", BB = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", UB = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", HB = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", YB = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", GB = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", KB = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", t$ = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", JB = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", tU = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", eU = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", iU = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", nU = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", rU = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", sU = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", aU = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", oU = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", lU = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", cU = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", hU = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", dU = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", uU = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", pU = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", fU = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", mU = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", yU = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", gU = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", wU = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", vU = "M12,17.5C14.33,17.5 16.3,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5M8.5,11A1.5,1.5 0 0,0 10,9.5A1.5,1.5 0 0,0 8.5,8A1.5,1.5 0 0,0 7,9.5A1.5,1.5 0 0,0 8.5,11M15.5,11A1.5,1.5 0 0,0 17,9.5A1.5,1.5 0 0,0 15.5,8A1.5,1.5 0 0,0 14,9.5A1.5,1.5 0 0,0 15.5,11M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", OU = "M15 18H18V15H20V18H23V20H20V23H18V20H15V18M12 17.5C9.67 17.5 7.69 16.04 6.89 14H15.69C14.5 14.78 13.62 15.97 13.23 17.36C12.83 17.45 12.42 17.5 12 17.5M8.5 11C7.67 11 7 10.33 7 9.5C7 8.67 7.67 8 8.5 8C9.33 8 10 8.67 10 9.5C10 10.33 9.33 11 8.5 11M15.5 11C14.67 11 14 10.33 14 9.5C14 8.67 14.67 8 15.5 8C16.33 8 17 8.67 17 9.5C17 10.33 16.33 11 15.5 11M12 20L13.07 19.93C13.18 20.61 13.4 21.26 13.72 21.85C13.16 21.95 12.58 22 12 22C6.47 22 2 17.5 2 12C2 6.5 6.47 2 12 2C17.5 2 22 6.5 22 12C22 12.59 21.95 13.16 21.85 13.72C21.26 13.4 20.62 13.18 19.93 13.07L20 12C20 7.58 16.42 4 12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20Z", bU = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", n9 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", r9 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", $U = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", xU = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", kU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", SU = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", CU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", PU = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", QU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", TU = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", MU = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", AU = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", RU = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", EU = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z", _U = "M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z", zU = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", LU = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", IU = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", VU = "M7,10L12,15L17,10H7Z", DU = "M7,15L12,10L17,15H7Z", WU = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z", qU = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18", FU = "M19,13H5V11H19V13Z", ZU = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", XU = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", NU = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", jU = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", BU = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", UU = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", HU = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", YU = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", GU = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", KU = "M2,21L23,12L2,3V10L17,12L2,14V21Z", JU = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", tH = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", eH = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", iH = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", nH = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", rH = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", sH = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", aH = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", oH = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", lH = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", cH = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", hH = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", dH = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", uH = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", pH = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const s9 = GU, a9 = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, fH = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, mH = {
  email: wU,
  file: bU,
  "file-upload": CU,
  "file-music": kU,
  "file-image": xU,
  "file-video": PU,
  "file-code": n9,
  "file-xml": n9,
  "file-document": r9,
  "file-word": QU,
  "file-excel": $U,
  "file-pdf": r9,
  "file-powerpoint": SU,
  "file-compressed": AU
}, o9 = {
  "account-minus": WB,
  "account-plus": qB,
  alert: FB,
  "alert-circle": ZB,
  "alert-octagon": XB,
  "arrow-collapse": NB,
  "arrow-expand": jB,
  attachment: UB,
  back: i9,
  "backup-restore": HB,
  bell: YB,
  "bell-off": GB,
  agent: rH,
  check: t$,
  "check-all": JB,
  "check-circle-outline": eU,
  "checkbox-blank": iU,
  "checkbox-marked": nU,
  "circle-outline": rU,
  "check-circle": tU,
  close: sU,
  "close-circle": aU,
  cloud: oU,
  comment: lU,
  "comment-outline": cU,
  "content-save": hU,
  delete: uU,
  "delete-restore": fU,
  "delete-forever": pU,
  "dots-vertical": mU,
  download: yU,
  earth: gU,
  emoticon: vU,
  "emoticon-plus": OU,
  "fit-screen": MU,
  "fit-width": TU,
  fullscreen: EU,
  "fullscreen-exit": _U,
  "help-circle": zU,
  information: LU,
  magnify: IU,
  meeting: ZU,
  "menu-down": VU,
  "menu-up": DU,
  message: WU,
  "message-text": qU,
  minus: FU,
  next: BB,
  "open-in-new": XU,
  pencil: NU,
  pin: jU,
  unpin: BU,
  plus: UU,
  "plus-circle-outline": HU,
  poll: KB,
  previous: i9,
  read: t$,
  restore: YU,
  unread: t$,
  send: KU,
  "server-network-off": JU,
  "shield-star": tH,
  "shield-star-outline": eH,
  sort: iH,
  star: nH,
  unstar: sH,
  stars: dU,
  "swap-horizontal": aH,
  textbox: RU,
  "thumb-up": oH,
  "thumb-up-outline": lH,
  trashcan: cH,
  video: hH,
  "view-list-outline": dH,
  "view-module-outline": uH,
  "wifi-off": pH,
  ...mH,
  ...fH
}, l9 = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function G5(n) {
  return n && n in o9 ? o9[n] : "";
}
c(G5, "Jw");
h(G5, "getIconMapping");
function AI(n) {
  return n && n in a9 ? a9[n] : "";
}
c(AI, "Z2");
h(AI, "getSvgMapping");
var Xp;
const RI = (Xp = class extends Oy {
  constructor(t) {
    if (super(t), this.it = C, t.type !== d1.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === C || t == null) return this._t = void 0, this.it = t;
    if (t === lr) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
}, c(Xp, "fw"), Xp);
h(RI, "e");
let r0 = RI;
r0.directiveName = "unsafeHTML", r0.resultType = 1;
const ll = zl(r0);
var Np;
const EI = (Np = class extends r0 {
}, c(Np, "mw"), Np);
h(EI, "t");
let K5 = EI;
K5.directiveName = "unsafeSVG", K5.resultType = 2;
const c9 = zl(K5), d4 = tt`[part~=wy-icon-wrapper]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width)/2);height:calc(var(--wy-component-icon-height)/2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-fill]{flex:1 0 auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem));text-align:center;line-height:var(--wy-line-height, 1.5)}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-light, #51606f))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-light, #645f41))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-surface-light, #f7f9ff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-light, #adb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9285de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #adb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-text-icon]{width:calc(1.25*var(--wy-size, 1rem));height:calc(1.25*var(--wy-size, 1rem));vertical-align:calc(-.3125*var(--wy-size, 1rem))}`;
var yH = Object.defineProperty, gH = Object.getOwnPropertyDescriptor, be = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? gH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && yH(t, e, r), r;
}, "__decorateClass$1a"), e$, jp;
let he = (e$ = (jp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.color = "", this.size = 24, this.path = s9, this.inline = !1, this.first = !1, this.last = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${Xm()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = G5(this.name) || s9, this.overlayPath = G5(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && l9[this.name] || void 0, this.nativeOverlayColor = this.overlayName && l9[this.overlayName] || void 0);
  }
  render() {
    const t = this.kind ? mP(this.kind) : this.kind, e = this.ext?.startsWith(".") ? this.ext.substring(1) : this.ext, i = {
      "wy-icon-wrapper": !0,
      "wy-icon-stack-layer": this.layer
    }, r = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + e]: !!e,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-inline": this.inline,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, s = this.size !== 24, a = this.size / 16, o = s ? `width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));` : "", l = this.svg && AI(this.svg);
    return this.overlayPath ? [
      v`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      v`
          <div part=${ut(i)}>
            <wy-icon-stack style="${o}">
              <svg
                part=${ut(r)}
                viewBox="0 0 24 24"
                width="${this.size}"
                height="${this.size}"
                style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
              >
                <defs>
                  <mask id="${this.uniqueId}-mask">
                    <rect class="icon-mask-bg" />
                    <rect class="icon-mask" />
                  </mask>
                </defs>
                ${l ? c9(l) : zO`
                    <path d="${this.path}" style="fill: ${Ot(this.nativeIconColor)}" />
                  `}
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
              <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
                <path d="${this.overlayPath}" style="fill: ${Ot(this.nativeOverlayColor)}" />
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
            </wy-icon-stack>
            <slot></slot>
          </div>
        `
    ] : v`
      <div part=${ut(i)}>
        <svg
          part=${ut(r)}
          style="${o}"
          viewBox="0 0 24 24"
          width="${this.size}"
          height="${this.size}"
        >
          ${l ? c9(l) : zO`
            <path d="${this.path}" style="fill: ${Ot(this.nativeIconColor)}" />
          `}
          <!--rect width="24" height="24" fill="transparent" /-->
        </svg>
        <slot></slot>
      </div>
    `;
  }
}, c(jp, "Sa"), jp), h(e$, "WyIcon"), e$);
he.styles = [re, d4, ft];
be([
  O()
], he.prototype, "name", 2);
be([
  O()
], he.prototype, "overlayName", 2);
be([
  O()
], he.prototype, "svg", 2);
be([
  O()
], he.prototype, "color", 2);
be([
  O({ type: Number })
], he.prototype, "size", 2);
be([
  O()
], he.prototype, "kind", 2);
be([
  O()
], he.prototype, "ext", 2);
be([
  O({ attribute: !1 })
], he.prototype, "path", 2);
be([
  O({ attribute: !1 })
], he.prototype, "overlayPath", 2);
be([
  O({ type: Boolean })
], he.prototype, "inline", 2);
be([
  O({ type: Boolean })
], he.prototype, "first", 2);
be([
  O({ type: Boolean })
], he.prototype, "last", 2);
be([
  O({ type: Boolean })
], he.prototype, "layer", 2);
be([
  O({ type: Boolean })
], he.prototype, "state", 2);
be([
  O({ type: Boolean })
], he.prototype, "active", 2);
be([
  Z()
], he.prototype, "nativeIconColor", 2);
be([
  Z()
], he.prototype, "nativeOverlayColor", 2);
he = be([
  U("wy-icon")
], he);
var i$, Bp;
let s0 = (i$ = (Bp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  render() {
    return v`<slot></slot>`;
  }
}, c(Bp, "Aa"), Bp), h(i$, "WyIconStack"), i$);
s0.styles = [re, d4];
s0 = be([
  U("wy-icon-stack")
], s0);
var n$, Up;
let Aw = (n$ = (Up = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.fill = !1;
  }
  render() {
    return v`
      <div part="wy-icon-display ${ut({ "wy-icon-display-fill": this.fill })}">
        <div part="wy-icon-display-icon">
          <slot></slot>
        </div>
        <div part="wy-icon-display-text">
          <slot name="text"></slot>
        </div>
        <div part="wy-icon-display-meta">
          <slot name="meta"></slot>
        </div>
      </div>
    `;
  }
}, c(Up, "za"), Up), h(n$, "WyIconDisplay"), n$);
Aw.styles = [re, d4, ft];
be([
  O({ type: Boolean })
], Aw.prototype, "fill", 2);
Aw = be([
  U("wy-icon-display")
], Aw);
var wH = Object.defineProperty, vH = Object.getOwnPropertyDescriptor, nn = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? vH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && wH(t, e, r), r;
}, "__decorateClass$19"), r$, Hp;
let hr = (r$ = (Hp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = v_(this.name));
    const i = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === l4.Active
    };
    return v`
      ${this.src ? v`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${ut(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : v`
            <div
              part=${ut(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? v`<wy-icon part="wy-avatar-type-icon" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : C}
      ${this.presence && !this.isAgent ? v`<wy-presence part="wy-avatar-presence" .status=${this.presence} id=${this.id}></wy-presence>` : C}
    `;
  }
}, c(Hp, "Ra"), Hp), h(r$, "WyAvatar"), r$);
hr.styles = [re, c4, MI];
nn([
  O({ type: Number })
], hr.prototype, "size", 2);
nn([
  O()
], hr.prototype, "src", 2);
nn([
  O()
], hr.prototype, "name", 2);
nn([
  O()
], hr.prototype, "description", 2);
nn([
  O({ type: Boolean, reflect: !0 })
], hr.prototype, "isAgent", 2);
nn([
  O()
], hr.prototype, "presence", 2);
hr = nn([
  U("wy-avatar")
], hr);
var s$, Yp;
let cl = (s$ = (Yp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.size = 32, this.uniqueId = `wy-avatar-${Xm()}`;
  }
  render() {
    if (!this.user)
      return C;
    const t = this.size / 16, e = (this.members || []).filter((s) => s.id !== this.user?.id).slice(0, 2).reverse(), i = e?.shift() || this.user, r = e?.shift() || (i !== this.user ? this.user : void 0);
    return [
      v`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          [part~="wy-avatar-mask-bg"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          [part~="wy-avatar-mask"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      v`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect part="wy-avatar-mask-bg" />
              <rect part="wy-avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      v`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${r?.avatar_url}
          .name=${r?.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${i.avatar_url}
          .name=${i.name}
          .isAgent=${i.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, c(Yp, "Ea"), Yp), h(s$, "WyAvatarGroup"), s$);
cl.styles = [re, c4, ft];
nn([
  O({ type: Number })
], cl.prototype, "size", 2);
nn([
  O({
    type: Array,
    attribute: !1
  })
], cl.prototype, "members", 2);
nn([
  Ve({ context: Y0, subscribe: !0 }),
  Z()
], cl.prototype, "user", 2);
cl = nn([
  U("wy-avatar-group")
], cl);
var a$, Gp;
let Rw = (a$ = (Gp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  render() {
    return v`
      <slot></slot>
      ${this.description ? v` <div part="wy-avatar-description">${this.description}</div> ` : C}
    `;
  }
}, c(Gp, "La"), Gp), h(a$, "WyAvatarHeader"), a$);
Rw.styles = [re, c4];
nn([
  O()
], Rw.prototype, "description", 2);
Rw = nn([
  U("wy-avatar-header")
], Rw);
const OH = tt`[part~=wy-empty]{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}`, _I = tt`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-progress-padded]{margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-progress-overlay]{position:absolute!important}[part~=wy-progress-reveal]{overflow:hidden;opacity:1;interpolate-size:allow-keywords;height:auto;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}`, bH = tt`[part~=wy-progress-circular]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress-circular]:not([width]),[part~=wy-progress-circular][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular]:not([height]),[part~=wy-progress-circular][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-progress-overlay]{position:absolute;inset:0;margin:auto}[part~=wy-progress-indeterminate-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-progress-indeterminate]{animation:wy-rotate 1.4s linear infinite}[part~=wy-progress-indeterminate] [part~=wy-progress-indeterminate-circle]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}25%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}50%{stroke:#0000}75%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}}`;
var $H = Object.defineProperty, xH = Object.getOwnPropertyDescriptor, Ca = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $H(t, e, r), r;
}, "__decorateClass$18"), o$, Kp;
let En = (o$ = (Kp = class extends pt {
  constructor() {
    super(...arguments), this.shadowParts = new G(this), this.size = 24, this.indeterminate = !1, this.padded = !1, this.overlay = !1, this.value = 0, this.max = 1, this.reveal = !1;
  }
  render() {
    const t = {
      "wy-progress": !0,
      "wy-progress-reveal": this.reveal,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded
    }, e = {
      "wy-progress-circular": !0,
      "wy-primary": !this.indeterminate,
      "wy-progress-indeterminate": this.indeterminate
    }, i = 10, r = Math.PI * (i * 2);
    let s;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (s = this.value / this.max);
    } catch (a) {
      console.error(a);
    }
    return v`
      <div part="${ut(t)}">
        ${this.indeterminate || s === void 0 ? zO`
              <svg
                part="${ut(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                role="progressbar"
                aria-label="${C}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${C}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-indeterminate-circle"
                  fill="none"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                ></circle>
              </svg>
            ` : zO`
              <svg
                part="${ut(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                transform="rotate(-90)"
                role="progressbar"
                aria-label="${C}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${this.value}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-remaining"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="#eee"
                ></circle>
                <circle
                  part="wy-progress-circle wy-progress-done"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-dasharray=${r}
                  stroke-dashoffset=${r * (1 - s)}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="currentColor"
                  path-length="200"
                ></circle>
              </svg>
            `}
      </div>
    `;
  }
}, c(Kp, "Oa"), Kp), h(o$, "WyProgressCircular"), o$);
En.styles = [re, _I, bH, ft];
Ca([
  O({ type: Number })
], En.prototype, "size", 2);
Ca([
  O({ type: Boolean })
], En.prototype, "indeterminate", 2);
Ca([
  O({ type: Boolean })
], En.prototype, "padded", 2);
Ca([
  O({ type: Boolean })
], En.prototype, "overlay", 2);
Ca([
  O({ type: Number })
], En.prototype, "value", 2);
Ca([
  O({ type: Number })
], En.prototype, "max", 2);
Ca([
  O({ type: Boolean })
], En.prototype, "reveal", 2);
En = Ca([
  U("wy-progress-circular")
], En);
var kH = Object.defineProperty, SH = Object.getOwnPropertyDescriptor, u4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? SH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && kH(t, e, r), r;
}, "__decorateClass$17"), l$, Jp;
let Ym = (l$ = (Jp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    return v`
      <div part="wy-empty">
        ${this.weavy && !this.noNetwork && this.weavy?.network.state === "unreachable" ? v`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${P("The server is offline, try again in a few minutes...")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : !this.noNetwork && this.weavy?.network.state === "offline" ? v`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${P("You are currently offline.")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : v`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${P("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy?.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavy?.removeNetworkListener(this.handleUpdate);
  }
}, c(Jp, "Ia"), Jp), h(l$, "WyEmpty"), l$);
Ym.styles = [
  OH,
  ft
];
u4([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], Ym.prototype, "weavy", 2);
u4([
  O({ type: Boolean })
], Ym.prototype, "noNetwork", 2);
Ym = u4([
  U("wy-empty"),
  kt()
], Ym);
const CH = tt`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var PH = Object.defineProperty, QH = Object.getOwnPropertyDescriptor, cs = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? QH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && PH(t, e, r), r;
}, "__decorateClass$16"), c$, tf;
let un = (c$ = (tf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.typing = new IL(this), this.isPrivateChat = !1, this.members = [], this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: i } = this.typing;
    this.typingMembers = e, this.names = i, e.length ? this.typingTime ||= /* @__PURE__ */ new Date() : this.typingTime = void 0;
  }
  render() {
    const t = this.typingMembers.map(
      (a) => this.members.find((o) => o.id === a.id)
    ).filter((a) => a), e = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), i = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", r = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(this.typingTime) : "", s = v`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? v`
          <div part=${ut({ "wy-message": !0, "wy-message-agent": !!t[0]?.is_agent })}>
            <div part="wy-message-author">
              ${t.length > 1 ? v`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${e}
                    ></wy-avatar-group>
                  ` : v`
                    <wy-avatar
                      .size=${32}
                      .src=${t[0]?.avatar_url}
                      .description=${t[0]?.comment}
                      .name=${e}
                      .isAgent=${t[0]?.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div part="wy-message-content">
              <div part="wy-message-meta">
                ${this.isPrivateChat ? v`
                      <time datetime=${Ot(this.typingTime?.toISOString())} title=${i}>${r}</time>
                    ` : e}
              </div>
              <div part="wy-message-bubble"> ${s} </div>
            </div>
          </div>
        ` : C;
  }
}, c(tf, "Ta"), tf), h(c$, "WyMessageTyping"), c$);
un.styles = [re, CH, hb];
cs([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], un.prototype, "weavy", 2);
cs([
  O({ attribute: !0, type: Number })
], un.prototype, "conversationId", 2);
cs([
  O({ attribute: !0, type: Number })
], un.prototype, "userId", 2);
cs([
  O({ type: Boolean })
], un.prototype, "isPrivateChat", 2);
cs([
  O({ attribute: !1 })
], un.prototype, "members", 2);
cs([
  Z()
], un.prototype, "typingMembers", 2);
cs([
  Z()
], un.prototype, "names", 2);
cs([
  Z()
], un.prototype, "typingTime", 2);
un = cs([
  U("wy-message-typing")
], un);
const db = tt`:host(wy-item),[part~=wy-item]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;clip-path:border-box;box-sizing:border-box}[part~=wy-item-rounded]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-item-inner]{display:flex;position:relative;align-items:center;text-decoration:none;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%;min-width:0}[part~=wy-item-inner-no-padding]{padding:0}[part~=wy-item-sm]{min-height:calc(2*var(--wy-size, 1rem));padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-md]{min-height:calc(3*var(--wy-size, 1rem))}[part~=wy-item-lg]{min-height:calc(4.5*var(--wy-size, 1rem))}[part~=wy-item-top]{align-items:flex-start}[part~=wy-item-body]{width:100%;min-width:0;min-height:100%;display:flex}[part~=wy-item-rows]{display:flex;flex-direction:column;min-width:0;justify-content:space-evenly;flex:1 1 100%}[part~=wy-item-row]{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));min-height:calc(var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem))}[part~=wy-item-title] a:after{position:absolute;inset:0;z-index:1;content:\"\"}[part~=wy-item-title] a{color:inherit;text-decoration:none}[part~=wy-item-title]{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}[part~=wy-item-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-image]{display:contents}[part~=wy-item-text]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-item-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-text-sm]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-item-meta]{white-space:nowrap}[part~=wy-item-actions]{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-item-actions-top]{align-self:flex-start;margin:calc(-.25*var(--wy-size, 1rem))}[part~=wy-item-actions-bottom]{align-self:flex-start;margin:calc(-.125*var(--wy-size, 1rem)) 0 calc(-.625*var(--wy-size, 1rem))}[part~=wy-item-left]{margin-right:auto}[part~=wy-item-right]{margin-left:auto}[part~=wy-read]{opacity:var(--wy-opacity-muted, 65%);--wy-component-color: var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-unread]{--wy-component-color: color.token(--wy-on-background)}[part~=wy-unread] [part~=wy-item-title],[part~=wy-unread] [part~=wy-item-text]{font-weight:var(--wy-font-weight-bold, 600);color:var(--wy-component-color)}[part~=wy-item-interactive]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-item-interactive]:hover,[part~=wy-item-interactive]:focus{--wy-component-background-color: var(--wy-component-background-color-hover, var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039))));text-decoration:none}[part~=wy-item-interactive]:active{--wy-component-background-color: var(--wy-component-background-color-active, var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843))))}[part~=wy-item-interactive][part~=wy-disabled],[part~=wy-item-interactive]:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}[part~=wy-item-interactive][part~=wy-selected]{--wy-component-background-color: var(--wy-component-background-color-selected, var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff)));--wy-component-color: var(--wy-component-color-selected, var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}[part~=wy-item-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-item-trashed][part~=wy-item-interactive]:hover{opacity:1}[part~=wy-item-list]{display:flex;flex-direction:column;gap:var(--wy-border, 1px);min-width:0}[part~=wy-item-list-filled]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-layer-low, var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843)));--wy-component-background-color-hover: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));--wy-component-background-color-active: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)))}[part~=wy-item-list-rounded]{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:content-box}[part~=wy-item-list-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));clip-path:content-box}[part~=wy-item-list-bordered]{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));gap:0}[part~=wy-item-list-bordered]>:not(slot),[part~=wy-item-list-bordered] ::slotted(*){border-left:none;border-right:none}[part~=wy-item-list-bordered]>:not(slot):not(:first-child),[part~=wy-item-list-bordered] ::slotted(*:not(:first-child)){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`, by = tt`[part~=wy-title]{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-meta]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-meta-sm]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-quote]{color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-quote]:before,[part~=wy-quote]:after{content:'\"'}`;
var TH = Object.defineProperty, MH = Object.getOwnPropertyDescriptor, $e = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? MH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && TH(t, e, r), r;
}, "__decorateClass$15"), h$, ef;
let Ie = (h$ = (ef = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.size = "auto", this.align = "middle", this.actionsPosition = "end", this.rounded = !1, this.noPadding = !1, this.outer = !1, this.interactive = !1, this.selected = !1, this.disabled = !1, this.url = void 0, this.trashed = !1;
  }
  /**
   * If it has an url; handles ctrl click event for the item.
   * @param event MouseEvent
   */
  handleLinkClick(t) {
    if (this.disabled) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    Gw(t) && t.stopPropagation();
  }
  render() {
    const t = !!this._slotActions.length, e = !!this._slotMeta.length, i = !!this._slotText.length || this.actionsPosition === "bottom" && t;
    return v`
      <div
        part=${ut({
      "wy-item-rounded": this.rounded,
      "wy-item-rounded-outer": this.outer,
      "wy-item-inner": !0,
      "wy-item-inner-no-padding": this.noPadding,
      "wy-item-interactive": this.interactive,
      "wy-item-sm": this.size === "sm",
      "wy-item-md": this.size === "md",
      "wy-item-lg": this.size === "lg",
      "wy-item-top": this.align === "top",
      "wy-item-middle": this.align === "middle",
      "wy-item-bottom": this.align === "bottom",
      "wy-read": this.status === "read",
      "wy-unread": this.status === "unread",
      "wy-selected": this.selected,
      "wy-disabled": this.disabled
    })}
      >
        <div part="wy-item-image"><slot name="image"></slot></div>
        <div part="wy-item-body">
          <slot name="content">
            <div part="wy-item-rows">
              <div part="wy-item-row wy-item-row-first">
                <div part="wy-item-title wy-item-left">
                  ${this.url ? v`<a href=${this.url} @click=${(r) => this.handleLinkClick(r)}><slot name="title"></slot></a>` : v`<slot name="title"></slot>`}
                </div>
                <div part="wy-item-meta wy-meta wy-meta-sm" ?hidden=${!e}
                  ><slot name="meta" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
              </div>
              <div part="wy-item-row wy-item-row-second" ?hidden=${!i}>
                <div part="wy-item-text wy-item-left ${ut({ "wy-item-text-sm": this.size === "auto" })}"
                  ><slot name="text" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
                ${this.actionsPosition === "bottom" ? v`
                      <div part="wy-item-actions wy-item-actions-bottom"
                        ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
                      ></div>
                    ` : C}
              </div>
            </div>
          </slot>
        </div>
        ${this.actionsPosition !== "bottom" ? v`
              <div
                part="wy-item-actions ${ut({
      "wy-item-actions-top": this.align === "top" || this.actionsPosition === "top"
    })}"
                ?hidden=${!t}
                ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
              ></div>
            ` : C}
      </div>
    `;
  }
}, c(ef, "Fa"), ef), h(h$, "WyItem"), h$);
Ie.styles = [re, db, by];
$e([
  O()
], Ie.prototype, "size", 2);
$e([
  O()
], Ie.prototype, "align", 2);
$e([
  O()
], Ie.prototype, "actionsPosition", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "rounded", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "noPadding", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "outer", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "interactive", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "selected", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "disabled", 2);
$e([
  O({ reflect: !0 })
], Ie.prototype, "url", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], Ie.prototype, "trashed", 2);
$e([
  O()
], Ie.prototype, "status", 2);
$e([
  Tl({ slot: "actions" })
], Ie.prototype, "_slotActions", 2);
$e([
  Tl({ slot: "meta" })
], Ie.prototype, "_slotMeta", 2);
$e([
  Tl({ slot: "text" })
], Ie.prototype, "_slotText", 2);
Ie = $e([
  U("wy-item")
], Ie);
var d$, nf;
let pa = (d$ = (nf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.outer = !1, this.bordered = !1, this.rounded = !1, this.filled = !1;
  }
  render() {
    const t = {
      "wy-item-list": !0,
      "wy-item-list-bordered": this.bordered,
      "wy-item-list-rounded": this.rounded,
      "wy-item-list-outer": this.outer,
      "wy-item-list-filled": this.filled
    };
    return v`<div part=${ut(t)}><slot></slot></div>`;
  }
}, c(nf, "Da"), nf), h(d$, "WyItemList"), d$);
pa.styles = [db, ft];
$e([
  O({ type: Boolean })
], pa.prototype, "outer", 2);
$e([
  O({ type: Boolean })
], pa.prototype, "bordered", 2);
$e([
  O({ type: Boolean })
], pa.prototype, "rounded", 2);
$e([
  O({ type: Boolean })
], pa.prototype, "filled", 2);
pa = $e([
  U("wy-item-list")
], pa);
const zI = tt`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-outline-light, #72777f));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5)}[part~=wy-button][part~=wy-disabled],[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-inline:calc(-1*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-inline][part~=wy-button-sm]{padding:calc(.5*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-inline:calc(-.5*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-color: var(--wy-on-primary, var(--wy-on-primary-light, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-background-color: transparent;--wy-component-color: unset}[part~=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));text-decoration:var(--wy-link-decoration, none)}[part~=wy-button-link]:hover,[part~=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5*var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));top:var(--wy-component-offset-top, 0px);z-index:1021;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}`, LI = tt`[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) rgba(0,0,0,0)}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:#0000;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:#0000}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:75%;border:0 solid rgba(0,0,0,0);border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*0)}`;
var AH = Object.defineProperty, RH = Object.getOwnPropertyDescriptor, Ii = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? RH(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && AH(t, e, r), r;
}, "__decorateClass$14"), u$, rf;
let Gi = (u$ = (rf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return this.href ? v`
      <a href=${this.href} target=${Ot(this.target)} download=${Ot(this.download)} part=${ut(t)} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </a>
    ` : v`
      <button part=${ut(t)} type=${Ot(this.type)} ?disabled=${this.disabled} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </button>
    `;
  }
}, c(rf, "Ha"), rf), h(u$, "WyButton"), u$);
Gi.styles = [
  re,
  zI,
  LI,
  ft,
  tt`
      :host {
        position: relative;
      }
    `
];
Ii([
  O()
], Gi.prototype, "type", 2);
Ii([
  O()
], Gi.prototype, "kind", 2);
Ii([
  O({ type: Boolean })
], Gi.prototype, "active", 2);
Ii([
  O()
], Gi.prototype, "color", 2);
Ii([
  O({ type: Boolean })
], Gi.prototype, "small", 2);
Ii([
  O({ type: Boolean, reflect: !0 })
], Gi.prototype, "disabled", 2);
Ii([
  O()
], Gi.prototype, "href", 2);
Ii([
  O()
], Gi.prototype, "target", 2);
Ii([
  O()
], Gi.prototype, "download", 2);
Gi = Ii([
  U("wy-button")
], Gi);
var p$, sf;
let hl = (p$ = (sf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return v`<div part=${ut(t)}><slot></slot></div>`;
  }
}, c(sf, "Va"), sf), h(p$, "WyButtons"), p$);
hl.styles = [
  re,
  zI,
  LI,
  ft
];
Ii([
  O({ type: Boolean })
], hl.prototype, "tabs", 2);
Ii([
  O({ type: String })
], hl.prototype, "position", 2);
Ii([
  O({ type: Boolean })
], hl.prototype, "reverse", 2);
hl = Ii([
  U("wy-buttons")
], hl);
const II = "important", EH = " !" + II, Ew = zl(class extends Oy {
  constructor(n) {
    if (super(n), n.type !== d1.ATTRIBUTE || n.name !== "style" || n.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return Object.keys(n).reduce(((t, e) => {
      const i = n[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }), "");
  }
  update(n, [t]) {
    const { style: e } = n.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft) t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const r = t[i];
      if (r != null) {
        this.ft.add(i);
        const s = typeof r == "string" && r.endsWith(EH);
        i.includes("-") || s ? e.setProperty(i, s ? r.slice(0, -11) : r, s ? II : "") : e[i] = r;
      }
    }
    return lr;
  }
}), a0 = Math.min, uo = Math.max, o0 = Math.round, nv = Math.floor, ar = /* @__PURE__ */ h((n) => ({
  x: n,
  y: n
}), "createCoords"), _H = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, zH = {
  start: "end",
  end: "start"
};
function J5(n, t, e) {
  return uo(n, a0(t, e));
}
c(J5, "ef");
h(J5, "clamp");
function u1(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(u1, "bh");
h(u1, "evaluate");
function fa(n) {
  return n.split("-")[0];
}
c(fa, "$s");
h(fa, "getSide");
function p1(n) {
  return n.split("-")[1];
}
c(p1, "xh");
h(p1, "getAlignment");
function p4(n) {
  return n === "x" ? "y" : "x";
}
c(p4, "Nm");
h(p4, "getOppositeAxis");
function f4(n) {
  return n === "y" ? "height" : "width";
}
c(f4, "jm");
h(f4, "getAxisLength");
const LH = /* @__PURE__ */ new Set(["top", "bottom"]);
function Ir(n) {
  return LH.has(fa(n)) ? "y" : "x";
}
c(Ir, "kr");
h(Ir, "getSideAxis");
function m4(n) {
  return p4(Ir(n));
}
c(m4, "Wm");
h(m4, "getAlignmentAxis");
function VI(n, t, e) {
  e === void 0 && (e = !1);
  const i = p1(n), r = m4(n), s = f4(r);
  let a = r === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (a = _w(a)), [a, _w(a)];
}
c(VI, "v5");
h(VI, "getAlignmentSides");
function DI(n) {
  const t = _w(n);
  return [l0(n), t, l0(t)];
}
c(DI, "g5");
h(DI, "getExpandedPlacements");
function l0(n) {
  return n.replace(/start|end/g, (t) => zH[t]);
}
c(l0, "Au");
h(l0, "getOppositeAlignmentPlacement");
const h9 = ["left", "right"], d9 = ["right", "left"], IH = ["top", "bottom"], VH = ["bottom", "top"];
function WI(n, t, e) {
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? d9 : h9 : t ? h9 : d9;
    case "left":
    case "right":
      return t ? IH : VH;
    default:
      return [];
  }
}
c(WI, "$5");
h(WI, "getSideList");
function qI(n, t, e, i) {
  const r = p1(n);
  let s = WI(fa(n), e === "start", i);
  return r && (s = s.map((a) => a + "-" + r), t && (s = s.concat(s.map(l0)))), s;
}
c(qI, "C5");
h(qI, "getOppositeAxisPlacements");
function _w(n) {
  return n.replace(/left|right|bottom|top/g, (t) => _H[t]);
}
c(_w, "Jd");
h(_w, "getOppositePlacement");
function FI(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
c(FI, "k5");
h(FI, "expandPaddingObject");
function ZI(n) {
  return typeof n != "number" ? FI(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
c(ZI, "_5");
h(ZI, "getPaddingObject");
function zw(n) {
  const {
    x: t,
    y: e,
    width: i,
    height: r
  } = n;
  return {
    width: i,
    height: r,
    top: e,
    left: t,
    right: t + i,
    bottom: e + r,
    x: t,
    y: e
  };
}
c(zw, "th");
h(zw, "rectToClientRect");
function tS(n, t, e) {
  let {
    reference: i,
    floating: r
  } = n;
  const s = Ir(t), a = m4(t), o = f4(a), l = fa(t), d = s === "y", u = i.x + i.width / 2 - r.width / 2, p = i.y + i.height / 2 - r.height / 2, f = i[o] / 2 - r[o] / 2;
  let y;
  switch (l) {
    case "top":
      y = {
        x: u,
        y: i.y - r.height
      };
      break;
    case "bottom":
      y = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      y = {
        x: i.x + i.width,
        y: p
      };
      break;
    case "left":
      y = {
        x: i.x - r.width,
        y: p
      };
      break;
    default:
      y = {
        x: i.x,
        y: i.y
      };
  }
  switch (p1(t)) {
    case "start":
      y[a] -= f * (e && d ? -1 : 1);
      break;
    case "end":
      y[a] += f * (e && d ? -1 : 1);
      break;
  }
  return y;
}
c(tS, "nf");
h(tS, "computeCoordsFromPlacement");
const DH = /* @__PURE__ */ h(async (n, t, e) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: a
  } = e, o = s.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let d = await a.getElementRects({
    reference: n,
    floating: t,
    strategy: r
  }), {
    x: u,
    y: p
  } = tS(d, i, l), f = i, y = {}, g = 0;
  for (let b = 0; b < o.length; b++) {
    const {
      name: S,
      fn: $
    } = o[b], {
      x: Q,
      y: E,
      data: z,
      reset: A
    } = await $({
      x: u,
      y: p,
      initialPlacement: i,
      placement: f,
      strategy: r,
      middlewareData: y,
      rects: d,
      platform: a,
      elements: {
        reference: n,
        floating: t
      }
    });
    u = Q ?? u, p = E ?? p, y = {
      ...y,
      [S]: {
        ...y[S],
        ...z
      }
    }, A && g <= 50 && (g++, typeof A == "object" && (A.placement && (f = A.placement), A.rects && (d = A.rects === !0 ? await a.getElementRects({
      reference: n,
      floating: t,
      strategy: r
    }) : A.rects), {
      x: u,
      y: p
    } = tS(d, f, l)), b = -1);
  }
  return {
    x: u,
    y: p,
    placement: f,
    strategy: r,
    middlewareData: y
  };
}, "computePosition$1");
async function y4(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: r,
    platform: s,
    rects: a,
    elements: o,
    strategy: l
  } = n, {
    boundary: d = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: p = "floating",
    altBoundary: f = !1,
    padding: y = 0
  } = u1(t, n), g = ZI(y), b = o[f ? p === "floating" ? "reference" : "floating" : p], S = zw(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(b))) == null || e ? b : b.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(o.floating)),
    boundary: d,
    rootBoundary: u,
    strategy: l
  })), $ = p === "floating" ? {
    x: i,
    y: r,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, Q = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(o.floating)), E = await (s.isElement == null ? void 0 : s.isElement(Q)) ? await (s.getScale == null ? void 0 : s.getScale(Q)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, z = zw(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: $,
    offsetParent: Q,
    strategy: l
  }) : $);
  return {
    top: (S.top - z.top + g.top) / E.y,
    bottom: (z.bottom - S.bottom + g.bottom) / E.y,
    left: (S.left - z.left + g.left) / E.x,
    right: (z.right - S.right + g.right) / E.x
  };
}
c(y4, "Qm");
h(y4, "detectOverflow");
const WH = /* @__PURE__ */ h(function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e, i;
      const {
        placement: r,
        middlewareData: s,
        rects: a,
        initialPlacement: o,
        platform: l,
        elements: d
      } = t, {
        mainAxis: u = !0,
        crossAxis: p = !0,
        fallbackPlacements: f,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: b = !0,
        ...S
      } = u1(n, t);
      if ((e = s.arrow) != null && e.alignmentOffset)
        return {};
      const $ = fa(r), Q = Ir(o), E = fa(o) === o, z = await (l.isRTL == null ? void 0 : l.isRTL(d.floating)), A = f || (E || !b ? [_w(o)] : DI(o)), V = g !== "none";
      !f && V && A.push(...qI(o, b, g, z));
      const D = [o, ...A], X = await y4(t, S), Y = [];
      let mt = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (u && Y.push(X[$]), p) {
        const st = VI(r, a, z);
        Y.push(X[st[0]], X[st[1]]);
      }
      if (mt = [...mt, {
        placement: r,
        overflows: Y
      }], !Y.every((st) => st <= 0)) {
        var ct, et;
        const st = (((ct = s.flip) == null ? void 0 : ct.index) || 0) + 1, Rt = D[st];
        if (Rt && (!(p === "alignment" && Q !== Ir(Rt)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        mt.every((It) => Ir(It.placement) === Q ? It.overflows[0] > 0 : !0)))
          return {
            data: {
              index: st,
              overflows: mt
            },
            reset: {
              placement: Rt
            }
          };
        let Qt = (et = mt.filter((It) => It.overflows[0] <= 0).sort((It, Wt) => It.overflows[1] - Wt.overflows[1])[0]) == null ? void 0 : et.placement;
        if (!Qt)
          switch (y) {
            case "bestFit": {
              var bt;
              const It = (bt = mt.filter((Wt) => {
                if (V) {
                  const qt = Ir(Wt.placement);
                  return qt === Q || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  qt === "y";
                }
                return !0;
              }).map((Wt) => [Wt.placement, Wt.overflows.filter((qt) => qt > 0).reduce((qt, xi) => qt + xi, 0)]).sort((Wt, qt) => Wt[1] - qt[1])[0]) == null ? void 0 : bt[0];
              It && (Qt = It);
              break;
            }
            case "initialPlacement":
              Qt = o;
              break;
          }
        if (r !== Qt)
          return {
            reset: {
              placement: Qt
            }
          };
      }
      return {};
    }
  };
}, "flip$1"), qH = /* @__PURE__ */ new Set(["left", "top"]);
async function XI(n, t) {
  const {
    placement: e,
    platform: i,
    elements: r
  } = n, s = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), a = fa(e), o = p1(e), l = Ir(e) === "y", d = qH.has(a) ? -1 : 1, u = s && l ? -1 : 1, p = u1(t, n);
  let {
    mainAxis: f,
    crossAxis: y,
    alignmentAxis: g
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return o && typeof g == "number" && (y = o === "end" ? g * -1 : g), l ? {
    x: y * u,
    y: f * d
  } : {
    x: f * d,
    y: y * u
  };
}
c(XI, "A5");
h(XI, "convertValueToCoords");
const FH = /* @__PURE__ */ h(function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      var e, i;
      const {
        x: r,
        y: s,
        placement: a,
        middlewareData: o
      } = t, l = await XI(t, n);
      return a === ((e = o.offset) == null ? void 0 : e.placement) && (i = o.arrow) != null && i.alignmentOffset ? {} : {
        x: r + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, "offset$1"), ZH = /* @__PURE__ */ h(function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: r
      } = t, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: /* @__PURE__ */ h((S) => {
            let {
              x: $,
              y: Q
            } = S;
            return {
              x: $,
              y: Q
            };
          }, "fn")
        },
        ...l
      } = u1(n, t), d = {
        x: e,
        y: i
      }, u = await y4(t, l), p = Ir(fa(r)), f = p4(p);
      let y = d[f], g = d[p];
      if (s) {
        const S = f === "y" ? "top" : "left", $ = f === "y" ? "bottom" : "right", Q = y + u[S], E = y - u[$];
        y = J5(Q, y, E);
      }
      if (a) {
        const S = p === "y" ? "top" : "left", $ = p === "y" ? "bottom" : "right", Q = g + u[S], E = g - u[$];
        g = J5(Q, g, E);
      }
      const b = o.fn({
        ...t,
        [f]: y,
        [p]: g
      });
      return {
        ...b,
        data: {
          x: b.x - e,
          y: b.y - i,
          enabled: {
            [f]: s,
            [p]: a
          }
        }
      };
    }
  };
}, "shift$1");
function f1() {
  return typeof window < "u";
}
c(f1, "$h");
h(f1, "hasWindow");
function Il(n) {
  return g4(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
c(Il, "Uc");
h(Il, "getNodeName");
function Ti(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
c(Ti, "Ne");
h(Ti, "getWindow");
function Ln(n) {
  var t;
  return (t = (g4(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
c(Ln, "zi");
h(Ln, "getDocumentElement");
function g4(n) {
  return f1() ? n instanceof Node || n instanceof Ti(n).Node : !1;
}
c(g4, "Km");
h(g4, "isNode");
function pn(n) {
  return f1() ? n instanceof Element || n instanceof Ti(n).Element : !1;
}
c(pn, "ci");
h(pn, "isElement");
function _n(n) {
  return f1() ? n instanceof HTMLElement || n instanceof Ti(n).HTMLElement : !1;
}
c(_n, "ki");
h(_n, "isHTMLElement");
function eS(n) {
  return !f1() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Ti(n).ShadowRoot;
}
c(eS, "af");
h(eS, "isShadowRoot");
const XH = /* @__PURE__ */ new Set(["inline", "contents"]);
function $y(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: r
  } = fn(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !XH.has(r);
}
c($y, "od");
h($y, "isOverflowElement");
const NH = /* @__PURE__ */ new Set(["table", "td", "th"]);
function NI(n) {
  return NH.has(Il(n));
}
c(NI, "O5");
h(NI, "isTableElement");
const jH = [":popover-open", ":modal"];
function m1(n) {
  return jH.some((t) => {
    try {
      return n.matches(t);
    } catch {
      return !1;
    }
  });
}
c(m1, "Ch");
h(m1, "isTopLayer");
const BH = ["transform", "translate", "scale", "rotate", "perspective"], UH = ["transform", "translate", "scale", "rotate", "perspective", "filter"], HH = ["paint", "layout", "strict", "content"];
function ub(n) {
  const t = pb(), e = pn(n) ? fn(n) : n;
  return BH.some((i) => e[i] ? e[i] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || UH.some((i) => (e.willChange || "").includes(i)) || HH.some((i) => (e.contain || "").includes(i));
}
c(ub, "py");
h(ub, "isContainingBlock");
function jI(n) {
  let t = Yr(n);
  for (; _n(t) && !dl(t); ) {
    if (ub(t))
      return t;
    if (m1(t))
      return null;
    t = Yr(t);
  }
  return null;
}
c(jI, "H5");
h(jI, "getContainingBlock");
function pb() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
c(pb, "uy");
h(pb, "isWebKit");
const YH = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function dl(n) {
  return YH.has(Il(n));
}
c(dl, "Cc");
h(dl, "isLastTraversableNode");
function fn(n) {
  return Ti(n).getComputedStyle(n);
}
c(fn, "li");
h(fn, "getComputedStyle$1");
function y1(n) {
  return pn(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
c(y1, "kh");
h(y1, "getNodeScroll");
function Yr(n) {
  if (Il(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    eS(n) && n.host || // Fallback.
    Ln(n)
  );
  return eS(t) ? t.host : t;
}
c(Yr, "Er");
h(Yr, "getParentNode");
function w4(n) {
  const t = Yr(n);
  return dl(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : _n(t) && $y(t) ? t : w4(t);
}
c(w4, "Gm");
h(w4, "getNearestOverflowAncestor");
function Gm(n, t, e) {
  var i;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const r = w4(n), s = r === ((i = n.ownerDocument) == null ? void 0 : i.body), a = Ti(r);
  if (s) {
    const o = c0(a);
    return t.concat(a, a.visualViewport || [], $y(r) ? r : [], o && e ? Gm(o) : []);
  }
  return t.concat(r, Gm(r, [], e));
}
c(Gm, "fl");
h(Gm, "getOverflowAncestors");
function c0(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
c(c0, "zu");
h(c0, "getFrameElement");
function v4(n) {
  const t = fn(n);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const r = _n(n), s = r ? n.offsetWidth : e, a = r ? n.offsetHeight : i, o = o0(e) !== s || o0(i) !== a;
  return o && (e = s, i = a), {
    width: e,
    height: i,
    $: o
  };
}
c(v4, "Zm");
h(v4, "getCssDimensions");
function fb(n) {
  return pn(n) ? n : n.contextElement;
}
c(fb, "yy");
h(fb, "unwrapElement");
function po(n) {
  const t = fb(n);
  if (!_n(t))
    return ar(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: r,
    $: s
  } = v4(t);
  let a = (s ? o0(e.width) : e.width) / i, o = (s ? o0(e.height) : e.height) / r;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
c(po, "mn");
h(po, "getScale");
const GH = /* @__PURE__ */ ar(0);
function O4(n) {
  const t = Ti(n);
  return !pb() || !t.visualViewport ? GH : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
c(O4, "Ym");
h(O4, "getVisualOffsets");
function BI(n, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Ti(n) ? !1 : t;
}
c(BI, "B5");
h(BI, "shouldAddVisualOffsets");
function ma(n, t, e, i) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const r = n.getBoundingClientRect(), s = fb(n);
  let a = ar(1);
  t && (i ? pn(i) && (a = po(i)) : a = po(n));
  const o = BI(s, e, i) ? O4(s) : ar(0);
  let l = (r.left + o.x) / a.x, d = (r.top + o.y) / a.y, u = r.width / a.x, p = r.height / a.y;
  if (s) {
    const f = Ti(s), y = i && pn(i) ? Ti(i) : i;
    let g = f, b = c0(g);
    for (; b && i && y !== g; ) {
      const S = po(b), $ = b.getBoundingClientRect(), Q = fn(b), E = $.left + (b.clientLeft + parseFloat(Q.paddingLeft)) * S.x, z = $.top + (b.clientTop + parseFloat(Q.paddingTop)) * S.y;
      l *= S.x, d *= S.y, u *= S.x, p *= S.y, l += E, d += z, g = Ti(b), b = c0(g);
    }
  }
  return zw({
    width: u,
    height: p,
    x: l,
    y: d
  });
}
c(ma, "Cs");
h(ma, "getBoundingClientRect");
function g1(n, t) {
  const e = y1(n).scrollLeft;
  return t ? t.left + e : ma(Ln(n)).left + e;
}
c(g1, "_h");
h(g1, "getWindowScrollBarX");
function b4(n, t) {
  const e = n.getBoundingClientRect(), i = e.left + t.scrollLeft - g1(n, e), r = e.top + t.scrollTop;
  return {
    x: i,
    y: r
  };
}
c(b4, "Xm");
h(b4, "getHTMLOffset");
function UI(n) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: r
  } = n;
  const s = r === "fixed", a = Ln(i), o = t ? m1(t.floating) : !1;
  if (i === a || o && s)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = ar(1);
  const u = ar(0), p = _n(i);
  if ((p || !p && !s) && ((Il(i) !== "body" || $y(a)) && (l = y1(i)), _n(i))) {
    const y = ma(i);
    d = po(i), u.x = y.x + i.clientLeft, u.y = y.y + i.clientTop;
  }
  const f = a && !p && !s ? b4(a, l) : ar(0);
  return {
    width: e.width * d.x,
    height: e.height * d.y,
    x: e.x * d.x - l.scrollLeft * d.x + u.x + f.x,
    y: e.y * d.y - l.scrollTop * d.y + u.y + f.y
  };
}
c(UI, "q5");
h(UI, "convertOffsetParentRelativeRectToViewportRelativeRect");
function HI(n) {
  return Array.from(n.getClientRects());
}
c(HI, "N5");
h(HI, "getClientRects");
function YI(n) {
  const t = Ln(n), e = y1(n), i = n.ownerDocument.body, r = uo(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), s = uo(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let a = -e.scrollLeft + g1(n);
  const o = -e.scrollTop;
  return fn(i).direction === "rtl" && (a += uo(t.clientWidth, i.clientWidth) - r), {
    width: r,
    height: s,
    x: a,
    y: o
  };
}
c(YI, "j5");
h(YI, "getDocumentRect");
const u9 = 25;
function GI(n, t) {
  const e = Ti(n), i = Ln(n), r = e.visualViewport;
  let s = i.clientWidth, a = i.clientHeight, o = 0, l = 0;
  if (r) {
    s = r.width, a = r.height;
    const u = pb();
    (!u || u && t === "fixed") && (o = r.offsetLeft, l = r.offsetTop);
  }
  const d = g1(i);
  if (d <= 0) {
    const u = i.ownerDocument, p = u.body, f = getComputedStyle(p), y = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, g = Math.abs(i.clientWidth - p.clientWidth - y);
    g <= u9 && (s -= g);
  } else d <= u9 && (s += d);
  return {
    width: s,
    height: a,
    x: o,
    y: l
  };
}
c(GI, "W5");
h(GI, "getViewportRect");
const KH = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function KI(n, t) {
  const e = ma(n, !0, t === "fixed"), i = e.top + n.clientTop, r = e.left + n.clientLeft, s = _n(n) ? po(n) : ar(1), a = n.clientWidth * s.x, o = n.clientHeight * s.y, l = r * s.x, d = i * s.y;
  return {
    width: a,
    height: o,
    x: l,
    y: d
  };
}
c(KI, "K5");
h(KI, "getInnerBoundingClientRect");
function iS(n, t, e) {
  let i;
  if (t === "viewport")
    i = GI(n, e);
  else if (t === "document")
    i = YI(Ln(n));
  else if (pn(t))
    i = KI(t, e);
  else {
    const r = O4(n);
    i = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return zw(i);
}
c(iS, "cf");
h(iS, "getClientRectFromClippingAncestor");
function $4(n, t) {
  const e = Yr(n);
  return e === t || !pn(e) || dl(e) ? !1 : fn(e).position === "fixed" || $4(e, t);
}
c($4, "Jm");
h($4, "hasFixedPositionAncestor");
function JI(n, t) {
  const e = t.get(n);
  if (e)
    return e;
  let i = Gm(n, [], !1).filter((o) => pn(o) && Il(o) !== "body"), r = null;
  const s = fn(n).position === "fixed";
  let a = s ? Yr(n) : n;
  for (; pn(a) && !dl(a); ) {
    const o = fn(a), l = ub(a);
    !l && o.position === "fixed" && (r = null), (s ? !l && !r : !l && o.position === "static" && r && KH.has(r.position) || $y(a) && !l && $4(n, a)) ? i = i.filter((d) => d !== a) : r = o, a = Yr(a);
  }
  return t.set(n, i), i;
}
c(JI, "G5");
h(JI, "getClippingElementAncestors");
function tV(n) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: r
  } = n;
  const s = [...e === "clippingAncestors" ? m1(t) ? [] : JI(t, this._c) : [].concat(e), i], a = s[0], o = s.reduce((l, d) => {
    const u = iS(t, d, r);
    return l.top = uo(u.top, l.top), l.right = a0(u.right, l.right), l.bottom = a0(u.bottom, l.bottom), l.left = uo(u.left, l.left), l;
  }, iS(t, a, r));
  return {
    width: o.right - o.left,
    height: o.bottom - o.top,
    x: o.left,
    y: o.top
  };
}
c(tV, "Z5");
h(tV, "getClippingRect");
function eV(n) {
  const {
    width: t,
    height: e
  } = v4(n);
  return {
    width: t,
    height: e
  };
}
c(eV, "Y5");
h(eV, "getDimensions");
function iV(n, t, e) {
  const i = _n(t), r = Ln(t), s = e === "fixed", a = ma(n, !0, s, t);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = ar(0);
  function d() {
    l.x = g1(r);
  }
  if (c(d, "u"), h(d, "setLeftRTLScrollbarOffset"), i || !i && !s)
    if ((Il(t) !== "body" || $y(r)) && (o = y1(t)), i) {
      const y = ma(t, !0, s, t);
      l.x = y.x + t.clientLeft, l.y = y.y + t.clientTop;
    } else r && d();
  s && !i && r && d();
  const u = r && !i && !s ? b4(r, o) : ar(0), p = a.left + o.scrollLeft - l.x - u.x, f = a.top + o.scrollTop - l.y - u.y;
  return {
    x: p,
    y: f,
    width: a.width,
    height: a.height
  };
}
c(iV, "X5");
h(iV, "getRectRelativeToOffsetParent");
function Bv(n) {
  return fn(n).position === "static";
}
c(Bv, "Tp");
h(Bv, "isStaticPositioned");
function nS(n, t) {
  if (!_n(n) || fn(n).position === "fixed")
    return null;
  if (t)
    return t(n);
  let e = n.offsetParent;
  return Ln(n) === e && (e = e.ownerDocument.body), e;
}
c(nS, "lf");
h(nS, "getTrueOffsetParent");
function x4(n, t) {
  const e = Ti(n);
  if (m1(n))
    return e;
  if (!_n(n)) {
    let r = Yr(n);
    for (; r && !dl(r); ) {
      if (pn(r) && !Bv(r))
        return r;
      r = Yr(r);
    }
    return e;
  }
  let i = nS(n, t);
  for (; i && NI(i) && Bv(i); )
    i = nS(i, t);
  return i && dl(i) && Bv(i) && !ub(i) ? e : i || jI(n) || e;
}
c(x4, "tv");
h(x4, "getOffsetParent");
const JH = /* @__PURE__ */ h(async function(n) {
  const t = this.getOffsetParent || x4, e = this.getDimensions, i = await e(n.floating);
  return {
    reference: iV(n.reference, await t(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "getElementRects");
function nV(n) {
  return fn(n).direction === "rtl";
}
c(nV, "tx");
h(nV, "isRTL");
const tY = {
  convertOffsetParentRelativeRectToViewportRelativeRect: UI,
  getDocumentElement: Ln,
  getClippingRect: tV,
  getOffsetParent: x4,
  getElementRects: JH,
  getClientRects: HI,
  getDimensions: eV,
  getScale: po,
  isElement: pn,
  isRTL: nV
};
function k4(n, t) {
  return n.x === t.x && n.y === t.y && n.width === t.width && n.height === t.height;
}
c(k4, "ev");
h(k4, "rectsAreEqual");
function rV(n, t) {
  let e = null, i;
  const r = Ln(n);
  function s() {
    var o;
    clearTimeout(i), (o = e) == null || o.disconnect(), e = null;
  }
  c(s, "n"), h(s, "cleanup");
  function a(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), s();
    const d = n.getBoundingClientRect(), {
      left: u,
      top: p,
      width: f,
      height: y
    } = d;
    if (o || t(), !f || !y)
      return;
    const g = nv(p), b = nv(r.clientWidth - (u + f)), S = nv(r.clientHeight - (p + y)), $ = nv(u), Q = {
      rootMargin: -g + "px " + -b + "px " + -S + "px " + -$ + "px",
      threshold: uo(0, a0(1, l)) || 1
    };
    let E = !0;
    function z(A) {
      const V = A[0].intersectionRatio;
      if (V !== l) {
        if (!E)
          return a();
        V ? a(!1, V) : i = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      V === 1 && !k4(d, n.getBoundingClientRect()) && a(), E = !1;
    }
    c(z, "R"), h(z, "handleObserve");
    try {
      e = new IntersectionObserver(z, {
        ...Q,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(z, Q);
    }
    e.observe(n);
  }
  return c(a, "o"), h(a, "refresh"), a(!0), s;
}
c(rV, "ix");
h(rV, "observeMove");
function S4(n, t, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: s = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, d = fb(n), u = r || s ? [...d ? Gm(d) : [], ...Gm(t)] : [];
  u.forEach(($) => {
    r && $.addEventListener("scroll", e, {
      passive: !0
    }), s && $.addEventListener("resize", e);
  });
  const p = d && o ? rV(d, e) : null;
  let f = -1, y = null;
  a && (y = new ResizeObserver(($) => {
    let [Q] = $;
    Q && Q.target === d && y && (y.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var E;
      (E = y) == null || E.observe(t);
    })), e();
  }), d && !l && y.observe(d), y.observe(t));
  let g, b = l ? ma(n) : null;
  l && S();
  function S() {
    const $ = ma(n);
    b && !k4(b, $) && e(), b = $, g = requestAnimationFrame(S);
  }
  return c(S, "I"), h(S, "frameLoop"), e(), () => {
    var $;
    u.forEach((Q) => {
      r && Q.removeEventListener("scroll", e), s && Q.removeEventListener("resize", e);
    }), p?.(), ($ = y) == null || $.disconnect(), y = null, l && cancelAnimationFrame(g);
  };
}
c(S4, "iv");
h(S4, "autoUpdate");
const sV = FH, aV = ZH, oV = WH, lV = /* @__PURE__ */ h((n, t, e) => {
  const i = /* @__PURE__ */ new Map(), r = {
    platform: tY,
    ...e
  }, s = {
    ...r.platform,
    _c: i
  };
  return DH(n, t, {
    ...r,
    platform: s
  });
}, "computePosition"), mb = tt`[part~=wy-dropdown-menu]{width:max-content;position:absolute;z-index:1000;min-width:calc(10*var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}[part~=wy-dropdown-menu]:not([popover]){display:block}[part~=wy-dropdown-item]{background-color:#0000;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-on-surface-light, #181c20)));width:100%;min-height:calc(2.5*var(--wy-size, 1rem));padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}[part~=wy-dropdown-item]:hover,[part~=wy-dropdown-item]:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-active],[part~=wy-dropdown-item]:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-disabled],[part~=wy-dropdown-item]:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-dropdown-item]>img,[part~=wy-dropdown-item]>wy-icon{margin-right:calc(.5*var(--wy-size, 1rem));color:inherit}[part~=wy-dropdown-item]:active>wy-icon{color:inherit}[part~=wy-dropdown-item][part~=wy-dropdown-option] wy-icon{visibility:hidden}[part~=wy-dropdown-item][part~=wy-dropdown-option][part~=wy-selected] wy-icon{visibility:visible}[part~=wy-dropdown-divider]{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`;
var eY = Object.defineProperty, iY = Object.getOwnPropertyDescriptor, ui = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? iY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && eY(t, e, r), r;
}, "__decorateClass$13"), f$, af;
let Ki = (f$ = (af = class extends pt {
  constructor() {
    super(), this.exportParts = new G(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = wt(), this.menuRef = wt(), this._documentClickHandler = (t) => {
      this.showMenu && (t.preventDefault(), this.menuRef.value?.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = S4(this.buttonRef.value, this.menuRef.value, () => {
      if (this.buttonRef.value && this.menuRef.value) {
        const e = !this.menuRef.value.popover, i = e || !D9(this.buttonRef.value);
        lV(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: e ? "fixed" : "absolute",
          middleware: [
            oV(),
            sV(({ placement: r }) => r.includes("top") ? 9 : 13),
            aV({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: i })
          ]
        }).then(({ x: r, y: s }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${r}px`,
            marginTop: `${s}px`,
            top: 0,
            left: 0,
            position: e ? "fixed" : void 0,
            zIndex: e ? 1075 : void 0
          });
        });
      }
    }) : !this.showMenu && this.computePositionCleanup && (this.computePositionCleanup?.(), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof he;
    return v`
      <span part="wy-dropdown">
        <span
          ${at(this.buttonRef)}
          part="wy-dropdown-button-container"
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${ze}
          @keyup=${di}
        >
          <wy-button
            part="wy-dropdown-button"
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button-content" @slotchange=${() => this.requestUpdate()}>
              <wy-icon part="wy-dropdown-button-icon" name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${at(this.menuRef)}
          part="wy-dropdown-menu"
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${cb}
          ?hidden=${Kv() && !this.showMenu}
          popover=${Ot(Kv() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this.computePositionCleanup?.(), super.disconnectedCallback();
  }
}, c(af, "Ua"), af), h(f$, "WyDropdown"), f$);
Ki.styles = [re, mb];
ui([
  O()
], Ki.prototype, "directionX", 2);
ui([
  O()
], Ki.prototype, "directionY", 2);
ui([
  O()
], Ki.prototype, "icon", 2);
ui([
  O({ type: Boolean })
], Ki.prototype, "small", 2);
ui([
  O({ type: Boolean })
], Ki.prototype, "disabled", 2);
ui([
  Z()
], Ki.prototype, "_placement", 2);
ui([
  Z()
], Ki.prototype, "showMenu", 2);
ui([
  Tl({ slot: "button-content" })
], Ki.prototype, "_slotButton", 2);
ui([
  Z()
], Ki.prototype, "computePositionCleanup", 2);
Ki = ui([
  U("wy-dropdown")
], Ki);
var m$, of;
let Lw = (m$ = (of = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.active = !1;
  }
  render() {
    return v`<div part="wy-dropdown-item ${ut({ "wy-active": this.active })}" tabindex="0"><slot></slot></div>`;
  }
}, c(of, "Ba"), of), h(m$, "WyDropdownItem"), m$);
Lw.styles = [re, mb, ft];
ui([
  O({ type: Boolean })
], Lw.prototype, "active", 2);
Lw = ui([
  U("wy-dropdown-item")
], Lw);
var y$, lf;
let Km = (y$ = (lf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return v`
      <div
        part="wy-dropdown-item wy-dropdown-option ${ut({
      "wy-active": this.active,
      "wy-selected": this.selected
    })}"
        tabindex="0"
      >
        <slot name="icon" style=${Ew(t)}
          ><wy-icon part="wy-dropdown-option-icon" name="check"></wy-icon
        ></slot>
        <slot></slot>
      </div>
    `;
  }
}, c(lf, "qa"), lf), h(y$, "WyDropdownOption"), y$);
Km.styles = [re, mb, ft];
ui([
  O({ type: Boolean })
], Km.prototype, "active", 2);
ui([
  O({ type: Boolean })
], Km.prototype, "selected", 2);
Km = ui([
  U("wy-dropdown-option")
], Km);
var g$, cf;
let h0 = (g$ = (cf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  render() {
    return v`<hr part="wy-dropdown-divider" />`;
  }
}, c(cf, "Na"), cf), h(g$, "WyDropdownDivider"), g$);
h0.styles = [re, mb, ft];
h0 = ui([
  U("wy-dropdown-divider")
], h0);
const cV = tt`[part~=wy-placeholder]{cursor:wait;color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));background:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite;line-height:1.45}@keyframes wy-placeholder-glow{50%{opacity:.2}}`;
var nY = Object.defineProperty, rY = Object.getOwnPropertyDescriptor, hV = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? rY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && nY(t, e, r), r;
}, "__decorateClass$12"), w$, hf;
let Iw = (w$ = (hf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    return v`
      <div part="wy-skeleton">
        ${t.length ? t.split(/(\n+)/).map((e) => {
      const i = e.split(/(\s+)/);
      return v`
                <div part="wy-placeholder-line">
                  ${i.map((r) => v` <span part="wy-placeholder">${r}</span> `)}
                </div>
              `;
    }) : C}
      </div>
    `;
  }
}, c(hf, "ja"), hf), h(w$, "WySkeleton"), w$);
Iw.styles = [cV, ft];
hV([
  O()
], Iw.prototype, "text", 2);
Iw = hV([
  U("wy-skeleton")
], Iw);
function C4(n) {
  const t = [n];
  for (; n && n.parent; )
    n = n.parent, t.push(n);
  return t;
}
c(C4, "lv");
h(C4, "getEntityChain");
function P4(n, t, e) {
  return n.type === t && (!e || n.id === e.id);
}
c(P4, "dv");
h(P4, "isEntityMatch");
function w1(n, t, e) {
  return C4(n).some((i) => i && P4(i, t, e));
}
c(w1, "Mh");
h(w1, "isEntityChainMatch");
function Q4(n, t, e) {
  return C4(n).find((i) => i && P4(i, t, e));
}
c(Q4, "hv");
h(Q4, "getEntityChainMatch");
function T4(n, t, e, i) {
  const r = Q4(n, i);
  return r && r.parent ? w1(r.parent, t, e) : !1;
}
c(T4, "pv");
h(T4, "hasEntityChildType");
async function M4(n, t, e) {
  let i;
  if (t && e?.link?.app?.id) {
    const s = await t.fetch(`/api/apps/${e.link.app.id}`);
    s.ok && (i = (await s.json()).metadata);
  }
  const r = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: e.link ? {
        ...e?.link,
        // HACK: pass along the agent uid so uikit can match the correct agent chat     
        agent: e.actor.is_agent && e.link?.app?.type && JO.has(e.link.app.type) ? e.actor.uid : void 0
      } : void 0,
      metadata: e.metadata,
      app_type: e?.link?.app?.type && dB.get(e.link.app.type) || Ls,
      source_name: i?.source_name,
      source_url: i?.source_url,
      source_data: i?.source_data
    }
  });
  return n.dispatchEvent(r);
}
c(M4, "uv");
h(M4, "dispatchLinkEvent");
function A4(n) {
  const t = n.args;
  switch (n.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} added ${i} to ${r}`),
        titleHtml: P(v`<strong>${e}</strong> added <em>${i}</em> to <strong>${r}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, i] = t;
      return {
        title: P(rt`${e} edited ${i}`),
        titleHtml: P(v`<strong>${e}</strong> edited <em>${i}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <em>${i}</em>`),
        detail: r
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} replied to your post`),
        titleHtml: P(v`<strong>${e}</strong> replied to your post`),
        detail: i
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} replied to a post`),
        titleHtml: P(v`<strong>${e}</strong> replied to a post`),
        detail: i
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} mentioned you in a comment`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a comment`),
        detail: i
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} posted in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> posted in <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} mentioned you in a post`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a post`),
        detail: i
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`New message from ${e}`),
        titleHtml: P(v`New message from <strong>${e}</strong>`),
        detail: i
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} sent a message in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> sent a message in <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} mentioned you in a message`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a message`),
        detail: i
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} edited a post`),
        titleHtml: P(v`<strong>${e}</strong> edited a post`),
        detail: i
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, i] = t;
      return {
        title: P(rt`${e} liked ${i}`),
        titleHtml: P(v`<strong>${e}</strong> liked <em>${i}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} reacted ${i} to ${r}`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to <em>${r}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} liked your comment`),
        titleHtml: P(v`<strong>${e}</strong> liked your comment`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} reacted ${i} to your comment`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your comment`),
        detail: r
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} liked your message`),
        titleHtml: P(v`<strong>${e}</strong> liked your message`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} reacted ${i} to your message`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your message`),
        detail: r
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(rt`${e} liked your post`),
        titleHtml: P(v`<strong>${e}</strong> liked your post`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(rt`${e} reacted ${i} to your post`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your post`),
        detail: r
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: P(rt`${e} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, i] = t;
      return {
        title: P(rt`${e} and ${i} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and <strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, i, r] = t;
      return {
        title: P(rt`${e}, ${i} and ${r} voted on your poll`),
        titleHtml: P(
          v`<strong>${e}</strong>, <strong>${i}</strong> and <strong>${r}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, i] = t;
      return {
        title: P(rt`${e} and ${i} others voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and ${i} others voted on your poll`)
      };
    }
    default:
      return {
        title: n.plain,
        titleHtml: v`${ll(n.html)}`
      };
  }
}
c(A4, "yv");
h(A4, "getNotificationText");
const R4 = tt`[part~=wy-code] pre,.wy-code pre,[part~=wy-content] pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] .code,[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-content] .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-content] .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-content] .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-content] .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-content] .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-content] .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-content] .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-content] .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-content] .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-content] .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-content] .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-content] .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-content] .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-content] .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-content] .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-content] .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-content] .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-content] .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-content] .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-content] .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-content] .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-content] .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-content] .token.important,[part~=wy-content] .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-content] .token.italic{font-style:italic}[part~=wy-content]{overflow-wrap:break-word;min-width:0}[part~=wy-content]:empty{display:none}[part~=wy-content]>:first-child{margin-top:0}[part~=wy-content]>:last-child{margin-bottom:0}[part~=wy-content] b,[part~=wy-content] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] blockquote{border-left:calc(2*var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) 0;padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-content] blockquote>p{margin:0}[part~=wy-content] hr{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content] pre,[part~=wy-content] code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-content] :not(pre)>code{overflow-wrap:inherit}[part~=wy-content] pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}[part~=wy-content] h1,[part~=wy-content] h2,[part~=wy-content] h3,[part~=wy-content] h4,[part~=wy-content] h5,[part~=wy-content] h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5))}[part~=wy-content] h1{font-size:var(--wy-h1-font-size, var(--wy-font-size-xxl, 1.5em));font-weight:var(--wy-h1-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content] h2{font-size:var(--wy-h2-font-size, var(--wy-font-size-xl, 1.25em));font-weight:var(--wy-h2-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h3{font-size:var(--wy-h3-font-size, var(--wy-font-size-lg, 1.125em));font-weight:var(--wy-h3-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h4{font-size:var(--wy-h4-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h4-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content] h5{font-size:var(--wy-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h5-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h5-margin, 0)}[part~=wy-content] h6{font-size:var(--wy-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h6-font-weight, inherit);margin:var(--wy-h6-margin, 0)}[part~=wy-content] table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}[part~=wy-content] table th,[part~=wy-content] table td{padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}[part~=wy-content] table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-content] table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}[part~=wy-content] table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}[part~=wy-content] table td:last-child{border-right-width:var(--wy-border, 1px)}[part~=wy-content] table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table>tbody{vertical-align:inherit}[part~=wy-content] table>thead{vertical-align:bottom}[part~=wy-content] img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol{list-style-type:decimal}[part~=wy-content] ul{list-style-type:disc}[part~=wy-content] li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0}[part~=wy-content] ol,[part~=wy-content] ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}[part~=wy-content] ol>li,[part~=wy-content] ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol>li>:first-child,[part~=wy-content] ul>li>:first-child{margin-bottom:0;margin-top:0}[part~=wy-content] ol>li>:last-child,[part~=wy-content] ul>li>:last-child{margin-bottom:0}[part~=wy-content] .wy-hashtag{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-content] .wy-mention{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] .wy-mention:before{content:\"@\"}[part~=wy-content-emoji] .wy-emoji{font-size:3em}`;
function yb(n) {
  const t = n;
  t && (t.complete && t.naturalHeight !== 0 ? !t.classList.contains("wy-loading") && !t.part.contains("wy-loading") ? (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
c(yb, "fy");
h(yb, "checkImageLoad");
function gb(n) {
  const t = n.target;
  t.tagName === "IMG" && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && !t.classList.contains("wy-loaded") && !t.part.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
c(gb, "my");
h(gb, "imageLoaded");
const sY = tt`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box;max-height:var(--wy-image-max-size, calc(32 * var(--wy-size, 1rem)))}[part~=wy-image-filled]{position:relative;background-size:100%,100% 100%;background-position:center;background-clip:content-box;clip-path:content-box;align-items:center;justify-content:center}[part~=wy-image-filled]:after{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));overflow:hidden;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-image-grid-outer]{border-radius:0}[part~=wy-image-area]{display:flex;height:100%;cursor:pointer;align-items:center}[part~=wy-image-content]{position:absolute;height:auto;max-height:100%;width:100%;object-fit:contain;z-index:2}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-icon]{object-fit:scale-down;object-position:center center}[part~=wy-image-grid-more]{position:absolute;z-index:3;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5*var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var aY = Object.defineProperty, oY = Object.getOwnPropertyDescriptor, wb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? oY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && aY(t, e, r), r;
}, "__decorateClass$11");
const p9 = 128;
var v$, df;
let ul = (v$ = (df = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.images = [], this.limit = 3, this.outer = !1;
  }
  /**
   * Dispatch a `file-open` event.
   *
   * @internal
   * @param e - Event that will be prevented.
   * @param file - The file to open.
   */
  dispatchFileOpen(t, e) {
    if (Gw(t)) {
      t.stopPropagation();
      return;
    }
    if (t.preventDefault(), !e.is_trashed) {
      const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(i);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return v`
      <div
        part=${ut({
      "wy-image-grid": !0,
      "wy-image-grid-outer": this.outer
    })}
      >
        ${e.map((i, r) => {
      const s = !i.width || i.width <= p9 || !i.height || i.height <= p9, a = i.width && i.height ? i.width / i.height : 1, o = 64, l = a.toPrecision(5), d = (a * o).toPrecision(5) + "px", u = s ? o + "px" : (100 / a).toPrecision(5) + "%", p = i.width + "px", f = this.images.length !== 2 && r === 0, y = en(i.name), g = y === ".gif" || y === ".svg" ? i.download_url : i.preview_url;
      return g ? v`
                <a
                  href="${i.download_url ?? "#"}"
                  @click=${(b) => {
        !b.defaultPrevented && this.dispatchFileOpen(b, i);
      }}
                  part=${ut({
        "wy-image": !0,
        "wy-image-filled": !0,
        "wy-image-full-width": f
      })}
                  style=${Ew({
        flexBasis: d,
        flexGrow: l,
        flexShrink: l,
        width: p,
        backgroundImage: `linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${g}), linear-gradient(var(--wy-shade-opaque, white));`
      })}
                >
                  <div part="wy-image-area" style=${Ew({ paddingBottom: u })}>
                    <img
                      part=${ut({ "wy-image-content": !0, "wy-image-icon": s })}
                      src=${g}
                      ${at(yb)}
                      @load=${gb}
                      alt=""
                      loading="lazy"
                      decoding="async"
                    />
                    ${r === e.length - 1 && t ? v`<span part="wy-image-grid-more">+${t}</span>` : ""}
                  </div>
                </a>
              ` : C;
    })}
      </div>
    `;
  }
}, c(df, "Wa"), df), h(v$, "WyImageGrid"), v$);
ul.styles = [sY, ft];
wb([
  O({ attribute: !1 })
], ul.prototype, "images", 2);
wb([
  O({ type: Number })
], ul.prototype, "limit", 2);
wb([
  O({ type: Boolean, reflect: !0 })
], ul.prototype, "outer", 2);
ul = wb([
  U("wy-image-grid")
], ul);
var lY = Object.defineProperty, cY = Object.getOwnPropertyDescriptor, v1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? cY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && lY(t, e, r), r;
}, "__decorateClass$10"), O$, uf;
let Vw = (O$ = (uf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Triggers file-open event.
   *
   * @param e
   * @param file
   * @returns
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? G0(this.file.size) : null, e = en(this.file.name), { icon: i } = ls(this.file.name), r = J0(this.file.name), s = wy(this.file.provider);
    return v`    
      <wy-item
        @click=${(a) => {
      !a.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(a, this.file);
    }}
        size="md"
        title=${this.file.name}
        url=${Ot(this.file.download_url ?? this.file.external_url)}
        interactive
      >
        <wy-icon slot="image" name=${i} .overlayName=${s} size="48" kind=${r} ext=${e}></wy-icon>
        <span slot="title">${this.file.name}</span>
        ${t ? v`<span slot="text" title="${t}">${t}</span>` : C}
      </wy-item>
    `;
  }
}, c(uf, "Qa"), uf), h(O$, "WyAttachment"), O$);
Vw.styles = [db, ft];
v1([
  O({ attribute: !1 })
], Vw.prototype, "file", 2);
Vw = v1([
  U("wy-attachment")
], Vw);
var b$, pf;
let Jm = (b$ = (pf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.files = [], this.filled = !1;
  }
  dispatchFileOpen(t) {
    const e = new CustomEvent("file-open", { detail: { fileId: t.id } });
    return this.dispatchEvent(e);
  }
  render() {
    return v`
      <wy-item-list rounded ?filled=${this.filled}>
        ${this.files.map((t) => v`<wy-attachment @file-open=${() => this.dispatchFileOpen(t)} .file=${t}></wy-attachment>`)}
      </wy-item-list>
    `;
  }
}, c(pf, "Ka"), pf), h(b$, "WyAttachmentList"), b$);
Jm.styles = [db, ft];
v1([
  O({ attribute: !1 })
], Jm.prototype, "files", 2);
v1([
  O({ type: Boolean })
], Jm.prototype, "filled", 2);
Jm = v1([
  U("wy-attachment-list")
], Jm);
var hY = Object.defineProperty, dY = Object.getOwnPropertyDescriptor, vb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? dY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && hY(t, e, r), r;
}, "__decorateClass$$"), $$, ff;
let Dw = ($$ = (ff = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Triggers file-open event.
   * @internal
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? G0(this.file.size) : null, e = en(this.file.name), { icon: i } = ls(this.file.name), r = J0(this.file.name), s = wy(this.file.provider), a = `${this.file.name}${t ? ` • ${t}` : ""}`;
    return v`
      <wy-button
        part="wy-annotation"
        @click=${(o) => {
      !o.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(o, this.file);
    }}
        kind="filled"
        small
        title=${a}
      >
        <wy-icon
          part="wy-annotation-icon"
          name=${i}
          .overlayName=${s}
          size="24"
          kind=${r}
          ext=${e}
        ></wy-icon>
        <span part="wy-annotation-text">${this.file.name}</span>
      </wy-button>
    `;
  }
}, c(ff, "Ga"), ff), h($$, "WyAnnotation"), $$);
Dw.styles = [ft];
vb([
  O({ type: Object, attribute: !1 })
], Dw.prototype, "file", 2);
Dw = vb([
  U("wy-annotation")
], Dw);
var x$, mf;
let Ww = (x$ = (mf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.files = [];
  }
  render() {
    return this.settings?.annotations === "none" ? C : v`
      <div part="wy-annotations">
        ${this.files.map((t) => v`<wy-annotation .file=${t}></wy-annotation>`)}
      </div>
    `;
  }
}, c(mf, "Za"), mf), h(x$, "WyAnnotationList"), x$);
Ww.styles = [ft];
vb([
  O({ attribute: !1 })
], Ww.prototype, "files", 2);
Ww = vb([
  U("wy-annotation-list")
], Ww);
function or(n = "", t = "", e = "", i = !1) {
  if (we(), n) {
    const r = document.createElement("a");
    i && (/^(data:|blob:)/.test(n) ? r.download = e || "download" : n = n.includes("?d=1") || n.includes("&d=1") ? n : n.includes("?") ? n + "&d=1" : n + "?d=1"), t && (r.target = t), r.href = n, document.body.appendChild(r);
    try {
      r.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(n))
        console.error(`Could not ${i ? "download" : "open"} ${e}`);
      else
        try {
          window.open(n, t);
        } catch {
          console.error(`Could not ${i ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(r);
  }
}
c(or, "ji");
h(or, "openUrl");
function rS(n, t) {
  return new URL(
    n,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
c(rS, "hf");
h(rS, "environmentUrl");
const dV = tt`[part~=wy-embed]{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color)}[part~=wy-embed-interactive]{background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-embed-interactive]:active,[part~=wy-embed-interactive]:hover,[part~=wy-embed-interactive]:focus{background-color:var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)))}[part~=wy-embed-interactive][part~=wy-disabled],[part~=wy-embed-interactive]:disabled{pointer-events:none;border-left:none;border-right:none;border-bottom:none;border-radius:0;background-color:#0000}[part~=wy-embed-area]{display:flex;justify-content:center;align-items:center}[part~=wy-embed-icon]{width:calc(3*var(--wy-size, 1rem));height:calc(3*var(--wy-size, 1rem));flex:0 0 auto;object-fit:contain}[part~=wy-embed-content]{display:flex;position:relative;padding:0;overflow:hidden;width:100%;flex-direction:column;align-items:center;justify-content:flex-start}[part~=wy-embed-content] iframe,[part~=wy-embed-content] embed,[part~=wy-embed-content] object,[part~=wy-embed-content] video{border:0;width:auto;height:auto;max-height:var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem))))}[part~=wy-embed-photo]{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;background-size:cover;background-position:center;clip-path:border-box}[part~=wy-embed-photo]:after{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));content:\"\";position:absolute;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-embed-photo-with-description]{--wy-component-border-bottom-radius: 0}[part~=wy-embed-image]{width:auto;height:auto;object-fit:contain;flex:0 1 auto;min-width:0;min-height:calc(3*var(--wy-size, 1rem));max-height:calc(var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem)))) - var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))*2 - var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem));z-index:2}[part~=wy-embed-provider]{color:var(--wy-outline, var(--wy-outline-light, #72777f));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-bottom:calc(.25*var(--wy-size, 1rem))}[part~=wy-embed-provider]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-embed-actions]{display:flex;justify-content:space-between}[part~=wy-embed-select]{display:flex;flex-direction:column;min-height:0;--wy-component-max-size: calc(12 * var(--wy-size, 1rem));--wy-component-background-color: transparent}[part~=wy-embed-select] wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));--wy-component-border-top-radius: 0;min-height:0;display:none}[part~=wy-embed-select] wy-embed:first-of-type{display:block}`;
var uY = Object.defineProperty, pY = Object.getOwnPropertyDescriptor, O1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? pY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && uY(t, e, r), r;
}, "__decorateClass$_"), k$, yf;
let ty = (k$ = (yf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.disabled = !1, this.embedContentRef = wt();
  }
  /**
   * Dispatch a wy-action event for this embed.
   *
   * @internal
   * @param {ActionType | string} [action=""] - Action to dispatch.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchActionEvent(t = ci.Default) {
    const e = new CustomEvent("wy-action", {
      detail: {
        action: t,
        embed: this.embed
      },
      bubbles: !0,
      composed: !0,
      cancelable: !0
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.embed.actions ? [...this.embed.actions] : [], e = t.shift(), i = t.length === 1 ? t.shift() : void 0, r = !!((this.embed.type === "photo" || this.embed.type === "link") && (this.embed.title || this.embed.description || this.embed.type === "photo" && this.embed.provider_name));
    return v`
      <slot name="before"></slot>
      <div
        part="wy-embed ${ut({
      "wy-embed-interactive": !!this.embed.url,
      "wy-disabled": this.disabled
    })}"
        title=${this.embed.url ? this.embed.url : this.embed.title || ""}
        @click=${() => this.embed.url && this.dispatchActionEvent(ci.Default) && or(this.embed.url, "_blank")}
        @keydown=${ze}
        @keyup=${di}
      >
        ${(this.embed.type === "video" || this.embed.type === "rich") && this.embed.html ? v`
              <div part="wy-embed-area">
                <div
                  ${at(this.embedContentRef)}
                  part=${ut({
      "wy-embed-content": !0,
      "wy-embed-video": this.embed.type === "video",
      "wy-embed-rich": this.embed.type === "rich"
    })}
                  data-width=${Ot(this.embed.width)}
                  data-height=${Ot(this.embed.height)}
                >
                  ${ll(this.embed.html)}
                </div>
              </div>
            ` : C}
        ${this.embed.type === "photo" && this.embed.image && this.embed.thumbnail_url ? v`
              <div
                part="wy-embed-photo wy-embed-area ${ut({
      "wy-embed-photo-with-description": r
    })}"
                style="background-image: linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${this.embed.thumbnail_url}), linear-gradient(var(--wy-shade-opaque, white));"
              >
                <img
                  part="wy-embed-image"
                  src=${this.embed.thumbnail_url}
                  alt=${this.embed.provider_name || this.embed.title || ""}
                  width=${Ot(this.embed.image.width)}
                  height=${Ot(this.embed.image.height)}
                />
              </div>
            ` : C}
        ${r ? v`
              <wy-item size="auto">
                ${this.embed.type === "link" && this.embed.image && this.embed.thumbnail_url ? v`
                      <img
                        part="wy-embed-icon"
                        slot="image"
                        src=${this.embed.thumbnail_url}
                        alt=${this.embed.provider_name || this.embed.title || ""}
                        width=${Ot(this.embed.image.width)}
                        height=${Ot(this.embed.image.height)}
                      />
                    ` : C}
                ${this.embed.provider_name ? v`<span slot="meta" part="wy-embed-provider">${this.embed.provider_name}</span>` : C}
                ${this.embed.title ? v`<span slot="title">${this.embed.title}</span>` : C}
                ${this.embed.description ? v`<span slot="text">${this.embed.description}</span>` : C}
                ${i ? v`
                      <wy-button
                        slot="actions"
                        color="variant"
                        @click=${(s) => {
      s.stopPropagation(), this.dispatchActionEvent(i);
    }}
                      >
                        ${i}
                      </wy-button>
                    ` : C}
                ${e ? v`
                      <wy-button
                        slot="actions"
                        color="primary"
                        @click=${(s) => {
      s.stopPropagation(), this.dispatchActionEvent(e);
    }}
                      >
                        ${e}
                      </wy-button>
                    ` : C}
                ${t.length ? v`
                      <wy-dropdown slot="actions">
                        ${t.map(
      (s) => v`
                              <wy-dropdown-item
                                @click=${(a) => {
        a.preventDefault(), a.stopPropagation(), this.dispatchActionEvent(s);
      }}
                              >
                                ${s}
                              </wy-dropdown-item>
                            `
    )}
                      </wy-dropdown>
                    ` : C}
              </wy-item>
            ` : C}
      </div>
    `;
  }
  updated(t) {
    if (this.embedContentRef.value) {
      const e = this.embedContentRef.value.firstElementChild, { width: i, height: r } = this.embedContentRef.value.dataset, s = Number(r ?? ""), a = s > 128 && s < 256 ? s : 128;
      i && r && (e.style.aspectRatio = `${i} / ${r}`, e.style.minHeight = `${a}px`);
    }
  }
}, c(yf, "Ya"), yf), h(k$, "WyEmbed"), k$);
ty.styles = [ft, dV];
O1([
  O({ attribute: !1 })
], ty.prototype, "embed", 2);
O1([
  O({ type: Boolean, reflect: !0 })
], ty.prototype, "disabled", 2);
ty = O1([
  U("wy-embed")
], ty);
var S$, gf;
let qw = (S$ = (gf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Dispatch a local embed-remove event for the embed with the given id.
  *
   * @internal
   * @param id - Embed id to remove.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", {
      detail: { id: t },
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a local embed-swap event to request rotating/swapping embeds.
  *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", {
      detail: {},
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div part="wy-embed-select">
        ${Mi(
      this.embeds,
      (t) => t.id,
      (t) => v`
            <wy-embed disabled .embed=${t}>
              <div part="wy-embed-actions" slot="before">
                ${this.embeds.length > 1 ? v`
                      <wy-button kind="icon" @click=${() => this.dispatchSwap()}>
                        <wy-icon name="swap-horizontal"></wy-icon>
                      </wy-button>
                    ` : v`<span></span>`}

                <wy-button kind="icon" @click=${() => this.dispatchRemove(t.id)}
                  ><wy-icon name="close-circle"></wy-icon
                ></wy-button>
              </div>
            </wy-embed>
          `
    )}
      </div>
    `;
  }
}, c(gf, "Xa"), gf), h(S$, "WyEmbedSelect"), S$);
qw.styles = [ft, dV];
O1([
  O({ attribute: !1 })
], qw.prototype, "embeds", 2);
qw = O1([
  U("wy-embed-select")
], qw);
function d0(n) {
  switch (n) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
c(d0, "Ru");
h(d0, "getMeetingIconName");
function u0(n) {
  switch (n) {
    case "zoom":
      return P("Zoom meeting");
    case "microsoft":
      return P("Teams meeting");
    case "google":
      return P("Google Meet");
  }
}
c(u0, "Eu");
h(u0, "getMeetingTitle");
var fY = Object.defineProperty, mY = Object.getOwnPropertyDescriptor, uV = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? mY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && fY(t, e, r), r;
}, "__decorateClass$Z"), C$, wf;
let Fw = (C$ = (wf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return v`
      <wy-item-list rounded filled>
        ${t ? v`
              <wy-item part="wy-meeting" size="lg" disabled title="${P("Meeting ended")}">
                <wy-icon slot="image" svg="${d0(this.meeting.provider)}" size="48"></wy-icon>
                <span slot="title">${u0(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            ` : v`
              <wy-item
                interactive
                size="lg"
                part="wy-meeting"
                @click=${(e) => {
      e.preventDefault(), or(this.meeting.join_url, "_blank");
    }}
                url=${Ot(this.meeting.join_url)}
                title="${P("Join meeting")}"
              >
                <wy-icon
                  slot="image"
                  svg="${d0(this.meeting.provider)}"
                  size="48"
                  color="native"
                ></wy-icon>
                <span slot="title">${u0(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            `}
        </wy-item-list>
    `;
  }
}, c(wf, "Ja"), wf), h(C$, "WyMeetingCard"), C$);
Fw.styles = [ft];
uV([
  O({ attribute: !1 })
], Fw.prototype, "meeting", 2);
Fw = uV([
  U("wy-meeting-card"),
  kt()
], Fw);
const E4 = tt`[part~=wy-poll]{min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));box-sizing:border-box;width:100%}[part~=wy-poll-form]{display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-poll-form]:empty{display:none}[part~=wy-poll-option]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;align-items:center;clip-path:border-box;overflow:hidden;position:relative;background-color:var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));border:var(--wy-border-outline, 0) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));cursor:pointer;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-poll-option]>:not([part~=wy-poll-meter]){z-index:1}[part=wy-poll-image]{display:flex;height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;line-height:1;align-items:center;justify-content:center}[part~=wy-poll-title]{width:100%;min-width:0;min-height:100%;color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));align-content:center}[part~=wy-poll-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-poll-amount]{min-width:3em;text-align:end}[part~=wy-poll-meter]{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843)))}`, yY = tt`[part~=wy-dialog]{background:none;border:none;padding:0;margin:0;width:100%;height:100%;max-width:100%;max-height:100%;container-type:inline-size;pointer-events:none}[part~=wy-dialog][popover]{position:fixed;inset:0;z-index:1055}[part~=wy-dialog-modal]{align-items:center;justify-content:center;overflow:visible}[part~=wy-dialog-modal][open]{display:flex}[part~=wy-dialog-modal]:popover-open{display:flex}[part~=wy-dialog-modal]:focus-visible{outline:none}[part~=wy-overlay]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;overflow:hidden;container-type:inline-size}[part~=wy-overlay]{interpolate-size:allow-keywords;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}[part~=wy-overlay]:not([part~=wy-open]){opacity:0;visibility:hidden}[part~=wy-overlay][part~=wy-open]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start,top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),right var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),bottom var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),left var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));visibility:visible;opacity:1;transform:none;pointer-events:auto}@starting-style{[part~=wy-overlay][part~=wy-open]{opacity:0;visibility:hidden}}`, gY = tt`[part~=wy-modal]{width:100%;height:100%;border-radius:0}@container (inline-size >= 768px){[part~=wy-modal-centered]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4*var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4*var(--wy-size, 1rem));margin-bottom:auto;width:calc(32*var(--wy-size, 1rem));max-height:calc(32*var(--wy-size, 1rem))}}@container (inline-size >= 768px){[part~=wy-modal-centered][part~=wy-maximized]{margin:0;width:100%;height:100%;max-width:calc(100% - 2*var(--wy-size, 1rem));max-height:calc(100% - 2*var(--wy-size, 1rem))}}`, wY = tt`[part~=wy-sheet]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;bottom:calc(.5*var(--wy-size, 1rem));left:calc(.5*var(--wy-size, 1rem));right:calc(.5*var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3*var(--wy-size, 1rem));margin:calc(.5*var(--wy-size, 1rem)) auto;max-width:calc(32*var(--wy-size, 1rem));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}[part~=wy-sheet]:not([part~=wy-open]){transform:translateY(calc(32 * var(--wy-size, 1rem)))}@starting-style{[part~=wy-sheet][part~=wy-open]{transform:translateY(calc(32 * var(--wy-size, 1rem)))}}`, vY = tt`[part~=wy-drawer]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));inset:0;border-radius:0}@container (inline-size >= 768px){[part~=wy-drawer]{top:var(--wy-padding-outer, 0px);right:var(--wy-padding-outer, 0px);bottom:var(--wy-padding-outer, 0px);left:auto;width:calc(24*var(--wy-size, 1rem));min-width:calc(24*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-outer, 0px)}}@container (inline-size >= 768px){[part~=wy-drawer][part~=wy-maximized]{width:calc(100% - 2*var(--wy-padding-outer, 0px))}}[part~=wy-drawer]:not([part~=wy-open]){transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}@starting-style{[part~=wy-drawer][part~=wy-open]{transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}}`, _4 = tt`[part~=wy-header]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));background-color:var(--wy-component-background-color);box-sizing:border-box}@supports (position: sticky){[part~=wy-header]{position:sticky;top:0;z-index:1020}}[part~=wy-header]{z-index:1022}[part~=wy-header-floating]{--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-header-outer]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}`, pV = tt`[part~=wy-titlebar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));box-sizing:border-box;display:grid;align-items:center;justify-content:space-between;justify-items:center;min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:0 0 var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:calc(2*var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));line-height:var(--wy-line-height, 1.5);color:var(--wy-component-color)}[part~=wy-titlebar-buttons],[part~=wy-titlebar-section]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%;box-shadow:var(--wy-component-box-shadow);border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));background-color:var(--wy-component-background-color)}[part~=wy-titlebar-lg]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:auto}[part~=wy-titlebar-buttons-first]{justify-content:flex-start}[part~=wy-titlebar-buttons-last]{justify-content:flex-end}[part~=wy-titlebar-text]{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-titlebar-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-titlebar-text-trashed]{text-decoration:line-through}`;
var OY = Object.defineProperty, bY = Object.getOwnPropertyDescriptor, Pa = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? bY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && OY(t, e, r), r;
}, "__decorateClass$Y"), P$, vf;
let Gr = (P$ = (vf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.header = !1, this.floating = !1, this.outer = !1, this.trashed = !1, this.size = "md";
  }
  /**
   * render function for the inner titlebar.
   * @internal
   * @returns
   */
  renderTitlebar() {
    return v`
      <nav part="wy-titlebar ${ut({ "wy-titlebar-lg": this.size === "lg" })}">
        <slot name="first">
          <div part="wy-titlebar-icon wy-titlebar-buttons wy-titlebar-buttons-first">
            <slot name="icon"></slot>
          </div>
        </slot>
        <slot name="middle">
          <div part="wy-titlebar-title wy-titlebar-section">
            <slot name="title-section">
              <wy-titlebar-text ?trashed=${this.trashed}><slot name="title"></slot></wy-titlebar-text>
            </slot>
          </div>
        </slot>
        <slot name="last">
          <div part="wy-titlebar-actions wy-titlebar-buttons wy-titlebar-buttons-last">
            <slot name="actions"></slot>
          </div>
        </slot>
      </nav>
    `;
  }
  render() {
    return this.header ? v`<header part="wy-header ${ut({ "wy-header-floating": this.floating, "wy-header-outer": this.outer })}"
          >${this.renderTitlebar()}</header
        >` : this.renderTitlebar();
  }
}, c(vf, "to"), vf), h(P$, "WyTitlebar"), P$);
Gr.styles = [_4, pV, ft];
Pa([
  O({ type: Boolean })
], Gr.prototype, "header", 2);
Pa([
  O({ type: Boolean })
], Gr.prototype, "floating", 2);
Pa([
  O({ type: Boolean })
], Gr.prototype, "outer", 2);
Pa([
  O({ type: Boolean })
], Gr.prototype, "trashed", 2);
Pa([
  O()
], Gr.prototype, "size", 2);
Gr = Pa([
  U("wy-titlebar")
], Gr);
var Q$, Of;
let Zw = (Q$ = (Of = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.trashed = !1;
  }
  render() {
    const t = {
      "wy-titlebar-text-trashed": this.trashed
    };
    return v` <slot part="wy-titlebar-text ${ut(t)}"></slot> `;
  }
}, c(Of, "eo"), Of), h(Q$, "WyTitlebarText"), Q$);
Zw.styles = [pV, ft];
Pa([
  O({ type: Boolean })
], Zw.prototype, "trashed", 2);
Zw = Pa([
  U("wy-titlebar-text")
], Zw);
var $Y = Object.defineProperty, xY = Object.getOwnPropertyDescriptor, b1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $Y(t, e, r), r;
}, "__decorateClass$X"), T$, bf;
let ya = (T$ = (bf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.viewportRef = wt(), this.show = !0, this.type = "modal", this.maximized = !1, this.noHeader = !1, this.handleClose = (t) => {
      if (this.isModal() || t?.type === "toggle" && t.newState === "closed" || t?.type === "close") {
        this.show = !1;
        const e = new CustomEvent("close");
        this.dispatchEvent(e);
      }
    };
  }
  /**
   * Close the modal.
   */
  close() {
    this.show = !1;
    try {
      this.type !== "modal" && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
    } catch {
    }
  }
  /**
   * Checks whether the overlay is using the modal api.
   *
   * @param [type] - Optional type to check
   * @returns Whether the overlay is using the modal api.
   */
  isModal(t) {
    return t ??= this.type, t === "modal" || t === "full";
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("type") && this.viewportRef.value) {
      const e = !this.isModal(t.get("type")) && this.viewportRef.value.popover ? "toggle" : "close";
      this.viewportRef.value.removeEventListener(e, this.handleClose);
    }
  }
  render() {
    if (this.type === "none")
      return C;
    const t = {
      "wy-dialog": !0,
      "wy-dialog-modal": this.isModal()
    }, e = {
      "wy-overlay": !0,
      "wy-modal": this.isModal(),
      // modal, full
      "wy-modal-centered": this.type === "modal",
      "wy-sheet": this.type === "sheet",
      "wy-drawer": this.type === "drawer",
      "wy-maximized": this.maximized,
      "wy-open": this.show
    }, i = this.isModal() ? void 0 : "auto";
    return v`
      <dialog
        part=${ut(t)}
        tabindex="0"
        popover=${Ot(i)}
        ${at(this.viewportRef)}
      >
        <div part=${ut(e)}>
          ${this.noHeader ? C : v`
                <slot name="header">
                  <wy-titlebar part="wy-overlay-titlebar" header>
                    <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <slot slot="title" name="title"></slot>
                    <slot slot="actions" name="actions"></slot>
                  </wy-titlebar>
                </slot>
              `}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    if (t.has("type")) {
      const e = !this.isModal() && this.viewportRef.value?.popover ? "toggle" : "close";
      this.viewportRef.value?.addEventListener(e, this.handleClose), this.show && (!this.isModal(t.get("type")) && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close(), this.requestUpdate("show"));
    }
    if (t.has("show"))
      try {
        this.show ? this.isModal() ? this.viewportRef.value?.showModal() : this.viewportRef.value?.popover ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.show() : !this.isModal() && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, c(bf, "io"), bf), h(T$, "WyOverlay"), T$);
ya.styles = [Qe, ft, yY, gY, wY, vY];
b1([
  O({ type: Boolean, reflect: !0 })
], ya.prototype, "show", 2);
b1([
  O({ type: String })
], ya.prototype, "type", 2);
b1([
  O({ type: Boolean })
], ya.prototype, "maximized", 2);
b1([
  O({ type: Boolean })
], ya.prototype, "noHeader", 2);
ya = b1([
  U("wy-overlay")
], ya);
const kY = tt`[part~=wy-container]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-container-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-container-outer]{padding:var(--wy-padding-outer, var(--wy-padding, 0))}`, Vl = tt`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}`;
var SY = Object.defineProperty, CY = Object.getOwnPropertyDescriptor, xy = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? CY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && SY(t, e, r), r;
}, "__decorateClass$W"), M$, $f;
let Kr = (M$ = ($f = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.scrollX = !1, this.scrollY = !1, this.padded = !1, this.outer = !1, this.scrollbars = !1;
  }
  render() {
    const t = {
      "wy-container": !0,
      "wy-container-padded": this.padded,
      "wy-container-outer": this.outer,
      "wy-scroll-x": this.scrollX && !this.scrollY,
      "wy-scroll-y": this.scrollY && !this.scrollX,
      "wy-scroll-x-y": this.scrollX && this.scrollY,
      "wy-scroll-x-always": this.scrollbars && this.scrollX,
      "wy-scroll-y-always": this.scrollbars && this.scrollY
    };
    return v`
      <div part=${ut(t)}>
        <slot></slot>
      </div>
    `;
  }
}, c($f, "ro"), $f), h(M$, "WyContainer"), M$);
Kr.styles = [Vl, ft, kY];
xy([
  O({ type: Boolean })
], Kr.prototype, "scrollX", 2);
xy([
  O({ type: Boolean })
], Kr.prototype, "scrollY", 2);
xy([
  O({ type: Boolean })
], Kr.prototype, "padded", 2);
xy([
  O({ type: Boolean })
], Kr.prototype, "outer", 2);
xy([
  O({ type: Boolean })
], Kr.prototype, "scrollbars", 2);
Kr = xy([
  U("wy-container")
], Kr);
var PY = Object.defineProperty, QY = Object.getOwnPropertyDescriptor, ky = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? QY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && PY(t, e, r), r;
}, "__decorateClass$V"), A$, xf;
let Xw = (A$ = (xf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.pollOptions = [];
  }
  /**
   * Dispatch a `vote` event for the specified option.
   *
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, i) => e + (i.votes?.count || 0), 0);
    return v`
      <div part="wy-poll">
        ${this.pollOptions.map(
      (e) => v`<wy-poll-option
              @vote=${(i) => this.dispatchVote(i.detail.optionId)}
              .option=${e}
              .totalVotes=${t}
            ></wy-poll-option>`
    )}
      </div>
    `;
  }
}, c(xf, "so"), xf), h(A$, "WyPoll"), A$);
Xw.styles = [
  E4,
  ft
];
ky([
  O({ type: Array, attribute: !1 })
], Xw.prototype, "pollOptions", 2);
Xw = ky([
  U("wy-poll")
], Xw);
var R$, kf;
let pl = (R$ = (kf = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new yn(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(oI(this.weavy, this.option.id));
  }
  /**
   * Dispatch a `vote` event for the provided option id.
   *
   * @internal
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle the voter sheet and refresh vote data.
   *
   * @internal
   * @param e - Triggering user event.
   */
  openSheet(t) {
    t.preventDefault(), t.stopPropagation(), this.getVotesQuery.observer?.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    if (!this.option || !this.option.id)
      return C;
    const { data: t, isLoading: e } = this.getVotesQuery.result ?? {}, i = this.totalVotes > 0 ? Math.round((this.option.votes?.count || 0) / this.totalVotes * 100) : 0;
    return v`
      <div
        part="wy-poll-option"
        tabindex="0"
        @click=${() => this.dispatchVote(this.option?.id)}
        @keydown=${ze}
        @keyup=${di}
      >
        <div part="wy-poll-meter" style="width: ${i + "%"}"></div>
        <div part="wy-poll-image">
          ${this.option.has_voted ? v`<wy-icon name="check-circle"></wy-icon>` : v`<wy-icon name="circle-outline"></wy-icon>`}
        </div>
        <div part="wy-poll-title">${this.option.text}</div>
        ${i > 0 ? v`<span
              part="wy-poll-amount"
              tabindex="0"
              @click=${(r) => this.openSheet(r)}
              @keydown=${ze}
              @keyup=${di}
            >
              ${i + "%"}
            </span>` : v`<span part="wy-poll-amount"></span>`}
      </div>

      ${this.weavy ? v`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${P(rt`Votes on ${this.option.text}`)}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? v`
                      ${t.votes?.data ? t.votes.data.map(
      (r) => v`
                              <wy-item>
                                <wy-avatar
                                  slot="image"
                                  .size=${32}
                                  .src=${r.avatar_url}
                                  .name=${r.name}
                                ></wy-avatar>
                                <span slot="title">${r.name}</span>
                              </wy-item>
                            `
    ) : C}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}
    `;
  }
}, c(kf, "no"), kf), h(R$, "WyPollOption"), R$);
pl.styles = [E4, ft];
ky([
  O({ type: Number, attribute: !1 })
], pl.prototype, "totalVotes", 2);
ky([
  O({ attribute: !1 })
], pl.prototype, "option", 2);
ky([
  Z()
], pl.prototype, "showSheet", 2);
pl = ky([
  U("wy-poll-option"),
  kt()
], pl);
function fV(n, t, e, i, r, s, a) {
  return new Zt(n.queryClient, {
    mutationFn: /* @__PURE__ */ h(async () => await n.fetch(`/api/${r}/${i}/reactions`, {
      method: s ? "POST" : "DELETE",
      body: JSON.stringify({ content: s })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ h(() => {
      const o = e === "apps" && r === "posts" ? [r, t] : [e, t, r];
      ge(n.queryClient, o, i, (l) => {
        ey(l, s, a);
      });
    }, "onMutate")
  });
}
c(fV, "Rx");
h(fV, "reactionMutation");
function mV(n, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ h(async () => await (await n.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
c(mV, "Ex");
h(mV, "getReactionListOptions");
function ey(n, t, e) {
  return !t && !n.reactions?.data || (n.reactions || (n.reactions = { count: 0, data: [] }), n.reactions.data || (n.reactions.data = []), t ? n.reactions.data = [
    ...n.reactions.data.filter((i) => i.created_by?.id !== e.id),
    { content: t, created_by: e }
  ] : n.reactions.data && (n.reactions.data = [...n.reactions.data.filter((i) => i.created_by?.id !== e.id)])), n;
}
c(ey, "Pl");
h(ey, "updateReaction");
const TY = tt`[part~=wy-reaction]{font-size:calc(1.125*var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25*var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25*var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;gap:calc(.1875*var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1*var(--wy-size, 1rem));right:calc(.25*var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.1875*var(--wy-size, 1rem));padding-right:calc(.1875*var(--wy-size, 1rem));gap:calc(.125*var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, yV = tt`[part~=wy-emoji-icon]{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25*var(--wy-size, 1rem))}[part~=wy-emoji-icon-sm]{width:calc(1.125*var(--wy-size, 1rem));height:calc(1.125*var(--wy-size, 1rem));font-size:calc(1.125*var(--wy-size, 1rem))}`;
var MY = Object.defineProperty, AY = Object.getOwnPropertyDescriptor, Ae = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? AY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && MY(t, e, r), r;
}, "__decorateClass$U"), E$, Sf;
let ve = (E$ = (Sf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = wt(), this.menuRef = wt(), this.reactionListQuery = new yn(this), this._documentClickHandler = (t) => {
      this.show && (t.preventDefault(), this.menuRef.value?.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const e = fV(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await e.mutate(), this.reactionListQuery.observer?.refetch();
    };
  }
  /**
   * Closes the picker when the popover hides.
   *
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("close");
      this.dispatchEvent(e);
    }
  }
  /**
   * Toggles the emoji picker visibility.
   *
   * @internal
   */
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  /**
   * Opens the detailed reaction sheet view.
   *
   * @internal
   */
  handleReactionsClick() {
    this.reactionListQuery.observer?.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(mV(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = this.reactions?.find((e) => e.created_by?.id === this.user?.id)?.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = S4(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && lV(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            oV(),
            sV({ mainAxis: 0, alignmentAxis: -8 }),
            aV({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: e, y: i }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${e}px`,
            marginTop: `${i}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
    t.has("settings") && this.settings?.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    const { data: t, isPending: e } = this.reactionListQuery.result ?? {};
    if (!this.emojis?.length)
      return C;
    const i = this.emojis?.length === 1 ? this.emojis[0] : "", r = [
      ...new Map(this.reactions?.map((d) => [d.content, d])).values()
    ], s = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, a = i ? v`
          ${this.reactions && this.reactions?.length > 1 ? v`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span part=${ut(s)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : C}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === i}
              @click=${() => {
      this.handleReaction(i);
    }}
              @keydown=${ze}
              @keyup=${di}
              title=${P("React", { desc: "Button action to react" })}
            >
              <span part=${ut(s)} title=${i}>${i}</span>
            </wy-button>
          </div>
        ` : v`
          ${r.length ? v`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${r.map((d) => v`<span part=${ut(s)} title="">${d.content}</span>`)}
                    ${this.reactions && this.reactions?.length > 1 ? v`<small part="wy-reaction-count">${this.reactions.length}</small>` : C}
                  </div>
                </wy-button>
              ` : C}

          <div ${at(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(d) => this.handleClickToggle(d)}
              @keydown=${ze}
              @keyup=${di}
              title=${P("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon" size=${this.small ? 20 : 24}></wy-icon>
            </wy-button>
          </div>

          <div
            ${at(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(d) => this.handleClickToggle(d)}
            @keyup=${cb}
            ?hidden=${!this.show}
            popover=${Ot(Kv() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (d) => v`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === d}
                      @click=${() => {
        this.handleReaction(d);
      }}
                    >
                      <span part="wy-emoji-icon">${d}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, o = v`
      ${this.weavy && this.showSheet ? v`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${P("Reactions")}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? v`
                      ${t.data?.map(
      (d) => v` <wy-reaction-item .reaction=${d}></wy-reaction-item> `
    )}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}
    `, l = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? v`
          <div part=${ut(l)}>${a}</div>
          ${o}
        ` : [a, o];
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this._computePositionCleanup?.(), super.disconnectedCallback();
  }
}, c(Sf, "ao"), Sf), h(E$, "WyReactions"), E$);
ve.styles = [re, TY, yV, ft];
Ae([
  O()
], ve.prototype, "directionX", 2);
Ae([
  O()
], ve.prototype, "directionY", 2);
Ae([
  O({ type: Boolean })
], ve.prototype, "small", 2);
Ae([
  O({ attribute: !1 })
], ve.prototype, "reactions", 2);
Ae([
  O({ attribute: !1 })
], ve.prototype, "emojis", 2);
Ae([
  O({ type: String })
], ve.prototype, "parentType", 2);
Ae([
  O({ attribute: !0, type: Number })
], ve.prototype, "parentId", 2);
Ae([
  O({ attribute: !0, type: String })
], ve.prototype, "entityType", 2);
Ae([
  O({ attribute: !0, type: Number })
], ve.prototype, "entityId", 2);
Ae([
  O({ type: Boolean })
], ve.prototype, "line", 2);
Ae([
  O({ type: Boolean })
], ve.prototype, "lineReverse", 2);
Ae([
  O({ type: Boolean })
], ve.prototype, "lineBottom", 2);
Ae([
  O({ type: Boolean })
], ve.prototype, "lineBelow", 2);
Ae([
  Z()
], ve.prototype, "_placement", 2);
Ae([
  Z()
], ve.prototype, "reactedEmoji", 2);
Ae([
  Z()
], ve.prototype, "show", 2);
Ae([
  Z()
], ve.prototype, "showSheet", 2);
ve = Ae([
  U("wy-reactions"),
  kt()
], ve);
var _$, Cf;
let Nw = (_$ = (Cf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  render() {
    return v`
      <wy-item>
        <wy-avatar
          slot="image"
          .src=${this.reaction.created_by?.avatar_url}
          .name=${this.reaction.created_by?.name}
        ></wy-avatar>
        <span slot="title">${this.reaction.created_by?.name}</span>
        <span slot="actions" part="wy-emoji-icon">${this.reaction.content}</span>
      </wy-item>
    `;
  }
}, c(Cf, "oo"), Cf), h(_$, "WyReactionItem"), _$);
Nw.styles = [re, yV];
Ae([
  O({ attribute: !1 })
], Nw.prototype, "reaction", 2);
Nw = Ae([
  U("wy-reaction-item")
], Nw);
const RY = tt`[part~=wy-preview]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;box-sizing:border-box;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%}[part~=wy-preview-layout]{width:100%;height:100%}[part~=wy-preview-main]{display:flex;height:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@container (inline-size < 768px){[part~=wy-preview-main]{flex-direction:column}}[part~=wy-preview-swiper]{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}[part~=wy-preview-swiper]::-webkit-scrollbar{display:none}[part~=wy-preview-swiper-disabled]{overflow-x:hidden}[part~=wy-preview-area]{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}[part~=wy-nav-prev],[part~=wy-nav-next]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}[part~=wy-nav-prev]{left:calc(.5*var(--wy-size, 1rem))}[part~=wy-nav-next]{right:calc(.5*var(--wy-size, 1rem))}`, EY = tt`[part~=wy-sidebar]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(22*var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}[part~=wy-sidebar]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar][hidden]{display:flex!important;flex-basis:0}[part~=wy-sidebar][hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@container (inline-size >= 768px){[part~=wy-sidebar]>*{min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar] [part~=wy-sidebar-handle]{display:none}}@container (inline-size < 768px){[part~=wy-sidebar]{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}[part~=wy-sidebar]:not([hidden]){margin-top:calc(-1*var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]{flex-basis:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*.5);margin-top:calc(-50% + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-prev],[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-next]{display:none}[part~=wy-sidebar]>*{min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}}[part~=wy-sidebar-handle]{width:calc(4*var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));height:calc(1*var(--wy-size, 1rem));border:calc(.375*var(--wy-size, 1rem)) solid rgba(0,0,0,0);position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}`;
var _Y = Object.defineProperty, zY = Object.getOwnPropertyDescriptor, Ob = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? zY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && _Y(t, e, r), r;
}, "__decorateClass$T"), z$, Pf;
let fl = (z$ = (Pf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Dispatch `file-preview-loaded` when the fallback content is ready.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.icon, e = wy(this.provider);
    return v`
      <wy-icon-display fill>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? v`
                <p>${P("No preview available :(")} </p>
                <wy-button kind="filled" color="variant" href=${this.src} target="_blank">${P(rt`Open in ${this.provider}`)}</wy-button>
              ` : v`<div>${P("No preview available :(")}</div>`}
        </span>
      </wy-icon-display>
    `;
  }
  updated(t) {
    (t.has("icon") || t.has("src")) && (this.icon || this.src) && this.dispatchLoaded();
  }
}, c(Pf, "co"), Pf), h(z$, "WyPreviewIcon"), z$);
fl.styles = [
  ft
];
Ob([
  O()
], fl.prototype, "src", 2);
Ob([
  O()
], fl.prototype, "icon", 2);
Ob([
  O()
], fl.prototype, "provider", 2);
fl = Ob([
  U("wy-preview-icon"),
  kt()
], fl);
const LY = tt`[part~=wy-content-image]{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;box-sizing:border-box;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}[part~=wy-content-image][part~=wy-zoom]{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}[part~=wy-content-image-img]{min-width:0;min-height:0;width:100%;height:100%}[part~=wy-content-image-img][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-image-img]~[part~=wy-content-progress]{position:absolute}`;
var IY = Object.defineProperty, VY = Object.getOwnPropertyDescriptor, bb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? VY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && IY(t, e, r), r;
}, "__decorateClass$S"), L$, Qf;
let ml = (L$ = (Qf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Dispatches the `file-preview-loaded` event once the image has loaded.
   *
   * @internal
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = !!(this.width && this.height), e = t ? { "--width": this.width, "--height": this.height } : {};
    return v`
      <div part="wy-content-image ${ut({ "wy-intrinsic-image": !t })}" style=${Ew(e)}>
        <img
          part="wy-content-image-img"
          src=${this.src}
          ${at(yb)}
          @load=${(i) => {
      gb(i), this.dispatchLoaded();
    }}
          width=${Ot(this.width)}
          height=${Ot(this.height)}
          decoding="async"
          alt=${P("Preview")}
        />
        ${t ? v`<wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>` : C}
      </div>
    `;
  }
}, c(Qf, "lo"), Qf), h(L$, "WyPreviewImage"), L$);
ml.styles = [LY, ft];
bb([
  O()
], ml.prototype, "src", 2);
bb([
  O({ type: Number })
], ml.prototype, "width", 2);
bb([
  O({ type: Number })
], ml.prototype, "height", 2);
ml = bb([
  U("wy-preview-image"),
  kt()
], ml);
function z4(n) {
  (n.classList.contains("wy-loading") || n.part.contains("wy-loading")) && (n.classList.add("wy-loaded"), n.part.add("wy-loaded")), n.classList.add("wy-error"), n.part.add("wy-error"), n.outerHTML = n.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
c(z4, "gv");
h(z4, "mediaFallback");
function gV(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
c(gV, "qx");
h(gV, "mediaLoaded");
function sS(n) {
  const t = n.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, i = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = i.toString(), e.querySelectorAll("source").length >= i && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), z4(e));
  }
}
c(sS, "pf");
h(sS, "mediaError");
function aS(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), z4(t));
}
c(aS, "uf");
h(aS, "codecError");
const DY = tt`[part~=wy-content-video]{box-sizing:border-box}[part~=wy-content-video]:not([part~=wy-error]){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}[part~=wy-content-video],[part~=wy-content-audio]{margin:auto}[part~=wy-content-video][part~=wy-loading]:not([part~=wy-loaded]),[part~=wy-content-audio][part~=wy-loading]:not([part~=wy-loaded]){visibility:hidden}[part~=wy-content-video][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress],[part~=wy-content-audio][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-video]:focus,[part~=wy-content-audio]:focus{outline:none}`;
var WY = Object.defineProperty, qY = Object.getOwnPropertyDescriptor, Sy = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && WY(t, e, r), r;
}, "__decorateClass$R"), I$, Tf;
let Jr = (I$ = (Tf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.format = "", this.play = !1, this.name = "", this.handleLoaded = (t) => {
      gV(t), this.dispatchLoaded();
    };
  }
  /**
   * Dispatches the `file-preview-loaded` event after the media metadata becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Registers load and error listeners on the provided media element.
   *
   * @internal
   * @param mediaElement - Media element to observe.
   */
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.part.add("wy-loading"), t.addEventListener("error", sS, !0), t.addEventListener("loadedmetadata", this.handleLoaded, !0), t.addEventListener("loadedmetadata", aS, !0));
  }
  /**
   * Cleans up listeners and state from the previously registered media element.
   *
   * @internal
   */
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", sS, !0), this.mediaElement.removeEventListener("loadedmetadata", this.handleLoaded, !0), this.mediaElement.removeEventListener("loadedmetadata", aS, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? v`
          <video ${at((t) => this.registerLoading(t))} part="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ot(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
        ` : v`
          <audio ${at((t) => this.registerLoading(t))} part="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ot(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, c(Tf, "ho"), Tf), h(I$, "WyPreviewMedia"), I$);
Jr.styles = [
  DY,
  ft
];
Sy([
  O()
], Jr.prototype, "format", 2);
Sy([
  O()
], Jr.prototype, "src", 2);
Sy([
  O({ type: Boolean })
], Jr.prototype, "play", 2);
Sy([
  O()
], Jr.prototype, "name", 2);
Sy([
  O()
], Jr.prototype, "mediaType", 2);
Jr = Sy([
  U("wy-preview-media")
], Jr);
const FY = tt`[part~=wy-content-code]{align-self:flex-start;box-sizing:border-box;width:100%;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}`, ZY = tt`[part~=wy-content-text],[part~=wy-content-html] pre,[part~=wy-content-html] code{word-break:break-word;white-space:pre-wrap}[part~=wy-content-html] hr{border-color:var(--wy-outline, var(--wy-outline-light, #72777f));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content-html] h1,[part~=wy-content-html] h2,[part~=wy-content-html] h3,[part~=wy-content-html] h4,[part~=wy-content-html] h5,[part~=wy-content-html] h6{font-family:var(--wy-document-headings-font-family, var(--wy-headings-font-family, var(--wy-font-family, unset)));line-height:var(--wy-document-headings-line-height, var(--wy-headings-line-height, var(--wy-line-height, 1.5)))}[part~=wy-content-html] h1{font-size:var(--wy-document-h1-font-size, calc(2 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h1-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content-html] h2{font-size:var(--wy-document-h2-font-size, calc(1.5 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h2-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h3{font-size:var(--wy-document-h3-font-size, calc(1.25 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h3-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h4{font-size:var(--wy-document-h4-font-size, calc(1.125 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h4-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h5{font-size:var(--wy-document-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h5-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h5-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h6{font-size:var(--wy-document-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h6-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h6-margin, 0)}`, XY = tt`[part~=wy-document]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));box-sizing:border-box;width:100%;min-height:100%;flex:1 0 auto}@container (inline-size >= 768px){[part~=wy-document]{padding:calc(3*var(--wy-size, 1rem)) calc(4*var(--wy-size, 1rem));margin:calc(2*var(--wy-size, 1rem)) auto;border-radius:calc(.125*var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5*var(--wy-size, 1rem))}}`, NY = tt`[part~=wy-code] pre,.wy-code pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic{font-style:italic}`;
var jY = Object.defineProperty, BY = Object.getOwnPropertyDescriptor, Dl = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? BY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && jY(t, e, r), r;
}, "__decorateClass$Q"), V$, Mf;
let dr = (V$ = (Mf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  /**
   * Dispatches the `file-preview-loaded` event when content becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then($_).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e, this.dispatchLoaded();
    }));
  }
  render() {
    return this.loading ? v` <wy-empty><wy-progress-circular part="wy-content-progress" indeterminate></wy-progress-circular></wy-empty> ` : this.html ? this.code ? v` <div part="wy-content-code wy-code">${ll(this.textOrHtmlContent)}</div> ` : v`
            <div part="wy-document wy-light">
              <div part="wy-content-html">${ll(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? v` <div part="wy-content-code">${this.textOrHtmlContent}</div> ` : v`
          <div part="wy-document wy-light">
            <pre part="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, c(Mf, "po"), Mf), h(V$, "WyPreviewText"), V$);
dr.styles = [Qe, ZY, FY, XY, NY, ft];
Dl([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], dr.prototype, "weavy", 2);
Dl([
  O()
], dr.prototype, "src", 2);
Dl([
  O({ type: Boolean })
], dr.prototype, "html", 2);
Dl([
  O({ type: Boolean })
], dr.prototype, "code", 2);
Dl([
  Z()
], dr.prototype, "textOrHtmlContent", 2);
Dl([
  Z()
], dr.prototype, "loading", 2);
dr = Dl([
  U("wy-preview-text")
], dr);
const UY = tt`[part~=wy-content-embed]{border:0;display:block;box-sizing:border-box;width:100%;height:100%;top:0;left:0;flex:1 1 100%}[part~=wy-content-embed][part~=wy-loaded]{--wy-component-background-color: var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-embed-fallback],[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]):not([part~=wy-fallback])~[part~=wy-content-embed-fallback]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded])[part~=wy-fallback]~[part~=wy-content-progress]{display:none}`;
var HY = Object.defineProperty, YY = Object.getOwnPropertyDescriptor, $1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? YY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && HY(t, e, r), r;
}, "__decorateClass$P"), D$, Af;
let ga = (D$ = (Af = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Emit `file-preview-loaded` once the preview has finished loading.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Attach load listeners and register the provided embed element.
   *
   * @internal
   * @param embedElement - Newly rendered embed element.
   */
  registerLoading(t) {
    if (this.unregisterLoading?.(), t) {
      this.embedElement = t, t.part.add("wy-loading");
      const e = window.setTimeout(() => {
        t.part.add("wy-fallback"), this.dispatchLoaded();
      }, 2500), i = /* @__PURE__ */ h((r) => {
        const s = r.target;
        s.tagName === "OBJECT" && s.part.contains("wy-loading") && !s.part.contains("wy-loaded") && (s.part.add("wy-loaded"), window.clearTimeout(e), this.dispatchLoaded());
      }, "embedLoaded");
      t.addEventListener("load", i, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", i, !0), window.clearTimeout(e), this.embedElement = void 0);
      };
    }
  }
  render() {
    return v`
      <object title=${P("Preview")} ${at((t) => this.registerLoading(t))} part="wy-content-embed" data=${this.src}></object>
      <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${Ot(this.provider)}
        part="wy-content-embed-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    this.unregisterLoading?.(), super.disconnectedCallback();
  }
}, c(Af, "uo"), Af), h(D$, "WyPreviewEmbed"), D$);
ga.styles = [
  UY,
  ft
];
$1([
  O()
], ga.prototype, "src", 2);
$1([
  O()
], ga.prototype, "name", 2);
$1([
  O()
], ga.prototype, "icon", 2);
$1([
  O()
], ga.prototype, "provider", 2);
ga = $1([
  U("wy-preview-embed"),
  kt()
], ga);
const GY = tt`.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}.wy-content-pdf .textLayer{position:absolute;text-align:initial;inset:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:#0000;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:#0000}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors:active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px*var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px*var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:#0000;border:none;inset:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px*var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:#0000}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px*var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px*var(--scale-factor)) calc(5px*var(--scale-factor)) #888;border-radius:calc(2px*var(--scale-factor));outline:1.5px solid #ffff4a;padding:calc(6px*var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px*var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid #333;margin-top:calc(2px*var(--scale-factor));padding-top:calc(2px*var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:#0000;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors:active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:#0000}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:#0000;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:#0000;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:#0000;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:#0000}.wy-content-pdf .xfaSelect{appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors:active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid rgba(0,0,0,0)}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3*var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5*var(--wy-size, 1rem))}`, wV = tt`[part~=wy-toolbar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));box-sizing:border-box;display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius)}[part~=wy-toolbar-center]{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-buttons]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%}[part~=wy-toolbar-buttons-last]{margin-inline-start:auto}[part~=wy-toolbar-text]{margin-left:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-center-text]{text-align:center}[part~=wy-toolbars-bottom]{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem)))/2);left:0;right:0;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center;box-sizing:border-box}`, Qa = tt`[part~=wy-input]{--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)));display:block;max-width:100%;min-width:0;flex:1 1 auto;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-input]:focus{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-input]::placeholder{color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:1}[part~=wy-input]:disabled{opacity:38%}[part~=wy-input]::file-selector-button,[part~=wy-input]::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1*var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}[part~=wy-input]:hover:not(:disabled):not([readonly])::file-selector-button,[part~=wy-input]:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}[part~=wy-input][type=file]{overflow:hidden}[part~=wy-input][type=file]:not(:disabled):not([readonly]){cursor:pointer}[part~=wy-input]::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))))*1em)}[part~=wy-input][type=search]::-webkit-search-cancel-button{-webkit-appearance:none}[part~=wy-input-filled]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}[part~=wy-input-filled]:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-label]{display:inline-block;font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-description]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25*var(--wy-size, 1rem))}[part~=wy-is-invalid],[part~=wy-is-invalid]:focus{border-color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-invalid-feedback]{margin-top:calc(.25*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-input-group]{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}[part~=wy-input-group-button-icon]{--wy-component-background-color: transparent}[part~=wy-input-group-input-with-overlay]{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-input-group-button-icon-overlay]{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}[part~=wy-input-group-input]:placeholder-shown~[part~=wy-input-group-button-icon][type=reset]{display:none}[part~=wy-input-group-input]:not(:placeholder-shown)~[part~=wy-input-group-button-icon][type=reset]+[part~=wy-input-group-button-icon]{display:none}[part~=wy-no-result]{text-align:center;padding:calc(1*var(--wy-size, 1rem))}`;
var KY = Object.defineProperty, JY = Object.getOwnPropertyDescriptor, $b = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JY(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && KY(t, e, r), r;
}, "__decorateClass$O"), W$, Rf;
let yl = (W$ = (Rf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = wt(), this.totalPagesRef = wt(), this.zoomLevelRef = wt(), this.viewerContainerRef = wt(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  /**
   * Emit `file-preview-loaded` once the viewer has initialized.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  ////////
  /**
   * Open the configured PDF source in the viewer.
   *
   * @internal
   */
  async open() {
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const e = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: this.CMAP_URL?.toString() || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = e, e.onProgress = (i) => {
    };
    try {
      const i = await e.promise;
      this.pdfDocument = i, this.pdfViewer.setDocument(i), this.pdfLinkService.setDocument(i), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: i.fingerprints[0]
      });
    } catch (i) {
      let r = "pdfjs-loading-error";
      i instanceof t.InvalidPDFException ? r = "pdfjs-invalid-file-error" : i instanceof t.MissingPDFException ? r = "pdfjs-missing-file-error" : i instanceof t.UnexpectedResponseException && (r = "pdfjs-unexpected-response-error"), await this.l10n.get(r, void 0, void 0).then((s) => {
        this.pdfViewError(t, s, { message: i?.message });
      });
    }
    this.dispatchLoaded();
  }
  /**
   * Close any currently loaded PDF and release resources.
   *
   * @internal
   */
  async close() {
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, this.pdfViewer?.setDocument(null), this.pdfLinkService?.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  /**
   * Log a pdf.js related error with contextual metadata.
   *
   * @internal
   * @param pdfjsLib - pdf.js core library.
   * @param message - Human readable error.
   * @param moreInfo - Additional error metadata.
   */
  pdfViewError(t, e, i) {
    const r = [`PDF.js v${t?.version || "?"} (build: ${t?.build || "?"})`];
    i && (r.push(`Message: ${i.message}`), i.stack ? r.push(`Stack: ${i.stack}`) : (i.filename && r.push(`File: ${i.filename}`), i.lineNumber && r.push(`Line: ${i.lineNumber}`))), console.error(`${e}

${r.join(`
`)}`);
  }
  ///////
  /**
   * Navigate to the provided page number.
   *
   * @param pageNumber - One-based page index.
   */
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  /**
   * Increase zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Decrease zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Apply an absolute zoom level or named scale preset.
   *
   * @param scale - Numeric zoom or preset name.
   */
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  /**
   * Validate and update the current page based on the input value.
   */
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  /**
   * Select all text inside an input, aiding quick replacement.
   *
   * @param e - Input focus event.
   */
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  /**
   * Fit the PDF to the current viewport height.
   */
  fitToPage() {
    this.setScale("page-fit");
  }
  /**
   * Fit the PDF to the current viewport width.
   */
  fitToWidth() {
    this.setScale("page-width");
  }
  /**
   * Validate and persist zoom level from the input field.
   */
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs-Bhye_tXX.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs-bp-6p92T.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), this.whenPdfjsResolve?.({
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = rS(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = rS(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: t, pdfjsViewer: e } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new e.EventBus(), this.pdfLinkService = new e.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new e.GenericL10n(this.weavy?.locale), this.pdfViewer = new e.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: t.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), this.pdfLinkService?.setViewer(this.pdfViewer), this.pdfHistory = new e.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), this.pdfLinkService?.setHistory(this.pdfHistory), this.pdfEventBus?.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), this.pdfEventBus?.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), this.pdfEventBus?.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return v`
      <div class="wy-content-pdf">
        <div part="wy-toolbars-bottom">
          <nav part="wy-toolbar wy-toolbar-center">
            <div part="wy-toolbar-buttons">
              <input
                type="text"
                part="wy-input wy-toolbar-center-text"
                class="wy-pdf-page-number"
                ${at(this.pageNumberRef)}
                @keydown=${Mw}
                @keyup=${Hr}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span part="wy-toolbar-text">/</span>
              <span part="wy-toolbar-text" ${at(this.totalPagesRef)}>1</span>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${P("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                part="wy-input"
                class="wy-pdf-zoom-level"
                ${at(this.zoomLevelRef)}
                @keydown=${Mw}
                @keyup=${Hr}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${P("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${P("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${P("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${at(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    this.resizer.unobserve(this);
    try {
      this.close(), this.pdfViewer?.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, c(Rf, "yo"), Rf), h(W$, "WyPdfViewer"), W$);
yl.styles = [
  GY,
  wV,
  Qa,
  ft
];
$b([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], yl.prototype, "weavy", 2);
$b([
  O()
], yl.prototype, "src", 2);
$b([
  Z()
], yl.prototype, "pdfViewer", 2);
yl = $b([
  U("wy-pdf-viewer"),
  kt()
], yl);
var tG = Object.defineProperty, eG = Object.getOwnPropertyDescriptor, L4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? eG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && tG(t, e, r), r;
}, "__decorateClass$N"), q$, Ef;
let iy = (q$ = (Ef = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.current = !1;
  }
  /**
   * Emits the `file-preview-loaded` event when the preview has finished loading.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: e } = ls(t.name), i = en(t.name);
    let r = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (i === ".gif" || i === ".svg") && (r = t.download_url || "");
    const s = r, a = t.external_url, o = t.is_trashed ? "none" : t.preview_format, l = t.name, d = t.width, u = t.height, p = t.media_type, f = t.provider;
    return o === "image" ? v`<wy-preview-image
        src=${s}
        width=${Ot(d)}
        height=${Ot(u)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-image>` : o === "pdf" ? v`<wy-pdf-viewer src=${s} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-pdf-viewer>` : o === "video" || o === "audio" ? v`<wy-preview-media
        format=${o}
        src=${s}
        name=${l}
        mediaType=${p}
        ?play=${this.current}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-media>` : o === "text" ? v`<wy-preview-text src=${s} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-preview-text>` : o === "code" ? v`<wy-preview-text
        src=${s}
        ?html=${!/^(?:blob:|data:)/.test(s)}
        code
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : o === "html" ? v`<wy-preview-text
        src=${s}
        html
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : o === "embed" ? v`<wy-preview-embed
        src=${s}
        name=${l}
        icon=${e}
        provider=${Ot(f)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-embed>` : o === "none" ? a ? v`<wy-preview-icon
            src=${a}
            icon=${e}
            provider=${Ot(f)}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : v`<wy-preview-icon
            src=${s}
            icon=${e}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : C;
  }
}, c(Ef, "wo"), Ef), h(q$, "WyPreviewItem"), q$);
iy.styles = [ft];
L4([
  O({ type: Object })
], iy.prototype, "file", 2);
L4([
  O({ type: Boolean })
], iy.prototype, "current", 2);
iy = L4([
  U("wy-preview-item")
], iy);
var iG = Object.defineProperty, nG = Object.getOwnPropertyDescriptor, x1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? nG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && iG(t, e, r), r;
}, "__decorateClass$M"), F$, _f;
let gl = (F$ = (_f = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, i) {
    if (this.hasEventListener) {
      const r = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, r) && Object.assign(this.hasEventListener, {
        [r]: !0
      });
    }
    super.addEventListener(t, e, i);
  }
  /**
   * Open download URL for the current file.
   * @internal
   */
  triggerDownload() {
    this.file && or(this.file.download_url, "_top", this.file.name, !0);
  }
  /**
   * Open external provider URL for the current file.
   * @internal
   */
  triggerExternal() {
    this.file && or(this.file.external_url, "_blank", this.file.name);
  }
  /**
   * Open application-specific URL for the current file.
   * @internal
   */
  triggerApplication() {
    this.file && or(this.file.application_url, "_top", this.file.name);
  }
  /**
   * Emit an `edit-name` event for the current file.
   * @internal
   */
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `subscribe` event toggling subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription setting.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event for the current file.
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event for the current file.
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `delete-forever` event for the current file.
   * @internal
   */
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    if (!this.file)
      return C;
    const { icon: t } = ls(this.file.name), e = this.file.id >= 1, i = this.file.provider, r = this.file.provider || "app";
    return v`
      <wy-dropdown directionX="left" ?small=${this.small}>
        ${e && this.file.is_trashed ? v`
              ${this.hasEventListener.restore ? v`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${P("Restore")}
                    </wy-dropdown-item>
                  ` : C}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? v` <wy-dropdown-divider></wy-dropdown-divider> ` : C}
              ${this.hasEventListener["delete-forever"] ? v`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${P("Delete")}
                    </wy-dropdown-item>
                  ` : C}
            ` : C}
        ${this.file.is_trashed ? C : v`
              ${this.file.external_url ? v`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${P(rt`Open in ${i}`)}
                    </wy-dropdown-item>
                  ` : v`
                    ${this.componentFeatures?.allowsFeature(I.WebDAV) && this.file.application_url ? v`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? mP(this.file.provider) : t}
                            ></wy-icon>
                            ${P(rt`Open in ${r}`)}
                          </wy-dropdown-item>
                        ` : C}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${P("Download")}
                    </wy-dropdown-item>
                  `}
              ${e ? v`
                    ${this.hasEventListener["edit-name"] ? v`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${P("Rename")}
                          </wy-dropdown-item>
                        ` : C}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          ` : C}
                    ${this.hasEventListener.trash ? v`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${P("Trash")}
                          </wy-dropdown-item>
                        ` : C}
                  ` : C}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, c(_f, "fo"), _f), h(F$, "WyFileMenu"), F$);
x1([
  Ve({ context: U0, subscribe: !0 }),
  Z()
], gl.prototype, "componentFeatures", 2);
x1([
  O({ type: Object })
], gl.prototype, "file", 2);
x1([
  O({ type: Boolean })
], gl.prototype, "small", 2);
x1([
  O({ type: Object })
], gl.prototype, "hasEventListener", 2);
gl = x1([
  U("wy-file-menu"),
  kt()
], gl);
function vV(n, t, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ h(async (r) => {
      const s = r.pageParam, a = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + s, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
c(vV, "l4");
h(vV, "getCommentsOptions");
function OV(n, t) {
  return {
    mutationFn: /* @__PURE__ */ h(async (e) => await (await n.fetch("/api/comments/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ h((e, i) => {
      i.id && ge(n.queryClient, [i.type, i.parent_id, "comments"], i.id, (r) => {
        r.text = e.text, r.html = e.html, r.attachments = e.attachments, r.meeting = e.meeting, r.updated_at = e.updated_at, r.updated_by = e.updated_by, r.options = e.options, r.embed = e.embed;
      });
    }, "onSuccess")
  };
}
c(OV, "d4");
h(OV, "getUpdateCommentMutationOptions");
function bV(n) {
  const t = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ h(async (e) => await (await n.fetch("/api/" + e.type + "/" + e.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        embed_id: e.embed_id,
        context: e.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ h(async (e) => {
      const i = [e.type, e.parent_id, "comments"];
      await t.cancelQueries({ queryKey: i });
      const r = ua(n.queryClient, i, !1);
      if (e.user) {
        const s = {
          id: r ? r.id - 1 : -1,
          app: e.type === "apps" ? { id: e.parent_id } : { id: -1 },
          is_trashed: !1,
          text: e.text,
          html: e.text,
          plain: e.text,
          created_by: e.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        e.type === "files" ? s.parent = { type: li.File, id: e.parent_id } : e.type === "posts" && (s.parent = { type: li.Post, id: e.parent_id }), da(t, i, s, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((e, i) => {
      const r = [i.type, e.parent?.id ?? e.app.id, "comments"];
      if (!c1(n.queryClient, r, e.id)) {
        const s = ua(n.queryClient, r, !0);
        s ? ge(n.queryClient, r, s.id, (a) => {
          a.id = e.id, a.app = e.app, a.text = e.text, a.html = e.html, a.embed = e.embed, a.meeting = e.meeting, a.attachments = e.attachments, a.options = e.options, a.created_at = e.created_at, a.created_by = e.created_by, a.updated_at = e.updated_at, a.updated_by = e.updated_by;
        }) : da(n.queryClient, r, e), e.parent?.type === li.Post && ge(t, ["posts", e.app.id], e.parent.id, (a) => {
          a.comments ? a.comments.count += 1 : a.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
c(bV, "h4");
h(bV, "getAddCommentMutationOptions");
function $V(n, t, e) {
  const i = n.queryClient, r = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ h(async ({ id: s }) => {
      if (!(await n.fetch("/api/comments/" + s + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((s) => {
      St(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        s.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((s, a) => {
      St(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, s)
      ), ge(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return r;
}
c($V, "p4");
h($V, "getTrashCommentMutationOptions");
function xV(n, t, e) {
  return new Zt(n.queryClient, $V(n, t, e));
}
c(xV, "u4");
h(xV, "getTrashCommentMutation");
function kV(n, t, e) {
  const i = n.queryClient, r = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ h(async ({ id: s }) => {
      const a = await n.fetch("/api/comments/" + s + "/restore", { method: "POST" });
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((s) => {
      St(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        s.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((s, a) => {
      St(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, s)
      ), ge(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count += 1;
      });
    }, "onSuccess")
  };
  return r;
}
c(kV, "y4");
h(kV, "getRestoreCommentMutationOptions");
function SV(n, t, e) {
  return new Zt(n.queryClient, kV(n, t, e));
}
c(SV, "w4");
h(SV, "getRestoreCommentMutation");
const I4 = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}:host(wy-comments){--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-comment-list-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-comments]{display:flex;flex-direction:column}[part~=wy-comment]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));margin-bottom:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-comment][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-comment-reveal]{interpolate-size:allow-keywords;overflow:hidden;transition:height var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-bottom var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-duration-fast, .1s);height:auto;opacity:1}@starting-style{[part~=wy-comment-reveal]{height:0;margin-bottom:0;opacity:0}}[part~=wy-comment-skeleton]{transition-delay:var(--wy-transition-reveal-delay, 1s)}[part~=wy-comment-body]{display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0;flex:1 1 100%}[part~=wy-comment-footer]{margin-left:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}wy-comment::part(wy-editor){padding-left:0;padding-right:0;margin-right:calc(-1*var(--wy-size, 1rem))}`, rG = 1e3 * 60 * 60, Z$ = rG * 24;
function Wl(n, t, e, i = 7) {
  e ??= /* @__PURE__ */ new Date();
  const r = new Date(e.getFullYear(), e.getMonth(), e.getDate()), s = t.valueOf() - e.valueOf(), a = t.toDateString() === e.toDateString(), o = t.valueOf() > r.valueOf() - Z$ * i && t.valueOf() < r.valueOf() + Z$ * i;
  if (!a && o) {
    const l = Math.round(s / Z$);
    return new Intl.RelativeTimeFormat(n, { numeric: "auto" }).format(l, "days");
  } else return a ? new Intl.DateTimeFormat(n, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(n, { dateStyle: "short" }).format(t);
}
c(Wl, "jc");
h(Wl, "relativeTime");
const CV = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}`;
var sG = Object.defineProperty, aG = Object.getOwnPropertyDescriptor, ql = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? aG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && sG(t, e, r), r;
}, "__decorateClass$L"), X$, zf;
let ur = (X$ = (zf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.location = "apps", this.highlight = !1, this.reveal = !1, this.editing = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt(), this.updateCommentMutation = new Rn(this);
  }
  /**
   * Dispatch a poll vote event for this comment.
   *
   * @internal
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.comment.id, parentType: "comments" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a trash event for this comment.
   *
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.comment.id } });
    return this.dispatchEvent(t);
  }
  /**
   * Dispatch a restore event for this comment.
   *
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { id: this.comment.id }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Submit updated comment content via mutation and exit edit mode.
   *
   * @internal
   */
  updateComment(t) {
    this.updateCommentMutation.mutate({
      id: this.comment.id,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.editing = !1;
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      OV(this.weavy, [this.location, this.parentId, "comments"])
    ), t.has("link") && (this.highlight = !!(this.link && w1(this.link, li.Comment, { id: this.comment.id }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    const t = this.comment.attachments?.data?.filter((a) => a.kind === "image" && a.thumbnail_url) || [], e = this.comment.attachments?.data?.filter((a) => a.kind !== "image" || !a.thumbnail_url) || [], i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.comment.created_at)), r = Wl(this.weavy?.locale, new Date(this.comment.created_at)), s = this.comment.id < 0;
    return v`
      <div part="wy-comment ${ut({ "wy-comment-reveal": this.reveal, "wy-comment-skeleton": s })}">
        ${s ? v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                      ${this.comment.updated_at ? v`<time datetime=${this.comment.updated_at}> · ${P("edited")}</time>` : C}
                    </small>
                  </div>
                  ${this.comment.html ? v`<div part="wy-content"><wy-skeleton .text=${this.comment.text}></wy-skeleton></div>` : ""}
                </div>
              </wy-item>
            ` : this.comment.is_trashed ? v`
              <wy-item part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <span part="wy-trashed" slot="title">${P("Comment was trashed.")}</span>
                <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
                  >${P("Undo")}</wy-button
                >
              </wy-item>
            ` : this.editing ? v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <wy-button small slot="actions" @click=${() => this.editing = !1} kind="icon">
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}

                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                    </small>
                  </div>
                  <wy-editor
                    editorLocation=${this.location}
                    .text=${this.comment.text}
                    .embed=${this.comment.embed}
                    .options=${this.comment.options?.data}
                    .attachments=${this.comment.attachments?.data ?? []}
                    .parentId=${this.comment.id}
                    .typing=${!1}
                    .draft=${!1}
                    placeholder=${P("Edit comment...")}
                    buttonText=${P("Update", { desc: "Button action to update" })}
                    @submit=${(a) => this.updateComment(a)}
                  ></wy-editor>
                </div>
              </wy-item>
            ` : v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src=${this.comment.created_by.avatar_url}
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>

                ${this.user && this.user.id === this.comment.created_by.id ? v`
                      <wy-dropdown small slot="actions">
                        ${this.user.id === this.comment.created_by.id ? v`
                              <wy-dropdown-item @click=${() => this.editing = !0}>
                                <wy-icon name="pencil"></wy-icon>
                                ${P("Edit")}
                              </wy-dropdown-item>
                            ` : C}
                        ${this.user.id === this.comment.created_by.id ? v`
                              <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                                <wy-icon name="trashcan"></wy-icon>
                                ${P("Trash")}
                              </wy-dropdown-item>
                            ` : C}
                      </wy-dropdown>
                    ` : C}

                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                      ${this.comment.updated_at ? v`<time datetime=${this.comment.updated_at}> · ${P("edited")}</time>` : C}
                    </small>
                  </div>

                  <!-- image grid -->
                  ${t && t.length ? v`<wy-image-grid
                        part="wy-comment-images"
                        .images=${t}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- text content -->
                  ${this.comment.html ? v`<div part="wy-content">${ll(this.comment.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.comment.annotations?.data?.length ? v`<wy-annotation-list
                        .files=${this.comment.annotations.data}
                        @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-annotation-list>` : C}

                  <!-- poll -->
                  ${this.comment.options?.data?.length ? v`
                        <wy-poll
                          .pollOptions=${this.comment.options.data}
                          @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                        ></wy-poll>
                      ` : C}

                  <!-- embeds -->
                  ${this.comment.embed && this.componentFeatures?.allowsFeature(I.Embeds) ? v` <wy-embed .embed=${this.comment.embed}></wy-embed> ` : C}

                  <!-- files -->
                  ${e.length ? v`<wy-attachment-list
                        filled
                        .files=${e ?? []}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachment-list>` : ""}

                  <!-- meeting -->
                  ${this.comment.meeting ? v`<wy-meeting-card .meeting=${this.comment.meeting}></wy-meeting-card>` : ""}

                  <div part="wy-comment-footer">
                    ${this.componentFeatures?.allowsFeature(I.Reactions) ? v` <wy-reactions
                          lineReverse
                          small
                          .reactions=${this.comment.reactions?.data}
                          parentType=${this.location}
                          parentId=${this.parentId}
                          entityId=${this.comment.id}
                          entityType="comments"
                        ></wy-reactions>` : C}
                    ${this.comment.annotations?.data?.length ? v`<wy-preview
                          ${at(this.previewAnnotationsRef)}
                          .files=${this.comment.annotations.data}
                          .isAttachment=${!0}
                        ></wy-preview> ` : C}
                    ${this.comment.attachments?.data?.length ? v`<wy-preview
                          ${at(this.previewAttachmentsRef)}
                          .files=${[...t, ...e]}
                          .isAttachment=${!0}
                        ></wy-preview> ` : C}
                  </div>
                </div>
              </wy-item>
            `}
      </div>
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(zf, "mo"), zf), h(X$, "WyComment"), X$);
ur.styles = [re, I4, by, CV, R4, ft];
ql([
  O({ type: Object, attribute: !1 })
], ur.prototype, "comment", 2);
ql([
  O({ type: Number })
], ur.prototype, "parentId", 2);
ql([
  O({ attribute: !1 })
], ur.prototype, "location", 2);
ql([
  Z()
], ur.prototype, "highlight", 2);
ql([
  O({ type: Boolean, reflect: !0 })
], ur.prototype, "reveal", 2);
ql([
  Z()
], ur.prototype, "editing", 2);
ur = ql([
  U("wy-comment"),
  kt()
], ur);
const oG = tt`[part~=wy-comment-editor]{position:relative;border-radius:var(--wy-padding-outer, var(--wy-padding, 0))}[part~=wy-comment-editor-bottom]{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-component-border-radius);color:var(--wy-component-color)}[part~=wy-comment-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-comment-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{padding-top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-comment-editor] .cm-editor{flex:1 1 100%;max-height:calc(11.25*var(--wy-size, 1rem));background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:calc(1.25*var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-comment-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-comment-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor] [part~=wy-is-invalid]+.cm-editor,[part~=wy-comment-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var N$, f9;
function PV() {
  if (f9) return N$;
  f9 = 1;
  var n = "Expected a function", t = NaN, e = "[object Symbol]", i = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, a = /^0o[0-7]+$/i, o = parseInt, l = typeof Y1 == "object" && Y1 && Y1.Object === Object && Y1, d = typeof self == "object" && self && self.Object === Object && self, u = l || d || Function("return this")(), p = Object.prototype, f = p.toString, y = Math.max, g = Math.min, b = /* @__PURE__ */ h(function() {
    return u.Date.now();
  }, "now");
  function S(V, D, X) {
    var Y, mt, ct, et, bt, st, Rt = 0, Qt = !1, It = !1, Wt = !0;
    if (typeof V != "function")
      throw new TypeError(n);
    D = A(D) || 0, Q(X) && (Qt = !!X.leading, It = "maxWait" in X, ct = It ? y(A(X.maxWait) || 0, D) : ct, Wt = "trailing" in X ? !!X.trailing : Wt);
    function qt(Bt) {
      var wn = Y, Aa = mt;
      return Y = mt = void 0, Rt = Bt, et = V.apply(Aa, wn), et;
    }
    c(qt, "Kt"), h(qt, "invokeFunc");
    function xi(Bt) {
      return Rt = Bt, bt = setTimeout(ee, D), Qt ? qt(Bt) : et;
    }
    c(xi, "rt"), h(xi, "leadingEdge");
    function Ee(Bt) {
      var wn = Bt - st, Aa = Bt - Rt, jl = D - wn;
      return It ? g(jl, ct - Aa) : jl;
    }
    c(Ee, "gt"), h(Ee, "remainingWait");
    function le(Bt) {
      var wn = Bt - st, Aa = Bt - Rt;
      return st === void 0 || wn >= D || wn < 0 || It && Aa >= ct;
    }
    c(le, "ri"), h(le, "shouldInvoke");
    function ee() {
      var Bt = b();
      if (le(Bt))
        return fe(Bt);
      bt = setTimeout(ee, Ee(Bt));
    }
    c(ee, "Be"), h(ee, "timerExpired");
    function fe(Bt) {
      return bt = void 0, Wt && Y ? qt(Bt) : (Y = mt = void 0, et);
    }
    c(fe, "Ei"), h(fe, "trailingEdge");
    function ki() {
      bt !== void 0 && clearTimeout(bt), Rt = 0, Y = st = mt = bt = void 0;
    }
    c(ki, "Li"), h(ki, "cancel");
    function Wi() {
      return bt === void 0 ? et : fe(b());
    }
    c(Wi, "Zc"), h(Wi, "flush");
    function rn() {
      var Bt = b(), wn = le(Bt);
      if (Y = arguments, mt = this, st = Bt, wn) {
        if (bt === void 0)
          return xi(st);
        if (It)
          return bt = setTimeout(ee, D), qt(st);
      }
      return bt === void 0 && (bt = setTimeout(ee, D)), et;
    }
    return c(rn, "pi"), h(rn, "debounced"), rn.cancel = ki, rn.flush = Wi, rn;
  }
  c(S, "I"), h(S, "debounce");
  function $(V, D, X) {
    var Y = !0, mt = !0;
    if (typeof V != "function")
      throw new TypeError(n);
    return Q(X) && (Y = "leading" in X ? !!X.leading : Y, mt = "trailing" in X ? !!X.trailing : mt), S(V, D, {
      leading: Y,
      maxWait: D,
      trailing: mt
    });
  }
  c($, "A"), h($, "throttle");
  function Q(V) {
    var D = typeof V;
    return !!V && (D == "object" || D == "function");
  }
  c(Q, "E"), h(Q, "isObject");
  function E(V) {
    return !!V && typeof V == "object";
  }
  c(E, "T"), h(E, "isObjectLike");
  function z(V) {
    return typeof V == "symbol" || E(V) && f.call(V) == e;
  }
  c(z, "q"), h(z, "isSymbol");
  function A(V) {
    if (typeof V == "number")
      return V;
    if (z(V))
      return t;
    if (Q(V)) {
      var D = typeof V.valueOf == "function" ? V.valueOf() : V;
      V = Q(D) ? D + "" : D;
    }
    if (typeof V != "string")
      return V === 0 ? V : +V;
    V = V.replace(i, "");
    var X = s.test(V);
    return X || a.test(V) ? o(V.slice(2), X ? 2 : 8) : r.test(V) ? t : +V;
  }
  return c(A, "R"), h(A, "toNumber"), N$ = $, N$;
}
c(PV, "b4");
h(PV, "requireLodash_throttle");
var lG = PV();
const oS = /* @__PURE__ */ k_(lG);
function QV(n, t) {
  return new Zt(n.queryClient, {
    mutationFn: /* @__PURE__ */ h(async () => await n.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
c(QV, "$4");
h(QV, "typingMutation");
function lS(n, t) {
  return new Zt(n.queryClient, {
    mutationFn: /* @__PURE__ */ h(async () => {
      const e = await n.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
c(lS, "wf");
h(lS, "addMeetingMutation");
async function TV(n, t) {
  const e = await n.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const i = await e.json();
    throw new Error(i.detail || i.title, { cause: i });
  }
  return await e.json();
}
c(TV, "C4");
h(TV, "externalBlob");
function MV(n, t, e, i) {
  const r = n.queryClient, s = ["apps", e, "blobs", i];
  return {
    mutationFn: /* @__PURE__ */ h(async (a) => await TV(n, a.externalBlob), "mutationFn"),
    mutationKey: s,
    onMutate: /* @__PURE__ */ h(async (a) => (await r.cancelQueries({ queryKey: s, exact: !0 }), { type: "attach", file: ZP(void 0, a.externalBlob.name, a.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((a, o, l) => {
      se(r, s, o, (d) => {
        d.status.state = "ok", d.status.progress = void 0, d.status.text = void 0;
      });
    }, "onSuccess"),
    onError(a, o, l) {
      const d = a.cause;
      d && d.status === 409 ? se(r, s, o, (u) => {
        u.status.state = "conflict", u.status.progress = void 0, u.status.text = d.detail || d.title;
      }) : se(r, s, o, (u) => {
        u && (u.status.state = "error", u.status.progress = void 0, u.status.text = d.detail || d.title);
      });
    }
  };
}
c(MV, "k4");
h(MV, "getExternalBlobMutationOptions");
function V4(n, t, e, i) {
  return new Zt(n.queryClient, MV(n, t, e, i));
}
c(V4, "$v");
h(V4, "getExternalBlobMutation");
const cG = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let Bc = [], jw = [], p0 = [], Uv = [], Rr = {};
const hG = /* @__PURE__ */ h((n, t) => n.length === t.length && n.every((e, i) => e === t[i]), "arrayEquals");
function AV() {
  return !!Object.keys(Rr).length;
}
c(AV, "M4");
h(AV, "isFetchingEmbeds");
async function RV(n, t) {
  let e;
  try {
    const i = await t.fetch(`/api/embeds?url=${encodeURIComponent(n)}`);
    if (!i.ok)
      throw new Error();
    e = await i.json(), delete Rr[n], jw = [...jw, n];
  } catch {
    p0 = [...p0, n], delete Rr[n];
  }
  return e;
}
c(RV, "S4");
h(RV, "fetchEmbed");
const dG = /* @__PURE__ */ h(() => {
  Bc = [], jw = [], p0 = [], Uv = [], Rr = {};
}, "clearEmbeds"), m9 = /* @__PURE__ */ h((n) => {
  jw = n;
}, "initEmbeds"), uG = /* @__PURE__ */ h((n, t, e) => {
  let i = n.match(cG)?.map((r) => r) || null;
  if (i !== null && (i = i.map((r) => r.startsWith("//") ? "http:" + r : !r.startsWith("http://") && !r.startsWith("https://") ? "http://" + r : r)), !(i === null || i.length === 0) && (i.length !== Bc.length || !hG(i, Bc))) {
    Bc = i, i.forEach((r) => {
      !jw.includes(r) && !p0.includes(r) && !Uv.includes(r) && typeof Rr[r] > "u" && (we(), Rr[r] = window.setTimeout(async () => {
        const s = await RV(r, e);
        s && t(s);
      }, 500));
    }), Uv = Uv.filter((r) => Bc.includes(r));
    for (const r in Rr)
      Bc.includes(r) || (we(), window.clearTimeout(Rr[r]), delete Rr[r]);
  }
}, "getEmbeds"), an = g0() ? window.navigator.userAgent : "", EV = an.includes("iPad") || an.includes("Android") && !an.includes("Mobi") || !1, pG = an.includes("Mobi") || EV || !1, fG = !pG && !EV, y9 = an.includes("Windows") ? "Windows" : an.includes("Macintosh") ? "Mac" : an.includes("iPad") || an.includes("iPhone") || an.includes("iPod") ? "iOS" : an.includes("Android") ? "Android" : void 0;
y9 === "Android" && an.includes("; wv") || y9 === "iOS" && an.includes("Safari");
const mG = tt`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}[part~=wy-code] pre,.wy-code pre,[part~=wy-editor] .cm-content pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content .code,[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-editor] .cm-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-editor] .cm-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-editor] .cm-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-editor] .cm-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-editor] .cm-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-editor] .cm-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-editor] .cm-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-editor] .cm-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-editor] .cm-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-editor] .cm-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-editor] .cm-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-editor] .cm-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-editor] .cm-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-editor] .cm-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-editor] .cm-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-editor] .cm-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-editor] .cm-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-editor] .cm-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-editor] .cm-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-editor] .cm-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-editor] .cm-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-editor] .cm-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-editor] .cm-content .token.important,[part~=wy-editor] .cm-content .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-editor] .cm-content .token.italic{font-style:italic}[part~=wy-editor]{box-sizing:border-box}[part~=wy-editor] .cm-scroller{font-family:unset;line-height:1.5}[part~=wy-editor] .cm-widgetBuffer{vertical-align:unset}[part~=wy-editor] .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-editor] .cm-content{caret-color:var(--wy-on-background, var(--wy-on-background-light, #181c20))}[part~=wy-editor] .cm-content ::part(wy-link){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-editor] .wy-mention{font-weight:700}[part~=wy-editor] .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}[part~=wy-editor] .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-editor] .cm-editor .cm-scroller{overflow:auto}[part~=wy-editor] .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15*var(--wy-size, 1rem))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}[part~=wy-editor] .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}[part~=wy-editor] .cm-tooltip-autocomplete ul li[aria-selected] wy-item{background:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:unset}[part~=wy-editor] .cm-tooltip-autocomplete .cm-completionLabel{display:none}[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):hover,[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):focus{background:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}`, yG = tt`[part~=wy-post-editor]{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-editor-buttons]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));flex:1 0 auto}[part~=wy-post-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-post-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);caret-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor] .cm-editor .cm-line{padding:0}[part~=wy-post-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-post-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`, _V = tt`[part~=wy-dragging]:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125*var(--wy-size, 1rem)) dashed var(--wy-outline, var(--wy-outline-light, #72777f));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));font-size:calc(1.5*var(--wy-size, 1rem));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}`;
var gG = Object.defineProperty, wG = Object.getOwnPropertyDescriptor, Fl = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? wG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && gG(t, e, r), r;
}, "__decorateClass$K"), j$, Lf;
let pr = (j$ = (Lf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.status = {
      state: "ok"
    }, this.interactive = !1, this.rounded = !1, this.isRenaming = !1;
  }
  /**
   * Emit an `edit-name` event requesting rename mode for the provided file.
   *
   * @param file - File that should enter rename mode.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event with a new filename.
   *
   * @param file - File being renamed.
   * @param name - New filename to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File slated for trashing.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover the provided file.
   *
   * @param file - File to restore from trash.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: e } = ls(t.name), i = en(t.name), r = /* @__PURE__ */ h((a) => {
      a.stopImmediatePropagation();
      const o = a.target;
      o.value && o.value !== t.name ? this.dispatchRename(t, o.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), s = /* @__PURE__ */ h((a) => {
      const o = a.target;
      a.key === "Escape" ? (a.preventDefault(), o.value = t.name, o.blur()) : a.key === "Enter" && (a.preventDefault(), o.blur());
    }, "handleRenameKey");
    return v`
      <wy-item
        ?rounded=${this.rounded}
        ?interactive=${this.interactive && !t.is_trashed && !this.isRenaming}
        ?trashed=${t.is_trashed}
        title=${t.name}
        size="sm"
      >
        ${this.status.state === "error" ? v`<wy-icon
              slot="image"
              name="alert-octagon"
              color="error"
              title=${Ot(this.status.text)}
            ></wy-icon>` : this.status.state === "conflict" ? v`<wy-icon slot="image" name="alert" color="yellow" title=${Ot(this.status.text)}></wy-icon>` : v`<wy-icon slot="image" .name=${e} .size=${24} .kind=${t.kind} ext=${i}></wy-icon>`}
        ${this.isRenaming ? v`
              <input
                slot="title"
                type="text"
                maxlength="256"
                part="wy-input"
                .defaultValue=${t.name}
                @blur=${r}
                @keyup=${(a) => {
      Hr(a), s(a);
    }}
                @click=${(a) => a.preventDefault()}
                @focus=${tb}
                ${at(uS)}
              />
            ` : v`
              <span slot="title" title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}>
                <slot name="title"
                  >${this.title || t.name}${this.status.text ? v`: <em>${this.status.text}</em>` : C}</slot
                >
              </span>
            `}

        <slot slot="actions" name="actions">
          <wy-file-menu
            .file=${t}
            @edit-name=${(a) => this.dispatchEditName(a.detail.file)}
            @trash=${(a) => this.dispatchTrash(a.detail.file)}
            @restore=${(a) => this.dispatchRestore(a.detail.file)}
            @delete-forever=${(a) => this.dispatchDeleteForever(a.detail.file)}
            @subscribe=${(a) => this.dispatchSubscribe(a.detail.file, a.detail.subscribe)}
          >
          </wy-file-menu>
        </slot>
      </wy-item>
    `;
  }
}, c(Lf, "vo"), Lf), h(j$, "WyFileItem"), j$);
pr.styles = [Qa];
Fl([
  O({ type: Object })
], pr.prototype, "file", 2);
Fl([
  O({ type: Object })
], pr.prototype, "status", 2);
Fl([
  O({ type: Boolean })
], pr.prototype, "interactive", 2);
Fl([
  O({ type: Boolean })
], pr.prototype, "rounded", 2);
Fl([
  O()
], pr.prototype, "actionType", 2);
Fl([
  Z()
], pr.prototype, "isRenaming", 2);
pr = Fl([
  U("wy-file-item")
], pr);
const vG = /* @__PURE__ */ h((n) => {
  var p;
  var t, e, i, r, s, a, o, l, d, u;
  return u = (p = class extends n {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...y) {
      super(...y), F(this, r), F(this, t, []), F(this, e), F(this, i, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return x(this, e);
    }
    set eventParent(y) {
      y?.eventChildren && y.eventChildren.add(this), L(this, e, y);
    }
    get eventChildren() {
      return x(this, i);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...y) {
      const g = vt(this, r, d).call(this, y);
      if (y[3]) {
        const b = /* @__PURE__ */ h((...S) => {
          try {
            g.handler.apply(this, S);
          } catch {
            try {
              g.handler();
            } catch ($) {
              console.warn("Could not invoke one handler:", $);
            }
          }
          vt(this, r, o).call(this, g.events, g.selector, null, g.handler);
        }, "attachedHandler");
        vt(this, r, s).call(this, g.events, g.selector, b, g.handler);
      } else
        vt(this, r, s).call(this, g.events, g.selector, g.handler, g.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(y, g, b) {
      this.on(y, g, b, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...y) {
      const g = vt(this, r, d).call(this, y), b = vt(this, r, a).call(this, g.events, g.selector, g.handler);
      return vt(this, r, o).call(this, g.events, g.selector, b, g.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      x(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(y, g, ...b) {
      const S = /^(before|on|after):/.test(y), $ = S ? y.split(":")[0] : "";
      y = y.replace(/^(before|on|after):/, "");
      const Q = "before:" + y, E = y, z = "after:" + y;
      if (g && typeof g == "string")
        try {
          g = JSON.parse(g);
        } catch {
          console.warn("Could not parse event data", y, g);
        }
      let A;
      if (S) {
        if ($ === "before" || $ === "after") {
          if (x(this, e) && (A = x(this, e).triggerEvent(
            $ === "before" ? Q : z,
            g,
            ...b
          ), g = A || A === !1 ? A : g, g === !1) || (A = vt(this, r, l).call(this, $ === "before" ? Q : z, g, ...b), g = A || A === !1 ? A : g, g === !1))
            return g;
        } else if ($ === "on" && (A = vt(this, r, l).call(this, E, g, ...b), g = A || A === !1 ? A : g, g === !1 || x(this, e) && (A = x(this, e).triggerEvent("on:" + E, g, ...b), g = A || A === !1 ? A : g, g === !1)))
          return g;
      } else {
        if (x(this, e) && (A = x(this, e).triggerEvent(Q, g, ...b), g = A || A === !1 ? A : g, g === !1) || (A = vt(this, r, l).call(this, Q, g, ...b), g = A || A === !1 ? A : g, g === !1) || (A = vt(this, r, l).call(this, E, g, ...b), g = A || A === !1 ? A : g, g === !1) || x(this, e) && (A = x(this, e).triggerEvent("on:" + E, g, ...b), g = A || A === !1 ? A : g, g === !1) || x(this, e) && (A = x(this, e).triggerEvent(z, g, ...b), g = A || A === !1 ? A : g, g === !1))
          return g;
        A = vt(this, r, l).call(this, z, g, ...b), g = A || A === !1 ? A : g;
      }
      return g;
    }
  }, c(p, "f"), p), t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakSet(), /**
  * Saves a single event handler.
  *
  * @internal
  * @function
  * @param {string} event - One or more events. Multiple events are currently not registered individually.
  * @param {string|Object} [selector] - Optional refinement selector
  * @param {function} handler - The handler function. may be wrapped for once-handlers
  * @param {function} originalHandler - The original non-wrapped event handler.
  */
  s = /* @__PURE__ */ h(function(f, y, g, b) {
    x(this, t).push({
      events: f,
      selector: y,
      handler: g,
      originalHandler: b
    });
  }, "#registerEventHandler"), /**
  * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} events - The events registered
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @param {function} handler - The registered handler
  * @param {function} [originalHandler] - The original registered handler
  */
  a = /* @__PURE__ */ h(function(f, y, g, b) {
    const S = {
      events: f,
      selector: y,
      handler: g,
      originalHandler: b || g
    }, $ = x(this, t).filter((Q) => lo(S, Q, !0)).pop();
    return $ && $.handler;
  }, "#getEventHandler"), /**
  * Unregister an event handler. Arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} event - The events registered
  * @param {function} handler - The registered handler
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @returns {boolean} - True if any handler was removed
  */
  o = /* @__PURE__ */ h(function(f, y, g, b) {
    const S = {
      events: f,
      selector: y,
      handler: g,
      originalHandler: b
    };
    let $ = !1;
    return x(this, t).forEach((Q, E) => {
      lo(S, Q, !0) && ($ = !0, x(this, t).splice(E, 1));
    }), $;
  }, "#unregisterEventHandler"), /**
  * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
  *
  * @example
  * weavyEvents.on("myevent", function(e, data) { ... })
  *
  * triggerHandler(this, "myevent", { key: 1 })
  *
  * @internal
  * @function
  * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
  * @param {any} data - Any data to pass to the handler
  * @param {any} ...additionalData - Any extra data
  */
  l = /* @__PURE__ */ h(function(f, y, ...g) {
    let b = !1;
    return x(this, t).forEach((S) => {
      S.events.split(" ").forEach(($) => {
        if ($ = $.indexOf("on:") === 0 ? $.split("on:")[1] : $, f === $ && (!S.selector || lo(S.selector, y, !0))) {
          const Q = S.handler(y, ...g);
          Q ? y = Q : Q === !1 && (b = !0);
        }
      });
    }), b ? !1 : y;
  }, "#triggerHandler"), /**
  * Extracts and normalizes all parts of the events arguments.
  *
  * @internal
  * @function
  * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
  * @returns {Object}
  * @property {string} events - Event names with added namespace for local events.
  * @property {string|Object} selector - The optional selector.
  * @property {function} handler - The handler function
  * @
  */
  d = /* @__PURE__ */ h(function(f) {
    const y = typeof f[1] == "function" ? f[1] : f[2], g = typeof f[1] == "function" ? null : f[1];
    return { events: f[0], selector: g, handler: y };
  }, "#getEventArguments"), h(u, "WeavyEvents"), u;
}, "MixinWeavyEvents"), OG = vG(class {
});
function cS(n) {
  let t = "";
  try {
    t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(n)?.[1] || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
c(cS, "vf");
h(cS, "extractOrigin");
var If;
const zV = (If = class extends OG {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = g0() ? cS(window.location.href) : "", this.timeout = 2e3, t?.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            e.source?.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const i = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, r = e.source ? this.contentWindowNames.get(e.source) : void 0;
              r && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: r,
                  weavyId: i || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (i) {
              console.error("could not register frame window", i);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && this.contentWindowsMapByWeavyId.get(e.data.weavyId)?.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const i = t.source === window && t.origin === this.origin;
    if (e ||= t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1, i || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const r = t.data.name;
      r && this.triggerEvent(r, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, i, r) {
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!i || i === "true") && (i = !0), this.contentWindowsMapByWeavyId.has(i) || this.contentWindowsMapByWeavyId.set(i, /* @__PURE__ */ new Map()), this.contentWindowsMapByWeavyId.get(i)?.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, i), this.contentWindowOrigins.set(t, r);
  }
  unregisterAll(t) {
    this.contentWindowsMapByWeavyId.has(t) && (this.contentWindowsMapByWeavyId.get(t)?.forEach((e, i) => {
      this.unregisterContentWindow(i, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if (this.contentWindowsMapByWeavyId.get(e)?.has(t)) {
        const i = this.contentWindowsMapByWeavyId.get(e)?.get(t);
        if (i)
          try {
            this.contentWindows.delete(i), this.contentWindowNames.delete(i), this.contentWindowWeavyIds.delete(i), this.contentWindowOrigins.delete(i);
          } catch {
          }
      }
      if (this.contentWindowsMapByWeavyId.get(e)?.delete(t), this.contentWindowsMapByWeavyId.get(e)?.size === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, i) {
    we(), i === null && (i = void 0);
    const r = t === window.self, s = r ? cS(window.location.href) : this.contentWindowOrigins.get(t);
    if (r || t && s === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = Xm() + Xm());
      let a;
      await Promise.race([
        new Promise((o, l) => {
          a = window.setTimeout(() => {
            l(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((o) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(a), o(void 0);
          }), t.postMessage(e, { targetOrigin: s, transfer: i });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + s + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((i) => {
      const r = this.contentWindowOrigins.get(i);
      if (r === this.contentWindowDomain.get(i))
        try {
          i.postMessage(t, { targetOrigin: r, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(i)
          );
        }
    });
  }
  async postToFrame(t, e, i, r) {
    if (typeof i != "object" || !i.name) {
      console.error("postToFrame() Invalid message format", i);
      return;
    }
    const s = this.contentWindowsMapByWeavyId.get(e)?.get(t);
    if (!s)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return i.weavyId = e, await this.whenPostMessage(s, i, r);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, i) {
    if (t.source && t.data.weavyId !== void 0) {
      const r = t.source === window.self && t.origin === this.origin, s = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (i === null && (i = void 0), r || s) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: i });
        } catch (a) {
          console.error("postToSource() Could not post message back to source", a);
        }
      }
    }
  }
}, c(If, "vw"), If);
h(zV, "WeavyPostalParent");
let bG = zV;
var $G = Object.defineProperty, xG = Object.getOwnPropertyDescriptor, xb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $G(t, e, r), r;
}, "__decorateClass$J"), B$, Vf;
let wl = (B$ = (Vf = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = wt(), this.overlayRef = wt();
  }
  /**
   * Open the file picker overlay.
   */
  open() {
    this.showOverlay = !0;
  }
  /**
   * Close the file picker overlay.
   */
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  /**
   * Returns the topmost available window/frame origin used when building the iframe src.
   *
   * @internal
   */
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  /**
   * Trigger `external-blobs` event with any selected blobs.
   *
   * @internal
   * @param {ExternalBlobType[] | null} externalBlobs - The externally selected blobs.
   * @returns {boolean} Whether the event was successful.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new bG()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavyPostal?.off("add-external-blobs", this.handleFiles), this.weavyPostal?.off("request:file-browser-close", this.handleClose), this.weavyPostal?.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? this.iframeElementRef.value?.contentWindow && (this.weavyPostal.registerContentWindow(
      this.iframeElementRef.value?.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    return this.weavy ? v`
      <wy-overlay
        ?noHeader=${this.iframeVisible}
        part="wy-cloud-files-overlay"
        .show=${this.showOverlay}
        ${at(this.overlayRef)}
        @close=${() => this.close()}
      >
        ${this.showOverlay ? v`
              <wy-progress-circular
                part="wy-cloud-files-progress"
                indeterminate
                overlay
                ?hidden=${this.iframeVisible}
              ></wy-progress-circular>
              <iframe
                part="wy-cloud-picker-frame"
                ${at(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${Ot(this.src?.toString())}
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${P("Cloud File Browser")}
              ></iframe>
            ` : C}
      </wy-overlay>
    ` : C;
  }
}, c(Vf, "go"), Vf), h(B$, "WyCloudFiles"), B$);
wl.styles = [
  ft,
  tt`
      [part~="wy-cloud-picker-frame"] {
        flex: 1 1 100%;
        border: 0;
      }
    `
];
xb([
  Z()
], wl.prototype, "src", 2);
xb([
  Z()
], wl.prototype, "iframeVisible", 2);
xb([
  Z()
], wl.prototype, "showOverlay", 2);
wl = xb([
  U("wy-cloud-files"),
  kt()
], wl);
var kG = Object.defineProperty, SG = Object.getOwnPropertyDescriptor, te = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? SG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && kG(t, e, r), r;
}, "__decorateClass$I"), U$, Df;
let Vt = (U$ = (Df = class extends Oe {
  constructor() {
    super(), this.exportParts = new G(this), this.storage = wP("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this._embeds = [], this.draftKey = "", this.uploadBlobMutation = new Rn(
      this
    ), this.mutatingFiles = new eb(this), this.fileInputRef = wt(), this.cloudFilesRef = wt(), this.dropZone = new bL(this), this.keyMap = [], this.editorRef = wt(), this.editorInitialized = !1, this.throttledTyping = oS(
      async () => {
        this.weavy && this.app && !JO.has(this.app.type) && await QV(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = oS(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), i = await lS(this.weavy, e).mutate();
        i.auth_url || (this.meeting = i);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", Mw), this.addEventListener("keyup", Hr);
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  selectAllContent() {
    this.editor?.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Place cursor at the end of the editor content.
   *
   * @internal
   */
  setCursorLast() {
    this.editor?.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusInput() {
    this.editor?.focus();
  }
  set embeds(t) {
    const e = t.filter((i) => i.type !== "link" || i.title || i.description);
    this._embeds = [...e];
  }
  get embeds() {
    return this._embeds;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("app") && (this.mutationAppId = void 0), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? this.app?.id ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        ib(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = V4(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const e = this.storage.getItem(this.draftKey);
        if (e) {
          const i = JSON.parse(e);
          this.text = i.text, this.embeds = i.embeds, this.meeting = i.meeting, i.pollOptions?.length > 0 && (this.showPolls = !0, this.pollOptions = i.pollOptions), m9(this.embeds.map((r) => r.url).filter((r) => typeof r == "string"));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], m9(this.embeds.map((e) => e.url).filter((e) => typeof e == "string"))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor-7s3r7liE.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: i,
          history: r,
          dropCursor: s,
          mentions: a,
          autocompletion: o,
          placeholder: l,
          keymap: d,
          weavyKeymap: u,
          defaultKeymap: p,
          historyKeymap: f,
          markdown: y,
          languages: g,
          EditorView: b,
          EditorState: S,
          weavyEnterSendKeymap: $,
          weavyModifierEnterSendKeymap: Q,
          Compartment: E
        }) => {
          this.editorInitialized || (this.editorInitialized = !0, this.editorEditable = new E(), this.editorPlaceholder = new E(), this.editorKeymap = new E(), this.EditorView = b, this.placeholderExtension = l, this.keymapFacet = d, this.keymaps = {
            weavyEnterSendKeymap: $,
            weavyModifierEnterSendKeymap: Q,
            weavyKeymap: u,
            defaultKeymap: [...p],
            historyKeymap: [...f]
          }, this.editorExtensions = [
            b.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on",
              enterkeyhint: this.settings?.enterToSend === "always" ? "send" : "enter"
            }),
            r(),
            s(),
            a,
            o({
              override: this.componentFeatures?.allowsFeature(I.Mentions) ? [(z) => this.autocomplete(z)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ h(function(z, A) {
                    const V = document.createElement("wy-item");
                    V.interactive = !1, (!z.item?.access || z.item.access === ks.None) && (V.disabled = !0);
                    const D = document.createElement("wy-avatar");
                    D.slot = "image", D.src = z.item?.avatar_url || "", D.name = z.item?.name || "";
                    const X = document.createElement("span");
                    return X.slot = "title", X.innerText = z.item?.name || "", V.appendChild(D), V.appendChild(X), V;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            i(e, { fallback: !0 }),
            b.lineWrapping,
            y({ codeLanguages: g }),
            b.domEventHandlers({
              paste: /* @__PURE__ */ h((z, A) => {
                let V = [];
                const D = z.clipboardData?.items || [];
                for (const X of D)
                  if (X.kind === "file") {
                    const Y = X.getAsFile();
                    Y && (V = [...V, Y]);
                  }
                if (this.componentFeatures?.allowsFeature(I.Attachments) && V.length > 0) {
                  for (let X = 0; X < V.length; X++)
                    this.handleUploadFiles(V);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ h((z, A) => {
                this.text = A.state.doc.toString(), this.componentFeatures?.allowsFeature(I.Typing) && this.typing && A.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), this.componentFeatures?.allowsFeature(I.Embeds) && A.state.doc.toString() !== "" && this.handleEmbeds(A.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of(b.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            this.editorKeymap.of(this.keymapFacet.of(this.getKeymaps())),
            b.updateListener.of((z) => {
              this.setPlaceHolderText();
              const A = Array.from(
                (this.editor?.state).config.compartments.keys()
              );
              this.editorEditable = A[0], this.editorPlaceholder = A[1], this.editorKeymap = A[2];
            })
          ], this.editor || (this.editor = new b({
            state: S.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), this.editorRef.value?.addEventListener("wy-submit", this.submit.bind(this))));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
    t.has("settings") && this.editor && this.editorKeymap && this.keymapFacet && (this.editor.dispatch({
      // Update readonly state
      effects: this.editorKeymap.reconfigure(this.keymapFacet.of(this.getKeymaps()))
    }), this.setEnterKeyHint());
  }
  /**
   * Update the visible placeholder text within the fallback DOM copy.
   *
   * @internal
   */
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  /**
   * Update contentEditable attribute on the fallback editor.
   *
   * @internal
   */
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  /**
   * Update enter key hint on the content element.
   *
   * @internal
   */
  setEnterKeyHint() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.enterKeyHint = this.settings?.enterToSend === "always" ? "send" : "enter");
  }
  /**
   * Compute and return keymaps for the current settings/editor type.
   *
   * @internal
   */
  getKeymaps() {
    if (!this.keymaps)
      return [];
    const { weavyEnterSendKeymap: t, weavyModifierEnterSendKeymap: e, weavyKeymap: i, defaultKeymap: r, historyKeymap: s } = this.keymaps;
    let a = this.settings?.enterToSend === "never" ? [] : [...e];
    return ((!this.settings?.enterToSend || this.settings?.enterToSend === "auto") && this.editorType === "messages" && fG || this.settings?.enterToSend === "always") && (a = [...t, ...a]), [...a, ...i, ...r, ...s];
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  /**
   * Autocomplete handler for mentions. Returns completion results or null.
   *
   * Called by the editor to resolve mention suggestions.
   *
   * @internal
   * @param context - Completion context from the editor
   * @returns Promise<CompletionResult | null>
   */
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?:^|\s)(?!\]\()@(?=\S)([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const i = e?.text.substring(1), r = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${i}`)).json();
    let s = [];
    return r.data && (s = r.data.filter((a) => typeof a.name < "u").map((a) => ({
      item: a,
      label: a.name,
      apply: /* @__PURE__ */ h((o, l, d, u) => {
        const p = "[" + a.name + "](@u" + a.id.toString() + ")";
        let f = o.state.update({ changes: { from: d - 1, to: d } });
        o.dispatch(f), f = o.state.update({
          changes: { from: d - 1, to: u - 1, insert: p }
        }), o.dispatch(f);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: s,
      filter: !1
    };
  }
  /**
   * Handle files dropped on the editor.
   *
   * @internal
   * @param e - Drop files event
   */
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  /**
   * Upload array of File objects via the upload blob mutation controller.
   *
   * Preserves input value if provided and saves draft after each upload.
   *
   * @internal
   * @param files - FileList or array of File objects to upload
   * @param input - Optional input element to reset after upload
   */
  async handleUploadFiles(t, e) {
    if (t) {
      for (let i = 0; i < t.length; i++) {
        const r = { file: t[i] };
        await this.uploadBlobMutation.mutate(r), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  /**
   * Handle external blob imports (cloud/external sources).
   *
   * @internal
   * @param externalBlobs - Array of external blob descriptors
   */
  handleExternalBlobs(t) {
    if (t)
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        this.externalBlobMutation?.mutate({ externalBlob: i });
      }
  }
  /**
   * Handle removal/abortion of an upload mutation and clean cache state.
   *
   * @internal
   * @param mutation - Mutation state object to remove
   */
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || (t.status === "pending" && HO(t.variables) && t.variables.abort?.(), FP(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => e.state.data?.id === t.data?.id
    ));
  }
  /**
   * Persist draft to storage if draft mode is enabled.
   *
   * Saves editor text, embeds, poll options and ongoing file uploads to localStorage.
   *
   * @internal
   */
  saveDraft() {
    if (!this.draft || !this.storage) return;
    const t = this.mutatingFiles.result;
    let e = this.editor?.state.doc.toString();
    if (e === void 0 && (e = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((i) => i.text.trim() !== "").length === 0) && e === "")
      this.storage.removeItem(this.draftKey);
    else {
      const i = {
        meeting: this.meeting,
        text: e,
        pollOptions: this.pollOptions.filter((r) => r.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(i));
    }
  }
  /**
   * Handle removal of an attachment reference from the editor state.
   *
   * @internal
   * @param attachment - Attachment to remove
   */
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  /**
   * Submit the editor content by dispatching a `submit` event.
   *
   * Validates that there is content to submit and that no uploads/embeds are still processing.
   *
   * @internal
   */
  submit() {
    const t = this.mutatingFiles.result, e = t?.some((u) => u.status === "pending"), i = this.editor?.state.doc.toString().trim() ?? "", r = this.meeting?.id, s = t?.map((u) => u.data?.id).filter((u) => u), a = this.attachments?.map((u) => u.id) || [], o = this.pollOptions.filter((u) => u.text.trim() !== "");
    if (AV() || e || !this.contextDataBlobs || !i && !r && s?.length == 0 && o.length == 0 && a.length == 0 && this.embeds.length == 0)
      return;
    const l = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, d = new CustomEvent("submit", {
      detail: { text: i, meetingId: r, blobs: s, attachments: a, pollOptions: o, embedId: this.embeds[0]?.id, contextData: l },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(d), this.resetEditor();
  }
  /**
   * Reset the editor state after a successful submit.
   *
   * Clears editor content, removes pending uploads from the query cache and deletes the stored draft.
   *
   * @internal
   */
  resetEditor() {
    this.clearEditor(), this.weavy && this.mutationAppId && aL(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), this.storage?.removeItem(this.draftKey);
  }
  /**
   * Clear the editor UI and internal state (text, embeds, attachments, metadata).
   *
   * @internal
   */
  clearEditor() {
    this.editor?.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, dG();
  }
  /**
   * Create or initiate a meeting for the current user.
   *
   * If the meeting requires third-party auth, opens an auth popup; otherwise stores the created meeting.
   *
   * @internal
   * @param name - Provider key for the meeting (e.g. "zoom", "google", "microsoft")
   */
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const e = await lS(this.weavy, t).mutate();
    e.auth_url ? this.authWindow = window.open(e.auth_url, "oauthwin", "height=640,width=480") : this.meeting = e;
  }
  /**
   * Add a discovered embed to the editor and persist draft.
   *
   * @internal
   * @param embed - Embed object to add.
   */
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  /**
   * Scan content for embeds and add them via setEmbeds callback.
   *
   * @internal
   * @param content - Text content to scan for embed links.
   */
  handleEmbeds(t) {
    this.weavy && uG(t, this.setEmbeds.bind(this), this.weavy);
  }
  /**
   * Remove an embed by id from the editor embeds list and persist draft.
   *
   * @internal
   * @param e - Embed remove event containing embed id.
   */
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  /**
   * Cycle the primary embed (move first to the end) and persist draft.
   *
   * @internal
   */
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  /**
   * Toggle the poll UI in the editor and initialize default options when opened.
   *
   * @internal
   */
  openPolls() {
    this.showPolls ? this.showPolls = !1 : (this.pollOptions.length === 0 && (this.pollOptions = Array.from({ length: 3 }, () => ({ id: null, text: "" }))), this.showPolls = !0);
  }
  /**
   * Handle change to a poll option input and persist draft.
   *
   * @internal
   * @param e - Input event
   * @param index - Index of the poll option changed
   */
  handlePollOptionChange(t, e) {
    const i = [...this.pollOptions];
    i[e].text = t.target.value, this.pollOptions = i, this.saveDraft();
  }
  /**
   * Add a new poll option when focus reaches the last option (limit 5).
   *
   * @internal
   * @param e - Focus/keyboard event
   * @param index - Index of the poll option that triggered the add
   */
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const i = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, i], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? C : v`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return C;
  }
  renderMiddleSlot() {
    return v`
      <!-- Input -->
      <div part=${ut({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${at(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div part="wy-post-editor-inputs">
        <div part="wy-post-editor-buttons">
          ${this.componentFeatures?.allowsFeature(I.Attachments) ? v`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${P("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${at(this.fileInputRef)}
                  @click=${(t) => t.stopPropagation()}
                  @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : C}
          ${this.componentFeatures?.allowsFeature(I.CloudFiles) ? v`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${P("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : C}
          ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.ZoomMeetings) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${P("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.GoogleMeet) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${P("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.MicrosoftTeams) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${P("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsFeature(I.Polls) ? v`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${P("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : C}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  /**
   * Render the bottom slot which aggregates lists (polls, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderBottomSlot() {
    return [this.renderLists()];
  }
  /**
   * Render the lists section (poll options, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderLists() {
    const t = this.mutatingFiles.result, e = this.componentFeatures?.allowsFeature(I.Polls) && this.showPolls && this.pollOptions.length > 0 || !1, i = this.meeting?.provider === "zoom" && this.componentFeatures?.allowsAnyFeature(I.Meetings, I.ZoomMeetings) || this.meeting?.provider === "google" && this.componentFeatures?.allowsAnyFeature(I.Meetings, I.GoogleMeet) || this.meeting?.provider === "microsoft" && this.componentFeatures?.allowsAnyFeature(I.Meetings, I.MicrosoftTeams) || !1, r = t && t.length > 0 || !1, s = this.attachments && this.attachments.length > 0, a = this.componentFeatures?.allowsFeature(I.Embeds) && this.embeds.length > 0 || !1;
    return this.disabled || !(e || i || r || s || a) ? C : v` <div part="wy-editor-parts">
      <!-- polls -->
      ${e ? v`
            <div part="wy-poll-form">
              ${this.pollOptions.map((o, l) => {
      const d = l + 1;
      return v`<input
                  value="${o.text}"
                  part="wy-input"
                  type="text"
                  placeholder=${P(rt`Option ${d}`)}
                  @change=${(u) => this.handlePollOptionChange(u, l)}
                  @keyup=${Hr}
                  @focus=${(u) => this.handlePollOptionAdd(u, l)}
                />`;
    })}
            </div>
          ` : C}

      <!-- meetings -->
      ${i && this.meeting ? v`
            <wy-item size="sm">
              <wy-icon slot="image" svg="${d0(this.meeting.provider)}"></wy-icon>
              <span slot="title">${u0(this.meeting.provider)}</span>
              <wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-item>
          ` : C}

      <!-- blobs -->
      ${r && t ? v`<div>
            ${Mi(
      t,
      (o) => "mutation" + o.submittedAt,
      (o) => {
        if (o.context?.file) {
          const l = o.context.file, d = {
            ...o.context.status
          };
          return v`
                    <wy-file-item
                      .file=${o.context.file}
                      .status=${d}
                      title="${fP(o.context.type)}: ${l.name + (d.text ? `: ${d.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${l.name}
                        ${d.text ? v`: <em>${d.text}</em>` : C}</span
                      >
                      ${d.state === "pending" ? v`
                            <wy-progress-circular
                              slot="actions"
                              padded
                              ?indeterminate=${!d.progress}
                              .max=${100}
                              .value=${d.progress || 0}
                            ></wy-progress-circular>
                          ` : C}
                      <wy-button
                        slot="actions"
                        kind="icon"
                        @click=${() => {
            this.handleRemoveUpload(o);
          }}
                        title=${P("Discard", { desc: "Button action to discard" })}
                      >
                        <wy-icon name="close"></wy-icon>
                      </wy-button>
                    </wy-file-item>
                  `;
        }
        return C;
      }
    )}
          </div>` : C}

      <!-- attachments -->
      ${s ? this.attachments.map(
      (o) => v`<wy-file-item .file=${o} title="${o.name}">
              <span slot="title">${o.name}</span>
              <wy-button
                slot="actions"
                kind="icon"
                @click=${() => this.handleRemoveAttachment(o)}
                title=${P("Remove", { desc: "Button action to remove" })}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-file-item>`
    ) : C}

      <!-- embeds -->
      ${a ? v`
            <wy-embed-select
              .embeds=${this.embeds}
              @embed-remove=${(o) => this.removeEmbed(o)}
              @embed-swap=${() => this.swapEmbed()}
            ></wy-embed-select>
          ` : C}
    </div>`;
  }
  /**
   * Render the cloud files picker if cloud files feature is enabled.
   *
   * @internal
   */
  renderCloudFiles() {
    return this.disabled ? C : v`
      <wy-cloud-files
        ${at(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        part=${ut({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${P("Drop files here")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, c(Df, "bo"), Df), h(U$, "WyEditor"), U$);
Vt.styles = [re, mG, yG, E4, _V, Qa];
te([
  O({ type: Boolean })
], Vt.prototype, "disabled", 2);
te([
  O({ attribute: !1 })
], Vt.prototype, "parentId", 2);
te([
  O()
], Vt.prototype, "placeholder", 1);
te([
  O()
], Vt.prototype, "text", 2);
te([
  O({ type: Object })
], Vt.prototype, "metadata", 2);
te([
  O({ attribute: !1 })
], Vt.prototype, "embed", 2);
te([
  O({ attribute: !1 })
], Vt.prototype, "options", 2);
te([
  O({ attribute: !1 })
], Vt.prototype, "attachments", 2);
te([
  O()
], Vt.prototype, "buttonText", 2);
te([
  O({ type: Boolean })
], Vt.prototype, "typing", 2);
te([
  O({ type: Boolean })
], Vt.prototype, "draft", 2);
te([
  O()
], Vt.prototype, "editorType", 2);
te([
  O()
], Vt.prototype, "editorClass", 2);
te([
  O()
], Vt.prototype, "editorLocation", 2);
te([
  Z()
], Vt.prototype, "meeting", 2);
te([
  Z()
], Vt.prototype, "editorError", 2);
te([
  Z()
], Vt.prototype, "showPolls", 2);
te([
  Z()
], Vt.prototype, "pollOptions", 2);
te([
  Z()
], Vt.prototype, "embeds", 1);
te([
  Z()
], Vt.prototype, "draftKey", 2);
te([
  Z()
], Vt.prototype, "mutationAppId", 2);
te([
  Z()
], Vt.prototype, "keyMap", 2);
te([
  Z()
], Vt.prototype, "editorExtensions", 2);
te([
  Z()
], Vt.prototype, "editor", 2);
Vt = te([
  U("wy-editor"),
  kt()
], Vt);
var CG = Object.getOwnPropertyDescriptor, PG = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? CG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(r) || r);
  return r;
}, "__decorateClass$H"), H$, Wf;
let f0 = (H$ = (Wf = class extends Vt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && (this.editorLocation === "files" ? this.editorClass = "wy-comment-editor wy-comment-editor-bottom" : this.editorLocation === "apps" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom"));
  }
  /**
   * Render the top slot for comment editor with no content.
   *
   * @internal
   */
  renderTopSlot() {
    return C;
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return v`<div part="wy-comment-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      I.Attachments,
      I.CloudFiles,
      I.Meetings,
      I.ZoomMeetings,
      I.GoogleMeet,
      I.MicrosoftTeams,
      I.Polls
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(I.Attachments) ? v`<wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${at(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : C}
            ${this.componentFeatures?.allowsFeature(I.CloudFiles) ? v`<wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${P("From cloud")}</span>
                </wy-dropdown-item>` : C}
            ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsFeature(I.Polls) ? v`<wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${P("Poll")}</span>
                </wy-dropdown-item>` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div
        part=${ut({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${at(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render content that appears below the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, c(Wf, "xo"), Wf), h(H$, "WyCommentEditor"), H$);
f0.styles = [...Vt.styles, oG];
f0 = PG([
  U("wy-comment-editor"),
  kt()
], f0);
var QG = Object.defineProperty, TG = Object.getOwnPropertyDescriptor, LV = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$9"), Cy = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? TG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && QG(t, e, r), r;
}, "__decorateClass$G"), IV = /* @__PURE__ */ h((n, t, e) => t.has(n) || LV("Cannot " + e), "__accessCheck$9"), rv = /* @__PURE__ */ h((n, t, e) => (IV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$9"), Y$ = /* @__PURE__ */ h((n, t, e) => t.has(n) ? LV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$9"), G$ = /* @__PURE__ */ h((n, t, e, i) => (IV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$8"), Hv, hS, Uc, K$, qf;
let ts = (K$ = (qf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.location = "apps", this.reveal = !1, this.padded = !1, Y$(this, Hv), Y$(this, hS, new Promise((t) => {
      G$(this, Hv, t);
    })), this.commentsQuery = new Al(this), this.addCommentMutation = new Rn(this), this.infiniteScroll = new Rl(this), this.pagerRef = wt(), Y$(this, Uc), this.handleRealtimeCommentCreated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== li.Comment || ge(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          ey(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== li.Comment || ge(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          ey(e, void 0, t.actor);
        }
      );
    };
  }
  /**
   * Resolves when `parentId` is available.
   *
   * @returns Promise<number>
   */
  async whenParentId() {
    return await rv(this, hS);
  }
  async willUpdate(t) {
    var e, i;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((e = rv(this, Hv)) == null || e.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(vV(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(bV(this.weavy)), this.removeCommentMutation = xV(this.weavy, this.location, this.parentId), this.restoreCommentMutation = SV(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = lb(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (i = rv(this, Uc)) == null || i.call(this);
      const r = `a${this.app.id}`;
      this.weavy.subscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(I.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), G$(this, Uc, () => {
        this.weavy?.unsubscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), G$(this, Uc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  /**
   * Handle submit from the comment editor and trigger add comment mutation.
   *
   * @internal
   */
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  /**
   * Render comment items from a flattened page array.
   *
   * @internal
   */
  renderComments(t) {
    return t ? Mi(
      t,
      (e) => e.id,
      (e) => this.parentId ? v`<wy-comment
                id="comment-${e.id}"
                ?reveal=${this.reveal}
                .parentId=${this.parentId}
                .location=${this.location}
                .comment=${e}
                @trash=${async (i) => {
        const r = await this.whenApp(), s = await this.whenParentId();
        this.removeCommentMutation?.mutate({
          id: i.detail.id,
          appId: r.id,
          parentId: s,
          type: this.location
        });
      }}
                @restore=${async (i) => {
        const r = await this.whenApp(), s = await this.whenParentId();
        this.restoreCommentMutation?.mutate({
          id: i.detail.id,
          appId: r.id,
          parentId: s,
          type: this.location
        });
      }}
                @vote=${(i) => {
        i.detail.parentId && i.detail.parentType && this.pollMutation?.mutate({
          optionId: i.detail.optionId,
          parentType: i.detail.parentType,
          parentId: i.detail.parentId
        });
      }}
              ></wy-comment>` : C
    ) : C;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.commentsQuery.result ?? {}, r = cr(t);
    return v`
      ${r && r.length ? v`
            <div part="wy-comments">
              ${this.renderComments(r)}
              ${e ? v`<div ${at(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : v`
            <wy-empty noNetwork
              ><wy-progress-circular indeterminate padded reveal ?hidden=${!i}></wy-progress-circular
            ></wy-empty>
          `}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!Um(al.Create, this.app?.permissions)}
        placeholder=${this.placeholder ?? P("Create a comment...")}
        buttonText=${P("Comment", { desc: "Button action to comment" })}
        @submit=${(s) => this.handleSubmit(s)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = rv(this, Uc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(qf, "$o"), qf), h(K$, "WyCommentList"), K$);
Hv = /* @__PURE__ */ new WeakMap();
hS = /* @__PURE__ */ new WeakMap();
Uc = /* @__PURE__ */ new WeakMap();
ts.styles = [I4, Sa];
Cy([
  O({ type: Number })
], ts.prototype, "parentId", 2);
Cy([
  O({ attribute: !1 })
], ts.prototype, "location", 2);
Cy([
  O()
], ts.prototype, "placeholder", 2);
Cy([
  O({ type: Boolean, reflect: !0 })
], ts.prototype, "reveal", 2);
Cy([
  O({ type: Boolean, reflect: !0 })
], ts.prototype, "padded", 2);
ts = Cy([
  U("wy-comment-list"),
  kt()
], ts);
function kb(n, t) {
  return ["apps", n.id, "file", t.id, "versions"];
}
c(kb, "$y");
h(kb, "getFileVersionsKey");
function VV(n, t, e) {
  const i = n.queryClient, r = ["apps", t.id, "files"], s = kb(t, e), a = {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ h(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        if (!(await n.fetch(`/api/files/${o.id}/versions/${o.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${o.name} to version ${o.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((o) => (St(
      i,
      { queryKey: a.mutationKey, exact: !1 },
      o.versionFile.id,
      (l) => Object.assign(l, o.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((o, l) => {
      St(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (d) => Object.assign(d, o, { status: "ok" })
      ), se(i, a.mutationKey, l, (d) => {
        d.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ h((o, l, d) => {
      d?.file && St(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (u) => Object.assign(u, d.file, { status: "error" })
      ), se(i, a.mutationKey, l, (u) => {
        u.status.state = "error", u.status.text = o.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ h(async () => {
      await i.invalidateQueries({ queryKey: s });
    }, "onSettled")
  };
  return a;
}
c(VV, "Q4");
h(VV, "getFileVersionRestoreMutationOptions");
function DV(n, t, e) {
  return new Zt(n.queryClient, VV(n, t, e));
}
c(DV, "K4");
h(DV, "getFileVersionRestoreMutation");
function WV(n, t, e) {
  const i = n.queryClient, r = kb(t, e);
  return {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ h(async ({ versionFile: s }) => {
      if (s.id >= 1 && s.rev) {
        const a = await n.fetch(`/api/files/${s.id}/versions/${s.rev}`, {
          method: "DELETE"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else {
        const a = {
          status: 400,
          title: `Could not remove ${s.name} version ${s.rev}.`
        };
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((s) => {
      ge(
        i,
        r,
        /* @__PURE__ */ h((a) => a.id === s.versionFile.id && a.rev === s.versionFile.rev, "versionPredicate"),
        (a) => Object.assign(a, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((s, a) => {
      ab(i, r, /* @__PURE__ */ h((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ h((s, a) => {
      ge(
        i,
        r,
        /* @__PURE__ */ h((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"),
        (o) => Object.assign(o, { status: void 0 })
      );
    }, "onError")
  };
}
c(WV, "G4");
h(WV, "getFileVersionDeleteMutationOptions");
function qV(n, t, e) {
  return new Zt(n.queryClient, WV(n, t, e));
}
c(qV, "Z4");
h(qV, "getFileVersionDeleteMutation");
var MG = Object.defineProperty, AG = Object.getOwnPropertyDescriptor, D4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? AG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && MG(t, e, r), r;
}, "__decorateClass$F"), J$, Ff;
let Bw = (J$ = (Ff = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.fileVersionsQuery = new yn(this);
  }
  /**
   * Selects the provided version and emits `file-version-select`.
   *
   * @param versionFile - Version to select.
   */
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  /**
   * Emit a `file-version-select` event with the chosen version.
   *
   * @internal
   * @param versionFile - Version to announce.
   * @returns Whether the event was not canceled.
   */
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", {
      detail: { versionFile: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Revert the file to the supplied version.
   *
   * @internal
   * @param versionFile - Version to restore.
   */
  handleRevert(t) {
    this.fileVersionRestoreMutation?.mutate({ versionFile: t }), this.selectVersion(t);
  }
  /**
   * Remove the supplied version and adjust the active selection if needed.
   *
   * @internal
   * @param versionFile - Version to delete.
   */
  handleRemove(t) {
    this.fileVersionDeleteMutation?.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  /**
   * Download the provided version via the browser.
   *
   * @internal
   * @param file - Version file to download.
   */
  triggerDownload(t) {
    or(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      gy(
        this.weavy,
        kb(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = DV(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = qV(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? v`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : t?.data ? v`
          <wy-item-list part="wy-versions">
            ${Mi(
      t.data,
      (i) => i.id,
      (i, r) => {
        const s = ls(i.name || "").icon, a = t.data ? t.data.length - r : NaN, o = en(i.name), l = new Date(i.updated_at || i.created_at), d = !!this.file.external_url, u = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(l), p = Wl(this.weavy?.locale, new Date(l));
        return d ? v`
                      <wy-empty noNetwork>
                        <span slot="title">${P("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : v`
                      <wy-item
                        size="lg"
                        interactive
                        ?selected=${i.rev == this.activeVersion?.rev}
                        tabindex="0"
                        @click=${() => this.selectVersion(i)}
                        @keydown=${ze}
                        @keyup=${di}
                      >
                        <wy-icon
                          slot="image"
                          name=${s}
                          size="48"
                          kind=${i.kind}
                          ext=${o}
                        ></wy-icon>
                        <span slot="title">${a}. ${i.name}</span>
                        <span slot="text">
                          <time datetime=${i.updated_at || i.created_at} title=${u}
                            >${p}</time
                          >
                          ${i.updated_by ? v`· ${i.updated_by?.name}` : C}
                        </span>

                        <wy-dropdown slot="actions" directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(i)}>
                            <wy-icon name="download"></wy-icon>
                            ${P("Download")}
                          </wy-dropdown-item>

                          ${r !== 0 ? v`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(i)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(i)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${P("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : C}
                        </wy-dropdown>
                      </wy-item>
                    `;
      }
    )}
          </wy-item-list>
        ` : C;
  }
}, c(Ff, "Co"), Ff), h(J$, "WyFileVersions"), J$);
D4([
  O({ attribute: !1 })
], Bw.prototype, "file", 2);
D4([
  O({ attribute: !1 })
], Bw.prototype, "activeVersion", 2);
Bw = D4([
  U("wy-file-versions"),
  kt()
], Bw);
var RG = Object.defineProperty, EG = Object.getOwnPropertyDescriptor, We = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? EG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && RG(t, e, r), r;
}, "__decorateClass$E"), tx, Zf;
let de = (tx = (Zf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new l1(this), this.swipeScroller = new bB(this), this.previewFileRef = wt(), this.nextRef = wt(), this.prevRef = wt(), this.loadingQueue = [], this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  /**
   * Moves a file to the front of the loading queue.
   *
   * @internal
   * @param file - File to prioritize.
   * @param state - Optional state override.
   */
  moveFirstInQueue(t, e) {
    let i = { file: t };
    const r = this.loadingQueue.filter((s) => s.file === t ? (i = s, !1) : !0);
    this.loadingQueue = [{ ...i, ...e }, ...r];
  }
  /**
   * Updates loading metadata for the supplied file.
   *
   * @internal
   * @param file - File whose state should change.
   * @param state - State patch to merge.
   */
  updateLoadingState(t, e) {
    t && (this.loadingQueue = this.loadingQueue.map((i) => t === i.file ? { ...i, ...e } : i));
  }
  /**
   * Marks the next unloaded item as loading.
   *
   * @internal
   */
  loadNextInQueue() {
    const t = this.loadingQueue.find((e) => !e.loaded);
    t && !t?.loading && this.updateLoadingState(t.file, { loading: !0 });
  }
  /**
   * Emits `wy-preview-open` with the current preview context.
   *
   * @internal
   */
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), i = this.currentId, r = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, s = this.currentFile ? [this.currentFile] : [], a = this.isAttachment, o = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: {
        fileId: i,
        tab: r,
        files: s,
        app: t,
        features: e.allowedFeatures().join(" "),
        isAttachment: a,
        contextDataBlobs: o
      },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Emits the `wy-preview-close` event.
   *
   * @internal
   */
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  /**
   * Opens the overlay for the provided file identifier.
   *
   * @param fileId - File to display.
   * @param showTab - Optional sidebar tab to activate.
   */
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  /**
   * Closes the preview overlay.
   */
  close() {
    this.showOverlay = !1;
  }
  /**
   * Toggles sidebar visibility for comments or versions.
   *
   * @internal
   * @param tab - Sidebar to affect.
   * @param state - Forced open state; toggles when omitted.
   */
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Handles file version selection events.
   *
   * @internal
   * @param e - Version selection event.
   */
  handleVersionFile(t) {
    this.currentVersionFile = t.detail.versionFile;
  }
  /**
   * Scrolls to the previous preview area.
   *
   * @internal
   */
  scrollToPrev() {
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Scrolls to the next preview area.
   *
   * @internal
   */
  scrollToNext() {
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Disables swipe scrolling for a short duration.
   *
   * @internal
   * @param duration - Milliseconds before re-enabling.
   */
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  /**
   * Re-enables swipe scrolling immediately.
   *
   * @internal
   */
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  /**
   * Selects the previous file when available.
   *
   * @internal
   */
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  /**
   * Selects the next file when available.
   *
   * @internal
   */
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  /**
   * Registers swipe observers on the active scroll element.
   *
   * @internal
   */
  registerSwipeScroller() {
    this.swipeScrollElement && (this.swipeScroller.whenPrev ??= () => this.setPrev(), this.swipeScroller.whenNext ??= () => this.setNext(), this.swipeScroller.createObserver(this.swipeScrollElement));
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e?.filter((i) => i && !i.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = cr(e).filter((i) => i && !i.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.currentVersionFile = void 0, this.currentVersionFile = this.currentFile = this.files.find((e, i) => this.files && e.id === this.currentId ? (i >= 1 && (this.previousFile = this.files[i - 1]), i < this.files.length - 1 && (this.nextFile = this.files[i + 1]), this.infiniteQueryResult && i >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && i <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("previousFile") && this.previousFile && this.moveFirstInQueue(this.previousFile), t.has("nextFile") && this.nextFile && this.moveFirstInQueue(this.nextFile), t.has("currentVersionFile") && this.currentVersionFile && this.moveFirstInQueue(this.currentVersionFile, { loading: !0 }), t.has("loadingQueue") && this.loadNextInQueue(), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  /**
   * Renders the preview header for the active file.
   *
   * @internal
   * @param activeFile - File displayed in the main pane.
   */
  renderHeader(t) {
    return v`
      <wy-titlebar header ?trashed=${!!t?.is_trashed}>
        <wy-button slot="icon" kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        ${t ? v` <span slot="title">${t.name}</span> ` : C}
        ${t ? v`
              ${this.componentFeatures?.allowsFeature(I.Comments) && t.id >= 1 && !this.isAttachment ? v`
                    <wy-button
                      slot="actions"
                      kind="icon"
                      ?active=${this.commentsOpen}
                      @click=${() => this.toggleSidebarTab("comments")}
                      title=${P("Comments")}
                    >
                      <wy-icon-stack>
                        ${t.comments?.count && t.comments?.count > 0 ? v`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : v`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                      </wy-icon-stack>
                    </wy-button>
                  ` : C}
              <wy-file-menu slot="actions" .file=${t}>
                ${this.componentFeatures?.allowsFeature(I.Versions) && t.id >= 1 && !this.isAttachment ? v`
                      <wy-dropdown-item ?active=${this.versionsOpen} @click=${() => this.toggleSidebarTab("versions")}>
                        <wy-icon name="backup-restore"></wy-icon>
                        ${P("Versions")}
                      </wy-dropdown-item>
                    ` : C}
              </wy-file-menu>
            ` : C}
      </wy-titlebar>
    `;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = [this.previousFile, this.currentVersionFile, this.nextFile].filter((r) => r);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const i = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? v`
      <wy-overlay
        part="wy-dark"
        maximized
        noHeader
        type=${this.filled ? "full" : "modal"}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
      >
        ${this.showOverlay ? v`<div part="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div part="wy-preview-main">
                ${this.isAttachment ? C : v` <aside
                        id="tab-comments"
                        part="wy-sidebar ${ut({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${P("Comments")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("comments", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? v`
                                <wy-comment-list
                                  reveal
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : C}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        part="wy-sidebar ${ut({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${P("Versions")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("versions", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          <div part="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? v`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.currentVersionFile}
                                    @file-version-select=${(r) => this.handleVersionFile(r)}
                                  ></wy-file-versions>
                                ` : C}
                          </div>
                        </div>
                      </aside>`}

                <div part="wy-preview">
                  <div
                    ${at((r) => {
      r && (this.swipeScrollElement = r);
    })}
                    part="wy-preview-swiper ${ut(i)}"
                  >
                    ${Mi(
      e,
      (r) => "preview-area-" + r?.id,
      (r) => {
        const s = /* @__PURE__ */ h((l) => {
          l?.scrollIntoView(), requestAnimationFrame(() => l?.scrollIntoView());
        }, "currentPreviewFileCallback"), a = r === this.currentVersionFile ? s : r === this.nextFile ? this.nextRef : r === this.previousFile ? this.prevRef : void 0, o = this.loadingQueue.find((l) => l.file === r);
        return r ? v`
                              <div
                                id="preview-${r.id}"
                                ${at(a)}
                                part="wy-preview-area wy-scroll-x-y"
                              >
                                ${!t && (o?.loading || o?.loaded) ? v`
                                      <wy-preview-item
                                        .file=${r}
                                        ?current=${r === this.currentVersionFile}
                                        @file-preview-loaded=${(l) => this.updateLoadingState(l.detail.file, { loaded: !0 })}
                                      ></wy-preview-item>
                                    ` : v` <wy-progress-circular indeterminate overlay></wy-progress-circular> `}
                              </div>
                            ` : C;
      }
    )}
                  </div>
                  ${this.currentFile ? v`
                        ${this.previousFile ? v`
                              <nav part="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                        ${this.nextFile ? v`
                              <nav part="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                      ` : C}
                </div>
              </div>
            </div> ` : C}
      </wy-overlay>
    ` : C;
  }
  updated(t) {
    t.has("swipeScrollElement") && t.get("swipeScrollElement") !== this.swipeScrollElement && this.registerSwipeScroller(), !this.disableSwipeScroll && this.swipeScroller.swipeElement === this.swipeScrollElement ? this.swipeScroller.observe(this.prevRef.value, this.nextRef.value) : this.swipeScroller.clearObserver();
  }
}, c(Zf, "ko"), Zf), h(tx, "WyPreview"), tx);
de.styles = [RY, EY, Ll, Vl, by, Qe];
We([
  O({ attribute: !1 })
], de.prototype, "files", 2);
We([
  O({ attribute: !1 })
], de.prototype, "queryResult", 2);
We([
  O({ attribute: !1 })
], de.prototype, "infiniteQueryResult", 2);
We([
  O({ type: Object })
], de.prototype, "user", 2);
We([
  O({ type: Number })
], de.prototype, "currentId", 2);
We([
  O({ type: Boolean })
], de.prototype, "isAttachment", 2);
We([
  O({ type: Boolean })
], de.prototype, "filled", 2);
We([
  Z()
], de.prototype, "currentFile", 2);
We([
  Z()
], de.prototype, "currentVersionFile", 2);
We([
  Z()
], de.prototype, "previousFile", 2);
We([
  Z()
], de.prototype, "nextFile", 2);
We([
  Z()
], de.prototype, "showOverlay", 2);
We([
  Z()
], de.prototype, "commentsOpen", 2);
We([
  Z()
], de.prototype, "versionsOpen", 2);
We([
  Z()
], de.prototype, "sidePanelMaximized", 2);
We([
  Z()
], de.prototype, "swipeScrollElement", 2);
We([
  Z()
], de.prototype, "loadingQueue", 2);
We([
  Z()
], de.prototype, "disableSwipeScroll", 2);
de = We([
  U("wy-preview"),
  kt()
], de);
var _G = Object.defineProperty, zG = Object.getOwnPropertyDescriptor, Re = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? zG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && _G(t, e, r), r;
}, "__decorateClass$D"), ex, Xf;
let oe = (ex = (Xf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && w1(this.link, li.Message, { id: this.messageId })));
  }
  render() {
    const t = this.attachments?.filter((a) => a.kind === "image" && a.thumbnail_url) || [], e = this.attachments?.filter((a) => a.kind !== "image" || !a.thumbnail_url) || [], i = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", r = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "", s = !this.annotations?.length && !this.attachments?.length && !this.embed && !this.meeting && !this.pollOptions?.length && O_(this.text);
    return v`
      <div
        part=${ut({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent, "wy-highlight": this.highlight })}
        ${at(this.highlightRef)}
      >
        ${this.me ? "" : v`
              <div part="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div part="wy-message-content">
          <div part="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? v` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${i}>${r}</time>
          </div>

          <div part=${ut({ "wy-message-bubble": !0, "wy-message-bubble-emoji": s })}>
            ${this.messageId < 0 ? v`<wy-skeleton .text=${this.text}></wy-skeleton>` : v`
                  ${t && t.length ? v`<wy-image-grid
                        part="wy-message-bubble-section"
                        .images=${t}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-image-grid>` : C}


                  <!-- text -->
                  ${this.html ? v`<div part=${ut({ "wy-content": !0, "wy-message-bubble-section": !0, "wy-content-emoji": s })}>${ll(this.html)}</div>` : C}

                  ${this.annotations && this.annotations.length ? v`<wy-annotation-list
                        part="wy-message-bubble-section"
                        .files=${this.annotations}
                        @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-annotation-list>` : C}

                  ${this.pollOptions && this.pollOptions.length ? v`<wy-poll
                        .pollOptions=${this.pollOptions}
                        @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                      ></wy-poll>` : C}

                  ${this.componentFeatures?.allowsFeature(I.Embeds) && this.embed ? v` <wy-embed .embed=${this.embed}></wy-embed> ` : C}

                  ${e && e.length ? v`<wy-attachment-list
                        filled
                        part="wy-message-bubble-section"
                        .files=${e}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachment-list>` : C}

                  ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : C}

                  ${this.componentFeatures?.allowsFeature(I.Reactions) && this.conversation ? v`
                        ${jv(
      `reactions-${this.conversation.id}-${this.messageId}`,
      v`<wy-reactions
                            lineBelow
                            ?lineReverse=${!this.me}
                            small
                            directionX=${this.me ? "right" : "left"}
                            .reactions=${this.reactions}
                            parentId=${this.conversation.id}
                            parentType="apps"
                            entityId=${this.messageId}
                            entityType="messages"
                          ></wy-reactions>`
    )}
                      ` : C}
                `}
          </div>
        </div>
      </div>
      ${this.componentFeatures?.allowsFeature(I.Receipts) ? v`<div part="wy-message-seenby">
            ${this.seenBy && this.seenBy.length ? v`
                  ${this.seenBy.map((a) => {
      const o = a.marked_at ? new Intl.DateTimeFormat(this.weavy?.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(a.marked_at)) : "";
      return v`<wy-avatar
                      title=${P(rt`Seen by ${a.name} at ${o}`)}
                      .name=${a.name}
                      .src=${a.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : C}
          </div>` : C}
      ${this.annotations ? jv(
      `annotation-preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${at(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
      ${this.attachments ? jv(
      `preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${at(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(Xf, "_o"), Xf), h(ex, "WyMessage"), ex);
oe.styles = [re, hb, R4, ft];
Re([
  O({ attribute: !1 })
], oe.prototype, "conversation", 2);
Re([
  O({ type: Number })
], oe.prototype, "messageId", 2);
Re([
  O({ type: Boolean })
], oe.prototype, "me", 2);
Re([
  O({ type: Boolean })
], oe.prototype, "isAgent", 2);
Re([
  O({ type: Boolean })
], oe.prototype, "isPrivateChat", 2);
Re([
  O()
], oe.prototype, "name", 2);
Re([
  O()
], oe.prototype, "comment", 2);
Re([
  O()
], oe.prototype, "avatar", 2);
Re([
  O()
], oe.prototype, "createdAt", 2);
Re([
  O()
], oe.prototype, "html", 2);
Re([
  O()
], oe.prototype, "text", 2);
Re([
  O({ type: Array })
], oe.prototype, "annotations", 2);
Re([
  O({ type: Array })
], oe.prototype, "attachments", 2);
Re([
  O({ attribute: !1 })
], oe.prototype, "meeting", 2);
Re([
  O({ type: Array })
], oe.prototype, "pollOptions", 2);
Re([
  O({ attribute: !1 })
], oe.prototype, "embed", 2);
Re([
  O({ type: Array })
], oe.prototype, "reactions", 2);
Re([
  O({ type: Array })
], oe.prototype, "seenBy", 2);
Re([
  O({ type: Boolean })
], oe.prototype, "highlight", 2);
oe = Re([
  U("wy-message"),
  kt()
], oe);
var LG = Object.defineProperty, IG = Object.getOwnPropertyDescriptor, FV = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$8"), In = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? IG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && LG(t, e, r), r;
}, "__decorateClass$C"), ZV = /* @__PURE__ */ h((n, t, e) => t.has(n) || FV("Cannot " + e), "__accessCheck$8"), g9 = /* @__PURE__ */ h((n, t, e) => (ZV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$8"), VG = /* @__PURE__ */ h((n, t, e) => t.has(n) ? FV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$8"), w9 = /* @__PURE__ */ h((n, t, e, i) => (ZV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$7"), Hc, ix, Nf;
let Ai = (ix = (Nf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.messagesQuery = new Al(this), this.membersQuery = new yn(this), this.addMessageMutation = new Rn(this), this.infiniteScroll = new wB(this), this.pagerRef = wt(), this.bottomRef = wt(), this.editorRef = wt(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await this.messagesQuery.observer?.getCurrentQuery().promise;
      const e = t.message.app.uid ?? t.message.app.id, i = ["messages", t.message.app.id];
      let r = c1(this.weavy.queryClient, i, t.message.id);
      r || (t.message.created_by.id === this.user.id && (r = ua(this.weavy.queryClient, i, !0), r && ge(this.weavy.queryClient, i, r.id, (s) => {
        s.id = t.message.id, s.app = t.message.app, s.text = t.message.text, s.html = t.message.html, s.embed = t.message.embed, s.meeting = t.message.meeting, s.attachments = t.message.attachments, s.options = t.message.options, s.created_at = t.message.created_at, s.created_by = t.message.created_by, s.updated_at = t.message.updated_at, s.updated_by = t.message.updated_by;
      })), r || da(this.weavy.queryClient, i, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", e],
        (s) => s && { ...s, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", e],
        (s) => s && { ...s, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), St(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (s) => {
          s.marked_id = t.message.id, s.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || St(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((i) => i.created_by?.id !== t.actor.id),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || St(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((i) => i.created_by?.id !== t.actor.id));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || St(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, VG(this, Hc);
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === gt.PrivateChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === gt.ChatRoom;
  }
  /**
   * Read-only helper returning whether the viewport is currently scrolled to the bottom.
   *
   * @internal
   */
  get isAtBottom() {
    return this.bottomRef.value ? CL(this.bottomRef.value) : !0;
  }
  /**
   * Scroll the conversation to the bottom.
   *
   * @param smooth - Whether to perform a smooth scroll.
   * @returns Promise<void>
   *
   * @internal
   */
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await Gv(this.bottomRef.value), SL(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      Iv(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await PL(this.bottomRef.value, t));
  }
  /**
   * Handle typing indicator events from child components.
   *
   * @internal
   * @param e - Typing event
   */
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  /**
   * Submit handler for the message editor. Adds a message and optionally creates a conversation first.
   *
   * @internal
   * @param e - Editor submit event
   * @returns Promise<MessageType>
   */
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const i = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, i;
  }
  /**
   * Set the editor text programmatically.
   *
   * @param text - Text to set in the editor.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  /**
   * Set metadata on the editor instance.
   *
   * @param metadata - Optional metadata object.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  async selectAllInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.selectAllContent());
  }
  /**
   * Move the editor cursor to the end of the content.
   *
   * @internal
   */
  async setCursorLastInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.setCursorLast());
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusEditor() {
    this.editorRef.value && this.editorRef.value?.focusInput();
  }
  /**
   * Sets the conversation title when the conversation is empty, based on message text.
   *
   * @internal
   * @param name - Title string to set.
   * @returns Promise<void>
   */
  async setEmptyConversationTitle(t) {
    !this.conversation || this.conversation.name || (t = gP(t), await this.updateConversationMutation?.mutate({ appId: this.conversation.id, name: t }));
  }
  /**
   * Mark the conversation as read. Respects visibility and component lifecycle.
   *
   * @param messageId - Optional message id to mark as read.
   * @returns Promise<void>
   *
   * @internal
   */
  async markAsRead(t) {
    await I9(), await Promise.race([Gv(this), pS(this, !1)]), !(!this.componentFeatures?.allowsFeature(I.Receipts) || !this.isConnected) && this.conversation && this.conversation.last_message && await this.markConversationMutation?.mutate({
      app: this.conversation,
      messageId: t ?? this.conversation.last_message.id,
      userId: this.user?.id
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = n4(this.weavy), this.markConversationMutation = e4(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (e = g9(this, Hc)) == null || e.call(this);
      const i = t.get("conversationId");
      if (i && i > 0 && requestAnimationFrame(() => {
        Iv(this.weavy?.queryClient, ["messages", i], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(KL(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          JL(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(s4(this.weavy, this.conversationId, {})), this.pollMutation = lb(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const r = `a${this.conversationId}`;
        this.weavy.subscribe(r, "message_created", this.handleRealtimeMessage), this.componentFeatures?.allowsFeature(I.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), this.componentFeatures?.allowsFeature(I.Receipts) && this.weavy.subscribe(r, "app_marked", this.handleRealtimeMarked).then((s) => {
          this.showReadReceipts = s;
        }), w9(this, Hc, () => {
          this.weavy?.unsubscribe(r, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), this.weavy?.unsubscribe(r, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, w9(this, Hc, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const i = t.get("conversation");
      if (i?.id !== this.conversation?.id || i?.is_unread !== this.conversation?.is_unread)
        if (this.componentFeatures?.allowsFeature(I.Receipts) && this.conversation?.is_unread) {
          const r = this.membersQuery.result.data?.data?.find(
            (s) => s.id === this.user?.id
          )?.marked_id;
          r && r < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = r, this.showNewMessages = !0), (i?.id !== this.conversation?.id || i?.last_message.id !== this.conversation?.last_message.id && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else i?.id !== this.conversation?.id && (this.showNewMessages = !1);
    }
    if (this.conversation && !this.conversation?.name && !H5(this.messagesQuery.result.data)) {
      const i = cr(this.messagesQuery.result.data).find((r) => r.plain);
      i && this.setEmptyConversationTitle(yP(i.plain));
    }
  }
  renderConversationHeader() {
    if (!this.header)
      return v` <!-- Top of the conversation --> `;
    const { isPending: t, hasNextPage: e } = this.messagesQuery.result ?? {};
    if (!this.conversation || t || e)
      return C;
    const { data: i } = this.membersQuery.result ?? {}, r = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-avatar-header description=${Ot(r?.comment)}>
        ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? v` <wy-avatar-group
              .members=${i?.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : r?.avatar_url ? v`
              <wy-avatar
                src=${Ot(r?.avatar_url)}
                name=${this.conversation.name}
                description=${Ot(r?.comment)}
                ?isAgent=${r?.is_agent}
                size=${96}
              ></wy-avatar>
            ` : C}
      </wy-avatar-header>
    `;
  }
  renderMessages() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, {
      data: e,
      isPending: i
      //hasNextPage,
    } = this.messagesQuery.result ?? { isPending: t }, { data: r } = this.membersQuery.result ?? {}, s = cr(e);
    let a;
    return this.conversation && e && !H5(e) ? v`
          <div part="wy-messages">
            <div ${at(this.pagerRef)} part="wy-pager wy-pager-top"></div>

            ${s && this.conversation && this.user ? Mi(
      s,
      (o) => o.id,
      (o, l) => {
        const d = new Date(o.created_at);
        let u = v``;
        if (a?.toDateString() !== d.toDateString()) {
          const y = new Intl.DateTimeFormat(this.weavy?.locale, {
            dateStyle: "short"
          }).format(d);
          a = d, u = v`<time part="wy-message-date-separator">${y}</time>`;
        }
        let p = v``;
        this.lastReadMessageId && this.lastReadMessageId === o.id && (p = v`<div
                        id="unread-marker"
                        part="wy-toast wy-toast-action wy-fade ${this.showNewMessages ? "wy-show" : ""}"
                        tabindex=${this.showNewMessages ? 0 : -1}
                        @click=${() => {
          let y = `#message-${this.lastReadMessageId}`;
          this.lastReadMessagePosition === "below" && (y += "~ wy-message"), this.renderRoot.querySelector(y)?.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                        @keydown=${ze}
                        @keyup=${di}
                      >
                        ${P("New messages")}
                      </div>`);
        const f = r?.data?.find((y) => y.id === o.created_by.id) || o.created_by;
        return v`${[
          v`${u}`,
          v`${this.lastReadMessagePosition === "above" ? p : C}`,
          jv(
            `message-${o.id}`,
            v`<wy-message
                          id="message-${o.id}"
                          .conversation=${this.conversation}
                          .messageId=${o.id}
                          .me=${f.id === this.user?.id}
                          .isAgent=${f.is_agent || !1}
                          .isPrivateChat=${this.conversation?.type === gt.PrivateChat || this.conversation?.type === gt.AgentChat}
                          .name=${f.name}
                          .comment=${f.comment}
                          .avatar=${f.avatar_url}
                          .createdAt=${o.created_at}
                          .text=${o.plain}
                          .html=${o.html}
                          .annotations=${o.annotations?.data}
                          .attachments=${o.attachments?.data}
                          .meeting=${o.meeting}
                          .pollOptions=${o.options?.data}
                          .embed=${o.embed}
                          .reactions=${o.reactions?.data}
                          .seenBy=${this.showReadReceipts && r && r.data && r.data.length > 0 ? r.data.filter((y) => y.marked_id === o.id && y.id !== this.user?.id) : []}
                          @vote=${(y) => {
              y.detail.parentId && y.detail.parentType && y.detail.parentId && this.pollMutation?.mutate({
                optionId: y.detail.optionId,
                parentType: y.detail.parentType,
                parentId: y.detail.parentId
              });
            }}
                        ></wy-message>`
          ),
          v`${this.lastReadMessagePosition === "below" ? p : C}`
        ]}`;
      }
    ) : C}
            ${this.componentFeatures?.allowsFeature(I.Typing) ? v`
                  <wy-message-typing
                    .conversationId=${this.conversation.id}
                    .userId=${this.user?.id}
                    .isPrivateChat=${this.isPrivateChat()}
                    .members=${r?.data ?? []}
                    @typing=${(o) => this.handleTyping(o)}
                  ></wy-message-typing>
                ` : C}
          </div>
        ` : v`
          <div part="wy-messages">
            <wy-empty part="wy-pane">
              ${i && this.conversationId || this.isCreatingConversation ? v`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : v` <slot name="empty">${this.conversationId ? P("Start the conversation!") : C}</slot> `}
            </wy-empty>
          </div>
        `;
  }
  render() {
    return v`
      ${this.renderConversationHeader()} ${this.renderMessages()}
      <div ${at(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky wy-footerbar-floating">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${at(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? P("Type a message...")}
          ?disabled=${this.conversation && !Um(al.Create, this.conversation?.permissions)}
          @submit=${(t) => this.handleSubmit(t)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && (Iv(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1), requestAnimationFrame(() => {
      this.scrollToBottom();
    })), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        e.isIntersecting && !this.isTyping && this.conversation?.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = g9(this, Hc)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, c(Nf, "Po"), Nf), h(ix, "WyConversation"), ix);
Hc = /* @__PURE__ */ new WeakMap();
Ai.styles = [
  hb,
  Sa,
  Ll,
  QI,
  o4,
  tt`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
In([
  os({ context: zP }),
  O({ attribute: !1 })
], Ai.prototype, "conversation", 2);
In([
  O({ type: Number })
], Ai.prototype, "conversationId", 2);
In([
  O({ type: Boolean })
], Ai.prototype, "header", 2);
In([
  O()
], Ai.prototype, "agentInstructions", 2);
In([
  O()
], Ai.prototype, "placeholder", 2);
In([
  Z()
], Ai.prototype, "lastReadMessagePosition", 2);
In([
  Z()
], Ai.prototype, "lastReadMessageId", 2);
In([
  Z()
], Ai.prototype, "showNewMessages", 2);
In([
  Z()
], Ai.prototype, "isCreatingConversation", 2);
In([
  Z()
], Ai.prototype, "showReadReceipts", 2);
Ai = In([
  U("wy-conversation"),
  kt()
], Ai);
const DG = tt`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--_warning-color: var(--wy-warning, var(--wy-warning-light, #adb140));--_error-color: var(--wy-error, var(--wy-error-light, #ba1821));--_track-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));display:contents;position:relative}[part~=wy-progress-linear]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress-linear][part~=wy-progress-padded]{margin:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{inset:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);inset:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-progress-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var WG = Object.defineProperty, qG = Object.getOwnPropertyDescriptor, hs = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && WG(t, e, r), r;
}, "__decorateClass$B"), nx, jf;
let mn = (nx = (jf = class extends pt {
  constructor() {
    super(...arguments), this.shadowParts = new G(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    let t;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (t = this.value / this.max);
    } catch (s) {
      console.error(s);
    }
    const e = this.indeterminate || t === void 0, i = {
      transform: `scaleX(${(e ? 1 : this.value / this.max) * 100}%)`
    }, r = {
      "wy-progress": !0,
      "wy-progress-linear": !0,
      "wy-progress-indeterminate": e,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return v`
      <div
        part=${ut(r)}
        role="progressbar"
        aria-label="${C}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${e ? C : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${Ew(i)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, c(jf, "Mo"), jf), h(nx, "WyProgressLinear"), nx);
mn.styles = [re, _I, DG];
hs([
  O({ type: Boolean })
], mn.prototype, "padded", 2);
hs([
  O({ type: Boolean })
], mn.prototype, "overlay", 2);
hs([
  O({ type: Boolean })
], mn.prototype, "reveal", 2);
hs([
  O({ type: Number })
], mn.prototype, "value", 2);
hs([
  O({ type: Number })
], mn.prototype, "max", 2);
hs([
  O({ type: Boolean })
], mn.prototype, "indeterminate", 2);
hs([
  O({ type: Boolean })
], mn.prototype, "warning", 2);
hs([
  O({ type: Boolean })
], mn.prototype, "error", 2);
mn = hs([
  U("wy-progress-linear")
], mn);
var FG = Object.getOwnPropertyDescriptor, XV = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$7"), ZG = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? FG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(r) || r);
  return r;
}, "__decorateClass$A"), XG = /* @__PURE__ */ h((n, t, e) => t.has(n) || XV("Cannot " + e), "__accessCheck$7"), v9 = /* @__PURE__ */ h((n, t, e) => (XG(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$7"), NG = /* @__PURE__ */ h((n, t, e) => t.has(n) ? XV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$7"), Yv, rx, Bf;
let m0 = (rx = (Bf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), NG(this, Yv, new eb(this));
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(I.ContextData) && await v9(this, Yv).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t, isMutating: e } = v9(this, Yv), i = t?.filter((a) => a.variables?.file), r = XP(i), s = GO(i);
    return this.componentFeatures?.allowsFeature(I.ContextData) && t && t.length ? v`
          ${e || r.percent !== null && r.percent < 100 ? v`
                <wy-progress-linear
                  ?indeterminate=${r.percent === null}
                  overlay
                  reveal
                  ?warning=${s === "error"}
                  value=${r.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : C}
        ` : C;
  }
}, c(Bf, "So"), Bf), h(rx, "WyContextDataProgress"), rx);
Yv = /* @__PURE__ */ new WeakMap();
m0.styles = [ft];
m0 = ZG([
  U("wy-context-data-progress")
], m0);
var jG = Object.defineProperty, BG = Object.getOwnPropertyDescriptor, NV = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? BG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && jG(t, e, r), r;
}, "__decorateClass$z"), sx, Uf;
let ny = (sx = (Uf = class extends zi {
  constructor() {
    super(...arguments), this.appType = gt.Chat, this.componentFeatures = new ii({
      // All available features as enabled/disabled by default
      [I.Attachments]: !0,
      [I.ContextData]: !0,
      [I.CloudFiles]: !0,
      [I.Embeds]: !0,
      [I.GoogleMeet]: !0,
      [I.Meetings]: !0,
      [I.Mentions]: !0,
      [I.MicrosoftTeams]: !0,
      [I.Polls]: !0,
      [I.Previews]: !0,
      [I.Reactions]: !0,
      [I.Receipts]: !1,
      [I.Typing]: !1,
      [I.ZoomMeetings]: !0
    }), this.theme = new gn(this, ny.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-conversation .conversation=${this.app} .conversationId=${this.app?.id} .placeholder=${this.placeholder}>
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, c(Uf, "Ao"), Uf), h(sx, "WyChat"), sx);
ny.styles = [wr, El, _l, Qe, bi];
NV([
  O()
], ny.prototype, "placeholder", 2);
ny = NV([
  U("wy-chat"),
  kt()
], ny);
var UG = Object.defineProperty, HG = Object.getOwnPropertyDescriptor, jV = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? HG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && UG(t, e, r), r;
}, "__decorateClass$y"), ax, Hf;
let ry = (ax = (Hf = class extends zi {
  constructor() {
    super(...arguments), this.appType = gt.Comments, this.componentFeatures = new ii({
      // All available features as enabled/disabled by default
      [I.Attachments]: !0,
      [I.CloudFiles]: !0,
      [I.ContextData]: !0,
      [I.Embeds]: !0,
      [I.GoogleMeet]: !1,
      [I.Meetings]: !1,
      [I.Mentions]: !0,
      [I.MicrosoftTeams]: !1,
      [I.Polls]: !0,
      [I.Previews]: !0,
      [I.Reactions]: !0,
      [I.Typing]: !1,
      // Has no effect currently
      [I.ZoomMeetings]: !1
    }), this.theme = new gn(this, ry.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-comment-list .parentId=${this.app?.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, c(Hf, "zo"), Hf), h(ax, "WyComments"), ax);
ry.styles = [wr, El, _l, Qe, bi, I4];
jV([
  O()
], ry.prototype, "placeholder", 2);
ry = jV([
  U("wy-comments"),
  kt()
], ry);
function BV(n) {
  if (!this.weavy || !this.app)
    return;
  const t = {
    message: n.message,
    direction: n.message.created_by.id === this.user?.id ? "outbound" : "inbound"
  };
  n.message.created_by.is_agent && (t.agent = n.message.created_by.uid);
  const e = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: t
  });
  this.dispatchEvent(e);
}
c(BV, "m3");
h(BV, "triggerMessageEvent");
var YG = Object.defineProperty, GG = Object.getOwnPropertyDescriptor, W4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? GG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && YG(t, e, r), r;
}, "__decorateClass$x"), ox, Yf;
let vl = (ox = (Yf = class extends zi {
  constructor() {
    super(...arguments), this.appType = gt.AgentChat, this.componentFeatures = new ii({
      // All available features as enabled/disabled by default
      [I.Attachments]: !1,
      [I.ContextData]: !0,
      [I.Embeds]: !0,
      [I.Mentions]: !1,
      [I.Previews]: !0,
      [I.Reactions]: !1,
      [I.Typing]: !0
    }), this.theme = new gn(this, vl.styles), this.conversationRef = wt(), this.handleRealtimeMessage = BV.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    await this.conversationRef.value?.setEditorText(t);
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = BP(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && (this.unsubscribeToRealtime?.(), this.app)) {
      const e = `a${this.app.id}`;
      this.weavy.subscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        this.weavy?.unsubscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
    t.has("agent") && t.get("agent") && this.agent && this.reset();
  }
  render() {
    return this.agent ? v`
          <wy-buttons position="floating" reverse>
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${at(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${this.app?.id}
            .placeholder=${this.placeholder ?? P("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (t) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const e = {
        uid: `wy-copilot-${yh()}`,
        name: gP(yP(this.name ?? t.text)),
        members: [this.agent],
        type: Sn.AgentChat
      }, i = await this.addConversationMutation.mutate(e);
      return this.app = i, await this.updateComplete, i;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (t) => {
      t.target.matches(".suggestion") && (t.stopPropagation(), await this.setSuggestion(t.target.innerText), await this.conversationRef.value?.setCursorLastInEditor(), this.conversationRef.value?.focusEditor());
    }}
              @keydown=${ze}
              @keyup=${di}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <wy-item-list>
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </wy-item-list>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>
        ` : v`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, c(Yf, "Ro"), Yf), h(ox, "WyCopilot"), ox);
vl.styles = [wr, El, _l, Qe, bi];
W4([
  O()
], vl.prototype, "instructions", 2);
W4([
  O()
], vl.prototype, "placeholder", 2);
vl = W4([
  U("wy-copilot"),
  kt()
], vl);
var KG = Object.defineProperty, JG = Object.getOwnPropertyDescriptor, k1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JG(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && KG(t, e, r), r;
}, "__decorateClass$w"), lx, Gf;
let wa = (lx = (Gf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new eb(
      this
    ), this.previousFailedFileMutations = [], this.fileInputRef = wt(), this.cloudFilesRef = wt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    };
  }
  // remove file attachment
  /**
   * Remove (or abort) an ongoing upload mutation.
   *
   * @internal
   * @param mutationState - Mutation state to remove.
   */
  async handleRemoveMutation(t) {
    const e = await this.whenWeavy(), i = await this.whenApp();
    t.status === "pending" && HO(t.variables) && t.variables.abort?.();
    const r = t.status === "error" && !t.variables?.blob || t.status === "pending" ? ["apps", i.id, "blobs"] : ["apps", i.id, "files"];
    FP(
      e.queryClient,
      r,
      (s) => s.state.submittedAt === t.submittedAt
    );
  }
  /**
   * Retry an upload by replacing the existing file.
   *
   * @internal
   * @param mutation - Failed mutation carrying the blob data.
   */
  handleOverwriteUpload(t) {
    const e = t.variables?.blob;
    e && this.dispatchCreateFiles([e], !0);
  }
  /**
   * Dispatch an `upload-files` event with the selected files.
   *
   * @param files - Files chosen from the native picker.
   * @returns Whether the event was not canceled.
   */
  dispatchUploadFiles(t) {
    this.weavy && this.app && (oL(this.weavy, this.app), GO(this.mutatingFiles.result) === "ok" && KO(this.weavy, this.app));
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `external-blobs` event with selected cloud blobs.
   *
   * @internal
   * @param externalBlobs - Blobs returned from the cloud picker.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `create-files` event for programmatic uploads.
   *
   * @internal
   * @param blobs - Blobs to create files from.
   * @param replace - When true, replace the existing file.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchCreateFiles(t, e = !1) {
    const i = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event reflecting the chosen sort order.
   *
   * @internal
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `view` event for changing layout mode.
   *
   * @internal
   * @param view - Layout to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `show-trashed` event to toggle trashed visibility.
   *
   * @internal
   * @param showTrashed - Whether to show trashed files.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event to toggle app subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("app") && this.app && this.app.id !== t.get("app")?.id && this.weavy && KO(this.weavy, this.app), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.app.id],
          exact: !1
        }
      },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    if (t.context?.file) {
      const e = t.context.file, i = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (i.text = P("Replace existing file?")), v`
        <wy-file-item
          rounded
          .file=${t.context?.file}
          .status=${i}
          .actionType=${t.context.type}
          title="${fP(t.context.type)}: ${e.name}"
        >
          <span slot="title">${e.name}</span>
          ${t.context.status.state === "conflict" && i.text ? v`: <span slot="actions" title=${i.text}><em>${i.text}</em></span>` : C}
          ${i.state === "conflict" && t.variables?.blob ? v`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${P("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : C}
          ${i.state === "pending" ? v`
                <wy-progress-circular
                  slot="actions"
                  padded
                  ?indeterminate=${!i.progress}
                  .max=${100}
                  .value=${i.progress || 0}
                ></wy-progress-circular>

                ${HO(t.variables) ? v`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>` : C}
              ` : v`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                <wy-icon name="close"></wy-icon>
              </wy-button> `}
        </wy-file-item>
      `;
    }
    return C;
  }
  render() {
    const t = this.mutatingFiles.result, e = U5(t), i = B5(t), r = XP(t), s = GO(t);
    return v`
      <header part="wy-files-header wy-header wy-header-outer">
        <nav part="wy-files-header-toolbar wy-toolbar">
          <div part="wy-toolbar-buttons">
            ${Um(al.Create, this.app?.permissions) ? v`
                  <wy-dropdown title=${P("Add files")}>
                    <wy-icon slot="button-content" name="plus" first></wy-icon>
                    <span slot="button-content">${P("Add files")}</span>
                    <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                      <wy-icon name="attachment"></wy-icon>
                      <span>${P("From device")}</span>
                    </wy-dropdown-item>
                    <input
                      type="file"
                      data-testid="uploadFile"
                      ${at(this.fileInputRef)}
                      @click=${(a) => a.stopPropagation()}
                      @change=${(a) => {
      this.dispatchUploadFiles(a.target.files) && (a.target.value = "");
    }}
                      multiple
                      hidden
                      tabindex="-1"
                    />
                    ${this.componentFeatures?.allowsFeature(I.CloudFiles) ? v`
                          <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                            <wy-icon name="cloud"></wy-icon>
                            <span>${P("From cloud")}</span>
                          </wy-dropdown-item>
                        ` : C}
                  </wy-dropdown>
                ` : C}
            ${t?.length ? v`
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                    title=${P(s === "conflict" ? "File conflict" : s === "error" ? "Upload error" : s === "pending" ? "Pending" : "All uploads finished")}
                  >
                    ${s === "conflict" ? v`<wy-icon name="alert" color="yellow"></wy-icon>` : s === "error" ? v`<wy-icon name="alert-octagon" color="error"></wy-icon>` : s === "pending" ? v`<wy-progress-circular
                          ?indeterminate=${r.percent === null}
                          .value=${r.loaded}
                          .max=${r.total}
                        ></wy-progress-circular>` : v`<wy-icon name="check"></wy-icon>`}
                  </wy-button>
                ` : C}
          </div>
          <div part="wy-toolbar-buttons wy-toolbar-buttons-last">
            <slot name="actions"></slot>

            <wy-dropdown icon="sort" title="Sort items by" directionX="left">
              <wy-dropdown-option
                ?selected=${this.order.by === "name"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
              >
                ${P("Name")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "updated_at"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
              >
                ${P("Modified")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "size"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
              >
                ${P("Size")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option
                ?selected=${!this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
              >
                ${P("Ascending")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
              >
                ${P("Descending")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown
              icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
              title="View options"
              directionX="left"
            >
              <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
                ${P("List view")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
                ${P("Grid view")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
                ${P("Hide trashed")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
                ${P("Show trashed")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown directionX="left" ?disabled=${!this.app}>
              ${this.app?.is_subscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                    <wy-icon name="bell-off"></wy-icon>
                    ${P("Unsubscribe")}
                  </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                    <wy-icon name="bell"></wy-icon>
                    ${P("Subscribe")}
                  </wy-dropdown-item>`}
              ${this.app?.archive_url ? v`<wy-dropdown-item
                    @click=${() => or(
      this.app?.archive_url,
      "_top",
      `${this.app?.uid ? this.app.uid : `${this.app?.type}-${this.app?.id}`}.zip`,
      !0
    )}
                  >
                    <wy-icon name="download"></wy-icon>
                    ${P("Download files")}
                  </wy-dropdown-item>` : C}
            </wy-dropdown>
          </div>
        </nav>

        <wy-context-data-progress></wy-context-data-progress>
      </header>

      ${this.weavy ? v`
            <wy-overlay
              type="sheet"
              .show=${this.showUploadSheet}
              @close=${() => {
      this.showUploadSheet = !1;
    }}
            >
              <span slot="title">${P("File actions")}</span>
              <wy-container scrollY padded>
                ${!e.length && !i.length ? v`
                      <wy-empty noNetwork><wy-container padded>${P("No pending uploads")}</wy-container></wy-empty>
                    ` : C}
                ${e.length ? v`
                      ${Mi(
      e,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ` : C}
                ${i.length ? v`
                      ${Mi(
      i,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}

      <wy-cloud-files
        ${at(this.cloudFilesRef)}
        @external-blobs=${(a) => this.dispatchExternalBlobs(a.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  updated(t) {
    super.updated(t);
    const e = U5(this.mutatingFiles.result), i = B5(this.mutatingFiles.result);
    e.some(
      (r) => !this.previousFailedFileMutations.includes(r)
    ) ? this.showUploadSheet = !0 : this.showUploadSheet && !e.length && !i.length && setTimeout(() => {
      !e.length && !i.length && (this.showUploadSheet = !1);
    }, 1500), this.previousFailedFileMutations = e ?? [];
  }
}, c(Gf, "Eo"), Gf), h(lx, "WyFilesHeader"), lx);
wa.styles = [_4, wV, ft];
k1([
  O({ type: Object })
], wa.prototype, "order", 2);
k1([
  O()
], wa.prototype, "view", 2);
k1([
  O({ type: Boolean })
], wa.prototype, "showTrashed", 2);
k1([
  Z()
], wa.prototype, "showUploadSheet", 2);
wa = k1([
  U("wy-files-header"),
  kt()
], wa);
function UV(n, t, e = {}, i = {}) {
  if (!n)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...i,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ h(async (r) => {
      const s = r.pageParam, a = !!e?.trashed, o = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let l = "/api/apps/" + t + "/files?skip=" + s + "&order_by=" + o;
      return a && (l += "&trashed=null"), await (await n.fetch(l)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((r) => r.end && r.end < r.count ? r.end : null, "getNextPageParam")
  };
}
c(UV, "$3");
h(UV, "getInfiniteFileListOptions");
function HV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ h(async ({ file: r }) => {
      if (r.id >= 1) {
        if (!(await n.fetch("/api/files/" + r.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${r.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => (St(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (s) => Object.assign(s, { is_trashed: !0 })
    ), { type: "trash", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, r)
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(r, s) {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }
  };
  return i;
}
c(HV, "C3");
h(HV, "getTrashFileMutationOptions");
function YV(n, t) {
  return new Zt(n.queryClient, HV(n, t));
}
c(YV, "k3");
h(YV, "getTrashFileMutation");
function GV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ h(async ({ file: r }) => {
      if (r.id >= 1) {
        const s = await n.fetch("/api/files/" + r.id + "/restore", { method: "POST" });
        if (!s.ok) {
          const a = await s.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const s = { status: 400, title: `Could not restore ${r.name}.` };
        throw new Error(s.detail || s.title, { cause: s });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => (St(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (s) => Object.assign(s, { status: "pending" })
    ), { type: "restore", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { is_trashed: !1, status: "ok" })
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(r, s) {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }
  };
  return i;
}
c(GV, "_3");
h(GV, "getRestoreFileMutationOptions");
function KV(n, t) {
  return new Zt(n.queryClient, GV(n, t));
}
c(KV, "P3");
h(KV, "getRestoreFileMutation");
function JV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ h(async ({ file: r }) => {
      if (r.id >= 1 && r.is_trashed) {
        const s = await n.fetch("/api/files/" + r.id, { method: "DELETE" });
        if (!s.ok) {
          const a = await s.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const s = { status: 400, title: `Could not delete ${r.name} forever.` };
        throw new Error(s.detail || s.title, { cause: s });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => (St(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (s) => Object.assign(s, { status: "pending" })
    ), { type: "delete-forever", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      $B(e, { queryKey: i.mutationKey, exact: !1 }, s.file.id), se(e, i.mutationKey, s, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(r, s) {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { status: void 0 })
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }
  };
  return i;
}
c(JV, "M3");
h(JV, "getDeleteForeverFileMutationOptions");
function tD(n, t) {
  return new Zt(n.queryClient, JV(n, t));
}
c(tD, "S3");
h(tD, "getDeleteForeverFileMutation");
function eD(n, t) {
  const e = n.queryClient, i = ["apps", t.id, "files"];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ h(async ({ file: r, subscribe: s }) => {
      if (r.id >= 1) {
        const a = await n.fetch(`/api/files/${r.id}/${s ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else
        throw new Error(`Could not ${s ? "subscribe" : "unsubscribe"} to ${r.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => (St(
      e,
      { queryKey: i, exact: !1 },
      r.file.id,
      (s) => Object.assign(s, { is_subscribed: r.subscribe, status: "pending" })
    ), {
      type: r.subscribe ? "subscribe" : "unsubscribe",
      file: r.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { status: "ok" })
      ), se(e, i, s, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { is_subscribed: s.file.is_subscribed, status: "error" })
      ), se(e, i, s, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }, "onError")
  };
}
c(eD, "A3");
h(eD, "getSubscribeFileMutationOptions");
function iD(n, t) {
  return new Zt(n.queryClient, eD(n, t));
}
c(iD, "z3");
h(iD, "getSubscribeFileMutation");
function nD(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ h(async ({ file: r, name: s }) => {
      if (r.id >= 1) {
        const a = await n.fetch("/api/files/" + r.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: s
          })
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
        return await a.json();
      } else
        throw new Error(`Could not rename ${r.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => (St(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (s) => Object.assign(s, { name: r.name })
    ), { type: "rename", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, r)
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.file.id,
        (a) => Object.assign(a, { name: s.file.name })
      ), se(e, i.mutationKey, s, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }, "onError")
  };
  return i;
}
c(nD, "R3");
h(nD, "getRenameFileMutationOptions");
function rD(n, t) {
  return new Zt(n.queryClient, nD(n, t));
}
c(rD, "E3");
h(rD, "getRenameFileMutation");
const tK = tt`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0}`, eK = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius);position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));align-items:center;display:flex}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;margin:auto}[part~=wy-card-image]{width:auto;height:auto;border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:center;flex:1 1 100%;max-height:calc(10*var(--wy-size, 1rem))}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-image-top]{object-position:top center}[part~=wy-card-title]{padding:0 var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;align-items:center;justify-content:space-between;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:2.25rem;box-sizing:border-box}[part~=wy-input]{height:2.25rem;box-sizing:border-box;flex:0 1 auto}[part~=wy-card-text]{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}[part~=wy-card-action]{flex:0 0 auto;white-space:nowrap}`, iK = tt`[part~=wy-badge]{display:inline-block;text-align:center;vertical-align:middle;align-self:center;font-weight:var(--wy-font-weight-bold, 600);font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));line-height:normal;color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));padding:.333333em;min-width:1lh}[part~=wy-badge]:empty{display:none!important}[part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .333333em*2));position:absolute}[part~=wy-badge-positioned]:not(:empty){display:block}[part~=wy-badge-top-right]{top:0;right:0}[part~=wy-badge-bottom-right]{bottom:0;right:0}[part~=wy-badge-bottom-left]{bottom:0;left:0}[part~=wy-badge-top-left]{top:0;left:0}[part~=wy-badge-compact]{padding:calc(var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*.25);max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))*3 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-compact]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-badge-compact][part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*.5))}[part~=wy-badge-dot]{content-visibility:hidden;line-height:0;min-width:0;height:0;width:0;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-badge-dot][part~=wy-badge-positioned]{margin:calc(-1*var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-reveal]{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-badge-reveal]{opacity:0}}`;
var nK = Object.defineProperty, rK = Object.getOwnPropertyDescriptor, Py = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? rK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && nK(t, e, r), r;
}, "__decorateClass$v"), cx, Kf;
let es = (cx = (Kf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.appearance = "count", this.position = "inline", this.reveal = !1, this.count = NaN, this.limit = 99;
  }
  render() {
    const t = Number.isInteger(this.count) ? this.count > this.limit ? `${this.limit}+` : this.count : "", e = /^(top|bottom)-(right|left)$/.test(this.position), i = {
      "wy-badge": !0,
      "wy-badge-reveal": this.reveal,
      "wy-badge-compact": this.appearance === "compact",
      "wy-badge-dot": this.appearance === "dot",
      "wy-badge-positioned": e,
      [`wy-badge-${this.position}`]: e
    };
    return this.appearance !== "none" && t ? v`<span part=${ut(i)} title=${this.count}>${t}</span>` : C;
  }
}, c(Kf, "Lo"), Kf), h(cx, "WyBadge"), cx);
es.styles = [iK, ft];
Py([
  O({ type: String })
], es.prototype, "appearance", 2);
Py([
  O({ type: String })
], es.prototype, "position", 2);
Py([
  O({ type: Boolean })
], es.prototype, "reveal", 2);
Py([
  O({ type: Number })
], es.prototype, "count", 2);
Py([
  O({ type: Number })
], es.prototype, "limit", 2);
es = Py([
  U("wy-badge")
], es);
var sK = Object.defineProperty, aK = Object.getOwnPropertyDescriptor, Sb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? aK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && sK(t, e, r), r;
}, "__decorateClass$u"), hx, Jf;
let Ol = (hx = (Jf = class extends Li {
  constructor() {
    super(), this.exportParts = new G(this), this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = wt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the given file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the selected sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the given file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event containing the updated file name.
   *
   * @param file - File being renamed.
   * @param name - New filename.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove a file.
   *
   * @param file - File to delete.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling file subscription.
   *
   * @param file - File to subscribe or unsubscribe.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    return this.files && this.files.length ? v`
        <div part="wy-grid">
          ${Mi(
      this.files,
      (t) => t.id,
      (t) => {
        const e = t.size && t.size > 0 ? G0(t.size) : C, i = t.updated_at || t.created_at, r = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(new Date(i)), s = !!(this.isRenamingId && this.isRenamingId === t.id), { icon: a } = ls(t.name), o = en(t.name), l = wy(t.provider), d = /* @__PURE__ */ h((f) => {
          f.stopImmediatePropagation();
          const y = f.target;
          y.value && y.value !== t.name ? this.dispatchRename(t, y.value) : this.dispatchEditName({ id: NaN });
        }, "handleRename"), u = /* @__PURE__ */ h((f) => {
          const y = f.target;
          f.key === "Escape" ? (f.preventDefault(), y.value = t.name, y.blur()) : f.key === "Enter" && (f.preventDefault(), y.blur());
        }, "handleRenameKey"), p = !!(this.highlightId && this.highlightId === t.id);
        return v`
                <div
                  part=${ut({
          "wy-card": !0,
          "wy-trashed": t.is_trashed,
          "wy-card-hover": !t.is_trashed && !s,
          "wy-highlight": p
        })}
                  title="${t.name} • ${e} • ${r}"
                  tabindex="0"
                  @click=${(f) => {
          Gw(f) && (f.stopPropagation(), f.preventDefault(), or(t.download_url ?? t.external_url, "_blank")), !f.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
        }}
                  @keydown=${ze}
                  @keyup=${di}
                  ${p && this.highlightRef ? at(this.highlightRef) : C}
                >
                  <div part="wy-card-actions">
                    <wy-file-menu
                      small
                      .file=${t}
                      @edit-name=${(f) => this.dispatchEditName(f.detail.file)}
                      @trash=${(f) => this.dispatchTrash(f.detail.file)}
                      @restore=${(f) => this.dispatchRestore(f.detail.file)}
                      @delete-forever=${(f) => this.dispatchDeleteForever(f.detail.file)}
                      @subscribe=${(f) => this.dispatchSubscribe(f.detail.file, f.detail.subscribe)}
                    ></wy-file-menu>
                  </div>
                  ${!t.is_trashed && t.thumbnail_url ? v`
                        <img
                          part="wy-card-image ${ut({ "wy-card-image-top": t.kind !== "image" })}"
                          width=${Ot(t.width)}
                          height=${Ot(t.height)}
                          src=${t.thumbnail_url}
                          alt=${t.name}
                          ${at(yb)}
                          @load=${gb}
                          loading="lazy"
                          decoding="async"
                        />
                      ` : v`
                        <div part="wy-card-icon ">
                          <wy-icon
                            name=${a}
                            .overlayName=${l}
                            size="96"
                            kind=${t.kind}
                            ext=${o}
                          ></wy-icon>
                        </div>
                      `}
                  ${s ? v`
                        <input
                          type="text"
                          name="filename"
                          maxlength="256"
                          part="wy-input"
                          .defaultValue=${t.name}
                          @blur=${d}
                          @keyup=${(f) => {
          Hr(f), u(f);
        }}
                          @click=${(f) => f.preventDefault()}
                          @focus=${tb}
                          ${at(uS)}
                        />
                      ` : v`<div part="wy-card-title">
                        <div part="wy-card-text">${t.name}</div> ${t.comments?.count ? v`<wy-button
                              part="wy-card-button-icon"
                              small
                              color="none"
                              kind="inline"
                              @click=${(f) => {
          !f.defaultPrevented && !t.is_trashed && (f.target.blur(), this.dispatchFileOpen(t.id, "comments"), f.stopPropagation());
        }}
                              title=${P(rt`${t.comments.count} comments`)}
                            >
                              <wy-badge count=${t.comments.count}></wy-badge>
                            </wy-button>` : C}
                      </div>`}
                </div>
              `;
      }
    )}
        </div>
      ` : C;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(Jf, "Oo"), Jf), h(hx, "WyFileGrid"), hx);
Ol.styles = [Qa, tK, eK, ft];
Sb([
  O({ attribute: !1 })
], Ol.prototype, "files", 2);
Sb([
  Z()
], Ol.prototype, "isRenamingId", 2);
Sb([
  Z()
], Ol.prototype, "highlightId", 2);
Ol = Sb([
  Uz("wy-file-grid"),
  kt()
], Ol);
const oK = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-table]{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}[part~=wy-table] tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-table] th{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-table] th,[part~=wy-table] td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2)}[part~=wy-table]>tbody{vertical-align:inherit}[part~=wy-table]>thead{vertical-align:bottom}[part~=wy-table][part~=wy-table-interactive]>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color);cursor:pointer}[part~=wy-col-icon]{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5) calc(var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5);width:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}[part~=wy-col-icon-content]{display:flex;justify-content:center;align-items:center}[part~=wy-trashed]{text-decoration:line-through}[part~=wy-sort-link]{display:inline-flex;align-items:center;color:var(--wy-primary, var(--wy-primary-light, #2f628c));cursor:pointer}`, lK = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}table thead{text-align:left;display:none}@container (inline-size >= 576px){table thead{display:table-header-group}}[part~=wy-col-name]{width:100%}[part~=wy-col-name]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-name] [part~=wy-input]{width:100%;box-sizing:border-box}[part~=wy-col-time]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-time]{display:table-cell}}[part~=wy-col-time]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-kind]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-kind]{display:table-cell}}[part~=wy-col-kind]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-size]{width:calc(6*var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){[part~=wy-col-size]{display:table-cell}}[part~=wy-col-size]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`;
var cK = Object.defineProperty, hK = Object.getOwnPropertyDescriptor, S1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? hK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && cK(t, e, r), r;
}, "__decorateClass$t"), dx, tm;
let va = (dx = (tm = class extends Li {
  constructor() {
    super(), this.exportParts = new G(this), this.order = { by: "name", descending: !1 }, this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = wt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the specified file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event carrying the updated filename.
   *
   * @param file - File being renamed.
   * @param name - New filename value.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription state for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Render the complete file table layout.
   *
   * @param files - Files to render.
   * @param order - Current table order.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTable(t, e, i, r, s) {
    return t && t.length ? v`
          <table part="wy-table wy-table-interactive">
            <thead>${this.renderFileTableHeaders.call(this, e)}</thead>
            <tbody>
              ${Mi(
      t,
      (a) => a.id,
      (a) => this.renderFileTableRow.call(this, this.weavy, { file: a }, i, r, s)
    )}
            </tbody>
          </table>
        ` : C;
  }
  /**
   * Render table header cells with sorting affordances.
   *
   * @param order - Current sort order.
   */
  renderFileTableHeaders(t) {
    const e = [
      { col: "icon", by: void 0, title: "" },
      // File icon
      { col: "name", by: "name", title: P("Name") },
      { col: "icon", by: void 0, title: "" },
      // Comments icon
      { col: "time", by: "updated_at", title: P("Modified") },
      { col: "kind", by: void 0, title: P("Kind") },
      { col: "size", by: "size", title: P("Size") },
      { col: "icon", by: void 0, title: "" }
      // Menu
    ];
    return v`
      <tr>
        ${e.map((i) => {
      if (i.title) {
        const r = i.by === t?.by, s = /* @__PURE__ */ h((a) => {
          a.preventDefault(), i.by && this.dispatchOrder({ by: i.by, descending: r && !t?.descending });
        }, "onHeaderClick");
        return v` <th part="wy-th ${`wy-col-${i.col}`}">
              ${i.by ? v`<div
                    part="wy-sort-link"
                    tabindex="0"
                    @click=${s}
                    @keydown=${ze}
                    @keyup=${di}
                    >${i.title}
                    ${r && v`<wy-icon name=${t?.descending ? "menu-down" : "menu-up"}></wy-icon>` || C}</div
                  >` : i.title}
            </th>`;
      } else
        return v`<th part="wy-th wy-col-icon"></th>`;
    })}
      </tr>
    `;
  }
  /**
   * Render a single file table row.
   *
   * @param weavy - Current Weavy context.
   * @param row - Row data containing the file.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTableRow(t, { file: e }, i, r, s) {
    const a = e.size && e.size > 0 ? G0(e.size) : C, o = e.updated_at || e.created_at, l = new Intl.DateTimeFormat(t?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(o)
    ), d = new Intl.DateTimeFormat(t?.locale, { dateStyle: "short" }).format(
      new Date(o)
    ), u = !!(i && i === e.id), { icon: p } = ls(e.name), f = en(e.name), y = wy(e.provider), g = /* @__PURE__ */ h(($) => {
      $.stopImmediatePropagation();
      const Q = $.target;
      Q.value && Q.value !== e.name ? this.dispatchRename(e, Q.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), b = /* @__PURE__ */ h(($) => {
      const Q = $.target;
      $.key === "Escape" ? ($.preventDefault(), Q.value = e.name, Q.blur()) : $.key === "Enter" && ($.preventDefault(), Q.blur());
    }, "handleRenameKey"), S = !!(r && r === e.id);
    return v`
      <tr
        part=${ut({ "wy-tr": !0, "wy-highlight": S, "wy-trashed": e.is_trashed })}
        @click=${($) => {
      Gw($) && ($.stopPropagation(), $.preventDefault(), or(e.download_url ?? e.external_url, "_blank")), !$.defaultPrevented && !e.is_trashed && this.dispatchFileOpen(e.id);
    }}
        ${S && s ? at(s) : C}
      >
        <td part="wy-td wy-col-icon"
          ><wy-icon part="wy-col-icon-content" name=${p} .overlayName=${y} size="24" kind=${e.kind} ext=${f}></wy-icon
        ></td>
        <td part="wy-td wy-col-name">
          ${u ? v`
                <input
                  type="text"
                  name="filename"
                  maxlength="256"
                  part="wy-input"
                  .defaultValue=${e.name}
                  @blur=${g}
                  @keyup=${($) => {
      Hr($), b($);
    }}
                  @click=${($) => $.preventDefault()}
                  @focus=${tb}
                  ${at(uS)}
                />
              ` : v`${e.name}`}
        </td>
        <td part="wy-td wy-col-icon"
          >${e.comments?.count ? v`<wy-button
                part="wy-col-icon-content"
                kind="inline"
                @click=${($) => {
      !$.defaultPrevented && !e.is_trashed && ($.target.blur(), this.dispatchFileOpen(e.id, "comments"), $.stopPropagation());
    }}
                title=${P(rt`${e.comments.count} comments`)}
              >
                <wy-badge count=${e.comments.count}></wy-badge>
              </wy-button>` : C}</td
        >
        <td part="wy-td wy-col-time"
          ><time datetime="${o}" title=${l}>${d}</time></td
        >
        <td part="wy-td wy-col-kind">${e.kind}</td>
        <td part="wy-td wy-col-size">${a}</td>
        <td part="wy-td wy-col-icon">
          <wy-file-menu
            part="wy-col-icon-content"
            .file=${e}
            @edit-name=${($) => this.dispatchEditName($.detail.file)}
            @trash=${($) => this.dispatchTrash($.detail.file)}
            @restore=${($) => this.dispatchRestore($.detail.file)}
            @delete-forever=${($) => this.dispatchDeleteForever($.detail.file)}
            @subscribe=${($) => this.dispatchSubscribe($.detail.file, $.detail.subscribe)}
          >
          </wy-file-menu>
        </td>
      </tr>
    `;
  }
  render() {
    return this.files && this.files.length ? this.renderFileTable.call(
      this,
      this.files,
      this.order,
      this.isRenamingId,
      this.highlightId,
      this.highlightRef
    ) : C;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(tm, "Io"), tm), h(dx, "WyFileTable"), dx);
va.styles = [Qa, oK, lK, ft];
S1([
  O({ attribute: !1 })
], va.prototype, "files", 2);
S1([
  O({ attribute: !1 })
], va.prototype, "order", 2);
S1([
  Z()
], va.prototype, "isRenamingId", 2);
S1([
  Z()
], va.prototype, "highlightId", 2);
va = S1([
  Uz("wy-file-table"),
  kt()
], va);
var dK = Object.defineProperty, uK = Object.getOwnPropertyDescriptor, sD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$6"), Qy = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? uK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && dK(t, e, r), r;
}, "__decorateClass$s"), aD = /* @__PURE__ */ h((n, t, e) => t.has(n) || sD("Cannot " + e), "__accessCheck$6"), O9 = /* @__PURE__ */ h((n, t, e) => (aD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$6"), pK = /* @__PURE__ */ h((n, t, e) => t.has(n) ? sD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$6"), b9 = /* @__PURE__ */ h((n, t, e, i) => (aD(n, t, "write to private field"), t.set(n, e), e), "__privateSet$6"), Yc, ux, em;
let is = (ux = (em = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.highlightId = NaN, this.highlightComment = !1, this.filesQuery = new Al(this), this.previewRef = wt(), this.infiniteScroll = new Rl(this), this.pagerRef = wt(), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, pK(this, Yc);
  }
  /**
   * Resolve the query key used for the app file listing.
   *
   * @internal
   * @param app - App owning the files.
   */
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("link") && (this.highlightId = this.link && Q4(this.link, li.File)?.id, this.highlightComment = this.link && this.highlightId ? T4(this.link, li.File, { id: this.highlightId }, li.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments"), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      UV(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      this.renameFileMutation = rD(this.weavy, this.app), this.subscribeFileMutation = iD(this.weavy, this.app), this.trashFileMutation = YV(this.weavy, this.app), this.restoreFileMutation = KV(this.weavy, this.app), this.deleteForeverFileMutation = tD(this.weavy, this.app), (e = O9(this, Yc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), b9(this, Yc, () => {
        this.weavy?.unsubscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy?.unsubscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy?.unsubscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy?.unsubscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy?.unsubscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), b9(this, Yc, void 0);
      });
    }
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.filesQuery.result, r = cr(t);
    return r && r.length ? v`
        ${this.view === "grid" ? v`
              <wy-file-grid
                .files=${r}
                .highlightId=${this.highlightId}
                @file-open=${(s) => {
      this.previewRef.value?.open(s.detail.fileId, s.detail.tab);
    }}
                @order=${(s) => this.dispatchOrder(s.detail.order)}
                @rename=${(s) => {
      this.renameFileMutation?.mutate({ file: s.detail.file, name: s.detail.name });
    }}
                @subscribe=${(s) => {
      this.subscribeFileMutation?.mutate({
        file: s.detail.file,
        subscribe: s.detail.subscribe
      });
    }}
                @trash=${(s) => {
      this.trashFileMutation?.mutate({ file: s.detail.file });
    }}
                @restore=${(s) => {
      this.restoreFileMutation?.mutate({ file: s.detail.file });
    }}
                @delete-forever=${(s) => {
      this.deleteForeverFileMutation?.mutate({ file: s.detail.file });
    }}
              ></wy-file-grid>
            ` : v`
              <wy-file-table
                .files=${r}
                .order=${this.order}
                .highlightId=${this.highlightId}
                @file-open=${(s) => {
      this.previewRef.value?.open(s.detail.fileId, s.detail.tab);
    }}
                @order=${(s) => this.dispatchOrder(s.detail.order)}
                @rename=${(s) => {
      this.renameFileMutation?.mutate({ file: s.detail.file, name: s.detail.name });
    }}
                @subscribe=${(s) => {
      this.subscribeFileMutation?.mutate({
        file: s.detail.file,
        subscribe: s.detail.subscribe
      });
    }}
                @trash=${(s) => {
      this.trashFileMutation?.mutate({ file: s.detail.file });
    }}
                @restore=${(s) => {
      this.restoreFileMutation?.mutate({ file: s.detail.file });
    }}
                @delete-forever=${(s) => {
      this.deleteForeverFileMutation?.mutate({ file: s.detail.file });
    }}
              ></wy-file-table>
            `}
        ${e ? v`<div ${at(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
        ${t ? v` <wy-preview ${at(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : C}
      ` : v`
        <wy-empty>
          ${i ? v`<wy-progress-circular indeterminate padded reveal></wy-progress-circular>` : v` <wy-icon-display>
                <wy-icon name="file-upload"></wy-icon>
                <span slot="text">${P("Add some files to get started!")}</span>
              </wy-icon-display>`}
        </wy-empty>
      `;
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  disconnectedCallback() {
    var t;
    (t = O9(this, Yc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(em, "To"), em), h(ux, "WyFilesList"), ux);
Yc = /* @__PURE__ */ new WeakMap();
is.styles = [Sa];
Qy([
  O({ type: Object })
], is.prototype, "order", 2);
Qy([
  O()
], is.prototype, "view", 2);
Qy([
  O({ type: Boolean })
], is.prototype, "showTrashed", 2);
Qy([
  Z()
], is.prototype, "highlightId", 2);
Qy([
  Z()
], is.prototype, "highlightComment", 2);
is = Qy([
  U("wy-files-list"),
  kt()
], is);
var fK = Object.defineProperty, mK = Object.getOwnPropertyDescriptor, Cb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? mK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && fK(t, e, r), r;
}, "__decorateClass$r"), px, im;
let Oa = (px = (im = class extends zi {
  constructor() {
    super(), this.appType = gt.Files, this.componentFeatures = new ii({
      // All available features as enabled/disabled by default
      [I.Attachments]: !0,
      [I.CloudFiles]: !0,
      [I.Comments]: !0,
      [I.ContextData]: !0,
      [I.Embeds]: !0,
      [I.GoogleMeet]: !1,
      [I.Meetings]: !1,
      [I.Mentions]: !0,
      [I.MicrosoftTeams]: !1,
      [I.Polls]: !0,
      [I.Previews]: !0,
      [I.Reactions]: !0,
      [I.Typing]: !1,
      // Has no effect currently
      [I.Versions]: !0,
      [I.WebDAV]: !0,
      [I.ZoomMeetings]: !1
    }), this.theme = new gn(this, Oa.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.persistState = new l1(this), this.dropZone = new bL(this), this.uploadBlobMutation = new Rn(this), this.createFileMutation = new Rn(this), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  /** @internal */
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        const r = { file: e.files[i] };
        this.uploadBlobMutation.mutate(r).then((s) => this.handleCreateFile(s));
      }
  }
  /** @internal */
  handleExternalBlobs(t) {
    if (t.detail.externalBlobs)
      for (let e = 0; e < t.detail.externalBlobs.length; e++) {
        const i = t.detail.externalBlobs[e];
        this.externalBlobMutation?.mutate({ externalBlob: i }).then((r) => this.handleCreateFile(r));
      }
  }
  /** @internal */
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user && (await this.uploadBlobMutation.trackMutation(ib(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(lL(this.weavy, this.user, this.app)), this.externalBlobMutation = V4(this.weavy, this.user, this.app.id));
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        part="wy-files ${ut({ "wy-dragging": t })}"
        data-drag-title=${P("Drop files here")}
      >
        <wy-files-header
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(e) => this.handleBlobUpload(e)}
          @external-blobs=${(e) => this.handleExternalBlobs(e)}
          @create-files=${(e) => e.detail.blobs.forEach((i) => this.handleCreateFile(i, e.detail.replace))}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
          @show-trashed=${(e) => {
      this.showTrashed = e.detail.showTrashed;
    }}
          @view=${(e) => {
      this.view = e.detail.view;
    }}
          @subscribe=${(e) => this.subscribe(e.detail.subscribe)}
        >
          <slot name="actions" slot="actions"></slot>
        </wy-files-header>

        <wy-files-list
          .view=${this.view}
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
        ></wy-files-list>
      </div>
    `;
  }
}, c(im, "Fo"), im), h(px, "WyFiles"), px);
Oa.styles = [
  _V,
  Qe,
  wr,
  El,
  bi,
  _l
];
Cb([
  O()
], Oa.prototype, "view", 2);
Cb([
  O({ type: Object })
], Oa.prototype, "order", 2);
Cb([
  O({ type: Boolean })
], Oa.prototype, "showTrashed", 2);
Oa = Cb([
  U("wy-files"),
  kt()
], Oa);
function oD(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ h(async ({ id: r }) => {
      if (!(await n.fetch("/api/posts/" + r + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (s) => Object.assign(s, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (a) => Object.assign(a, r)
      );
    }, "onSuccess")
  };
  return i;
}
c(oD, "G3");
h(oD, "getTrashPostMutationOptions");
function lD(n, t) {
  return new Zt(n.queryClient, oD(n, t));
}
c(lD, "Z3");
h(lD, "getTrashPostMutation");
function cD(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ h(async ({ id: r }) => {
      const s = await n.fetch("/api/posts/" + r + "/restore", { method: "POST" });
      if (!s.ok) {
        const a = await s.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (s) => Object.assign(s, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return i;
}
c(cD, "Y3");
h(cD, "getRestorePostMutationOptions");
function hD(n, t) {
  return new Zt(n.queryClient, cD(n, t));
}
c(hD, "X3");
h(hD, "getRestorePostMutation");
function dD(n, t) {
  const e = n.queryClient, i = ["posts", t.id];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ h(async ({ id: r, subscribe: s }) => {
      const a = await n.fetch(
        `/api/posts/${r}/${s ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
      return await a.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ h((r) => {
      St(
        e,
        { queryKey: i, exact: !1 },
        r.id,
        (s) => Object.assign(s, { is_subscribed: r.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((r, s) => {
      St(
        e,
        { queryKey: i, exact: !1 },
        s.id,
        (a) => Object.assign(a, r)
      );
    }, "onSuccess")
  };
}
c(dD, "J3");
h(dD, "getSubscribePostMutationOptions");
function uD(n, t) {
  return new Zt(n.queryClient, dD(n, t));
}
c(uD, "t$");
h(uD, "getSubscribePostMutation");
function pD(n, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ h(async (e) => {
      const i = e.pageParam, r = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + i, s = await (await n.fetch(r)).json();
      return s.data = s.data || [], s;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ h((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
c(pD, "e$");
h(pD, "getPostsOptions");
function fD(n, t) {
  return {
    mutationFn: /* @__PURE__ */ h(async (e) => await (await n.fetch("/api/posts/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ h((e) => {
      ge(n.queryClient, ["posts", e.app_id], e.id, (i) => {
        i.text = e.text, i.html = e.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((e, i) => {
      i.id && ge(n.queryClient, ["posts", i.app_id], i.id, (r) => {
        r.text = e.text, r.html = e.html, r.attachments = e.attachments, r.embed = e.embed, r.meeting = e.meeting, r.updated_at = e.updated_at, r.updated_by = e.updated_by, r.options = e.options;
      });
    }, "onSuccess")
  };
}
c(fD, "i$");
h(fD, "getUpdatePostMutationOptions");
function mD(n, t) {
  const e = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ h(async (i) => await (await n.fetch("/api/apps/" + i.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((r) => r.text.trim() !== "").map((r) => ({ text: r.text })),
        embed_id: i.embed_id,
        context: i.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ h(async (i) => {
      const r = ["posts", i.app_id];
      await e.cancelQueries({ queryKey: r });
      const s = ua(n.queryClient, r, !1);
      if (i.user) {
        const a = {
          id: s ? s.id - 1 : -1,
          app: { id: i.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: i.text,
          html: i.text,
          plain: i.text,
          created_by: i.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        da(e, ["posts", i.app_id], a, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ h((i) => {
      const r = ["posts", i.app.id];
      if (!c1(n.queryClient, r, i.id)) {
        const s = ua(n.queryClient, r, !0);
        s ? ge(n.queryClient, r, s.id, (a) => {
          a.id = i.id, a.app = i.app, a.text = i.text, a.html = i.html, a.embed = i.embed, a.meeting = i.meeting, a.attachments = i.attachments, a.options = i.options, a.created_at = i.created_at, a.created_by = i.created_by, a.updated_at = i.updated_at, a.updated_by = i.updated_by;
        }) : da(n.queryClient, r, i);
      }
    }, "onSuccess")
  };
}
c(mD, "r$");
h(mD, "getAddPostMutationOptions");
const Pb = tt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-posts]{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-posts-header]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-post]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-background, var(--wy-background-light, #f7f9ff));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;clip-path:border-box;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-post][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-post-images]{display:flex;flex-direction:column;margin-top:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-header]{display:flex;flex-direction:column;padding:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-body]{display:flex;flex-direction:column;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-footer]{display:flex;align-items:center;justify-content:space-between;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-post-content]{padding:0 var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-comments]{background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));interpolate-size:allow-keywords;padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:0;visibility:hidden;transition:height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),padding var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));overflow:hidden}[part~=wy-post-comments][part~=wy-show]{height:auto;visibility:visible;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-post-trashed]{padding-bottom:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}`;
var yK = Object.defineProperty, gK = Object.getOwnPropertyDescriptor, q4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? gK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && yK(t, e, r), r;
}, "__decorateClass$q"), fx, nm;
let sy = (fx = (nm = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this);
  }
  /**
   * Emit a `restore` event requesting restoration of the trashed post.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div part="wy-post wy-post-trashed">
        <wy-item part="wy-post-header" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span part="wy-trashed" slot="title">${P("Post was trashed.")}</span>
          <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
            >${P("Undo")}</wy-button
          >
        </wy-item>
      </div>
    `;
  }
}, c(nm, "Do"), nm), h(fx, "WyPostTrashed"), fx);
sy.styles = [Pb, ft];
q4([
  O({ type: Number })
], sy.prototype, "postId", 2);
q4([
  O({ attribute: !1 })
], sy.prototype, "createdBy", 2);
sy = q4([
  U("wy-post-trashed"),
  kt()
], sy);
var wK = Object.defineProperty, vK = Object.getOwnPropertyDescriptor, xe = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? vK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && wK(t, e, r), r;
}, "__decorateClass$p"), mx, rm;
let ie = (mx = (rm = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.highlight = !1, this.showComments = !1, this.loadComments = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to move into trash.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit an `edit` event toggling edit mode for this post.
   *
   * @internal
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle comment visibility and ensure comment data is loaded.
   *
   * @internal
   * @param e - Click event originating from the comment button.
   */
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && w1(this.link, li.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && T4(this.link, li.Post, { id: this.postId }, li.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    const t = this.attachments?.filter((g) => g.kind === "image" && g.thumbnail_url), e = this.attachments?.filter((g) => g.kind !== "image" || !g.thumbnail_url), i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), r = Wl(this.weavy?.locale, new Date(this.createdAt)), s = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "", a = !!(t && t.length), o = !!this.html, l = !!(this.annotations && this.annotations.length), d = !!(this.pollOptions && this.pollOptions.length), u = !!(this.componentFeatures?.allowsFeature(I.Embeds) && this.embed), p = e && !!e.length, f = !!this.meeting, y = o || l || d || u || p || f;
    return this.postId < 0 ? v`
          <div part="wy-post">
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
              <time slot="text" part="wy-placeholder">${r}</time>
            </wy-item>
            <div part="wy-post-body">
              <div part="wy-content wy-post-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
            </div>
            <div part="wy-post-footer"></div>
          </div>
        ` : v`
          <div
            part=${ut({ "wy-post": !0, "wy-highlight": this.highlight && !this.isCommentLinked })}
            ${at(this.highlightRef)}
          >
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title">${this.createdBy.name}</span>
              <span slot="text">
                <time datetime=${this.createdAt} title=${i}>${r}</time>
                ${this.modifiedAt ? v`<time datetime="${this.modifiedAt}" title=${s}> · ${P("edited")}</time>` : C}
              </span>
              <wy-dropdown slot="actions">
                ${this.isSubscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                        <wy-icon name="bell-off"></wy-icon>
                        ${P("Unsubscribe")}
                      </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                        <wy-icon name="bell"></wy-icon>
                        ${P("Subscribe")}
                      </wy-dropdown-item>`}
                ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                        <wy-icon name="pencil"></wy-icon>
                        ${P("Edit")}
                      </wy-dropdown-item>` : C}
                ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${P("Trash")}
                      </wy-dropdown-item>` : C}
              </wy-dropdown>
            </wy-item>

            <!-- image grid -->
            ${a ? v`<wy-image-grid
                    part="wy-post-images"
                    outer
                    .images=${t}
                    @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

            ${y ? v`
                    <div part="wy-post-body">
                      <!-- text content -->
                      ${o ? v`<div part="wy-content wy-post-content">${ll(this.html)}</div>` : ""}

                      <!-- annotations -->
                      ${l ? v`<wy-annotation-list
                            .files=${this.annotations}
                            @file-open=${(g) => {
      this.previewAnnotationsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-annotation-list>` : C}

                      <!-- poll -->
                      ${d && this.pollOptions ? v`
                            <wy-poll
                              .pollOptions=${this.pollOptions}
                              @vote=${(g) => this.dispatchVote(g.detail.optionId)}
                            ></wy-poll>
                          ` : C}

                      <!-- embeds -->
                      ${u && this.embed ? v` <wy-embed .embed=${this.embed}></wy-embed> ` : C}

                      <!-- files -->
                      ${p ? v`<wy-attachment-list
                            filled
                            part="wy-post-attachments"
                            .files=${e ?? []}
                            @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-attachment-list>` : C}
                      <!-- meeting -->
                      ${f && this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : C}
                    </div>
                  ` : C}
          <div part="wy-post-footer">

            <!-- comment count -->
            ${this.componentFeatures?.allowsFeature(I.Comments) ? v` <wy-button
                    small
                    kind="inline"
                    ?active=${this.showComments}
                    part="wy-meta"
                    color="inherit"
                    @click=${(g) => this.handleCommentsClick(g)}
                  >
                    ${this.commentCount !== 1 ? P(rt`${this.commentCount} comments`) : P("1 comment")}
                  </wy-button>` : C}

            <!-- reactions -->
            ${this.componentFeatures?.allowsFeature(I.Reactions) && this.app ? v`
                    <wy-reactions
                      line
                      small
                      .reactions=${this.reactions}
                      parentId=${this.app.id}
                      parentType="apps"
                      entityId=${this.postId}
                      entityType="posts"
                    ></wy-reactions>
                  ` : C}

          </div>

          <!-- comments -->
          <div part="wy-post-comments ${ut({ "wy-show": this.showComments })}">
            ${this.loadComments ? v`
                    <wy-comment-list
                      reveal
                      part="wy-post-comment-list"
                      .parentId=${this.postId}
                      .location=${"posts"}
                    ></wy-comment-list>
                  ` : C}
          </div>
        </div>

            ${this.annotations?.length ? v`<wy-preview
                    ${at(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
            ${this.attachments?.length ? v`<wy-preview
                    ${at(this.previewAttachmentsRef)}
                    .files=${[...t, ...e]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
          </div>
        `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(rm, "Ho"), rm), h(mx, "WyPostView"), mx);
ie.styles = [Pb, CV, R4, cV, hb, by, ft];
xe([
  O({ type: Number })
], ie.prototype, "postId", 2);
xe([
  O({ attribute: !1 })
], ie.prototype, "createdBy", 2);
xe([
  O()
], ie.prototype, "createdAt", 2);
xe([
  O()
], ie.prototype, "modifiedAt", 2);
xe([
  O({ type: Boolean })
], ie.prototype, "isSubscribed", 2);
xe([
  O({ type: Boolean })
], ie.prototype, "isTrashed", 2);
xe([
  O()
], ie.prototype, "html", 2);
xe([
  O()
], ie.prototype, "text", 2);
xe([
  O({ type: Array })
], ie.prototype, "annotations", 2);
xe([
  O({ type: Array })
], ie.prototype, "attachments", 2);
xe([
  O({ type: Array })
], ie.prototype, "pollOptions", 2);
xe([
  O({ attribute: !1 })
], ie.prototype, "meeting", 2);
xe([
  O({ attribute: !1 })
], ie.prototype, "embed", 2);
xe([
  O({ type: Array })
], ie.prototype, "reactions", 2);
xe([
  O({ attribute: !1 })
], ie.prototype, "commentCount", 2);
xe([
  O({ type: Array })
], ie.prototype, "seenBy", 2);
xe([
  O({ type: Boolean })
], ie.prototype, "highlight", 2);
xe([
  Z()
], ie.prototype, "showComments", 2);
xe([
  Z()
], ie.prototype, "loadComments", 2);
xe([
  Z()
], ie.prototype, "isCommentLinked", 2);
ie = xe([
  U("wy-post-view"),
  kt()
], ie);
var OK = Object.defineProperty, bK = Object.getOwnPropertyDescriptor, $i = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? bK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && OK(t, e, r), r;
}, "__decorateClass$o"), yx, sm;
let Be = (yx = (sm = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new Rn(this);
  }
  /**
   * Emit an `edit` event toggling edit mode for the post.
   *
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Handle editor submit events and trigger the post update mutation.
   *
   * @param e - Editor submit detail containing updated content.
   */
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(fD(this.weavy, ["posts", this.app.id]));
  }
  render() {
    const t = Wl(this.weavy?.locale, new Date(this.createdAt));
    return v`
      <div part="wy-post">
        <wy-item part="wy-post-header" align="top" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
          <time slot="text" part="wy-placeholder">${t}</time>
          <wy-button slot="actions" kind="icon" @click=${() => this.dispatchEdit(!1)}>
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-item>

        <wy-editor
          editorLocation="apps"
          .text=${this.text}
          .embed=${this.embed}
          .options=${this.pollOptions}
          .attachments=${this.attachments ?? []}
          .parentId=${this.postId}
          .typing=${!1}
          .draft=${!1}
          placeholder=${P("Edit post...")}
          buttonText=${P("Update", { desc: "Button action to update" })}
          @submit=${(e) => this.handleSubmit(e)}
        ></wy-editor>
      </div>
    `;
  }
}, c(sm, "Vo"), sm), h(yx, "WyPostEdit"), yx);
Be.styles = [Pb, by, ft];
$i([
  O({ type: Number })
], Be.prototype, "postId", 2);
$i([
  O({ type: Boolean })
], Be.prototype, "temp", 2);
$i([
  O({ attribute: !1 })
], Be.prototype, "createdBy", 2);
$i([
  O()
], Be.prototype, "createdAt", 2);
$i([
  O()
], Be.prototype, "modifiedAt", 2);
$i([
  O({ type: Boolean })
], Be.prototype, "isSubscribed", 2);
$i([
  O({ type: Boolean })
], Be.prototype, "isTrashed", 2);
$i([
  O()
], Be.prototype, "text", 2);
$i([
  O({ type: Array })
], Be.prototype, "attachments", 2);
$i([
  O({ type: Array })
], Be.prototype, "pollOptions", 2);
$i([
  O({ attribute: !1 })
], Be.prototype, "meeting", 2);
$i([
  O({ attribute: !1 })
], Be.prototype, "embed", 2);
$i([
  O({ type: Array })
], Be.prototype, "reactions", 2);
$i([
  O({ type: Array })
], Be.prototype, "seenBy", 2);
Be = $i([
  U("wy-post-edit"),
  kt()
], Be);
var $K = Object.defineProperty, xK = Object.getOwnPropertyDescriptor, qe = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $K(t, e, r), r;
}, "__decorateClass$n"), gx, am;
let ue = (gx = (am = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  /**
   * Emit a `vote` event scoped to the post.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.postId, parentType: "posts" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to be trashed.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event requesting the post to be restored.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-post-trashed
            postId=${this.postId}
            .createdBy=${this.createdBy}
            @restore=${() => {
      this.dispatchRestore();
    }}
          ></wy-post-trashed> ` : C}
      ${!this.isTrashed && this.editing ? v`<wy-post-edit
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
          ></wy-post-edit> ` : C}
      ${!this.isTrashed && !this.editing ? v`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}
          ></wy-post-view> ` : C}
    `;
  }
}, c(am, "Uo"), am), h(gx, "WyPost"), gx);
ue.styles = [re];
qe([
  O({ type: Number })
], ue.prototype, "postId", 2);
qe([
  O({ attribute: !1 })
], ue.prototype, "createdBy", 2);
qe([
  O()
], ue.prototype, "createdAt", 2);
qe([
  O()
], ue.prototype, "modifiedAt", 2);
qe([
  O({ type: Boolean })
], ue.prototype, "isSubscribed", 2);
qe([
  O({ type: Boolean })
], ue.prototype, "isTrashed", 2);
qe([
  O()
], ue.prototype, "html", 2);
qe([
  O()
], ue.prototype, "text", 2);
qe([
  O()
], ue.prototype, "plain", 2);
qe([
  O({ attribute: !1 })
], ue.prototype, "annotations", 2);
qe([
  O({ attribute: !1 })
], ue.prototype, "attachments", 2);
qe([
  O({ type: Array })
], ue.prototype, "pollOptions", 2);
qe([
  O({ attribute: !1 })
], ue.prototype, "meeting", 2);
qe([
  O({ attribute: !1 })
], ue.prototype, "embed", 2);
qe([
  O({ type: Array })
], ue.prototype, "reactions", 2);
qe([
  O({ attribute: !1 })
], ue.prototype, "commentCount", 2);
qe([
  O({ type: Array })
], ue.prototype, "seenBy", 2);
qe([
  Z()
], ue.prototype, "editing", 2);
ue = qe([
  U("wy-post")
], ue);
var kK = Object.defineProperty, SK = Object.getOwnPropertyDescriptor, yD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$5"), gD = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? SK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && kK(t, e, r), r;
}, "__decorateClass$m"), wD = /* @__PURE__ */ h((n, t, e) => t.has(n) || yD("Cannot " + e), "__accessCheck$5"), $9 = /* @__PURE__ */ h((n, t, e) => (wD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$5"), CK = /* @__PURE__ */ h((n, t, e) => t.has(n) ? yD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$5"), x9 = /* @__PURE__ */ h((n, t, e, i) => (wD(n, t, "write to private field"), t.set(n, e), e), "__privateSet$5"), Gc, wx, om;
let Uw = (wx = (om = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.postsQuery = new Al(this), this.infiniteScroll = new Rl(this), this.pagerRef = wt(), this.addPostMutation = new Rn(this), this.handleRealtimePostCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), r = await this.whenUser();
      t.post.app.id !== i.id || t.post.created_by?.id === r.id || (t.post.created_by = t.actor, da(e.queryClient, ["posts", i.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), r = await this.whenUser();
      t.actor.id === r.id || !t.comment.parent || (ge(e.queryClient, ["posts", i.id], t.comment.parent.id, (s) => {
        s.comments ? s.comments.count += 1 : s.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === li.Post && ge(e.queryClient, ["posts", i.id], t.entity.id, (r) => {
        ey(r, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === li.Post && ge(e.queryClient, ["posts", i.id], t.entity.id, (r) => {
        ey(r, void 0, t.actor);
      });
    }, CK(this, Gc);
  }
  /**
   * Handle editor submissions by dispatching the create-post mutation.
   *
   * @param e - Submitted editor data.
   */
  async handleSubmit(t) {
    const e = await this.whenApp(), i = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: i,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id && await this.postsQuery.trackInfiniteQuery(pD(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id) {
      await this.addPostMutation.trackMutation(mD(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = uD(this.weavy, this.app), this.removePostMutation = lD(this.weavy, this.app), this.restorePostMutation = hD(this.weavy, this.app), this.pollMutation = lb(this.weavy, this.app.id, ["posts", this.app.id]), (e = $9(this, Gc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(I.Reactions) && (this.weavy.subscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted)), x9(this, Gc, () => {
        this.weavy?.unsubscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted), x9(this, Gc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.postsQuery.result ?? {}, r = cr(t);
    return v`
      <div part="wy-posts">
        <div part="wy-posts-header">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!Um(al.Create, this.app?.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? P("Create a post...")}
            buttonText=${P("Post")}
            @submit=${(s) => this.handleSubmit(s)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${e ? v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty> ` : v`
              ${r ? Mi(
      r,
      (s) => s.id,
      (s) => v`<wy-post
                        id="post-${s.id}"
                        .postId=${s.id}
                        .createdBy=${s.created_by}
                        .createdAt=${s.created_at}
                        .modifiedAt=${s.updated_at}
                        .isSubscribed=${s.is_subscribed}
                        .isTrashed=${s.is_trashed}
                        .html=${s.html}
                        .text=${s.text}
                        .plain=${s.plain}
                        .annotations=${s.annotations?.data}
                        .attachments=${s.attachments?.data}
                        .meeting=${s.meeting}
                        .pollOptions=${s.options?.data}
                        .embed=${s.embed}
                        .reactions=${s.reactions?.data}
                        .commentCount=${s.comments?.count || 0}
                        @subscribe=${(a) => {
        this.subscribePostMutation?.mutate({
          id: a.detail.id,
          subscribe: a.detail.subscribe
        });
      }}
                        @trash=${(a) => {
        this.removePostMutation?.mutate({ id: a.detail.id });
      }}
                        @restore=${(a) => {
        this.restorePostMutation?.mutate({ id: a.detail.id });
      }}
                        @vote=${(a) => {
        a.detail.parentType && a.detail.parentId && this.pollMutation?.mutate({
          optionId: a.detail.optionId,
          parentType: a.detail.parentType,
          parentId: a.detail.parentId
        });
      }}
                      ></wy-post>`
    ) : v`<wy-empty></wy-empty>`}
              ${i ? v`<div ${at(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = $9(this, Gc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(om, "Bo"), om), h(wx, "WyPostList"), wx);
Gc = /* @__PURE__ */ new WeakMap();
Uw.styles = [Pb, _4, Sa, ft];
gD([
  O()
], Uw.prototype, "placeholder", 2);
Uw = gD([
  U("wy-post-list"),
  kt()
], Uw);
var PK = Object.defineProperty, QK = Object.getOwnPropertyDescriptor, vD = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? QK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && PK(t, e, r), r;
}, "__decorateClass$l"), vx, lm;
let ay = (vx = (lm = class extends zi {
  constructor() {
    super(...arguments), this.appType = gt.Posts, this.componentFeatures = new ii({
      // All available features as enabled/disabled by default
      [I.Attachments]: !0,
      [I.CloudFiles]: !0,
      [I.Comments]: !0,
      [I.ContextData]: !0,
      [I.Embeds]: !0,
      [I.GoogleMeet]: !1,
      [I.Meetings]: !1,
      [I.Mentions]: !0,
      [I.MicrosoftTeams]: !1,
      [I.Polls]: !0,
      [I.Previews]: !0,
      [I.Reactions]: !0,
      [I.Typing]: !1,
      // Has no effect currently
      [I.ZoomMeetings]: !1
    }), this.theme = new gn(this, ay.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, c(lm, "qo"), lm), h(vx, "WyPosts"), vx);
ay.styles = [
  Qe,
  wr,
  El,
  _l,
  bi
];
vD([
  O()
], ay.prototype, "placeholder", 2);
ay = vD([
  U("wy-posts"),
  kt()
], ay);
const TK = tt`[part~=wy-notification] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-notification] p{display:inline}[part~=wy-notification-text]{color:var(--wy-component-color)}[part~=wy-notification-text]{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}[part~=wy-notification-text]{white-space:normal}`;
var MK = Object.defineProperty, AK = Object.getOwnPropertyDescriptor, C1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? AK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && MK(t, e, r), r;
}, "__decorateClass$k"), Ox, cm;
let ba = (Ox = (cm = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.selected = !1, this.standalone = !1;
  }
  /**
   * Emit a `select` event for the current notification.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `mark` event toggling read status.
   *
   * @internal
   * @param e - Source event triggering the action.
   * @param markAsRead - Target read state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const i = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(i);
    }
    return !0;
  }
  /**
   * Emit a `hide` event when the toast should disappear.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Emit a `close` event when the toast should close.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Handle click interactions and trigger navigation plus dismissal.
   *
   * @internal
   */
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await M4(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    const t = this.notification.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", e = this.notification.created_at ? Wl(this.weavy?.locale, new Date(this.notification.created_at)) : "", i = this.notification.actor, { title: r, titleHtml: s, detail: a } = A4(this.notification);
    return v`
      <wy-item
        part="wy-notification"
        size="md"
        interactive
        outer
        status=${!this.standalone && !this.notification.is_unread ? "read" : void 0}
        ?selected=${!this.standalone && this.selected}
        align="top"
        actionsPosition=${this.standalone ? "end" : "bottom"}
        tabindex="0"
        @click=${(o) => this.handleClick(o)}
        @keydown=${ze}
        @keyup=${di}
      >
        <wy-avatar
          slot="image"
          src=${Ot(i?.avatar_url)}
          name=${Ot(i?.name)}
          description=${Ot(i?.comment)}
          presence=${i?.presence || "away"}
          ?isAgent=${i?.is_agent}
          id=${Ot(i?.id)}
          size=${48}
        ></wy-avatar>

        <div slot="title" part="wy-notification-text" title=${r + (a ? `: "${a}"` : "")}>
          ${s}${a ? v`: <q part="wy-quote">${a}</q> ` : C}
      </div>

        ${this.standalone ? C : v`
              <time slot="text" part="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
                ${e}
              </time>
            `}
        ${this.standalone ? v`
              <wy-button
                slot="actions"
                kind="icon"
                @click=${(o) => this.dispatchMark(o, !!this.notification.is_unread) && this.dispatchClose()}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            ` : v`
              <wy-button
                small
                slot="actions"
                kind="icon"
                @click=${(o) => this.dispatchMark(o, !!this.notification.is_unread) && this.dispatchClose()}
                title=${this.notification.is_unread ? P("Mark as read") : P("Mark as unread")}
              >
                <wy-icon
                  name=${this.notification.is_unread ? "read" : "unread"}
                  color=${this.notification.is_unread ? "" : "secondary"}
                ></wy-icon>
              </wy-button>
            `}
      </wy-item>
    `;
  }
}, c(cm, "No"), cm), h(Ox, "WyNotificationListItem"), Ox);
ba.styles = [re, by, TK, ft];
C1([
  O({ type: Number })
], ba.prototype, "notificationId", 2);
C1([
  O({ type: Boolean, reflect: !0 })
], ba.prototype, "selected", 2);
C1([
  O({ type: Boolean })
], ba.prototype, "standalone", 2);
C1([
  O({ attribute: !1 })
], ba.prototype, "notification", 2);
ba = C1([
  U("wy-notification-list-item"),
  kt()
], ba);
var RK = Object.defineProperty, EK = Object.getOwnPropertyDescriptor, OD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$4"), Zl = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? EK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && RK(t, e, r), r;
}, "__decorateClass$j"), bD = /* @__PURE__ */ h((n, t, e) => t.has(n) || OD("Cannot " + e), "__accessCheck$4"), k9 = /* @__PURE__ */ h((n, t, e) => (bD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$4"), _K = /* @__PURE__ */ h((n, t, e) => t.has(n) ? OD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$4"), S9 = /* @__PURE__ */ h((n, t, e, i) => (bD(n, t, "write to private field"), t.set(n, e), e), "__privateSet$4"), Kc, bx, hm;
let oy = (bx = (hm = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.typeFilter = Ft.All, this.notificationsQuery = new Al(this), this.infiniteScroll = new Rl(this), this.pagerRef = wt(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), ge(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const i = e.actor;
        i.presence = t.indexOf(i.id) != -1 ? "active" : "away", e.actor = i;
      }));
    }, _K(this, Kc);
  }
  /**
   * Mark or unmark a notification as read.
   *
   * @param notificationId - Target notification id.
   * @param markAsRead - Desired read state.
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  /**
   * Select the provided notification and emit a `wy-action` event.
   *
   * @internal
   * @param notification - Notification to select.
   */
  selectNotification(t) {
    this.notificationId = t.id, this.dispatchAction(ci.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   *
   * @internal
   * @param action - The performed action.
   * @param notification - Selected notification payload.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, notification: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(
      WL(this.weavy, this.typeFilter, this.app?.id)
    ), t.has("weavy") && this.weavy && (this.markNotificationMutation = GP(this.weavy), (e = k9(this, Kc)) == null || e.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), S9(this, Kc, () => {
      this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), S9(this, Kc, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  /**
   * Render the notifications collection.
   *
   * @internal
   * @param user - Current user.
   * @param infiniteData - Notification pages.
   */
  renderNotifications(t, e) {
    if (e) {
      const i = cr(e);
      return Mi(
        i,
        (r) => r?.id,
        (r) => [
          v`<wy-notification-list-item
              notificationId=${r.id}
              .notification=${r}
              .selected=${this.notificationId == r.id}
              @select=${(s) => this.selectNotification(r)}
              @mark=${(s) => this.markAsRead(s.detail.notificationId, s.detail.markAsRead)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return C;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.notificationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <div class="wy-notifications">
              ${!i && this.user && t ? t.pages[0]?.count ? this.renderNotifications(this.user, t) : v`
                      <div part="wy-pane-body">
                        <div part="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${P("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
              ${e ? v`<div ${at(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : v`<wy-empty part="wy-pane"><wy-progress-circular indeterminate overlay></wy-progress-circular></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = k9(this, Kc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(hm, "jo"), hm), h(bx, "WyNotificationList"), bx);
Kc = /* @__PURE__ */ new WeakMap();
oy.styles = [
  Ll,
  Sa,
  tt`
      :host {
        position: relative;
      }
    `
];
Zl([
  O({ type: Number })
], oy.prototype, "notificationId", 2);
Zl([
  O()
], oy.prototype, "typeFilter", 2);
oy = Zl([
  U("wy-notification-list"),
  kt()
], oy);
var $x, dm;
let bl = ($x = (dm = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.typeFilter = Ft.All, this.activeFilter = Ft.All;
  }
  /**
   * Trigger `filter` event.
   *
   * @param typeFilter - Filter to emit.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchFilter(t) {
    const e = new CustomEvent("filter", {
      detail: { typeFilter: t }
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = !!this._slotDefault.length;
    return v`
      <div part="wy-pane-toolbar">
        <slot @slotchange=${() => this.requestUpdate()}></slot>
        ${t ? C : v`
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === Ft.All}
                  @click=${() => {
      this.dispatchFilter(Ft.All) && (this.typeFilter = Ft.All);
    }}
                  kind="tab"
                  small
                >
                  ${P("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ft.Activity}
                  @click=${() => {
      this.dispatchFilter(Ft.Activity) && (this.typeFilter = Ft.Activity);
    }}
                  kind="tab"
                  small
                >
                  ${P("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ft.Mention}
                  @click=${() => {
      this.dispatchFilter(Ft.Mention) && (this.typeFilter = Ft.Mention);
    }}
                  kind="tab"
                  small
                >
                  ${P("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ft.Reaction}
                  @click=${() => {
      this.dispatchFilter(Ft.Reaction) && (this.typeFilter = Ft.Reaction);
    }}
                  kind="tab"
                  small
                >
                  ${P("Reactions")}
                </wy-button>
              </wy-buttons>
            `}

        <slot name="actions" @slotchange=${() => this.requestUpdate()}></slot>
      </div>
    `;
  }
}, c(dm, "Wo"), dm), h($x, "WyNotificationHeader"), $x);
bl.styles = [
  Ll,
  Sa,
  tt`
      :host {
        position: relative;
      }
    `
];
Zl([
  O()
], bl.prototype, "typeFilter", 2);
Zl([
  Z()
], bl.prototype, "activeFilter", 2);
Zl([
  Tl({ flatten: !0, selector: ":not(slot)" })
], bl.prototype, "_slotDefault", 2);
bl = Zl([
  U("wy-notification-header"),
  kt()
], bl);
var zK = Object.defineProperty, LK = Object.getOwnPropertyDescriptor, F4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? LK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && zK(t, e, r), r;
}, "__decorateClass$i"), xx, um;
let $l = (xx = (um = class extends vy {
  constructor() {
    super(...arguments), this.unreadNotifications = new KP(this), this.theme = new gn(this, $l.styles), this.currentTypeFilter = Ft.All, this.typeFilter = Ft.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === Ft.All;
    return v`
      ${t ? v`
            <wy-notification-header
              @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
            >
              <slot name="actions" slot="actions">
                <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${P("Mark all as read")}>
                  <wy-icon name="check-all"></wy-icon>
                </wy-button>
              </slot>
            </wy-notification-header>
          ` : C}
      ${this.user ? v` <wy-notification-list typeFilter=${this.currentTypeFilter}></wy-notification-list> ` : v`
            <wy-empty>
              <wy-progress-circular indeterminate padded reveal></wy-progress-circular>
            </wy-empty>
          `}
    `;
  }
}, c(um, "Qo"), um), h(xx, "WyNotifications"), xx);
$l.styles = [Qe, wr, El, _l, bi];
F4([
  Z()
], $l.prototype, "currentTypeFilter", 2);
F4([
  O()
], $l.prototype, "typeFilter", 2);
$l = F4([
  U("wy-notifications"),
  kt()
], $l);
const $D = tt`:host{display:inline-flex}`;
var IK = Object.defineProperty, VK = Object.getOwnPropertyDescriptor, Qb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? VK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && IK(t, e, r), r;
}, "__decorateClass$h"), kx, pm;
let xl = (kx = (pm = class extends vy {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.unreadNotifications = new KP(this), this.badge = "count", this.badgePosition = "inline", this.typeFilter = Ft.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    return this.user && this.badge !== "none" ? v`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
          ></wy-badge>
        ` : C;
  }
}, c(pm, "Ko"), pm), h(kx, "WyNotificationBadge"), kx);
xl.styles = [$D, Qe, bi];
Qb([
  O({ type: String })
], xl.prototype, "badge", 2);
Qb([
  O({ type: String })
], xl.prototype, "badgePosition", 2);
Qb([
  O()
], xl.prototype, "typeFilter", 2);
xl = Qb([
  U("wy-notification-badge")
], xl);
var DK = Object.defineProperty, WK = Object.getOwnPropertyDescriptor, Xl = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? WK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && DK(t, e, r), r;
}, "__decorateClass$g"), Sx, fm;
let fr = (Sx = (fm = class extends vy {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.unreadNotifications = new KP(this), this.list = "sheet", this.badge = "compact", this.badgePosition = "top-right", this.typeFilter = Ft.All, this.currentTypeFilter = Ft.All, this.showNotificationList = !1;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === Ft.All;
    return v`
      <wy-button
        kind="icon"
        ?active=${this.showNotificationList}
        @click=${() => this.showNotificationList = !this.showNotificationList}
      >
        <wy-icon name="bell">
          ${this.user && this.badge !== "none" ? v`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
                ></wy-badge>
              ` : C}
        </wy-icon>
      </wy-button>

      ${this.list !== "none" ? v`<wy-overlay
            type=${this.list}
            .show=${this.showNotificationList}
            @close=${() => this.showNotificationList = !1}
          >
            <slot name="actions" slot="actions">
              <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${P("Mark all as read")}>
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              ${this.app ? v`
                    <wy-dropdown>
                      ${this.app?.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.subscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.subscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          `}
                    </wy-dropdown>
                  ` : C}
            </slot>
            <slot slot="title">${P("Notifications")}</slot>
            <wy-container scrollY>
              ${this.showNotificationList ? v`
                    ${t ? v`
                          <wy-notification-header
                            @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
                          ></wy-notification-header>
                        ` : C}
                    <wy-notification-list typeFilter=${this.currentTypeFilter}>
                      ${this.app && !this.app?.is_subscribed ? v`
                            <wy-empty slot="empty">
                              <div>${P("You are not subscribed to updates yet.")}</div>
                              <wy-button color="primary" @click=${() => this.subscribe(!0)}
                                >${P("Subscribe")}</wy-button
                              >
                            </wy-empty>
                          ` : C}
                    </wy-notification-list>
                  ` : C}
            </wy-container>
          </wy-overlay>` : C}
    `;
  }
}, c(fm, "Go"), fm), h(Sx, "WyNotificationButton"), Sx);
fr.styles = [ft, Qe, bi];
Xl([
  O({ type: String })
], fr.prototype, "list", 2);
Xl([
  O({ type: String })
], fr.prototype, "badge", 2);
Xl([
  O({ type: String })
], fr.prototype, "badgePosition", 2);
Xl([
  O()
], fr.prototype, "typeFilter", 2);
Xl([
  Z()
], fr.prototype, "currentTypeFilter", 2);
Xl([
  Z()
], fr.prototype, "showNotificationList", 2);
fr = Xl([
  U("wy-notification-button"),
  kt()
], fr);
var qK = Object.defineProperty, FK = Object.getOwnPropertyDescriptor, P1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? FK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && qK(t, e, r), r;
}, "__decorateClass$f"), Cx, mm;
let Hw = (Cx = (mm = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.show = !1, this.viewportRef = wt();
  }
  /**
   * Close the popover layer.
   */
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.hidePopover();
    } catch {
    }
  }
  /**
   * Handler when popover is toggled.
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("hide");
      this.dispatchEvent(e);
    }
  }
  render() {
    return v`
      <div part="wy-toasts" tabindex="0" ${at(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.hidePopover();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (e) => {
      this.handleClose(e);
    }), this.show && this.viewportRef.value?.showPopover();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, c(mm, "Zo"), mm), h(Cx, "WyToasts"), Cx);
Hw.styles = [
  o4,
  ft
];
P1([
  O({ type: Boolean })
], Hw.prototype, "show", 2);
Hw = P1([
  U("wy-toasts")
], Hw);
var Px, ym;
let ns = (Px = (ym = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.toastRef = wt(), this.show = !1, this.duration = ns.defaultDuration;
  }
  /**
   * Hide the toast.
   */
  hide() {
    this.show = !1;
  }
  /**
   * Hide and close the toast.
   * 
   * @param silent - Indicates that the toast should close silently.
   * @fires {ClosedEventType} closed - When the toast has been hidden and closed.
   */
  async close(t = !1) {
    this.show = !1, await new Promise((i) => requestAnimationFrame(i)), this.toastRef.value && await Gv(this.toastRef.value, !1);
    const e = new CustomEvent("closed", { detail: { silent: t } });
    this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return v`
      <div
        ${at(this.toastRef)}
        part="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${cb}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, c(ym, "Yo"), ym), h(Px, "WyToast"), Px);
ns.styles = [
  o4,
  ft
];
ns.defaultDuration = 5e3;
P1([
  Z()
], ns.prototype, "show", 2);
P1([
  O({ type: Number })
], ns.prototype, "duration", 2);
ns = P1([
  U("wy-toast")
], ns);
var ZK = Object.defineProperty, XK = Object.getOwnPropertyDescriptor, xD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$3"), Ty = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? XK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && ZK(t, e, r), r;
}, "__decorateClass$e"), kD = /* @__PURE__ */ h((n, t, e) => t.has(n) || xD("Cannot " + e), "__accessCheck$3"), C9 = /* @__PURE__ */ h((n, t, e) => (kD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$3"), NK = /* @__PURE__ */ h((n, t, e) => t.has(n) ? xD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$3"), P9 = /* @__PURE__ */ h((n, t, e, i) => (kD(n, t, "write to private field"), t.set(n, e), e), "__privateSet$3"), Jc, Qx, gm;
let mr = (Qx = (gm = class extends vy {
  constructor() {
    super(...arguments), this.theme = new gn(this, mr.styles), this.typeFilter = Ft.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = ns.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      if (this.typeFilter === Ft.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: e, detail: i } = A4(t.notification), r = {
            ...t.notification,
            title: e,
            detail: i,
            lang: this.weavy?.locale
          }, s = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: r
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission()) && this.dispatchEvent(s) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(r));
        }
    }, NK(this, Jc);
  }
  /** @internal */
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((r) => r.id === t.id);
      i !== -1 ? (e.splice(i, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  /** @internal */
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((r) => r.id === t.id);
      i !== -1 && (e.splice(i, 1, t), this._notifications = e);
    }
  }
  /** @internal */
  removeNotification(t) {
    const e = [...this._notifications], i = e.findIndex((r) => r.id === t);
    i !== -1 && (e.splice(i, 1), this._notifications = e);
  }
  /** @internal */
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), i = t.actor, r = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: i.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      r.onclick = async () => {
        await this.markAsRead(t.id, !0), await M4(this, this.weavy, t);
      }, r.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, r];
    }
  }
  /** @internal */
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], i = e.findIndex(
      (r) => r.tag === `wy-${t}`
    );
    return i ? (e.splice(i, 1), this._nativeNotifications = e, !0) : !1;
  }
  /** @internal */
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (i) => i.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  /** Checks if the user has granted permission for desktop notifications. A request will be made if permission has not yet been granted. */
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  /** Clears queued internal toast notifications. */
  clearNotifications() {
    this._notifications = [];
  }
  /**
   * Marks a notification as read or unread.
   * @param notificationId - The ID of the notification to mark.
   * @param [markAsRead=true] - Whether to mark the notification as read (true) or unread (false).
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = GP(this.weavy), (e = C9(this, Jc)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), P9(this, Jc, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleEvent), this.weavy?.unsubscribe(null, "notification_updated", this.handleEvent), P9(this, Jc, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return v`
      ${this.user && this.appearance === "internal" ? v`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${Mi(
      this._notifications,
      (t) => t.id,
      (t) => v`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.markAsRead(t.id, !0), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = C9(this, Jc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(gm, "Xo"), gm), h(Qx, "WyNotificationToasts"), Qx);
Jc = /* @__PURE__ */ new WeakMap();
mr.styles = [Qe, ft, bi];
Ty([
  O()
], mr.prototype, "typeFilter", 2);
Ty([
  O()
], mr.prototype, "appearance", 2);
Ty([
  O({ type: Boolean })
], mr.prototype, "requestUserPermission", 2);
Ty([
  O({ type: Number })
], mr.prototype, "duration", 2);
Ty([
  Z()
], mr.prototype, "_notifications", 2);
mr = Ty([
  U("wy-notification-toasts"),
  kt()
], mr);
const aet = new Map(
  Object.entries({
    [Sn.ChatRoom]: gt.ChatRoom,
    [Sn.PrivateChat]: gt.PrivateChat,
    [gt.ChatRoom]: Sn.ChatRoom,
    [gt.PrivateChat]: Sn.PrivateChat
  })
);
new Map(
  Object.entries({
    [Sn.AgentChat]: gt.AgentChat,
    [gt.AgentChat]: Sn.AgentChat
  })
);
const ly = {
  // All available features as enabled/disabled by default
  [I.Attachments]: !0,
  [I.CloudFiles]: !0,
  [I.ContextData]: !0,
  [I.Embeds]: !0,
  [I.GoogleMeet]: !0,
  [I.Meetings]: !0,
  [I.Mentions]: !0,
  [I.MicrosoftTeams]: !0,
  [I.Polls]: !0,
  [I.Previews]: !0,
  [I.Reactions]: !0,
  [I.Receipts]: !0,
  [I.Typing]: !0,
  [I.ZoomMeetings]: !0
}, Z4 = {
  // All available features as enabled/disabled by default
  [I.Attachments]: !0,
  [I.ContextData]: !0,
  [I.Embeds]: !0,
  [I.Previews]: !0,
  [I.Reactions]: !1,
  [I.Receipts]: !0,
  [I.Typing]: !0
}, X4 = tt`[part~=wy-messenger-layout]{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0;box-sizing:border-box}[part~=wy-messenger-overlay-container]{--wy-padding-outer: var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));--wy-component-offset-top: calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))))}[part~=wy-messenger-conversation-list]{flex:0 1 100%;min-width:0;max-width:none;display:flex;flex-direction:column;padding:var(--wy-padding-outer, var(--wy-padding, 0));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-messenger-conversation]{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;box-sizing:border-box;padding:var(--wy-padding-outer, var(--wy-padding, 0));--wy-component-offset-top: var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}[part~=wy-close-conversation]{display:contents}@container (inline-size < 768px){[part~=wy-messenger-conversation-list]:not([data-conversation-id=\"\"]){display:none}[part~=wy-messenger-conversation][data-conversation-id=\"\"]{display:none}}@container (inline-size >= 768px){[part~=wy-messenger-conversation-list]{flex:0 1 50%;max-width:calc(24*var(--wy-size, 1rem));padding-right:var(--wy-padding-outer, calc(.5 * var(--wy-size, 1rem)));border-right:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-messenger-conversation]{min-width:max(50%,calc(16 * var(--wy-size, 1rem)));padding-left:var(--wy-padding-outer, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-close-conversation]{display:none}}`;
var jK = Object.defineProperty, BK = Object.getOwnPropertyDescriptor, N4 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? BK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && jK(t, e, r), r;
}, "__decorateClass$d"), Tx, wm;
let cy = (Tx = (wm = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.uploadBlobMutation = new Rn(this), this.fileInputRef = wt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    };
  }
  /**
   * Uploads the first selected file and resets the input.
   *
   * @internal
   */
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const i = { file: t[0] };
      await this.uploadBlobMutation.trackMutation(hL(this.weavy));
      const r = await this.uploadBlobMutation.mutate(i);
      e && (e.value = "");
      const s = new CustomEvent("blob-uploaded", { detail: { blob: r } });
      this.dispatchEvent(s);
    }
  }
  render() {
    return v`
      <div part="wy-upload">
        <slot
          part="wy-upload-placeholder"
          name="placeholder"
          @click=${this.openFileInput}
          @keydown=${ze}
          @keyup=${di}
        ></slot>
        <input
          accept=${Ot(this.accept)}
          type="file"
          ${at(this.fileInputRef)}
          @click=${(t) => t.stopPropagation()}
          @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
          hidden
        />
        <slot part="wy-upload-action" name="action">
          ${this.label ? v`<wy-button part="wy-upload-button" @click=${this.openFileInput}>${this.label}</wy-button>` : C}
        </slot>
      </div>
    `;
  }
}, c(wm, "Jo"), wm), h(Tx, "WyUpload"), Tx);
cy.styles = [
  tt`
      :host {
        display: contents;
      }

      [part~="wy-upload"] {
        text-align: center;
      }

      [part~="wy-upload-placeholder"] {
        cursor: pointer;
      }
    `
];
N4([
  O({ attribute: !1 })
], cy.prototype, "label", 2);
N4([
  O({ attribute: !1 })
], cy.prototype, "accept", 2);
cy = N4([
  U("wy-upload")
], cy);
var UK = Object.defineProperty, HK = Object.getOwnPropertyDescriptor, Tb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? HK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && UK(t, e, r), r;
}, "__decorateClass$c"), Mx, vm;
let kl = (Mx = (vm = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.inputRef = wt(), this.compact = !1, this.query = "", this.throttledSearch = oS(
      () => {
        this.query = this.inputRef.value?.value || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  /**
   * Put focus on the input field.
   */
  focusInput() {
    this.inputRef.value?.focus();
  }
  /**
   * Clear the input field.
   */
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return v`
      <div part="wy-input-group">
        <input
          part=${ut(t)}
          name="text"
          .value=${this.query || ""}
          ${at(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${CI}
          @keyup=${Hr}
          placeholder=${this.placeholder || P("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" part=${ut(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" part=${ut(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, c(vm, "tc"), vm), h(Mx, "WySearch"), Mx);
kl.styles = [Qa, ft];
Tb([
  O()
], kl.prototype, "placeholder", 2);
Tb([
  O({ type: Boolean })
], kl.prototype, "compact", 2);
Tb([
  Z()
], kl.prototype, "query", 2);
kl = Tb([
  U("wy-search"),
  kt()
], kl);
var YK = Object.defineProperty, GK = Object.getOwnPropertyDescriptor, Ta = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? GK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && YK(t, e, r), r;
}, "__decorateClass$b"), Ax, Om;
let zn = (Ax = (Om = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new Al(this), this.searchRef = wt(), this.infiniteScroll = new Rl(this), this.pagerRef = wt();
  }
  /**
   * Emits the selected members via the `submit` event.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", {
      detail: { members: this.selected }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Checks whether a member is currently selected.
   *
   * @internal
   */
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  /**
   * Toggles selection state for the provided member.
   *
   * @internal
   */
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((i) => i.id !== t.id), this.selected = this.selected.filter((i) => i.id !== t.id));
  }
  /**
   * Renders the list of currently selected members.
   *
   * @internal
   */
  getSelected() {
    return this.selected.length > 0 ? v`
        ${this.selected.map((t) => v`
            <wy-item
              interactive
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${ze}
              @keyup=${ze}
            >
              <wy-avatar
                slot="image"
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${t.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="checkbox-marked"></wy-icon
              ></wy-button>
            </wy-item>
          `)}
      ` : C;
  }
  /**
   * Renders search results for the current query and filter.
   *
   * @internal
   */
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: i } = this.peopleQuery.result ?? { data: [], isPending: !0 }, r = cr(t), s = !!r.length, a = [];
    return i ? a.push(v`<wy-progress-circular indeterminate overlay></wy-progress-circular>`) : s || a.push(v`<div part="wy-pane-group">
        <div part="wy-no-result">
          ${this.text ? P("Your search did not match any people.") : P("No more users found.")}
        </div>
      </div>`), s && a.push(
      v` ${r.filter((o) => this.selected.find((l) => l.id === o.id) === void 0).map((o) => v` <wy-item
              interactive
              @click=${() => this.handleSelected(o, !this.isChecked(o.id))}
              @keydown=${ze}
              @keyup=${ze}
            >
              <wy-avatar
                slot="image"
                id=${o.id}
                .src=${o.avatar_url}
                .name=${o.name}
                .description=${o.comment}
                .presence=${o.presence}
                .isAgent=${o.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${o.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="${this.isChecked(o.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon
              ></wy-button>
            </wy-item>`) ?? C}`
    ), e && a.push(v`<div ${at(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), a;
  }
  render() {
    return v`<div part="wy-pane wy-scroll-y wy-scroll-y-always">
      <div part="wy-pane-body">
        <div part="wy-pane-group wy-pane-group-fixed-size">
          <wy-search ${at(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${P("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${P("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${P("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div part="wy-pane-body"> ${this.getSelected()} ${this.getSearchResult()} </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div part="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? P("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      xI(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await this.peopleQuery.result?.refetch?.(), this.searchRef.value?.focusInput());
  }
}, c(Om, "ec"), Om), h(Ax, "WyUsersSearch"), Ax);
zn.styles = [Vl, QI, Qa, Sa, ft, Ll];
Ta([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], zn.prototype, "weavy", 2);
Ta([
  O({ attribute: !1 })
], zn.prototype, "appId", 2);
Ta([
  O({ attribute: !1 })
], zn.prototype, "buttonTitle", 2);
Ta([
  Z()
], zn.prototype, "agentFilter", 2);
Ta([
  Z()
], zn.prototype, "selected", 2);
Ta([
  Z()
], zn.prototype, "select", 2);
Ta([
  Z()
], zn.prototype, "text", 2);
zn = Ta([
  U("wy-users-search"),
  kt()
], zn);
var KK = Object.defineProperty, JK = Object.getOwnPropertyDescriptor, SD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$2"), Nl = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JK(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && KK(t, e, r), r;
}, "__decorateClass$a"), CD = /* @__PURE__ */ h((n, t, e) => t.has(n) || SD("Cannot " + e), "__accessCheck$2"), Q9 = /* @__PURE__ */ h((n, t, e) => (CD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$2"), tJ = /* @__PURE__ */ h((n, t, e) => t.has(n) ? SD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$2"), T9 = /* @__PURE__ */ h((n, t, e, i) => (CD(n, t, "write to private field"), t.set(n, e), e), "__privateSet$2"), th, Rx, bm;
let yr = (Rx = (bm = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.membersQuery = new yn(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ h((i = []) => (i.forEach((r) => {
        r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
      }), i), "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], (i) => (i.members.data = e(i.members.data), i)), this.weavy.queryClient.setQueryData(["members", this.conversationId], (i) => e(i));
    }, tJ(this, th);
  }
  /** Checks whether the current or provided conversation is an agent chat. */
  isAgentChat(t) {
    return (t ?? this.conversation)?.type === gt.AgentChat;
  }
  /** Checks whether the current or provided conversation is a chat room. */
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === gt.ChatRoom;
  }
  /** Checks whether the current or provided conversation is a private chat. */
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === gt.PrivateChat;
  }
  /**
   * Adds a list of members to the conversation.
   *
   * @internal
   */
  async addMembers(t) {
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await this.addMembersMutation?.mutate({ appId: this.conversationId, members: t.map((e) => e.id) }), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Handles saving the conversation name from the conversation name input.
   *
   * @internal
   */
  async handleSaveConversationName() {
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await this.updateConversationMutation?.mutate({ appId: this.conversationId, name: t });
  }
  /**
   * Updates the avatar with an uploaded blob picture.
   *
   * @internal
   */
  async handleAvatarUploaded(t) {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    });
  }
  /**
   * Clears the set avatar for the conversation.
   *
   * @internal
   */
  async clearAvatar() {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null });
  }
  /**
   * Updates the access for a member in the conversation.
   *
   * @internal
   */
  async updateMember(t, e) {
    !this.weavy || !this.conversationId || (await this.updateMemberMutation?.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    }), await this.membersQuery.result.refetch());
  }
  /**
   * Removes the current or provided member from the conversation.
   *
   * If no memberId is provided, the current user leaves the conversation and the component state is cleared.
   *
   * @internal
   */
  async leaveConversation(t) {
    !this.weavy || !this.conversationId || !this.user || (t && await this.leaveConversationMutation?.mutate({
      appId: this.conversationId,
      members: [t]
    }), !t || t === this.user.id ? (this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0, this.dispatchAction(ci.Select, null)) : await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Triggers `wy-action` event.
   *
   * @param action - The performed action.
   * @param conversation - The conversation to select or `null` to clear.
   * @returns Whether the event was successful.
   *
   * @internal
   */
  dispatchAction(t, e) {
    this.conversationId = e?.id;
    const i = new CustomEvent("wy-action", { detail: { action: t, app: e }, bubbles: !0, composed: !0 });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = i4(this.weavy), this.addMembersMutation = bI(this.weavy), this.updateConversationMutation = n4(this.weavy), this.updateMemberMutation = OI(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = Q9(this, th)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          s4(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ h(() => {
              if (this.conversationId)
                return this.weavy?.queryClient.getQueryData(["apps", this.conversationId])?.members;
            }, "initialData")
          })
        );
        const i = `a${this.conversationId}`;
        this.weavy.subscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), T9(this, th, () => {
          this.weavy?.unsubscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), T9(this, th, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    const { data: t } = this.membersQuery.result ?? {}, e = (t?.data || []).filter((r) => r.access === ks.Admin).length, i = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return this.conversationId ? v`
          <wy-titlebar outer header floating part="wy-conversation-titlebar">
            <slot slot="icon" name="icon"><span></span></slot>
            ${this.conversation && this.user ? v`
                  ${this.conversation.type === gt.PrivateChat ? v`<wy-presence
                        slot="title-section"
                        placement="text"
                        .status=${i?.presence}
                        id=${Ot(i?.id)}
                      ></wy-presence>` : C}
                  <wy-titlebar-text slot="title-section">${this.conversationTitle}</wy-titlebar-text>
                ` : C}
            ${this.isChatRoom() ? v`<wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.showDetails = !0}
                  title="${P("Details")}"
                >
                  <wy-icon name="information"></wy-icon>
                </wy-button>` : C}
          </wy-titlebar>

          <!-- details modal -->
          ${this.weavy ? v`
                <wy-overlay
                  part="wy-conversation-details"
                  .show=${this.showDetails}
                  @close=${() => {
      this.showDetails = !1;
    }}
                >
                  <wy-titlebar header slot="header">
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showDetails = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${this.conversationTitle}</span>
                  </wy-titlebar>
                  <div part="wy-scroll-y">
                    ${this.showDetails && this.conversation && this.user ? v`
                          <wy-avatar-header>
                            ${this.isChatRoom() ? v`
                                  <wy-upload
                                    @blob-uploaded=${(r) => this.handleAvatarUploaded(r.detail.blob)}
                                    .accept=${"image/*"}
                                    .label=${P("Select picture")}
                                  >
                                    <div slot="placeholder">
                                      ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : v`<wy-avatar-group
                                            .members=${t?.data}
                                            title=${this.conversation.name}
                                            .size=${96}
                                          ></wy-avatar-group>`}
                                    </div>
                                    ${this.conversation.avatar_url ? v`<div slot="action"
                                          ><wy-button @click=${() => this.clearAvatar()}
                                            >${P("Remove picture")}</wy-button
                                          ></div
                                        >` : C}
                                  </wy-upload>
                                ` : v`
                                  <wy-avatar
                                    src=${Ot(i?.avatar_url)}
                                    name=${Ot(i?.name)}
                                    presence=${i?.presence || "away"}
                                    ?isAgent=${i?.is_agent}
                                    id=${Ot(i?.id)}
                                    size=${96}
                                  ></wy-avatar>
                                `}
                          </wy-avatar-header>
                          ${this.isChatRoom() ? v`
                                <div part="wy-pane-group">
                                  <label part="wy-label" for="roomName">${P("Room name")}</label>

                                  <input
                                    id="roomName"
                                    part="wy-input"
                                    .value=${this.conversationTitleInput}
                                    @input=${(r) => {
      this.conversationTitleInput = r.target.value;
    }}
                                    @keyup=${SI}
                                    @blur=${() => this.handleSaveConversationName()}
                                  />

                                  <div part="wy-description">
                                    ${P("Changing the name of a group chat changes it for everyone.")}
                                  </div>
                                  <br />
                                  <label part="wy-label">${P("Members")}</label>
                                  ${t ? v`
                                        <wy-item-list>
                                          ${t.data?.map(
      (r) => v`
                                              <wy-item>
                                                <wy-avatar
                                                  slot="image"
                                                  .src=${r.avatar_url}
                                                  .name=${r.name}
                                                  .description=${r.comment}
                                                  .isAgent=${r.is_agent}
                                                  size=${32}
                                                ></wy-avatar>
                                                <span slot="title">
                                                  ${r.name}
                                                  ${r.access === ks.Admin ? v` <wy-icon
                                                        size="20"
                                                        inline
                                                        name="shield-star"
                                                        title=${P("Admin")}
                                                      ></wy-icon>` : C}
                                                </span>
                                                ${this.user && this.user.id === r.id && !Um(al.Admin, this.conversation?.permissions) ? v` <wy-button
                                                      slot="actions"
                                                      @click=${() => this.leaveConversation(r.id)}
                                                      title=${P("Leave conversation")}
                                                      kind="icon"
                                                    >
                                                      <wy-icon name="close"></wy-icon>
                                                    </wy-button>` : Um(al.Admin, this.conversation?.permissions) ? v`<wy-dropdown slot="actions">
                                                      <wy-dropdown-item
                                                        @click=${() => this.leaveConversation(r.id)}
                                                      >
                                                        <wy-icon name="account-minus"></wy-icon>
                                                        ${this.user && this.user.id === r.id ? P("Leave conversation") : P("Remove member")}
                                                      </wy-dropdown-item>
                                                      ${e > 1 && r.access === ks.Admin ? v`<wy-dropdown-item
                                                            @click=${() => this.updateMember(r.id, ks.Write)}
                                                          >
                                                            <wy-icon name="shield-star-outline"></wy-icon>
                                                            ${P("Remove as admin")}
                                                          </wy-dropdown-item>` : r.access !== ks.Admin ? v`<wy-dropdown-item
                                                            @click=${() => this.updateMember(r.id, ks.Admin)}
                                                          >
                                                            <wy-icon name="shield-star"></wy-icon>
                                                            ${P("Make admin")}
                                                          </wy-dropdown-item>` : C}
                                                    </wy-dropdown>` : C}
                                              </wy-item>
                                            `
    ) ?? C}
                                        </wy-item-list>
                                      ` : C}
                                  <div>
                                    <wy-button
                                      part="wy-conversation-details-add-members-button"
                                      kind="filled"
                                      color="primary"
                                      @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                      title=${P("Add members")}
                                    >
                                      ${P("Add members")}
                                    </wy-button>
                                  </div>
                                </div>
                              ` : C}
                        ` : C}
                  </div>
                </wy-overlay>
              ` : C}

          <!-- add members modal -->
          ${this.weavy ? v`
                <wy-overlay
                  part="wy-conversation-add-members"
                  .show=${this.showAddMembers}
                  @close=${() => {
      this.showAddMembers = !1;
    }}
                >
                  <wy-titlebar header>
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showAddMembers = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${P("Add members")}</span>
                  </wy-titlebar>
                  ${this.showAddMembers ? v`
                        <wy-users-search
                          .buttonTitle=${P("Add members")}
                          .appId=${this.conversationId}
                          @submit=${(r) => this.addMembers(r.detail.members)}
                        ></wy-users-search>
                      ` : C}
                </wy-overlay>
              ` : C}
        ` : C;
  }
  disconnectedCallback() {
    var t;
    (t = Q9(this, th)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(bm, "ic"), bm), h(Rx, "WyConversationHeader"), Rx);
th = /* @__PURE__ */ new WeakMap();
yr.styles = [Qa, Ll, Vl, ft];
Nl([
  O({ attribute: !1 })
], yr.prototype, "conversationId", 2);
Nl([
  O({ attribute: !1 })
], yr.prototype, "conversation", 2);
Nl([
  Z()
], yr.prototype, "showDetails", 2);
Nl([
  Z()
], yr.prototype, "showAddMembers", 2);
Nl([
  Z()
], yr.prototype, "conversationTitle", 2);
Nl([
  Z()
], yr.prototype, "conversationTitleInput", 2);
yr = Nl([
  U("wy-conversation-header"),
  kt()
], yr);
var eJ = Object.defineProperty, iJ = Object.getOwnPropertyDescriptor, Q1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? iJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && eJ(t, e, r), r;
}, "__decorateClass$9"), Ex, $m;
let rs = (Ex = ($m = class extends Me {
  constructor() {
    super(...arguments), this.componentFeatures = new ii(ly), this.theme = new gn(this, rs.styles), this.unreadConversationsController = new sb(this), this.createConversationController = new rb(this), this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.conversationId = null, this.conversationQuery = new yn(this), this.persistState = new l1(this), this.conversationListRef = wt(), this.conversationNewRef = wt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [gt.AgentChat], this.componentFeatures = new ii(
      Z4,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.componentFeatures = new ii(
      ly,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: ci.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(
      r4(this.weavy, this.conversationId, this.componentTypes)
    ) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <div part="wy-messenger-layout">
        <div
          part="wy-messenger-conversation-list"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-container padded outer scrollY>
            <slot name="header"></slot>
            <wy-conversation-list
              ${at(this.conversationListRef)}
              .conversationTypes=${this.componentTypes}
              .agent=${this.agent}
              conversationId=${Ot(this.conversationId !== null ? this.conversationId : void 0)}
              @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === ci.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
            >
              <wy-conversation-new
                slot="actions"
                .agent=${this.agent}
                @create=${async (r) => {
      const s = await this.createConversationController.create(r.detail.members);
      s && (this.conversationId = s.id);
    }}
                ${at(this.conversationNewRef)}
              >
                <slot name="conversation-new"></slot>
              </wy-conversation-new>
              <slot name="actions" slot="actions"></slot>
            </wy-conversation-list>
          </wy-container>
        </div>

        <div
          part="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-conversation-header
            .conversationId=${this.conversationId || void 0}
            .conversation=${e}
            @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === ci.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
            ?hidden=${!this.conversationId}
          >
            <span slot="icon" part="wy-close-conversation">
              <wy-button kind="icon" @click=${() => this.conversationId = null}>
                <wy-icon name="back"></wy-icon>
              </wy-button>
              <wy-badge
                reveal
                .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
              ></wy-badge>
            </span>
          </wy-conversation-header>

          ${this.conversationId ? v`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${e}
                .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : C}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, c($m, "rc"), $m), h(Ex, "WyMessenger"), Ex);
rs.styles = [Qe, Vl, X4, wr, bi];
Q1([
  O({ attribute: !1 })
], rs.prototype, "componentTypes", 2);
Q1([
  O({ type: String })
], rs.prototype, "agent", 1);
Q1([
  O()
], rs.prototype, "placeholder", 2);
Q1([
  O({ type: Number })
], rs.prototype, "conversationId", 2);
rs = Q1([
  U("wy-messenger"),
  kt()
], rs);
var nJ = Object.defineProperty, rJ = Object.getOwnPropertyDescriptor, vr = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? rJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && nJ(t, e, r), r;
}, "__decorateClass$8"), _x, xm;
let Ri = (_x = (xm = class extends Me {
  constructor() {
    super(...arguments), this.componentFeatures = new ii(ly), this.theme = new gn(this, Ri.styles), this.unreadConversationsController = new sb(this), this.createConversationController = new rb(this), this.list = "drawer", this.badge = "compact", this.badgePosition = "top-right", this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.conversationId = null, this.show = !1, this.maximized = !1, this.conversationQuery = new yn(this), this.persistState = new l1(this), this.conversationListRef = wt(), this.conversationNewRef = wt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [gt.AgentChat], this.componentFeatures = new ii(
      Z4,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.componentFeatures = new ii(
      ly,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * - When in agent mode, a conversation is created instantly.
   *
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: ci.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(r4(this.weavy, this.conversationId, this.componentTypes)) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <wy-button kind="icon" ?active=${this.show} @click=${() => this.show = !this.show}>
        <wy-icon name="message-text">
          ${this.user && this.badge !== "none" ? v`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                ></wy-badge>
              ` : C}
        </wy-icon>
      </wy-button>

      ${this.list !== "none" ? v`<wy-overlay
            type=${this.list}
            .show=${this.show}
            .maximized=${this.maximized}
            @close=${() => this.show = !1}
            noHeader
          >
            <div part="wy-messenger-layout wy-messenger-overlay-container">
              <div
                part="wy-messenger-conversation-list wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <slot name="header">
                  <wy-titlebar floating header outer>
                    <wy-button kind="icon" slot="icon" @click=${() => this.show = !1}
                      ><wy-icon name="close"></wy-icon
                    ></wy-button>
                    <slot name="title" slot="title">${P("Conversations")}</slot>
                    <slot name="actions" slot="actions"></slot>
                    <wy-button kind="icon" slot="actions" @click=${() => this.maximized = !this.maximized}
                      ><wy-icon name=${this.maximized ? "arrow-collapse" : "arrow-expand"}></wy-icon
                    ></wy-button>
                  </wy-titlebar>
                </slot>

                <wy-conversation-list
                  ${at(this.conversationListRef)}
                  .conversationTypes=${this.componentTypes}
                  .agent=${this.agent}
                  conversationId=${Ot(this.conversationId !== null ? this.conversationId : void 0)}
                  @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === ci.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
                >
                  <wy-conversation-new
                    slot="actions"
                    .agent=${this.agent}
                    @create=${async (r) => {
      const s = await this.createConversationController.create(r.detail.members);
      s && (this.conversationId = s.id);
    }}
                    ${at(this.conversationNewRef)}
                  >
                    <slot name="conversation-new"></slot>
                  </wy-conversation-new>
                </wy-conversation-list>
              </div>

              <div
                part="wy-messenger-conversation wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <wy-conversation-header
                  .conversationId=${this.conversationId || void 0}
                  .conversation=${e}
                  @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === ci.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
                  ?hidden=${!this.conversationId}
                >
                  <span slot="icon" part="wy-close-conversation">
                    <wy-button kind="icon" @click=${() => this.conversationId = null}>
                      <wy-icon name="back"></wy-icon>
                    </wy-button>
                    <wy-badge
                      reveal
                      .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                    ></wy-badge>
                  </span>
                </wy-conversation-header>

                ${this.conversationId ? v`<wy-conversation
                      .conversationId=${this.conversationId}
                      .conversation=${e}
                      .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                      .header=${!this.agent}
                    ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : C}
              </div>

              <wy-context-data-progress></wy-context-data-progress>
            </div>
          </wy-overlay> ` : C}
    `;
  }
}, c(xm, "sc"), xm), h(_x, "WyMessengerButton"), _x);
Ri.styles = [Qe, Vl, X4, wr, bi];
vr([
  O({ type: String })
], Ri.prototype, "list", 2);
vr([
  O({ type: String })
], Ri.prototype, "badge", 2);
vr([
  O({ type: String })
], Ri.prototype, "badgePosition", 2);
vr([
  O({ attribute: !1 })
], Ri.prototype, "componentTypes", 2);
vr([
  O({ type: String })
], Ri.prototype, "agent", 1);
vr([
  O()
], Ri.prototype, "placeholder", 2);
vr([
  O({ type: Number })
], Ri.prototype, "conversationId", 2);
vr([
  Z()
], Ri.prototype, "show", 2);
vr([
  Z()
], Ri.prototype, "maximized", 2);
Ri = vr([
  U("wy-messenger-button"),
  kt()
], Ri);
var sJ = Object.getOwnPropertyDescriptor, aJ = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? sJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(r) || r);
  return r;
}, "__decorateClass$7"), zx, km;
let Yw = (zx = (km = class extends Me {
  constructor() {
    super(...arguments), this.theme = new gn(this, Yw.styles), this.createConversationController = new rb(this), this.conversationNewRef = wt();
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, the conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select-member dialog.
   *
   * @returns Promise resolving to the selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("agent") && (this.createConversationController.agent = this.agent);
  }
  render() {
    return v`
      <wy-conversation-new
        .agent=${this.agent}
        @create=${async (t) => {
      await this.createConversationController.create(t.detail.members);
    }}
        ${at(this.conversationNewRef)}
      ></wy-conversation-new>
    `;
  }
}, c(km, "nc"), km), h(zx, "WyMessengerNew"), zx);
Yw.styles = [Qe, Vl, X4, wr, bi];
Yw = aJ([
  U("wy-messenger-new")
], Yw);
var oJ = Object.defineProperty, lJ = Object.getOwnPropertyDescriptor, T1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? lJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && oJ(t, e, r), r;
}, "__decorateClass$6"), Lx, Sm;
let $a = (Lx = (Sm = class extends Me {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.unreadConversations = new sb(this), this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.badge = "count", this.badgePosition = "inline";
  }
  set agent(t) {
    super.agent = t, this._agentUid ? this.componentTypes = [gt.AgentChat] : this.componentTypes = [gt.ChatRoom, gt.PrivateChat];
  }
  get agent() {
    return super.agent;
  }
  /**
   * Current unread conversation count.
   */
  get unread() {
    return this.unreadConversations.unread;
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return this.user && this.badge !== "none" ? v`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadConversations.isUnreadPending ? NaN : this.unreadConversations.unread}
          ></wy-badge>
        ` : C;
  }
}, c(Sm, "ac"), Sm), h(Lx, "WyMessengerBadge"), Lx);
$a.styles = [$D, Qe, bi];
T1([
  O({ attribute: !1 })
], $a.prototype, "componentTypes", 2);
T1([
  O({ type: String })
], $a.prototype, "badge", 2);
T1([
  O({ type: String })
], $a.prototype, "badgePosition", 2);
T1([
  O({ type: String })
], $a.prototype, "agent", 1);
$a = T1([
  U("wy-messenger-badge")
], $a);
const PD = tt`[part~=wy-conversations]{position:relative;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-conversation-list]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}`;
var cJ = Object.defineProperty, hJ = Object.getOwnPropertyDescriptor, Mb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? hJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && cJ(t, e, r), r;
}, "__decorateClass$5"), Ix, Cm;
let hy = (Ix = (Cm = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.typing = new IL(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    const { names: t, ellipsis: e } = this.typing;
    let i;
    if (t.length === 1) {
      const r = t[0];
      i = P(rt`${r} is typing${e}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const r = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      i = P(rt`${r} are typing${e}`, {
        desc: "A, B and C are typing..."
      });
    }
    return i ? v`<span>${i}</span>` : v`<slot></slot>`;
  }
}, c(Cm, "oc"), Cm), h(Ix, "WyTyping"), Ix);
Mb([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], hy.prototype, "weavy", 2);
Mb([
  O({ attribute: !0, type: Number })
], hy.prototype, "appId", 2);
Mb([
  O({ attribute: !0, type: Number })
], hy.prototype, "userId", 2);
hy = Mb([
  U("wy-typing"),
  kt()
], hy);
var dJ = Object.defineProperty, uJ = Object.getOwnPropertyDescriptor, QD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError$1"), Vi = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? uJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && dJ(t, e, r), r;
}, "__decorateClass$4"), TD = /* @__PURE__ */ h((n, t, e) => t.has(n) || QD("Cannot " + e), "__accessCheck$1"), M9 = /* @__PURE__ */ h((n, t, e) => (TD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$1"), pJ = /* @__PURE__ */ h((n, t, e) => t.has(n) ? QD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$1"), A9 = /* @__PURE__ */ h((n, t, e, i) => (TD(n, t, "write to private field"), t.set(n, e), e), "__privateSet$1"), eh, Vx, Pm;
let ni = (Vx = (Pm = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = gt.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (ge(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
      }), St(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
        }
      ));
    }, this.handleConversationUpdated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      this.user && t.actor.id === this.user.id && this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, pJ(this, eh);
  }
  /**
   * Trigger `selected` event.
   *
   * @returns Whether the event was dispatched successfully.
   */
  dispatchSelected() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("selected", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Trigger `star` event.
   *
   * @param star - Whether the conversation should be starred.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchStar(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("star", {
      detail: { id: this.conversationId, star: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `pin` event.
   *
   * @param pin - Whether the conversation should be pinned.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchPin(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `mark` event for marking the conversation as read/unread.
   *
   * @param mark - Whether the conversation should be marked as read.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchMarked(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? this.lastMessage?.id : null }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Triggers `leave` event when the current user is leaving the conversation.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `remove` when the conversation should be removed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `trash` event when the conversation should be trashed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = M9(this, eh)) == null || e.call(this);
      const i = `a${this.conversationId}`;
      this.weavy.subscribe(i, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(i, "member_added", this.handleConversationUpdated), this.weavy.subscribe(i, "message_created", this.handleMessageCreated), this.weavy.subscribe(i, "app_marked", this.handleConversationMarked), A9(this, eh, () => {
        this.weavy?.unsubscribe(i, "app_updated", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "member_added", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "message_created", this.handleMessageCreated), this.weavy?.unsubscribe(i, "app_marked", this.handleConversationMarked), A9(this, eh, void 0);
      });
    }
  }
  render() {
    const t = this.lastMessage?.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", e = this.lastMessage?.created_at ? Wl(this.weavy?.locale, new Date(this.lastMessage.created_at)) : "", i = this.type === gt.PrivateChat && this.user ? (this.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-item
        part="wy-conversation-item"
        size="lg"
        interactive
        outer
        status=${this.unread ? "unread" : void 0}
        ?selected=${this.selected}
        tabindex="0"
        actionsPosition="bottom"
        @click=${(r) => (r.preventDefault(), this.dispatchSelected())}
        @keydown=${ze}
        @keyup=${di}
      >
        ${this.type !== gt.AgentChat ? this.avatarUrl ? v`<wy-avatar slot="image" .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == gt.ChatRoom ? v` <wy-avatar-group
                slot="image"
                .members=${this.members?.data}
                title=${this.name}
                .size=${48}
              ></wy-avatar-group>` : v`
                <wy-avatar
                  slot="image"
                  src=${Ot(i?.avatar_url)}
                  name=${Ot(i?.name)}
                  description=${Ot(i?.comment)}
                  presence=${i?.presence || "away"}
                  ?isAgent=${i?.is_agent}
                  id=${Ot(i?.id)}
                  size=${48}
                ></wy-avatar>
              ` : C}

        <span slot="title">${this.name || this.lastMessage?.plain || P("Untitled conversation")}</span>
        ${this.lastMessage ? v`
              <time slot="meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                >${e}</time
              >
            ` : C}
        <span slot="text">
          ${this.user ? v`
                <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                  ${this.lastMessage ? v`
                        ${this.user.id === this.lastMessage.created_by.id ? v`${P("You")}: ` : C}
                        ${this.members.count > 2 && this.user.id !== this.lastMessage?.created_by.id ? v`${this.lastMessage?.created_by.name}: ` : C}
                      ` : C}
                  ${this.lastMessage?.text ? v`<span>${this.lastMessage.plain}</span>` : C}
                  ${!this.lastMessage?.text && (this.lastMessage?.attachments?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : C}
                  ${!this.lastMessage?.text && this.lastMessage?.meeting?.id ? v`<wy-icon kind="text-icon" name="video"></wy-icon>` : C}
                  ${!this.lastMessage?.text && (this.lastMessage?.options?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="poll"></wy-icon>` : C}
                  ${this.lastMessage ? C : v`&nbsp;`}
                </wy-typing>
              ` : C}
        </span>

        ${this.starred ? v`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(r) => {
      r.stopPropagation(), this.dispatchStar(!1);
    }}
            >
              <wy-icon name="star" size=${24} color="yellow"></wy-icon>
            </wy-button>` : C}
        ${this.pinned ? v`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(r) => {
      r.stopPropagation(), this.dispatchPin(!1);
    }}
            >
              <wy-icon name="pin" size=${20} color=""></wy-icon>
            </wy-button>` : C}
 
        <wy-dropdown small slot="actions" directionX="left">
          <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
            <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
            ${this.unread ? P("Mark as read") : P("Mark as unread")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchPin(!this.pinned)}>
            <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
            ${this.pinned ? P("Unpin") : P("Pin")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchStar(!this.starred)}>
            <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
            ${this.starred ? P("Unstar") : P("Star")}
          </wy-dropdown-item>
          ${this.type === gt.PrivateChat ? v`<wy-dropdown-item @click=${() => this.dispatchRemoveConversation()}>
                <wy-icon name="trashcan"></wy-icon>
                ${P("Delete")}
              </wy-dropdown-item>` : C}
          ${this.type === gt.ChatRoom ? v`<wy-dropdown-item @click=${() => this.dispatchLeaveConversation()}>
                <wy-icon name="account-minus"></wy-icon>
                ${P("Leave")}
              </wy-dropdown-item>` : C}
          ${this.type === gt.AgentChat ? v`
                <wy-dropdown-item @click=${() => this.dispatchTrashConversation()}>
                  <wy-icon name="trashcan"></wy-icon>
                  ${P("Delete")}
                </wy-dropdown-item>
              ` : C}
        </wy-dropdown>
      </wy-item>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = M9(this, eh)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Pm, "cc"), Pm), h(Vx, "WyConversationItem"), Vx);
eh = /* @__PURE__ */ new WeakMap();
ni.styles = [PD];
Vi([
  Ve({ context: Te, subscribe: !0 }),
  Z()
], ni.prototype, "weavy", 2);
Vi([
  Ve({ context: Y0, subscribe: !0 }),
  Z()
], ni.prototype, "user", 2);
Vi([
  O({ attribute: !0, type: Number })
], ni.prototype, "conversationId", 2);
Vi([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "unread", 2);
Vi([
  O({ attribute: !0 })
], ni.prototype, "avatarUrl", 2);
Vi([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "hideAvatar", 2);
Vi([
  O({ attribute: !0 })
], ni.prototype, "name", 2);
Vi([
  O({ attribute: !0, type: String })
], ni.prototype, "type", 2);
Vi([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "selected", 2);
Vi([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "starred", 2);
Vi([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "pinned", 2);
Vi([
  O({ attribute: !1 })
], ni.prototype, "members", 2);
Vi([
  O({ attribute: !1 })
], ni.prototype, "lastMessage", 2);
ni = Vi([
  U("wy-conversation-item"),
  kt()
], ni);
var fJ = Object.defineProperty, mJ = Object.getOwnPropertyDescriptor, MD = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "__typeError"), M1 = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? mJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && fJ(t, e, r), r;
}, "__decorateClass$3"), AD = /* @__PURE__ */ h((n, t, e) => t.has(n) || MD("Cannot " + e), "__accessCheck"), R9 = /* @__PURE__ */ h((n, t, e) => (AD(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet"), yJ = /* @__PURE__ */ h((n, t, e) => t.has(n) ? MD("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd"), E9 = /* @__PURE__ */ h((n, t, e, i) => (AD(n, t, "write to private field"), t.set(n, e), e), "__privateSet"), ih, Dx, Qm;
let xa = (Dx = (Qm = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this.conversationTypes = [gt.ChatRoom, gt.PrivateChat], this.searchText = "", this.conversationsQuery = new Al(this), this.infiniteScroll = new Rl(this), this.pagerRef = wt(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ h((i) => {
        const r = i.members.data ?? [];
        r.forEach((s) => {
          s.presence = t.indexOf(s.id) != -1 ? "active" : "away";
        }), i.members.data = r;
      }, "updateMembersInApps");
      St(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, yJ(this, ih);
  }
  /**
   * Selects a conversation and triggers an action event.
   *
   * @param conversation - The conversation to select.
   */
  selectConversation(t) {
    this.conversationId = t?.id, this.dispatchAction(ci.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   * @param action - The performed action.
   * @param app - The conversation to select.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, app: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  /**
   * Marks a conversation as read.
   *
   * @param appId - The id of the conversation to mark.
   * @param messageId - Optional message id to set the marker to.
   */
  async handleMark(t, e) {
    await this.markConversationMutation?.mutate({ app: t, messageId: e, userId: this.user?.id });
  }
  /**
   * Sets a conversation as starred.
   *
   * @param appId -  The id of the conversation to star.
   * @param star - Whether to make the conversation starred.
   */
  async handleStar(t, e) {
    await this.starConversationMutation?.mutate({ appId: t, star: e });
  }
  /**
   * Sets a conversation as pinned.
   *
   * @param appId - The id of the conversation to pin.
   * @param pin - Whether to make the conversation pinned.
   */
  async handlePin(t, e) {
    await this.pinConversationMutation?.mutate({ appId: t, pin: e });
  }
  /**
   * Leave a conversation (for the current user).
   *
   * @param appId - The id of the conversation to leave.
   */
  async handleLeaveConversation(t) {
    this.conversationId === t && this.selectConversation(null);
    const e = await this.whenUser();
    await this.leaveConversationMutation?.mutate({ appId: t, members: [e.id] }), this.conversationsQuery.result.refetch();
  }
  /**
   * Remove a conversation.
   *
   * @param appId - The id of the conversation to remove.
   */
  async handleRemoveConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.removeConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  /**
   * Trash a conversation.
   *
   * @param appId - The id of the conversation to trash.
   */
  async handleTrashConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.trashConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      wL(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = e4(this.weavy), this.starConversationMutation = gI(this.weavy), this.pinConversationMutation = wI(this.weavy), this.leaveConversationMutation = i4(this.weavy), this.removeConversationMutation = vI(this.weavy), this.trashConversationMutation = $I(this.weavy), (e = R9(this, ih)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), E9(this, ih, () => {
      this.weavy?.unsubscribe(null, "app_created", this.handleRefresh), this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "member_added", this.handleRefresh), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), E9(this, ih, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await this.conversationsQuery.result.refetch?.();
  }
  renderConversations(t) {
    if (t) {
      const e = cr(t);
      return Mi(
        e,
        (i) => i?.id,
        (i) => [
          v`<wy-conversation-item
              conversationId=${i?.id}
              .avatarUrl=${i?.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${i.name}
              .lastMessage=${i.last_message}
              .members=${i.members}
              .unread=${i.is_unread}
              .starred=${i.is_starred}
              .pinned=${i.is_pinned}
              .type=${i.type}
              .selected=${this.conversationId == i.id}
              @selected=${() => this.selectConversation(i)}
              @mark=${(r) => this.handleMark(i, r.detail.messageId)}
              @star=${(r) => this.handleStar(r.detail.id, r.detail.star)}
              @pin=${(r) => this.handlePin(r.detail.id, r.detail.pin)}
              @leave=${(r) => this.handleLeaveConversation(r.detail.id)}
              @remove=${(r) => this.handleRemoveConversation(r.detail.id)}
              @trash=${(r) => this.handleTrashConversation(r.detail.id)}
            ></wy-conversation-item>`
        ]
      );
    }
    return C;
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.conversationsQuery.result ?? {};
    return v`
      <div part="wy-conversations">
        <wy-buttons part="wy-conversations-toolbar" position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
          <slot name="navigation"></slot>
          ${this.agent ? C : v`
                <wy-search
                  compact
                  placeholder=${P("Search for conversations...")}
                  @search=${(r) => this.searchText = r.detail.query}
                ></wy-search>
              `}
          <slot name="actions"></slot>
        </wy-buttons>

        <div part="wy-conversation-list">
          ${!e && this.user && t ? t.pages[0]?.count || this.searchText ? this.renderConversations(t) : v`
                  <div part="wy-pane-body">
                    <div part="wy-pane-group">
                      <wy-empty noNetwork>${P("Create a conversation to get started.")}</wy-empty>
                    </div>
                  </div>
                ` : v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
          ${i ? v`<div ${at(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
        </div>
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = R9(this, ih)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Qm, "lc"), Qm), h(Dx, "WyConversationList"), Dx);
ih = /* @__PURE__ */ new WeakMap();
xa.styles = [PD, Ll, ft, Sa];
M1([
  O({ type: Number })
], xa.prototype, "conversationId", 2);
M1([
  O({ type: Array })
], xa.prototype, "conversationTypes", 2);
M1([
  O()
], xa.prototype, "agent", 2);
M1([
  Z()
], xa.prototype, "searchText", 2);
xa = M1([
  U("wy-conversation-list"),
  kt()
], xa);
var gJ = Object.defineProperty, wJ = Object.getOwnPropertyDescriptor, Ab = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? wJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && gJ(t, e, r), r;
}, "__decorateClass$2"), Wx, Tm;
let ka = (Wx = (Tm = class extends Me {
  constructor() {
    super(...arguments), this.componentFeatures = new ii(ly), this.theme = new gn(this, ka.styles), this.unreadConversations = new sb(this), this.createConversationController = new rb(this), this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.conversationId = null, this.conversationQuery = new yn(this), this.persistState = new l1(this), this.conversationNewRef = wt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [gt.AgentChat], this.componentFeatures = new ii(
      Z4,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.componentFeatures = new ii(
      ly,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversations.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user choose members.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: ci.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("agent") && (this.createConversationController.agent = this.agent), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return v`
      <wy-conversation-list
        .conversationTypes=${this.componentTypes}
        .agent=${this.agent}
        conversationId=${Ot(this.conversationId !== null ? this.conversationId : void 0)}
        @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === ci.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
      >
        <wy-conversation-new
          slot="actions"
          .agent=${this.agent}
          @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === ci.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
          ${at(this.conversationNewRef)}
        >
          <slot name="conversation-new"></slot>
        </wy-conversation-new>
        <slot name="actions" slot="actions"></slot>
      </wy-conversation-list>
    `;
  }
}, c(Tm, "dc"), Tm), h(Wx, "WyMessengerConversations"), Wx);
ka.styles = [Qe, wr, bi, El, _l];
Ab([
  O({ attribute: !1 })
], ka.prototype, "componentTypes", 2);
Ab([
  O({ type: String })
], ka.prototype, "agent", 1);
Ab([
  O({ type: Number })
], ka.prototype, "conversationId", 2);
ka = Ab([
  U("wy-messenger-conversations"),
  kt()
], ka);
var vJ = Object.defineProperty, OJ = Object.getOwnPropertyDescriptor, Rb = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? OJ(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && vJ(t, e, r), r;
}, "__decorateClass$1"), qx, Mm;
let Sl = (qx = (Mm = class extends Li {
  constructor() {
    super(...arguments), this.exportParts = new G(this), this._whenMembers = this.createMembersPromise(), this.show = !1;
  }
  /**
   * Resolves when members are selected from the modal.
   *
   * @returns Promise<MemberIdType[]>
   */
  async whenMembers() {
    return this._whenMembers;
  }
  /**
   * Create an internal members promise and store resolve/reject handlers.
   *
   * @internal
   */
  createMembersPromise() {
    const t = new Promise((e, i) => {
      this._resolveMembers = e, this._rejectMembers = i;
    });
    return this._whenMembers = t, t;
  }
  /**
   * Open the new conversation dialog and return selected members.
   *
   * @returns Promise<MemberIdType[]>
   */
  async selectMembers() {
    return this.show = !0, await this.whenMembers();
  }
  /**
   * Close the new conversation dialog and resolve or reject the selection promise.
   *
   * @internal
   * @param members - Optional selected member ids to resolve the promise with.
   */
  close(t) {
    this.show = !1, t ? this._resolveMembers?.(t) : this._rejectMembers?.();
  }
  /**
   * Create a conversation by dispatching a `create` event and closing the dialog.
   *
   * @param members - Array of members by id/uid for a new conversation.
   */
  async submit(t = []) {
    await this.whenUser(), this.close(t);
    const e = new CustomEvent("create", {
      detail: { members: t }
    });
    this.dispatchEvent(e), this.createMembersPromise();
  }
  render() {
    return v`
      ${this.slotElements.length ? C : v`
            <wy-button
              part="wy-conversation-new-button"
              kind="icon"
              @click=${() => this.agent ? this.submit() : this.selectMembers()}
            >
              <wy-icon name="plus"></wy-icon>
            </wy-button>
          `}
      <slot></slot>

      ${!this.agent && this.weavy && this.user ? v`<wy-overlay
            part="wy-conversation-new-dialog"
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
          >
            <wy-titlebar header slot="header">
              <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
              <span slot="title">${P("New conversation")}</span>
            </wy-titlebar>
            ${this.show ? v`
                  <wy-users-search
                    @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}
                  ></wy-users-search>
                ` : C}
          </wy-overlay>` : C}
    `;
  }
}, c(Mm, "hc"), Mm), h(qx, "WyConversationNew"), qx);
Sl.styles = [ft];
Rb([
  O()
], Sl.prototype, "agent", 2);
Rb([
  Z()
], Sl.prototype, "show", 2);
Rb([
  Tl({ flatten: !0, selector: ":not(slot)" })
], Sl.prototype, "slotElements", 2);
Sl = Rb([
  U("wy-conversation-new"),
  kt()
], Sl);
const bJ = tt`[part~=wy-message-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2)}[part~=wy-message-editor-text]{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor-parts]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-message-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-message-editor] .cm-editor:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5*var(--wy-size, 1rem))}[part~=wy-message-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-message-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var $J = Object.getOwnPropertyDescriptor, xJ = /* @__PURE__ */ h((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? $J(t, e) : t, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = a(r) || r);
  return r;
}, "__decorateClass"), Fx, Am;
let y0 = (Fx = (Am = class extends Vt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  /**
   * Render content that appears above the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return v` <div part="wy-message-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      I.Attachments,
      I.CloudFiles,
      I.Polls,
      I.Meetings,
      I.ZoomMeetings,
      I.GoogleMeet,
      I.MicrosoftTeams
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(I.Attachments) ? v`
                  <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${at(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : C}
            ${this.componentFeatures?.allowsFeature(I.CloudFiles) ? v`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${P("From cloud")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsFeature(I.Polls) ? v`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${P("Poll")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(I.Meetings, I.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div part="wy-message-editor-text" ${at(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${P("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render the bottom slot for message editor with no content.
   *
   * @internal
   */
  renderBottomSlot() {
    return C;
  }
}, c(Am, "pc"), Am), h(Fx, "WyMessageEditor"), Fx);
y0.styles = [...Vt.styles, bJ];
y0 = xJ([
  U("wy-message-editor"),
  kt()
], y0);
const K = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAnnotation() {
    return Dw;
  },
  get WyAnnotationList() {
    return Ww;
  },
  get WyAttachment() {
    return Vw;
  },
  get WyAttachmentList() {
    return Jm;
  },
  get WyAvatar() {
    return hr;
  },
  get WyAvatarGroup() {
    return cl;
  },
  get WyAvatarHeader() {
    return Rw;
  },
  get WyBadge() {
    return es;
  },
  get WyButton() {
    return Gi;
  },
  get WyButtons() {
    return hl;
  },
  get WyCloudFiles() {
    return wl;
  },
  get WyComment() {
    return ur;
  },
  get WyCommentEditor() {
    return f0;
  },
  get WyCommentList() {
    return ts;
  },
  get WyContainer() {
    return Kr;
  },
  get WyContextDataProgress() {
    return m0;
  },
  get WyConversation() {
    return Ai;
  },
  get WyConversationHeader() {
    return yr;
  },
  get WyConversationItem() {
    return ni;
  },
  get WyConversationList() {
    return xa;
  },
  get WyConversationNew() {
    return Sl;
  },
  get WyDropdown() {
    return Ki;
  },
  get WyDropdownDivider() {
    return h0;
  },
  get WyDropdownItem() {
    return Lw;
  },
  get WyDropdownOption() {
    return Km;
  },
  get WyEditor() {
    return Vt;
  },
  get WyEmbed() {
    return ty;
  },
  get WyEmbedSelect() {
    return qw;
  },
  get WyEmpty() {
    return Ym;
  },
  get WyFileGrid() {
    return Ol;
  },
  get WyFileItem() {
    return pr;
  },
  get WyFileMenu() {
    return gl;
  },
  get WyFileTable() {
    return va;
  },
  get WyFileVersions() {
    return Bw;
  },
  get WyFilesHeader() {
    return wa;
  },
  get WyFilesList() {
    return is;
  },
  get WyIcon() {
    return he;
  },
  get WyIconDisplay() {
    return Aw;
  },
  get WyIconStack() {
    return s0;
  },
  get WyImageGrid() {
    return ul;
  },
  get WyItem() {
    return Ie;
  },
  get WyItemList() {
    return pa;
  },
  get WyMeetingCard() {
    return Fw;
  },
  get WyMessage() {
    return oe;
  },
  get WyMessageEditor() {
    return y0;
  },
  get WyMessageTyping() {
    return un;
  },
  get WyNotificationHeader() {
    return bl;
  },
  get WyNotificationList() {
    return oy;
  },
  get WyNotificationListItem() {
    return ba;
  },
  get WyOverlay() {
    return ya;
  },
  get WyPdfViewer() {
    return yl;
  },
  get WyPoll() {
    return Xw;
  },
  get WyPollOption() {
    return pl;
  },
  get WyPost() {
    return ue;
  },
  get WyPostEdit() {
    return Be;
  },
  get WyPostList() {
    return Uw;
  },
  get WyPostTrashed() {
    return sy;
  },
  get WyPostView() {
    return ie;
  },
  get WyPresence() {
    return Hm;
  },
  get WyPreview() {
    return de;
  },
  get WyPreviewEmbed() {
    return ga;
  },
  get WyPreviewIcon() {
    return fl;
  },
  get WyPreviewImage() {
    return ml;
  },
  get WyPreviewItem() {
    return iy;
  },
  get WyPreviewMedia() {
    return Jr;
  },
  get WyPreviewText() {
    return dr;
  },
  get WyProgressCircular() {
    return En;
  },
  get WyProgressLinear() {
    return mn;
  },
  get WyReactionItem() {
    return Nw;
  },
  get WyReactions() {
    return ve;
  },
  get WySearch() {
    return kl;
  },
  get WySkeleton() {
    return Iw;
  },
  get WyTitlebar() {
    return Gr;
  },
  get WyTitlebarText() {
    return Zw;
  },
  get WyToast() {
    return ns;
  },
  get WyToasts() {
    return Hw;
  },
  get WyTyping() {
    return hy;
  },
  get WyUpload() {
    return cy;
  },
  get WyUsersSearch() {
    return zn;
  }
}, Symbol.toStringTag, { value: "Module" }));
_e.version = "1.0.0";
_e.sourceName = "@weavy/uikit-react";
const kJ = JD(null);
function oet(n, t = []) {
  const [e, i] = b3(), r = {
    ...n,
    cloudFilePickerUrl: n.cloudFilePickerUrl?.toString(),
    locales: $3(() => n.locales, [n.locales?.length]),
    tokenUrl: n.tokenUrl?.toString(),
    tokenFactory: $3(
      () => n.tokenFactory,
      [n.tokenFactory?.toString(), ...t]
    ),
    url: n.url?.toString()
  }, [s, a] = b3(r);
  return Zx(() => {
    if (!e) {
      const l = Wc?.value ?? new Se(r);
      i(l);
    }
  }, []), Zx(() => {
    if (e && !e.isDestroyed) {
      const o = {};
      Object.entries(r).forEach(([l, d]) => {
        d !== s[l] && Object.assign(o, { [l]: d });
      }), Object.keys(o).length && (a(r), Object.assign(e, o));
    }
  }, [r]), e;
}
c(oet, "useWeavy");
const RD = Promise.resolve(), B4 = class B4 {
  constructor(t, e) {
    this.o = [], this.t = !0, this.i = !1, this.l = t, this.h = e, this.u = new Promise(((i, r) => {
      this.p = i;
    }));
  }
  addController(t) {
    this.o.push(t);
  }
  removeController(t) {
    this.o?.splice(this.o.indexOf(t) >>> 0, 1);
  }
  requestUpdate() {
    this.t || (this.t = !0, RD.then((() => this.h(++this.l))));
  }
  get updateComplete() {
    return this.u;
  }
  m() {
    this.i = !0, this.o.forEach(((t) => t.hostConnected?.()));
  }
  _() {
    this.i = !1, this.o.forEach(((t) => t.hostDisconnected?.()));
  }
  v() {
    this.o.forEach(((t) => t.hostUpdate?.()));
  }
  C() {
    this.t = !1;
    const t = this.p;
    this.u = new Promise(((e, i) => {
      this.p = e;
    })), this.o.forEach(((e) => e.hostUpdated?.())), t(this.t);
  }
};
c(B4, "s");
let dS = B4;
const SJ = /* @__PURE__ */ c((n, t) => {
  const { useState: e, useLayoutEffect: i } = n, [r, s] = e(0);
  let a = !1;
  const [o] = e((() => {
    const l = new dS(r, s), d = t(l);
    return l.M = d, l.m(), a = !0, RD.then((() => {
      a && l._();
    })), l;
  }));
  return o.t = !0, i((() => (a = !1, o.i || o.m(), () => o._())), []), i((() => o.C())), o.v(), o.M;
}, "e$1");
function CJ(n, t) {
  const e = (typeof n == "function" ? n() : n && "current" in n ? n.current : n) || void 0, i = SJ(
    N,
    (r) => new iB(r, t ?? Te, e)
  );
  return Zx(() => {
    e && i.setRef(e);
  }, [i, e]), i.context?.value;
}
c(CJ, "useWeavyContext");
const PJ = /* @__PURE__ */ new Set(["children", "localName", "ref", "style", "className"]), _9 = /* @__PURE__ */ new WeakMap(), z9 = /* @__PURE__ */ c((n, t, e, i, r) => {
  const s = r?.[t];
  s === void 0 ? (n[t] = e, e == null && t in HTMLElement.prototype && n.removeAttribute(t)) : e !== i && ((a, o, l) => {
    let d = _9.get(a);
    d === void 0 && _9.set(a, d = /* @__PURE__ */ new Map());
    let u = d.get(o);
    l !== void 0 ? u === void 0 ? (d.set(o, u = { handleEvent: l }), a.addEventListener(o, u)) : u.handleEvent = l : u !== void 0 && (d.delete(o), a.removeEventListener(o, u));
  })(n, s, e);
}, "t"), j = /* @__PURE__ */ c(({ react: n, tagName: t, elementClass: e, events: i, displayName: r }) => {
  const s = new Set(Object.keys(i ?? {})), a = n.forwardRef(((o, l) => {
    const d = n.useRef(/* @__PURE__ */ new Map()), u = n.useRef(null), p = {}, f = {};
    for (const [y, g] of Object.entries(o)) PJ.has(y) ? p[y === "className" ? "class" : y] = g : s.has(y) || y in e.prototype ? f[y] = g : p[y] = g;
    return n.useLayoutEffect((() => {
      if (u.current === null) return;
      const y = /* @__PURE__ */ new Map();
      for (const g in f) z9(u.current, g, o[g], d.current.get(g), i), d.current.delete(g), y.set(g, o[g]);
      for (const [g, b] of d.current) z9(u.current, g, void 0, b, i);
      d.current = y;
    })), n.useLayoutEffect((() => {
      u.current?.removeAttribute("defer-hydration");
    }), []), p.suppressHydrationWarning = !0, n.createElement(t, { ...p, ref: n.useCallback(((y) => {
      u.current = y, typeof l == "function" ? l(y) : l !== null && (l.current = y);
    }), [l]) });
  }));
  return a.displayName = r ?? e.name, a;
}, "o"), pe = "wy-action", Di = "wy-app", Eb = "wy-link", ED = "wy-message", _D = "wy-notification", ri = "wy-preview-open", si = "wy-preview-close", Ma = "wy-unread", QJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  onWyAction: pe,
  onWyApp: Di,
  onWyLink: Eb,
  onWyMessage: ED,
  onWyNotification: _D,
  onWyPreviewClose: si,
  onWyPreviewOpen: ri,
  onWyUnread: Ma
}, Symbol.toStringTag, { value: "Module" })), cet = j({
  react: N,
  tagName: "wy-chat",
  elementClass: ny,
  events: {
    onWyApp: Di,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), het = j({
  react: N,
  tagName: "wy-comments",
  elementClass: ry,
  events: {
    onWyApp: Di,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), det = j({
  react: N,
  tagName: "wy-component",
  elementClass: ol,
  events: {
    ...QJ
  }
}), TJ = j({
  react: N,
  tagName: "wy-context",
  elementClass: ce
});
function uet({
  children: n,
  ...t
}) {
  const e = tW(null), i = CJ(() => e.current);
  return /* @__PURE__ */ N.createElement(TJ, { ref: e, ...t }, /* @__PURE__ */ N.createElement(kJ.Provider, { value: i ?? null }, n));
}
c(uet, "WyContext");
const pet = j({
  react: N,
  tagName: "wy-copilot",
  elementClass: vl,
  events: {
    onWyApp: Di,
    onWyAction: pe,
    onWyMessage: ED,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), fet = j({
  react: N,
  tagName: "wy-files",
  elementClass: Oa,
  events: {
    onWyApp: Di,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), met = j({
  react: N,
  tagName: "wy-messenger",
  elementClass: rs,
  events: {
    onWyAction: pe,
    onWyApp: Di,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si,
    onWyUnread: Ma
  }
}), yet = j({
  react: N,
  tagName: "wy-messenger-badge",
  elementClass: $a,
  events: {
    onWyUnread: Ma
  }
}), get = j({
  react: N,
  tagName: "wy-messenger-button",
  elementClass: Ri,
  events: {
    onWyAction: pe,
    onWyApp: Di,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si,
    onWyUnread: Ma
  }
}), wet = j({
  react: N,
  tagName: "wy-messenger-conversations",
  elementClass: ka,
  events: {
    onWyAction: pe,
    onWyApp: Di,
    onWyUnread: Ma
  }
}), vet = j({
  react: N,
  tagName: "wy-messenger-new",
  elementClass: Yw,
  events: {
    onWyApp: Di
  }
}), Oet = j({
  react: N,
  tagName: "wy-notifications",
  elementClass: $l,
  events: {
    onWyAction: pe,
    onWyApp: Di,
    onWyLink: Eb,
    onWyUnread: Ma
  }
}), bet = j({
  react: N,
  tagName: "wy-notification-badge",
  elementClass: xl,
  events: {
    onWyApp: Di,
    onWyUnread: Ma
  }
}), $et = j({
  react: N,
  tagName: "wy-notification-button",
  elementClass: fr,
  events: {
    onWyAction: pe,
    onWyApp: Di,
    onWyLink: Eb,
    onWyUnread: Ma
  }
}), xet = j({
  react: N,
  tagName: "wy-notification-toasts",
  elementClass: mr,
  events: {
    onWyApp: Di,
    onWyLink: Eb,
    onWyNotification: _D
  }
}), ket = j({
  react: N,
  tagName: "wy-posts",
  elementClass: ay,
  events: {
    onWyAction: pe,
    onWyApp: Di,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), MJ = j({
  react: N,
  tagName: "wy-avatar",
  elementClass: K.WyAvatar
}), AJ = j({
  react: N,
  tagName: "wy-avatar-group",
  elementClass: K.WyAvatarGroup
}), RJ = j({
  react: N,
  tagName: "wy-avatar-header",
  elementClass: K.WyAvatarHeader
}), EJ = j({
  react: N,
  tagName: "wy-button",
  elementClass: K.WyButton
}), _J = j({
  react: N,
  tagName: "wy-buttons",
  elementClass: K.WyButtons
}), zJ = j({
  react: N,
  tagName: "wy-badge",
  elementClass: K.WyBadge
}), LJ = j({
  react: N,
  tagName: "wy-dropdown",
  elementClass: K.WyDropdown
}), IJ = j({
  react: N,
  tagName: "wy-dropdown-item",
  elementClass: K.WyDropdownItem
}), VJ = j({
  react: N,
  tagName: "wy-dropdown-option",
  elementClass: K.WyDropdownOption
}), DJ = j({
  react: N,
  tagName: "wy-dropdown-divider",
  elementClass: K.WyDropdownDivider
}), WJ = j({
  react: N,
  tagName: "wy-icon",
  elementClass: K.WyIcon
}), qJ = j({
  react: N,
  tagName: "wy-icon-stack",
  elementClass: K.WyIconStack
}), FJ = j({
  react: N,
  tagName: "wy-icon-display",
  elementClass: K.WyIconDisplay
}), ZJ = j({
  react: N,
  tagName: "wy-image-grid",
  elementClass: K.WyImageGrid,
  events: {
    onFileOpen: "file-open"
  }
}), XJ = j({
  react: N,
  tagName: "wy-item",
  elementClass: K.WyItem
}), NJ = j({
  react: N,
  tagName: "wy-item-list",
  elementClass: K.WyItemList
}), jJ = j({
  react: N,
  tagName: "wy-overlay",
  elementClass: K.WyOverlay,
  events: {
    onClose: "close"
  }
}), BJ = j({
  react: N,
  tagName: "wy-presence",
  elementClass: K.WyPresence
}), UJ = j({
  react: N,
  tagName: "wy-progress-circular",
  elementClass: K.WyProgressCircular
}), HJ = j({
  react: N,
  tagName: "wy-progress-linear",
  elementClass: K.WyProgressLinear
}), YJ = j({
  react: N,
  tagName: "wy-search",
  elementClass: K.WySearch,
  events: {
    onSearch: "search"
  }
}), GJ = j({
  react: N,
  tagName: "wy-container",
  elementClass: K.WyContainer
}), KJ = j({
  react: N,
  tagName: "wy-skeleton",
  elementClass: K.WySkeleton
}), JJ = j({
  react: N,
  tagName: "wy-titlebar",
  elementClass: K.WyTitlebar
}), ttt = j({
  react: N,
  tagName: "wy-titlebar-text",
  elementClass: K.WyTitlebarText
}), ett = j({
  react: N,
  tagName: "wy-toasts",
  elementClass: K.WyToasts,
  events: {
    onHide: "hide"
  }
}), itt = j({
  react: N,
  tagName: "wy-toast",
  elementClass: K.WyToast,
  events: {
    onClosed: "closed"
  }
}), ntt = j({
  react: N,
  tagName: "wy-annotation",
  elementClass: K.WyAnnotation
}), rtt = j({
  react: N,
  tagName: "wy-annotation-list",
  elementClass: K.WyAnnotationList,
  events: {
    onFileOpen: "file-open"
  }
}), stt = j({
  react: N,
  tagName: "wy-attachment",
  elementClass: K.WyAttachment,
  events: {
    onFileOpen: "file-open"
  }
}), att = j({
  react: N,
  tagName: "wy-attachment-list",
  elementClass: K.WyAttachmentList,
  events: {
    onFileOpen: "file-open"
  }
}), ott = j({
  react: N,
  tagName: "wy-upload",
  elementClass: K.WyUpload,
  events: {
    onBlobUploaded: "blob-uploaded"
  }
}), ltt = j({
  react: N,
  tagName: "wy-cloud-files",
  elementClass: K.WyCloudFiles,
  events: {
    onExternalBlobs: "external-blobs"
  }
}), ctt = j({
  react: N,
  tagName: "wy-comment-list",
  elementClass: K.WyCommentList,
  events: {
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), htt = j({
  react: N,
  tagName: "wy-comment",
  elementClass: K.WyComment,
  events: {
    onVote: "vote",
    onTrash: "trash",
    onRestore: "restore",
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), dtt = j({
  react: N,
  tagName: "wy-context-data-progress",
  elementClass: K.WyContextDataProgress
}), utt = j({
  react: N,
  tagName: "wy-conversation",
  elementClass: K.WyConversation,
  events: {
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), ptt = j({
  react: N,
  tagName: "wy-conversation-header",
  elementClass: K.WyConversationHeader,
  events: {
    onWyAction: pe
  }
}), ftt = j({
  react: N,
  tagName: "wy-conversation-new",
  elementClass: K.WyConversationNew,
  events: {
    onSelected: "create"
  }
}), mtt = j({
  react: N,
  tagName: "wy-conversation-list",
  elementClass: K.WyConversationList,
  events: {
    onWyAction: pe
  }
}), ytt = j({
  react: N,
  tagName: "wy-conversation-item",
  elementClass: K.WyConversationItem,
  events: {
    onSelected: "selected",
    onStar: "star",
    onPin: "pin",
    onMark: "mark",
    onLeave: "leave",
    onRemove: "remove",
    onTrash: "trash"
  }
}), gtt = j({
  react: N,
  tagName: "wy-editor",
  elementClass: K.WyEditor,
  events: {
    onSubmit: "submit"
  }
}), wtt = j({
  react: N,
  tagName: "wy-comment-editor",
  elementClass: K.WyCommentEditor,
  events: {
    onSubmit: "submit"
  }
}), vtt = j({
  react: N,
  tagName: "wy-message-editor",
  elementClass: K.WyMessageEditor,
  events: {
    onSubmit: "submit"
  }
}), Ott = j({
  react: N,
  tagName: "wy-embed",
  elementClass: K.WyEmbed,
  events: {
    onWyAction: pe
  }
}), btt = j({
  react: N,
  tagName: "wy-embed-select",
  elementClass: K.WyEmbedSelect,
  events: {
    onEmbedRemove: "embed-remove",
    onEmbedSwap: "embed-swap"
  }
}), $tt = j({
  react: N,
  tagName: "wy-empty",
  elementClass: K.WyEmpty
}), xtt = j({
  react: N,
  tagName: "wy-file-grid",
  elementClass: K.WyFileGrid,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), ktt = j({
  react: N,
  tagName: "wy-file-item",
  elementClass: K.WyFileItem,
  events: {
    onEditName: "edit-name",
    onRename: "rename",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), Stt = j({
  react: N,
  tagName: "wy-file-menu",
  elementClass: K.WyFileMenu,
  events: {
    onEditName: "edit-name",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), Ctt = j({
  react: N,
  tagName: "wy-file-table",
  elementClass: K.WyFileTable,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), Ptt = j({
  react: N,
  tagName: "wy-file-versions",
  elementClass: K.WyFileVersions,
  events: {
    onFileVersionSelect: "file-version-select"
  }
}), Qtt = j({
  react: N,
  tagName: "wy-files-header",
  elementClass: K.WyFilesHeader,
  events: {
    onUploadFiles: "upload-files",
    onExternalBlobs: "external-blobs",
    onCreateFiles: "create-files",
    onOrder: "order",
    onView: "view",
    onShowTrashed: "show-trashed",
    onSubscribe: "subscribe"
  }
}), Ttt = j({
  react: N,
  tagName: "wy-files-list",
  elementClass: K.WyFilesList,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe",
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), Mtt = j({
  react: N,
  tagName: "wy-meeting-card",
  elementClass: K.WyMeetingCard
}), Att = "vote", Rtt = "typing", Ett = j({
  react: N,
  tagName: "wy-message",
  elementClass: K.WyMessage,
  events: {
    onVote: Att,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), _tt = j({
  react: N,
  tagName: "wy-message-typing",
  elementClass: K.WyMessageTyping,
  events: {
    onTyping: Rtt
  }
}), ztt = j({
  react: N,
  tagName: "wy-notification-list",
  elementClass: K.WyNotificationList,
  events: {
    onWyAction: pe
  }
}), Ltt = j({
  react: N,
  tagName: "wy-notification-header",
  elementClass: K.WyNotificationHeader
}), Itt = j({
  react: N,
  tagName: "wy-notification-list-item",
  elementClass: K.WyNotificationListItem,
  events: {
    onSelect: "select",
    onMark: "mark",
    onHide: "hide",
    onClose: "close"
  }
}), Vtt = j({
  react: N,
  tagName: "wy-pdf-viewer",
  elementClass: K.WyPdfViewer,
  events: {
    onFilePreviewLoaded: "file-preview-loaded"
  }
}), Dtt = j({
  react: N,
  tagName: "wy-poll",
  elementClass: K.WyPoll,
  events: {
    onVote: "vote"
  }
}), Wtt = j({
  react: N,
  tagName: "wy-poll-option",
  elementClass: K.WyPollOption,
  events: {
    onVote: "vote"
  }
}), j4 = "edit", zD = "vote", LD = "subscribe", ID = "trash", VD = "restore", qtt = j({
  react: N,
  tagName: "wy-post-list",
  elementClass: K.WyPostList,
  events: {
    onEdit: j4,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), Ftt = j({
  react: N,
  tagName: "wy-post",
  elementClass: K.WyPost,
  events: {
    onVote: zD,
    onSubscribe: LD,
    onTrash: ID,
    onRestore: VD,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), Ztt = j({
  react: N,
  tagName: "wy-post-view",
  elementClass: K.WyPostView,
  events: {
    onVote: zD,
    onSubscribe: LD,
    onTrash: ID,
    onEdit: j4,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: si
  }
}), Xtt = j({
  react: N,
  tagName: "wy-post-edit",
  elementClass: K.WyPostEdit,
  events: {
    onEdit: j4
  }
}), Ntt = j({
  react: N,
  tagName: "wy-post-trashed",
  elementClass: K.WyPostTrashed,
  events: {
    onRestore: VD
  }
}), My = "file-preview-loaded", jtt = j({
  react: N,
  tagName: "wy-preview",
  elementClass: K.WyPreview,
  events: {
    onWyPreviewOpen: ri,
    onWyPreviewClose: si,
    onWyAction: pe
  }
}), Btt = j({
  react: N,
  tagName: "wy-preview-embed",
  elementClass: K.WyPreviewEmbed,
  events: {
    onFilePreviewLoaded: My
  }
}), Utt = j({
  react: N,
  tagName: "wy-preview-icon",
  elementClass: K.WyPreviewIcon,
  events: {
    onFilePreviewLoaded: My
  }
}), Htt = j({
  react: N,
  tagName: "wy-preview-image",
  elementClass: K.WyPreviewImage,
  events: {
    onFilePreviewLoaded: My
  }
}), Ytt = j({
  react: N,
  tagName: "wy-preview-item",
  elementClass: K.WyPreviewItem,
  events: {
    onFilePreviewLoaded: My
  }
}), Gtt = j({
  react: N,
  tagName: "wy-preview-media",
  elementClass: K.WyPreviewMedia,
  events: {
    onFilePreviewLoaded: My
  }
}), Ktt = j({
  react: N,
  tagName: "wy-preview-text",
  elementClass: K.WyPreviewText,
  events: {
    onFilePreviewLoaded: My
  }
}), Jtt = "close", tet = j({
  react: N,
  tagName: "wy-reactions",
  elementClass: K.WyReactions,
  events: {
    onClose: Jtt
  }
}), eet = j({
  react: N,
  tagName: "wy-reaction-item",
  elementClass: K.WyReactionItem
}), iet = j({
  react: N,
  tagName: "wy-typing",
  elementClass: K.WyTyping
}), net = j({
  react: N,
  tagName: "wy-users-search",
  elementClass: K.WyUsersSearch,
  events: {
    onSubmit: "submit"
  }
}), Cet = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WyAnnotation: ntt,
  WyAnnotationList: rtt,
  WyAttachment: stt,
  WyAttachmentList: att,
  WyAvatar: MJ,
  WyAvatarGroup: AJ,
  WyAvatarHeader: RJ,
  WyBadge: zJ,
  WyButton: EJ,
  WyButtons: _J,
  WyCloudFiles: ltt,
  WyComment: htt,
  WyCommentEditor: wtt,
  WyCommentList: ctt,
  WyContainer: GJ,
  WyContextDataProgress: dtt,
  WyConversation: utt,
  WyConversationAppbar: ptt,
  WyConversationItem: ytt,
  WyConversationList: mtt,
  WyConversationNew: ftt,
  WyDropdown: LJ,
  WyDropdownDivider: DJ,
  WyDropdownItem: IJ,
  WyDropdownOption: VJ,
  WyEditor: gtt,
  WyEmbed: Ott,
  WyEmbedSelect: btt,
  WyEmpty: $tt,
  WyFileGrid: xtt,
  WyFileItem: ktt,
  WyFileMenu: Stt,
  WyFileTable: Ctt,
  WyFileVersions: Ptt,
  WyFilesHeader: Qtt,
  WyFilesList: Ttt,
  WyIcon: WJ,
  WyIconDisplay: FJ,
  WyIconStack: qJ,
  WyImageGrid: ZJ,
  WyItem: XJ,
  WyItemList: NJ,
  WyMeetingCard: Mtt,
  WyMessage: Ett,
  WyMessageEditor: vtt,
  WyMessageTyping: _tt,
  WyNotificationHeader: Ltt,
  WyNotificationList: ztt,
  WyNotificationListitem: Itt,
  WyOverlay: jJ,
  WyPdfViewer: Vtt,
  WyPoll: Dtt,
  WyPollOption: Wtt,
  WyPost: Ftt,
  WyPostEdit: Xtt,
  WyPostList: qtt,
  WyPostTrashed: Ntt,
  WyPostView: Ztt,
  WyPresence: BJ,
  WyPreview: jtt,
  WyPreviewEmbed: Btt,
  WyPreviewIcon: Utt,
  WyPreviewImage: Htt,
  WyPreviewItem: Ytt,
  WyPreviewMedia: Gtt,
  WyPreviewText: Ktt,
  WyProgressCircular: UJ,
  WyProgressLinear: HJ,
  WyReactionItem: eet,
  WyReactions: tet,
  WySearch: YJ,
  WySkeleton: KJ,
  WyTitlebar: JJ,
  WyTitlebarText: ttt,
  WyToast: itt,
  WyToasts: ett,
  WyTyping: iet,
  WyUpload: ott,
  WyUsersSearch: net
}, Symbol.toStringTag, { value: "Module" }));
export {
  dB as AppTypeGuids,
  uB as AppTypeStrings,
  I as Feature,
  aet as MessengerTypes,
  Se as Weavy,
  Cet as WeavyComponents,
  kJ as WeavyContext,
  cet as WyChat,
  het as WyComments,
  det as WyComponent,
  uet as WyContext,
  pet as WyCopilot,
  fet as WyFiles,
  met as WyMessenger,
  yet as WyMessengerBadge,
  get as WyMessengerButton,
  wet as WyMessengerConversations,
  vet as WyMessengerNew,
  bet as WyNotificationBadge,
  $et as WyNotificationButton,
  xet as WyNotificationToasts,
  Oet as WyNotifications,
  ket as WyPosts,
  oet as useWeavy,
  CJ as useWeavyContext
};
