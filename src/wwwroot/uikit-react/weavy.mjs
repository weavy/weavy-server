"use client";
var bZ = Object.defineProperty;
var h = (n, t) => bZ(n, "name", { value: t, configurable: !0 });
import J, { createContext as OZ, useState as EC, useMemo as zC, useEffect as d$, useRef as $Z } from "react";
var xZ = Object.defineProperty, y = /* @__PURE__ */ h((n, t) => xZ(n, "name", { value: t, configurable: !0 }), "c$1");
const Zk = /* @__PURE__ */ y((n) => {
  n && requestAnimationFrame(() => {
    var t;
    return (t = n == null ? void 0 : n.focus) == null ? void 0 : t.call(n);
  });
}, "autofocusRef");
async function sl(n, t = "wy-") {
  const e = [];
  for (let i = n; i = i.parentElement; )
    i.matches(":not(:defined)") && i.localName.startsWith(t) && e.push(customElements.whenDefined(i.localName));
  await Promise.all(e);
}
h(sl, "Uw$1");
y(sl, "whenParentsDefined");
const t9 = /* @__PURE__ */ y((n, t) => {
  let e;
  const i = new ResizeObserver(() => {
    const { isConnected: s } = n;
    s !== e && (e = s, t(s, n));
  });
  return i.observe(n), i;
}, "observeConnected");
async function Wk(n, t = !0) {
  if (n.isConnected === t)
    return t;
  {
    let e;
    const i = new Promise((r) => e = r), s = t9(n, (r) => {
      r === t && (e == null || e(t));
    });
    return await i, s.disconnect(), t;
  }
}
h(Wk, "Ww$1");
y(Wk, "whenConnected");
async function e9() {
  ti(), document.hidden && await new Promise((n) => {
    window.addEventListener(
      "visibilitychange",
      () => {
        document.hidden || n(!0);
      },
      { once: !0 }
    );
  });
}
h(e9, "Xw$1");
y(e9, "whenDocumentVisible");
const Dk = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  /* @ts-ignore */
  opacityProperty: !0,
  visibilityProperty: !0,
  // Legacy compatibility
  checkOpacity: !0,
  checkVisibilityCSS: !0
};
function qk(n, t = !0, e = Dk, i) {
  n.checkVisibility(e) === t ? i(t) : requestAnimationFrame(() => qk(n, t, e, i));
}
h(qk, "_d$1");
y(qk, "untilVisibility");
async function q1(n, t = !0, e = Dk) {
  n.checkVisibility(e) !== t && await new Promise((i) => {
    qk(n, t, e, i);
  });
}
h(q1, "Yw$1");
y(q1, "whenElementVisible");
function u$(n) {
  return n.getRootNode() instanceof ShadowRoot;
}
h(u$, "Iw$1");
y(u$, "isInShadowDom");
function V1() {
  var n;
  return !!((n = document.body) != null && n.showPopover && !/native code/i.test(document.body.showPopover.toString()));
}
h(V1, "jw$1");
y(V1, "isPopoverPolyfilled");
function a0() {
  return typeof window < "u";
}
h(a0, "qw$1");
y(a0, "isDomAvailable");
function ti() {
  if (typeof window > "u")
    throw Error("DOM not available");
}
h(ti, "Cd$1");
y(ti, "throwOnDomNotAvailable");
let p$ = [], i9 = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, e = 0; t < n.length; t++)
    (t % 2 ? i9 : p$).push(e = e + n[t]);
})();
function n9(n) {
  if (n < 768) return !1;
  for (let t = 0, e = p$.length; ; ) {
    let i = t + e >> 1;
    if (n < p$[i]) e = i;
    else if (n >= i9[i]) t = i + 1;
    else return !0;
    if (t == e) return !1;
  }
}
h(n9, "mg$1");
y(n9, "isExtendingChar");
function f$(n) {
  return n >= 127462 && n <= 127487;
}
h(f$, "vc$1");
y(f$, "isRegionalIndicator");
const _C = 8205;
function s9(n, t, e = !0, i = !0) {
  return (e ? Vk : r9)(n, t, i);
}
h(s9, "gg$1");
y(s9, "findClusterBreak$1");
function Vk(n, t, e) {
  if (t == n.length) return t;
  t && jk(n.charCodeAt(t)) && Fk(n.charCodeAt(t - 1)) && t--;
  let i = Hg(n, t);
  for (t += y$(i); t < n.length; ) {
    let s = Hg(n, t);
    if (i == _C || s == _C || e && n9(s))
      t += y$(s), i = s;
    else if (f$(s)) {
      let r = 0, a = t - 2;
      for (; a >= 0 && f$(Hg(n, a)); )
        r++, a -= 2;
      if (r % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
h(Vk, "Vd");
y(Vk, "nextClusterBreak");
function r9(n, t, e) {
  for (; t > 0; ) {
    let i = Vk(n, t - 2, e);
    if (i < t) return i;
    t--;
  }
  return 0;
}
h(r9, "yg$1");
y(r9, "prevClusterBreak");
function Hg(n, t) {
  let e = n.charCodeAt(t);
  if (!Fk(e) || t + 1 == n.length) return e;
  let i = n.charCodeAt(t + 1);
  return jk(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
h(Hg, "Po$1");
y(Hg, "codePointAt$1");
function jk(n) {
  return n >= 56320 && n < 57344;
}
h(jk, "Ud");
y(jk, "surrogateLow$1");
function Fk(n) {
  return n >= 55296 && n < 56320;
}
h(Fk, "Wd");
y(Fk, "surrogateHigh$1");
function y$(n) {
  return n < 65536 ? 1 : 2;
}
h(y$, "Ac$1");
y(y$, "codePointSize$1");
var Ya;
const a9 = (Ya = class {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, e, i) {
    [t, e] = _o(this, t, e);
    let s = [];
    return this.decompose(
      0,
      t,
      s,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      e,
      this.length,
      s,
      1
      /* Open.From */
    ), Yg.from(s, this.length - (e - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, e = this.length) {
    [t, e] = _o(this, t, e);
    let i = [];
    return this.decompose(t, e, i, 0), Yg.from(i, e - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), s = new Hm(this), r = new Hm(t);
    for (let a = e, o = e; ; ) {
      if (s.next(a), r.next(a), a = 0, s.lineBreak != r.lineBreak || s.done != r.done || s.value != r.value)
        return !1;
      if (o += s.value.length, s.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new Hm(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, e = this.length) {
    return new u9(this, t, e);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let s = this.line(t).from;
      i = this.iterRange(s, Math.max(s, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new f9(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? Ya.empty : t.length <= 32 ? new wn(t) : Yg.from(wn.split(t, []));
  }
}, h(Ya, "Us"), Ya);
y(a9, "Text");
let Zt = a9;
var pi;
const o9 = (pi = class extends Zt {
  constructor(t, e = c9(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, s) {
    for (let r = 0; ; r++) {
      let a = this.text[r], o = s + a.length;
      if ((e ? i : o) >= t)
        return new kZ(s, o, i, a);
      s = o + 1, i++;
    }
  }
  decompose(t, e, i, s) {
    let r = t <= 0 && e >= this.length ? this : new pi(m$(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (s & 1) {
      let a = i.pop(), o = Nm(r.text, a.text.slice(), 0, r.length);
      if (o.length <= 32)
        i.push(new pi(o, a.length + r.length));
      else {
        let l = o.length >> 1;
        i.push(new pi(o.slice(0, l)), new pi(o.slice(l)));
      }
    } else
      i.push(r);
  }
  replace(t, e, i) {
    if (!(i instanceof pi))
      return super.replace(t, e, i);
    [t, e] = _o(this, t, e);
    let s = Nm(this.text, Nm(i.text, m$(this.text, 0, t)), e), r = this.length + i.length - (e - t);
    return s.length <= 32 ? new pi(s, r) : Yg.from(pi.split(s, []), r);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = _o(this, t, e);
    let s = "";
    for (let r = 0, a = 0; r <= e && a < this.text.length; a++) {
      let o = this.text[a], l = r + o.length;
      r > t && a && (s += i), t < l && e > r && (s += o.slice(Math.max(0, t - r), e - r)), r = l + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], s = -1;
    for (let r of t)
      i.push(r), s += r.length + 1, i.length == 32 && (e.push(new pi(i, s)), i = [], s = -1);
    return s > -1 && e.push(new pi(i, s)), e;
  }
}, h(pi, "Ze"), pi);
y(o9, "TextLeaf");
let wn = o9;
var yn;
const l9 = (yn = class extends Zt {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, s) {
    for (let r = 0; ; r++) {
      let a = this.children[r], o = s + a.length, l = i + a.lines - 1;
      if ((e ? l : o) >= t)
        return a.lineInner(t, e, i, s);
      s = o + 1, i = l + 1;
    }
  }
  decompose(t, e, i, s) {
    for (let r = 0, a = 0; a <= e && r < this.children.length; r++) {
      let o = this.children[r], l = a + o.length;
      if (t <= l && e >= a) {
        let c = s & ((a <= t ? 1 : 0) | (l >= e ? 2 : 0));
        a >= t && l <= e && !c ? i.push(o) : o.decompose(t - a, e - a, i, c);
      }
      a = l + 1;
    }
  }
  replace(t, e, i) {
    if ([t, e] = _o(this, t, e), i.lines < this.lines)
      for (let s = 0, r = 0; s < this.children.length; s++) {
        let a = this.children[s], o = r + a.length;
        if (t >= r && e <= o) {
          let l = a.replace(t - r, e - r, i), c = this.lines - a.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let d = this.children.slice();
            return d[s] = l, new yn(d, this.length - (e - t) + i.length);
          }
          return super.replace(r, o, l);
        }
        r = o + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = _o(this, t, e);
    let s = "";
    for (let r = 0, a = 0; r < this.children.length && a <= e; r++) {
      let o = this.children[r], l = a + o.length;
      a > t && r && (s += i), t < l && e > a && (s += o.sliceString(t - a, e - a, i)), a = l + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof yn))
      return 0;
    let i = 0, [s, r, a, o] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; s += e, r += e) {
      if (s == a || r == o)
        return i;
      let l = this.children[s], c = t.children[r];
      if (l != c)
        return i + l.scanIdentical(c, e);
      i += l.length + 1;
    }
  }
  static from(t, e = t.reduce((i, s) => i + s.length + 1, -1)) {
    let i = 0;
    for (let m of t)
      i += m.lines;
    if (i < 32) {
      let m = [];
      for (let w of t)
        w.flatten(m);
      return new wn(m, e);
    }
    let s = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), r = s << 1, a = s >> 1, o = [], l = 0, c = -1, d = [];
    function p(m) {
      let w;
      if (m.lines > r && m instanceof yn)
        for (let b of m.children)
          p(b);
      else m.lines > a && (l > a || !l) ? (f(), o.push(m)) : m instanceof wn && l && (w = d[d.length - 1]) instanceof wn && m.lines + w.lines <= 32 ? (l += m.lines, c += m.length + 1, d[d.length - 1] = new wn(w.text.concat(m.text), w.length + 1 + m.length)) : (l + m.lines > s && f(), l += m.lines, c += m.length + 1, d.push(m));
    }
    h(p, "u"), y(p, "add");
    function f() {
      l != 0 && (o.push(d.length == 1 ? d[0] : yn.from(d, c)), c = -1, l = d.length = 0);
    }
    h(f, "d"), y(f, "flush");
    for (let m of t)
      p(m);
    return f(), o.length == 1 ? o[0] : new yn(o, e);
  }
}, h(yn, "yt"), yn);
y(l9, "TextNode");
let Yg = l9;
Zt.empty = /* @__PURE__ */ new wn([""], 0);
function c9(n) {
  let t = -1;
  for (let e of n)
    t += e.length + 1;
  return t;
}
h(c9, "bg$1");
y(c9, "textLength");
function Nm(n, t, e = 0, i = 1e9) {
  for (let s = 0, r = 0, a = !0; r < n.length && s <= i; r++) {
    let o = n[r], l = s + o.length;
    l >= e && (l > i && (o = o.slice(0, i - s)), s < e && (o = o.slice(e - s)), a ? (t[t.length - 1] += o, a = !1) : t.push(o)), s = l + 1;
  }
  return t;
}
h(Nm, "jn$1");
y(Nm, "appendText");
function m$(n, t, e) {
  return Nm(n, [""], t, e);
}
h(m$, "Zc$1");
y(m$, "sliceText");
var Bc;
const h9 = (Bc = class {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof wn ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, s = this.nodes[i], r = this.offsets[i], a = r >> 1, o = s instanceof wn ? s.text.length : s.children.length;
      if (a == (e > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (s instanceof wn) {
        let l = s.text[a + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : e > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = s.children[a + (e < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(e > 0 ? 1 : (l instanceof wn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}, h(Bc, "_h"), Bc);
y(h9, "RawTextCursor");
let Hm = h9;
var Xc;
const d9 = (Xc = class {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new Hm(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: s } = this.cursor.next(t);
    return this.pos += (s.length + t) * e, this.value = s.length <= i ? s : e < 0 ? s.slice(s.length - i) : s.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}, h(Xc, "Ch"), Xc);
y(d9, "PartialTextCursor");
let u9 = d9;
var Nc;
const p9 = (Nc = class {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: s } = this.inner.next(t);
    return e && this.afterBreak ? (this.value = "", this.afterBreak = !1) : e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}, h(Nc, "Eh"), Nc);
y(p9, "LineCursor");
let f9 = p9;
typeof Symbol < "u" && (Zt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Hm.prototype[Symbol.iterator] = u9.prototype[Symbol.iterator] = f9.prototype[Symbol.iterator] = function() {
  return this;
});
var cb, Hc;
let kZ = (cb = (Hc = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.number = i, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}, h(Hc, "Ti$1"), Hc), y(cb, "Line"), cb);
function _o(n, t, e) {
  return t = Math.max(0, Math.min(n.length, t)), [t, Math.max(t, Math.min(n.length, e))];
}
h(_o, "Vi$1");
y(_o, "clip");
function gn(n, t, e = !0, i = !0) {
  return s9(n, t, e, i);
}
h(gn, "Oe$2");
y(gn, "findClusterBreak");
function y9(n) {
  return n >= 56320 && n < 57344;
}
h(y9, "Qg$1");
y(y9, "surrogateLow");
function m9(n) {
  return n >= 55296 && n < 56320;
}
h(m9, "wg$1");
y(m9, "surrogateHigh");
function ur(n, t) {
  let e = n.charCodeAt(t);
  if (!m9(e) || t + 1 == n.length)
    return e;
  let i = n.charCodeAt(t + 1);
  return y9(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
h(ur, "Wt$2");
y(ur, "codePointAt");
function w9(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
h(w9, "xg$1");
y(w9, "fromCodePoint");
function Da(n) {
  return n < 65536 ? 1 : 2;
}
h(Da, "ui$1");
y(Da, "codePointSize");
const w$ = /\r\n?|\n/;
var mi = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(mi || (mi = {})), Rs;
const g9 = (Rs = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let e = 0, i = 0, s = 0; e < this.sections.length; ) {
      let r = this.sections[e++], a = this.sections[e++];
      a < 0 ? (t(i, s, r), s += r) : s += a, i += r;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, e = !1) {
    j1(this, t, e);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      s < 0 ? t.push(i, s) : t.push(s, i);
    }
    return new Rs(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : Uk(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, e = !1) {
    return t.empty ? this : F1(this, t, e);
  }
  mapPos(t, e = -1, i = mi.Simple) {
    let s = 0, r = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], l = this.sections[a++], c = s + o;
      if (l < 0) {
        if (c > t)
          return r + (t - s);
        r += o;
      } else {
        if (i != mi.Simple && c >= t && (i == mi.TrackDel && s < t && c > t || i == mi.TrackBefore && s < t || i == mi.TrackAfter && c > t))
          return null;
        if (c > t || c == t && e < 0 && !o)
          return t == s || e < 0 ? r : r + l;
        r += l;
      }
      s = c;
    }
    if (t > s)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${s}`);
    return r;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, e = t) {
    for (let i = 0, s = 0; i < this.sections.length && s <= e; ) {
      let r = this.sections[i++], a = this.sections[i++], o = s + r;
      if (a >= 0 && s <= e && o >= t)
        return s < t && o > e ? "cover" : !0;
      s = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      t += (t ? " " : "") + i + (s >= 0 ? ":" + s : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Rs(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new Rs(t);
  }
}, h(Rs, "yi"), Rs);
y(g9, "ChangeDesc");
let zc = g9;
var qi;
const v9 = (qi = class extends zc {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return j1(this, (e, i, s, r, a) => t = t.replace(s, s + (i - e), a), !1), t;
  }
  mapDesc(t, e = !1) {
    return F1(this, t, e, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let s = 0, r = 0; s < e.length; s += 2) {
      let a = e[s], o = e[s + 1];
      if (o >= 0) {
        e[s] = o, e[s + 1] = a;
        let l = s >> 1;
        for (; i.length < l; )
          i.push(Zt.empty);
        i.push(a ? t.slice(r, r + a) : Zt.empty);
      }
      r += a;
    }
    return new qi(e, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : Uk(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, e = !1) {
    return t.empty ? this : F1(this, t, e, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, e = !1) {
    j1(this, t, e);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return zc.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let e = [], i = [], s = [], r = new ow(this);
    t: for (let a = 0, o = 0; ; ) {
      let l = a == t.length ? 1e9 : t[a++];
      for (; o < l || o == l && r.len == 0; ) {
        if (r.done)
          break t;
        let d = Math.min(r.len, l - o);
        Ge(s, d, -1);
        let p = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
        Ge(e, d, p), p > 0 && Ps(i, e, r.text), r.forward(d), o += d;
      }
      let c = t[a++];
      for (; o < c; ) {
        if (r.done)
          break t;
        let d = Math.min(r.len, c - o);
        Ge(e, d, -1), Ge(s, d, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(d), o += d;
      }
    }
    return {
      changes: new qi(e, i),
      filtered: zc.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], s = this.sections[e + 1];
      s < 0 ? t.push(i) : s == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, e, i) {
    let s = [], r = [], a = 0, o = null;
    function l(d = !1) {
      if (!d && !s.length)
        return;
      a < e && Ge(s, e - a, -1);
      let p = new qi(s, r);
      o = o ? o.compose(p.map(o)) : p, s = [], r = [], a = 0;
    }
    h(l, "a"), y(l, "flush");
    function c(d) {
      if (Array.isArray(d))
        for (let p of d)
          c(p);
      else if (d instanceof qi) {
        if (d.length != e)
          throw new RangeError(`Mismatched change set length (got ${d.length}, expected ${e})`);
        l(), o = o ? o.compose(d.map(o)) : d;
      } else {
        let { from: p, to: f = p, insert: m } = d;
        if (p > f || p < 0 || f > e)
          throw new RangeError(`Invalid change range ${p} to ${f} (in doc of length ${e})`);
        let w = m ? typeof m == "string" ? Zt.of(m.split(i || w$)) : m : Zt.empty, b = w.length;
        if (p == f && b == 0)
          return;
        p < a && l(), p > a && Ge(s, p - a, -1), Ge(s, f - p, b), Ps(r, s, w), a = f;
      }
    }
    return h(c, "h"), y(c, "process"), c(t), l(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new qi(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (typeof r == "number")
        e.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          e.push(r[0], 0);
        else {
          for (; i.length < s; )
            i.push(Zt.empty);
          i[s] = Zt.of(r.slice(1)), e.push(r[0], i[s].length);
        }
      }
    }
    return new qi(e, i);
  }
  /**
  @internal
  */
  static createSet(t, e) {
    return new qi(t, e);
  }
}, h(qi, "Fe"), qi);
y(v9, "ChangeSet");
let xn = v9;
function Ge(n, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let s = n.length - 2;
  s >= 0 && e <= 0 && e == n[s + 1] ? n[s] += t : s >= 0 && t == 0 && n[s] == 0 ? n[s + 1] += e : i ? (n[s] += t, n[s + 1] += e) : n.push(t, e);
}
h(Ge, "ae$2");
y(Ge, "addSection");
function Ps(n, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(e);
  else {
    for (; n.length < i; )
      n.push(Zt.empty);
    n.push(e);
  }
}
h(Ps, "St$2");
y(Ps, "addInsert");
function j1(n, t, e) {
  let i = n.inserted;
  for (let s = 0, r = 0, a = 0; a < n.sections.length; ) {
    let o = n.sections[a++], l = n.sections[a++];
    if (l < 0)
      s += o, r += o;
    else {
      let c = s, d = r, p = Zt.empty;
      for (; c += o, d += l, l && i && (p = p.append(i[a - 2 >> 1])), !(e || a == n.sections.length || n.sections[a + 1] < 0); )
        o = n.sections[a++], l = n.sections[a++];
      t(s, c, r, d, p), s = c, r = d;
    }
  }
}
h(j1, "il$1");
y(j1, "iterChanges");
function F1(n, t, e, i = !1) {
  let s = [], r = i ? [] : null, a = new ow(n), o = new ow(t);
  for (let l = -1; ; ) {
    if (a.done && o.len || o.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && o.ins == -1) {
      let c = Math.min(a.len, o.len);
      Ge(s, c, -1), a.forward(c), o.forward(c);
    } else if (o.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !e))) {
      let c = o.len;
      for (Ge(s, o.ins, -1); c; ) {
        let d = Math.min(a.len, c);
        a.ins >= 0 && l < a.i && a.len <= d && (Ge(s, 0, a.ins), r && Ps(r, s, a.text), l = a.i), a.forward(d), c -= d;
      }
      o.next();
    } else if (a.ins >= 0) {
      let c = 0, d = a.len;
      for (; d; )
        if (o.ins == -1) {
          let p = Math.min(d, o.len);
          c += p, d -= p, o.forward(p);
        } else if (o.ins == 0 && o.len < d)
          d -= o.len, o.next();
        else
          break;
      Ge(s, c, l < a.i ? a.ins : 0), r && l < a.i && Ps(r, s, a.text), l = a.i, a.forward(a.len - d);
    } else {
      if (a.done && o.done)
        return r ? xn.createSet(s, r) : zc.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
h(F1, "rl$1");
y(F1, "mapSet");
function Uk(n, t, e = !1) {
  let i = [], s = e ? [] : null, r = new ow(n), a = new ow(t);
  for (let o = !1; ; ) {
    if (r.done && a.done)
      return s ? xn.createSet(i, s) : zc.create(i);
    if (r.ins == 0)
      Ge(i, r.len, 0, o), r.next();
    else if (a.len == 0 && !a.done)
      Ge(i, 0, a.ins, o), s && Ps(s, i, a.text), a.next();
    else {
      if (r.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(r.len2, a.len), c = i.length;
        if (r.ins == -1) {
          let d = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Ge(i, l, d, o), s && d && Ps(s, i, a.text);
        } else a.ins == -1 ? (Ge(i, r.off ? 0 : r.len, l, o), s && Ps(s, i, r.textBit(l))) : (Ge(i, r.off ? 0 : r.len, a.off ? 0 : a.ins, o), s && !a.off && Ps(s, i, a.text));
        o = (r.ins > l || a.ins >= 0 && a.len > l) && (o || i.length > c), r.forward2(l), a.forward(l);
      }
    }
  }
}
h(Uk, "Xd");
y(Uk, "composeSets");
var Yc;
const b9 = (Yc = class {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? Zt.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? Zt.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}, h(Yc, "Vh"), Yc);
y(b9, "SectionIter");
let ow = b9;
var Sr;
const O9 = (Sr = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, e = -1) {
    let i, s;
    return this.empty ? i = s = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), s = t.mapPos(this.to, -1)), i == this.from && s == this.to ? this : new Sr(i, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return it.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return it.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, e = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!e || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return it.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Sr(t, e, i);
  }
}, h(Sr, "Rr"), Sr);
y(O9, "SelectionRange");
let kg = O9;
var De;
const $9 = (De = class {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, e = -1) {
    return t.empty ? this : De.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, e = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], e))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new De([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, e = !0) {
    return De.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, De.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new De(t.ranges.map((e) => kg.fromJSON(e)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, e = t) {
    return new De([De.range(t, e)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, s = 0; s < t.length; s++) {
      let r = t[s];
      if (r.empty ? r.from <= i : r.from < i)
        return De.normalized(t.slice(), e);
      i = r.to;
    }
    return new De(t, e);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, e = 0, i, s) {
    return kg.create(t, t, (e == 0 ? 0 : e < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, e, i, s) {
    let r = (i ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return e < t ? kg.create(e, t, 48 | r) : kg.create(t, e, (e > t ? 8 : 0) | r);
  }
  /**
  @internal
  */
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((s, r) => s.from - r.from), e = t.indexOf(i);
    for (let s = 1; s < t.length; s++) {
      let r = t[s], a = t[s - 1];
      if (r.empty ? r.from <= a.to : r.from < a.to) {
        let o = a.from, l = Math.max(r.to, a.to);
        s <= e && e--, t.splice(--s, 2, r.anchor > r.head ? De.range(l, o) : De.range(o, l));
      }
    }
    return new De(t, e);
  }
}, h(De, "fe"), De);
y($9, "EditorSelection");
let it = $9;
function Bk(n, t) {
  for (let e of n.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
h(Bk, "Yd");
y(Bk, "checkSelection");
let Xk = 0;
var Ga;
const x9 = (Ga = class {
  constructor(t, e, i, s, r) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = s, this.id = Xk++, this.default = t([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new Ga(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : o0), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new Gg([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Gg(t, this, 1, e);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Gg(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = /* @__PURE__ */ y((i) => i, "get")), this.compute([t], (i) => e(i.field(t)));
  }
}, h(Ga, "Ws"), Ga);
y(x9, "Facet");
let gt = x9;
function o0(n, t) {
  return n == t || n.length == t.length && n.every((e, i) => e === t[i]);
}
h(o0, "Ja$1");
y(o0, "sameArray$1");
var Gc;
const k9 = (Gc = class {
  constructor(t, e, i, s) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = s, this.id = Xk++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, s = this.facet.compareInput, r = this.id, a = t[r] >> 1, o = this.type == 2, l = !1, c = !1, d = [];
    for (let p of this.dependencies)
      p == "doc" ? l = !0 : p == "selection" ? c = !0 : (((e = t[p.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && d.push(t[p.id]);
    return {
      create(p) {
        return p.values[a] = i(p), 1;
      },
      update(p, f) {
        if (l && f.docChanged || c && (f.docChanged || f.selection) || U1(p, d)) {
          let m = i(p);
          if (o ? !g$(m, p.values[a], s) : !s(m, p.values[a]))
            return p.values[a] = m, 1;
        }
        return 0;
      },
      reconfigure: /* @__PURE__ */ y((p, f) => {
        let m, w = f.config.address[r];
        if (w != null) {
          let b = lw(f, w);
          if (this.dependencies.every((x) => x instanceof gt ? f.facet(x) === p.facet(x) : x instanceof Hs ? f.field(x, !1) == p.field(x, !1) : !0) || (o ? g$(m = i(p), b, s) : s(m = i(p), b)))
            return p.values[a] = b, 0;
        } else
          m = i(p);
        return p.values[a] = m, 1;
      }, "reconfigure")
    };
  }
}, h(Gc, "Uh"), Gc);
y(k9, "FacetProvider");
let Gg = k9;
function g$(n, t, e) {
  if (n.length != t.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!e(n[i], t[i]))
      return !1;
  return !0;
}
h(g$, "Lc$1");
y(g$, "compareArray");
function U1(n, t) {
  let e = !1;
  for (let i of t)
    _c(n, i) & 1 && (e = !0);
  return e;
}
h(U1, "nl$1");
y(U1, "ensureAll");
function S9(n, t, e) {
  let i = e.map((l) => n[l.id]), s = e.map((l) => l.type), r = i.filter((l) => !(l & 1)), a = n[t.id] >> 1;
  function o(l) {
    let c = [];
    for (let d = 0; d < i.length; d++) {
      let p = lw(l, i[d]);
      if (s[d] == 2)
        for (let f of p)
          c.push(f);
      else
        c.push(p);
    }
    return t.combine(c);
  }
  return h(o, "l"), y(o, "get"), {
    create(l) {
      for (let c of i)
        _c(l, c);
      return l.values[a] = o(l), 1;
    },
    update(l, c) {
      if (!U1(l, r))
        return 0;
      let d = o(l);
      return t.compare(d, l.values[a]) ? 0 : (l.values[a] = d, 1);
    },
    reconfigure(l, c) {
      let d = U1(l, i), p = c.config.facets[t.id], f = c.facet(t);
      if (p && !d && o0(e, p))
        return l.values[a] = f, 0;
      let m = o(l);
      return t.compare(m, f) ? (l.values[a] = f, 0) : (l.values[a] = m, 1);
    }
  };
}
h(S9, "Pg$1");
y(S9, "dynamicFacetSlot");
const Sg = /* @__PURE__ */ gt.define({ static: !0 });
var Ka;
const P9 = (Ka = class {
  constructor(t, e, i, s, r) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = s, this.spec = r, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let e = new Ka(Xk++, t.create, t.update, t.compare || ((i, s) => i === s), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    let e = t.facet(Sg).find((i) => i.field == this);
    return ((e == null ? void 0 : e.create) || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: /* @__PURE__ */ y((i) => (i.values[e] = this.create(i), 1), "create"),
      update: /* @__PURE__ */ y((i, s) => {
        let r = i.values[e], a = this.updateF(r, s);
        return this.compareF(r, a) ? 0 : (i.values[e] = a, 1);
      }, "update"),
      reconfigure: /* @__PURE__ */ y((i, s) => {
        let r = i.facet(Sg), a = s.facet(Sg), o;
        return (o = r.find((l) => l.field == this)) && o != a.find((l) => l.field == this) ? (i.values[e] = o.create(i), 1) : s.config.address[this.id] != null ? (i.values[e] = s.field(this), 0) : (i.values[e] = this.create(i), 1);
      }, "reconfigure")
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, Sg.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}, h(Ka, "Xs"), Ka);
y(P9, "StateField");
let Hs = P9;
const qa = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function lc(n) {
  return (t) => new Q9(t, n);
}
h(lc, "rr$1");
y(lc, "prec");
const rl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ lc(qa.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ lc(qa.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ lc(qa.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ lc(qa.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ lc(qa.lowest)
};
var Kc;
const C9 = (Kc = class {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}, h(Kc, "Wh"), Kc);
y(C9, "PrecExtension");
let Q9 = C9;
var Ja;
const M9 = (Ja = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new v$(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return Ja.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}, h(Ja, "Ys"), Ja);
y(M9, "Compartment");
let T9 = M9;
var Jc;
const A9 = (Jc = class {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}, h(Jc, "Xh"), Jc);
y(A9, "CompartmentInstance");
let v$ = A9;
var to;
const R9 = (to = class {
  constructor(t, e, i, s, r, a) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = s, this.staticValues = r, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let s = [], r = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let f of E9(t, e, a))
      f instanceof Hs ? s.push(f) : (r[f.facet.id] || (r[f.facet.id] = [])).push(f);
    let o = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let f of s)
      o[f.id] = c.length << 1, c.push((m) => f.slot(m));
    let d = i == null ? void 0 : i.config.facets;
    for (let f in r) {
      let m = r[f], w = m[0].facet, b = d && d[f] || [];
      if (m.every(
        (x) => x.type == 0
        /* Provider.Static */
      ))
        if (o[w.id] = l.length << 1 | 1, o0(b, m))
          l.push(i.facet(w));
        else {
          let x = w.combine(m.map((O) => O.value));
          l.push(i && w.compare(x, i.facet(w)) ? i.facet(w) : x);
        }
      else {
        for (let x of m)
          x.type == 0 ? (o[x.id] = l.length << 1 | 1, l.push(x.value)) : (o[x.id] = c.length << 1, c.push((O) => x.dynamicSlot(O)));
        o[w.id] = c.length << 1, c.push((x) => S9(x, w, m));
      }
    }
    let p = c.map((f) => f(o));
    return new to(t, a, p, o, l, r);
  }
}, h(to, "Is"), to);
y(R9, "Configuration");
let LC = R9;
function E9(n, t, e) {
  let i = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function r(a, o) {
    let l = s.get(a);
    if (l != null) {
      if (l <= o)
        return;
      let c = i[l].indexOf(a);
      c > -1 && i[l].splice(c, 1), a instanceof v$ && e.delete(a.compartment);
    }
    if (s.set(a, o), Array.isArray(a))
      for (let c of a)
        r(c, o);
    else if (a instanceof v$) {
      if (e.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = t.get(a.compartment) || a.inner;
      e.set(a.compartment, c), r(c, o);
    } else if (a instanceof Q9)
      r(a.inner, a.prec);
    else if (a instanceof Hs)
      i[o].push(a), a.provides && r(a.provides, o);
    else if (a instanceof Gg)
      i[o].push(a), a.facet.extensions && r(a.facet.extensions, qa.default);
    else {
      let c = a.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(c, o);
    }
  }
  return h(r, "s"), y(r, "inner"), r(n, qa.default), i.reduce((a, o) => a.concat(o));
}
h(E9, "kg$1");
y(E9, "flatten");
function _c(n, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = n.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[e] = 4;
  let s = n.computeSlot(n, n.config.dynamicSlots[e]);
  return n.status[e] = 2 | s;
}
h(_c, "mr$1");
y(_c, "ensureAddr");
function lw(n, t) {
  return t & 1 ? n.config.staticValues[t >> 1] : n.values[t >> 1];
}
h(lw, "ts$2");
y(lw, "getAddr");
const z9 = /* @__PURE__ */ gt.define(), b$ = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => n.some((t) => t), "combine"),
  static: !0
}), _9 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => n.length ? n[0] : void 0, "combine"),
  static: !0
}), L9 = /* @__PURE__ */ gt.define(), I9 = /* @__PURE__ */ gt.define(), Z9 = /* @__PURE__ */ gt.define(), W9 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => n.length ? n[0] : !1, "combine")
});
var th;
const D9 = (th = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new SZ();
  }
}, h(th, "Yh"), th);
y(D9, "Annotation");
let Ys = D9;
var eh;
const q9 = (eh = class {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new Ys(this, t);
  }
}, h(eh, "Ih"), eh);
y(q9, "AnnotationType");
let SZ = q9;
var ih;
const V9 = (ih = class {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new Bt(this, t);
  }
}, h(ih, "jh"), ih);
y(V9, "StateEffectType");
let PZ = V9;
var eo;
const j9 = (eo = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new eo(this.type, e);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new PZ(t.map || ((e) => e));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let s of t) {
      let r = s.map(e);
      r && i.push(r);
    }
    return i;
  }
}, h(eo, "js"), eo);
y(j9, "StateEffect");
let Bt = j9;
Bt.reconfigure = /* @__PURE__ */ Bt.define();
Bt.appendConfig = /* @__PURE__ */ Bt.define();
var Nn;
const F9 = (Nn = class {
  constructor(t, e, i, s, r, a) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = s, this.annotations = r, this.scrollIntoView = a, this._doc = null, this._state = null, i && Bk(i, e.newLength), r.some((o) => o.type == Nn.time) || (this.annotations = r.concat(Nn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, e, i, s, r, a) {
    return new Nn(t, e, i, s, r, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let e = this.annotation(Nn.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}, h(Nn, "It"), Nn);
y(F9, "Transaction");
let wi = F9;
wi.time = /* @__PURE__ */ Ys.define();
wi.userEvent = /* @__PURE__ */ Ys.define();
wi.addToHistory = /* @__PURE__ */ Ys.define();
wi.remote = /* @__PURE__ */ Ys.define();
function U9(n, t) {
  let e = [];
  for (let i = 0, s = 0; ; ) {
    let r, a;
    if (i < n.length && (s == t.length || t[s] >= n[i]))
      r = n[i++], a = n[i++];
    else if (s < t.length)
      r = t[s++], a = t[s++];
    else
      return e;
    !e.length || e[e.length - 1] < r ? e.push(r, a) : e[e.length - 1] < a && (e[e.length - 1] = a);
  }
}
h(U9, "Rg$1");
y(U9, "joinRanges");
function Nk(n, t, e) {
  var i;
  let s, r, a;
  return e ? (s = t.changes, r = xn.empty(t.changes.length), a = n.changes.compose(t.changes)) : (s = t.changes.map(n.changes), r = n.changes.mapDesc(t.changes, !0), a = n.changes.compose(s)), {
    changes: a,
    selection: t.selection ? t.selection.map(r) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(s),
    effects: Bt.mapEffects(n.effects, s).concat(Bt.mapEffects(t.effects, r)),
    annotations: n.annotations.length ? n.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: n.scrollIntoView || t.scrollIntoView
  };
}
h(Nk, "Nd");
y(Nk, "mergeTransaction");
function B1(n, t, e) {
  let i = t.selection, s = Ua(t.annotations);
  return t.userEvent && (s = s.concat(wi.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof xn ? t.changes : xn.of(t.changes || [], e, n.facet(_9)),
    selection: i && (i instanceof it ? i : it.single(i.anchor, i.head)),
    effects: Ua(t.effects),
    annotations: s,
    scrollIntoView: !!t.scrollIntoView
  };
}
h(B1, "al$1");
y(B1, "resolveTransactionInner");
function Hk(n, t, e) {
  let i = B1(n, t.length ? t[0] : {}, n.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let r = 1; r < t.length; r++) {
    t[r].filter === !1 && (e = !1);
    let a = !!t[r].sequential;
    i = Nk(i, B1(n, t[r], a ? i.changes.newLength : n.doc.length), a);
  }
  let s = wi.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return X9(e ? B9(s) : s);
}
h(Hk, "Gd");
y(Hk, "resolveTransaction");
function B9(n) {
  let t = n.startState, e = !0;
  for (let s of t.facet(L9)) {
    let r = s(n);
    if (r === !1) {
      e = !1;
      break;
    }
    Array.isArray(r) && (e = e === !0 ? r : U9(e, r));
  }
  if (e !== !0) {
    let s, r;
    if (e === !1)
      r = n.changes.invertedDesc, s = xn.empty(t.doc.length);
    else {
      let a = n.changes.filter(e);
      s = a.changes, r = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    n = wi.create(t, s, n.selection && n.selection.map(r), Bt.mapEffects(n.effects, r), n.annotations, n.scrollIntoView);
  }
  let i = t.facet(I9);
  for (let s = i.length - 1; s >= 0; s--) {
    let r = i[s](n);
    r instanceof wi ? n = r : Array.isArray(r) && r.length == 1 && r[0] instanceof wi ? n = r[0] : n = Hk(t, Ua(r), !1);
  }
  return n;
}
h(B9, "$g$1");
y(B9, "filterTransaction");
function X9(n) {
  let t = n.startState, e = t.facet(Z9), i = n;
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s](n);
    r && Object.keys(r).length && (i = Nk(i, B1(t, r, n.changes.newLength), !0));
  }
  return i == n ? n : wi.create(t, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
h(X9, "vg$1");
y(X9, "extendTransaction");
const CZ = [];
function Ua(n) {
  return n == null ? CZ : Array.isArray(n) ? n : [n];
}
h(Ua, "Ri$1");
y(Ua, "asArray");
var Cs = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(Cs || (Cs = {}));
const QZ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let O$;
try {
  O$ = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function N9(n) {
  if (O$)
    return O$.test(n);
  for (let t = 0; t < n.length; t++) {
    let e = n[t];
    if (/\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || QZ.test(e)))
      return !0;
  }
  return !1;
}
h(N9, "Zg$1");
y(N9, "hasWordChar");
function H9(n) {
  return (t) => {
    if (!/\S/.test(t))
      return Cs.Space;
    if (N9(t))
      return Cs.Word;
    for (let e = 0; e < n.length; e++)
      if (t.indexOf(n[e]) > -1)
        return Cs.Word;
    return Cs.Other;
  };
}
h(H9, "Lg$1");
y(H9, "makeCategorizer");
var ri;
const Y9 = (ri = class {
  constructor(t, e, i, s, r, a) {
    this.config = t, this.doc = e, this.selection = i, this.values = s, this.status = t.statusTemplate.slice(), this.computeSlot = r, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      _c(this, o << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return _c(this, i), lw(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return Hk(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: s } = e;
    for (let o of t.effects)
      o.is(T9.reconfigure) ? (e && (s = /* @__PURE__ */ new Map(), e.compartments.forEach((l, c) => s.set(c, l)), e = null), s.set(o.value.compartment, o.value.extension)) : o.is(Bt.reconfigure) ? (e = null, i = o.value) : o.is(Bt.appendConfig) && (e = null, i = Ua(i).concat(o.value));
    let r;
    e ? r = t.startState.values.slice() : (e = LC.resolve(i, s, this), r = new ri(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (o, l) => l.reconfigure(o, this), null).values);
    let a = t.startState.facet(b$) ? t.newSelection : t.newSelection.asSingle();
    new ri(e, t.newDoc, a, r, (o, l) => l.update(o, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: it.cursor(e.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), s = this.changes(i.changes), r = [i.range], a = Ua(i.effects);
    for (let o = 1; o < e.ranges.length; o++) {
      let l = t(e.ranges[o]), c = this.changes(l.changes), d = c.map(s);
      for (let f = 0; f < o; f++)
        r[f] = r[f].map(d);
      let p = s.mapDesc(c, !0);
      r.push(l.range.map(p)), s = s.compose(d), a = Bt.mapEffects(a, d).concat(Bt.mapEffects(Ua(l.effects), p));
    }
    return {
      changes: s,
      selection: it.create(r, e.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof xn ? t : xn.of(t, this.doc.length, this.facet(ri.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Zt.of(t.split(this.facet(ri.lineSeparator) || w$));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (_c(this, e), lw(this, e));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let s = t[i];
        s instanceof Hs && this.config.address[s.id] != null && (e[i] = s.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (i) {
      for (let r in i)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          let a = i[r], o = t[r];
          s.push(a.init((l) => a.spec.fromJSON(o, l)));
        }
    }
    return ri.create({
      doc: t.doc,
      selection: it.fromJSON(t.selection),
      extensions: e.extensions ? s.concat([e.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let e = LC.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Zt ? t.doc : Zt.of((t.doc || "").split(e.staticFacet(ri.lineSeparator) || w$)), s = t.selection ? t.selection instanceof it ? t.selection : it.single(t.selection.anchor, t.selection.head) : it.single(0);
    return Bk(s, i.length), e.staticFacet(b$) || (s = s.asSingle()), new ri(e, i, s, e.dynamicSlots.map(() => null), (r, a) => a.create(r), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ri.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ri.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(W9);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...e) {
    for (let i of this.facet(ri.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, s) => {
      if (s == "$")
        return "$";
      let r = +(s || 1);
      return !r || r > e.length ? i : e[r - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, e, i = -1) {
    let s = [];
    for (let r of this.facet(z9))
      for (let a of r(this, e, i))
        Object.prototype.hasOwnProperty.call(a, t) && s.push(a[t]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return H9(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: e, from: i, length: s } = this.doc.lineAt(t), r = this.charCategorizer(t), a = t - i, o = t - i;
    for (; a > 0; ) {
      let l = gn(e, a, !1);
      if (r(e.slice(l, a)) != Cs.Word)
        break;
      a = l;
    }
    for (; o < s; ) {
      let l = gn(e, o);
      if (r(e.slice(o, l)) != Cs.Word)
        break;
      o = l;
    }
    return a == o ? null : it.range(a + i, o + i);
  }
}, h(ri, "Pe"), ri);
y(Y9, "EditorState");
let ze = Y9;
ze.allowMultipleSelections = b$;
ze.tabSize = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => n.length ? n[0] : 4, "combine")
});
ze.lineSeparator = _9;
ze.readOnly = W9;
ze.phrases = /* @__PURE__ */ gt.define({
  compare(n, t) {
    let e = Object.keys(n), i = Object.keys(t);
    return e.length == i.length && e.every((s) => n[s] == t[s]);
  }
});
ze.languageData = z9;
ze.changeFilter = L9;
ze.transactionFilter = I9;
ze.transactionExtender = Z9;
T9.reconfigure = /* @__PURE__ */ Bt.define();
function Yk(n, t, e = {}) {
  let i = {};
  for (let s of n)
    for (let r of Object.keys(s)) {
      let a = s[r], o = i[r];
      if (o === void 0)
        i[r] = a;
      else if (!(o === a || a === void 0)) if (Object.hasOwnProperty.call(e, r))
        i[r] = e[r](o, a);
      else
        throw new Error("Config merge conflict for field " + r);
    }
  for (let s in t)
    i[s] === void 0 && (i[s] = t[s]);
  return i;
}
h(Yk, "Hd");
y(Yk, "combineConfig");
var nh;
const G9 = (nh = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, e = t) {
    return $$.create(t, e, this);
  }
}, h(nh, "qh"), nh);
y(G9, "RangeValue");
let Lo = G9;
Lo.prototype.startSide = Lo.prototype.endSide = 0;
Lo.prototype.point = !1;
Lo.prototype.mapMode = mi.TrackDel;
var Pg, sh;
let $$ = (Pg = (sh = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Pg(t, e, i);
  }
}, h(sh, "ei$1"), sh), y(Pg, "Range"), Pg);
function X1(n, t) {
  return n.from - t.from || n.value.startSide - t.value.startSide;
}
h(X1, "cl$1");
y(X1, "cmpRange");
var io;
const K9 = (io = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, e, i, s = 0) {
    let r = i ? this.to : this.from;
    for (let a = s, o = r.length; ; ) {
      if (a == o)
        return a;
      let l = a + o >> 1, c = r[l] - t || (i ? this.value[l].endSide : this.value[l].startSide) - e;
      if (l == a)
        return c >= 0 ? a : o;
      c >= 0 ? o = l : a = l + 1;
    }
  }
  between(t, e, i, s) {
    for (let r = this.findIndex(e, -1e9, !0), a = this.findIndex(i, 1e9, !1, r); r < a; r++)
      if (s(this.from[r] + t, this.to[r] + t, this.value[r]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], s = [], r = [], a = -1, o = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], d = this.from[l] + t, p = this.to[l] + t, f, m;
      if (d == p) {
        let w = e.mapPos(d, c.startSide, c.mapMode);
        if (w == null || (f = m = w, c.startSide != c.endSide && (m = e.mapPos(d, c.endSide), m < f)))
          continue;
      } else if (f = e.mapPos(d, c.startSide), m = e.mapPos(p, c.endSide), f > m || f == m && c.startSide > 0 && c.endSide <= 0)
        continue;
      (m - f || c.endSide - c.startSide) < 0 || (a < 0 && (a = f), c.point && (o = Math.max(o, m - f)), i.push(c), s.push(f - a), r.push(m - a));
    }
    return { mapped: i.length ? new io(s, r, i, o) : null, pos: a };
  }
}, h(io, "qs"), io);
y(K9, "Chunk");
let MZ = K9;
var ki;
const J9 = (ki = class {
  constructor(t, e, i, s) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(t, e, i, s) {
    return new ki(t, e, i, s);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: s = 0, filterTo: r = this.length } = t, a = t.filter;
    if (e.length == 0 && !a)
      return this;
    if (i && (e = e.slice().sort(X1)), this.isEmpty)
      return e.length ? ki.of(e) : this;
    let o = new nQ(this, null, -1).goto(0), l = 0, c = [], d = new N1();
    for (; o.value || l < e.length; )
      if (l < e.length && (o.from - e[l].from || o.startSide - e[l].value.startSide) >= 0) {
        let p = e[l++];
        d.addInner(p.from, p.to, p.value) || c.push(p);
      } else o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (l == e.length || this.chunkEnd(o.chunkIndex) < e[l].from) && (!a || s > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && d.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || s > o.to || r < o.from || a(o.from, o.to, o.value)) && (d.addInner(o.from, o.to, o.value) || c.push($$.create(o.from, o.to, o.value))), o.next());
    return d.finishInner(this.nextLayer.isEmpty && !c.length ? ki.empty : this.nextLayer.update({ add: c, filter: a, filterFrom: s, filterTo: r }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], s = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], l = this.chunk[a], c = t.touchesRange(o, o + l.length);
      if (c === !1)
        s = Math.max(s, l.maxPoint), e.push(l), i.push(t.mapPos(o));
      else if (c === !0) {
        let { mapped: d, pos: p } = l.map(o, t);
        d && (s = Math.max(s, d.maxPoint), e.push(d), i.push(p));
      }
    }
    let r = this.nextLayer.map(t);
    return e.length == 0 ? r : new ki(i, e, r || ki.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let r = this.chunkPos[s], a = this.chunk[s];
        if (e >= r && t <= r + a.length && a.between(r, t - r, e - r, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return k$.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, e = 0) {
    return k$.from(t).goto(e);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, e, i, s, r = -1) {
    let a = t.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= r), o = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= r), l = x$(a, o, i), c = new zy(a, l, r), d = new zy(o, l, r);
    i.iterGaps((p, f, m) => S$(c, p, d, f, m, s)), i.empty && i.length == 0 && S$(c, 0, d, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, e, i = 0, s) {
    s == null && (s = 999999999);
    let r = t.filter((d) => !d.isEmpty && e.indexOf(d) < 0), a = e.filter((d) => !d.isEmpty && t.indexOf(d) < 0);
    if (r.length != a.length)
      return !1;
    if (!r.length)
      return !0;
    let o = x$(r, a), l = new zy(r, o, 0).goto(i), c = new zy(a, o, 0).goto(i);
    for (; ; ) {
      if (l.to != c.to || !H1(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > s)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, e, i, s, r = -1) {
    let a = new zy(t, null, r).goto(e), o = e, l = a.openStart;
    for (; ; ) {
      let c = Math.min(a.to, i);
      if (a.point) {
        let d = a.activeForPoint(a.to), p = a.pointFrom < e ? d.length + 1 : a.point.startSide < 0 ? d.length : Math.min(d.length, l);
        s.point(o, c, a.point, d, p, a.pointRank), l = Math.min(a.openEnd(c), d.length);
      } else c > o && (s.span(o, c, a.active, l), l = a.openEnd(c));
      if (a.to > i)
        return l + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, e = !1) {
    let i = new N1();
    for (let s of t instanceof $$ ? [t] : e ? tQ(t) : t)
      i.add(s.from, s.to, s.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return ki.empty;
    let e = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let s = t[i]; s != ki.empty; s = s.nextLayer)
        e = new ki(s.chunkPos, s.chunk, e, Math.max(s.maxPoint, e.maxPoint));
    return e;
  }
}, h(ki, "We"), ki);
y(J9, "RangeSet");
let li = J9;
li.empty = /* @__PURE__ */ new li([], [], null, -1);
function tQ(n) {
  if (n.length > 1)
    for (let t = n[0], e = 1; e < n.length; e++) {
      let i = n[e];
      if (X1(t, i) > 0)
        return n.slice().sort(X1);
      t = i;
    }
  return n;
}
h(tQ, "Mg$1");
y(tQ, "lazySort");
li.empty.nextLayer = li.empty;
var no;
const eQ = (no = class {
  finishChunk(t) {
    this.chunks.push(new MZ(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new no())).add(t, e, i);
  }
  /**
  @internal
  */
  addInner(t, e, i) {
    let s = t - this.lastTo || i.startSide - this.last.endSide;
    if (s <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(li.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = li.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}, h(no, "Ds"), no);
y(eQ, "RangeSetBuilder");
let N1 = eQ;
function x$(n, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let r of n)
    for (let a = 0; a < r.chunk.length; a++)
      r.chunk[a].maxPoint <= 0 && i.set(r.chunk[a], r.chunkPos[a]);
  let s = /* @__PURE__ */ new Set();
  for (let r of t)
    for (let a = 0; a < r.chunk.length; a++) {
      let o = i.get(r.chunk[a]);
      o != null && (e ? e.mapPos(o) : o) == r.chunkPos[a] && !(e != null && e.touchesRange(o, o + r.chunk[a].length)) && s.add(r.chunk[a]);
    }
  return s;
}
h(x$, "Mc$1");
y(x$, "findSharedChunks");
var rh;
const iQ = (rh = class {
  constructor(t, e, i, s = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < t || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}, h(rh, "Dh"), rh);
y(iQ, "LayerCursor");
let nQ = iQ;
var so;
const sQ = (so = class {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let s = [];
    for (let r = 0; r < t.length; r++)
      for (let a = t[r]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && s.push(new nQ(a, e, i, r));
    return s.length == 1 ? s[0] : new so(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Kg(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Kg(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Kg(this.heap, 0);
    }
  }
}, h(so, "Bs"), so);
y(sQ, "HeapCursor");
let k$ = sQ;
function Kg(n, t) {
  for (let e = n[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= n.length)
      break;
    let s = n[i];
    if (i + 1 < n.length && s.compare(n[i + 1]) >= 0 && (s = n[i + 1], i++), e.compare(s) < 0)
      break;
    n[i] = e, n[t] = s, t = i;
  }
}
h(Kg, "ko$1");
y(Kg, "heapBubble");
var ah;
const rQ = (ah = class {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = k$.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    am(this.active, t), am(this.activeTo, t), am(this.activeRank, t), this.minActive = P$(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: s, rank: r } = this.cursor;
    for (; e < this.activeRank.length && (r - this.activeRank[e] || s - this.activeTo[e]) > 0; )
      e++;
    om(this.active, e, i), om(this.activeTo, e, s), om(this.activeRank, e, r), t && om(t, e, this.cursor.from), this.minActive = P$(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > t) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), i && am(i, s);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let r = this.cursor.value;
          if (!r.point)
            this.addActive(i), this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let s = i.length - 1; s >= 0 && i[s] < t; s--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}, h(ah, "Bh"), ah);
y(rQ, "SpanCursor");
let zy = rQ;
function S$(n, t, e, i, s, r) {
  n.goto(t), e.goto(i);
  let a = i + s, o = i, l = i - t;
  for (; ; ) {
    let c = n.to + l - e.to, d = c || n.endSide - e.endSide, p = d < 0 ? n.to + l : e.to, f = Math.min(p, a);
    if (n.point || e.point ? n.point && e.point && (n.point == e.point || n.point.eq(e.point)) && H1(n.activeForPoint(n.to), e.activeForPoint(e.to)) || r.comparePoint(o, f, n.point, e.point) : f > o && !H1(n.active, e.active) && r.compareRange(o, f, n.active, e.active), p > a)
      break;
    (c || n.openEnd != e.openEnd) && r.boundChange && r.boundChange(p), o = p, d <= 0 && n.next(), d >= 0 && e.next();
  }
}
h(S$, "_c$1");
y(S$, "compare");
function H1(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] != t[e] && !n[e].eq(t[e]))
      return !1;
  return !0;
}
h(H1, "dl$1");
y(H1, "sameValues");
function am(n, t) {
  for (let e = t, i = n.length - 1; e < i; e++)
    n[e] = n[e + 1];
  n.pop();
}
h(am, "Pn$1");
y(am, "remove");
function om(n, t, e) {
  for (let i = n.length - 1; i >= t; i--)
    n[i + 1] = n[i];
  n[t] = e;
}
h(om, "kn$1");
y(om, "insert");
function P$(n, t) {
  let e = -1, i = 1e9;
  for (let s = 0; s < t.length; s++)
    (t[s] - i || n[s].endSide - n[e].endSide) < 0 && (e = s, i = t[s]);
  return e;
}
h(P$, "Cc$1");
y(P$, "findMinIndex");
function Br(n, t, e = n.length) {
  let i = 0;
  for (let s = 0; s < e && s < n.length; )
    n.charCodeAt(s) == 9 ? (i += t - i % t, s++) : (i++, s = gn(n, s));
  return i;
}
h(Br, "dt$1");
y(Br, "countColumn");
function aQ(n, t, e, i) {
  for (let s = 0, r = 0; ; ) {
    if (r >= t)
      return s;
    if (s == n.length)
      break;
    r += n.charCodeAt(s) == 9 ? e - r % e : 1, s = gn(n, s);
  }
  return n.length;
}
h(aQ, "_g$1");
y(aQ, "findColumn");
const C$ = "ͼ", IC = typeof Symbol > "u" ? "__" + C$ : Symbol.for(C$), Q$ = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), ZC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var oh;
const oQ = (oh = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function s(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    h(s, "n"), y(s, "splitSelector");
    function r(a, o, l, c) {
      let d = [], p = /^@(\w+)\b/.exec(a[0]), f = p && p[1] == "keyframes";
      if (p && o == null) return l.push(a[0] + ";");
      for (let m in o) {
        let w = o[m];
        if (/&/.test(m))
          r(
            m.split(/,\s*/).map((b) => a.map((x) => b.replace(/&/, x))).reduce((b, x) => b.concat(x)),
            w,
            l
          );
        else if (w && typeof w == "object") {
          if (!p) throw new RangeError("The value of a property (" + m + ") should be a primitive value.");
          r(s(m), w, d, f);
        } else w != null && d.push(m.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + w + ";");
      }
      (d.length || f) && l.push((i && !p && !c ? a.map(i) : a).join(", ") + " {" + d.join(" ") + "}");
    }
    h(r, "s"), y(r, "render");
    for (let a in t) r(s(a), t[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = ZC[IC] || 1;
    return ZC[IC] = t + 1, C$ + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, e, i) {
    let s = t[Q$], r = i && i.nonce;
    s ? r && s.setNonce(r) : s = new TZ(t, r), s.mount(Array.isArray(e) ? e : [e], t);
  }
}, h(oh, "zh"), oh);
y(oQ, "StyleModule");
let Xr = oQ, WC = /* @__PURE__ */ new Map();
var lh;
const lQ = (lh = class {
  constructor(t, e) {
    let i = t.ownerDocument || t, s = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && s.CSSStyleSheet) {
      let r = WC.get(i);
      if (r) return t[Q$] = r;
      this.sheet = new s.CSSStyleSheet(), WC.set(i, this);
    } else
      this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e);
    this.modules = [], t[Q$] = this;
  }
  mount(t, e) {
    let i = this.sheet, s = 0, r = 0;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = this.modules.indexOf(o);
      if (l < r && l > -1 && (this.modules.splice(l, 1), r--, l = -1), l == -1) {
        if (this.modules.splice(r++, 0, o), i) for (let c = 0; c < o.rules.length; c++)
          i.insertRule(o.rules[c], s++);
      } else {
        for (; r < l; ) s += this.modules[r++].rules.length;
        s += o.rules.length, r++;
      }
    }
    if (i)
      e.adoptedStyleSheets.indexOf(this.sheet) < 0 && (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]);
    else {
      let a = "";
      for (let l = 0; l < this.modules.length; l++)
        a += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = a;
      let o = e.head || e;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}, h(lh, "Nh"), lh);
y(lQ, "StyleSet");
let TZ = lQ;
var Nr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, cw = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, AZ = typeof navigator < "u" && /Mac/.test(navigator.platform), RZ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Ke = 0; Ke < 10; Ke++) Nr[48 + Ke] = Nr[96 + Ke] = String(Ke);
for (var Ke = 1; Ke <= 24; Ke++) Nr[Ke + 111] = "F" + Ke;
for (var Ke = 65; Ke <= 90; Ke++)
  Nr[Ke] = String.fromCharCode(Ke + 32), cw[Ke] = String.fromCharCode(Ke);
for (var hb in Nr) cw.hasOwnProperty(hb) || (cw[hb] = Nr[hb]);
function cQ(n) {
  var t = AZ && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || RZ && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", e = !t && n.key || (n.shiftKey ? cw : Nr)[n.keyCode] || n.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
h(cQ, "Vg$1");
y(cQ, "keyName");
function Df(n) {
  let t;
  return n.nodeType == 11 ? t = n.getSelection ? n : n.ownerDocument : t = n, t.getSelection();
}
h(Df, "Hr$1");
y(Df, "getSelection");
function Y1(n, t) {
  return t ? n == t || n.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
h(Y1, "gl$1");
y(Y1, "contains");
function Ym(n, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return Y1(n, t.anchorNode);
  } catch {
    return !1;
  }
}
h(Ym, "qn$1");
y(Ym, "hasSelection");
function Io(n) {
  return n.nodeType == 3 ? Yr(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
h(Io, "Wi$1");
y(Io, "clientRectsFor");
function Lc(n, t, e, i) {
  return e ? M$(n, t, e, i, -1) || M$(n, t, e, i, 1) : !1;
}
h(Lc, "gr$1");
y(Lc, "isEquivalentPosition");
function Hr(n) {
  for (var t = 0; ; t++)
    if (n = n.previousSibling, !n)
      return t;
}
h(Hr, "ii$1");
y(Hr, "domIndex");
function hw(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
h(hw, "rs$2");
y(hw, "isBlockElement");
function M$(n, t, e, i, s) {
  for (; ; ) {
    if (n == e && t == i)
      return !0;
    if (t == (s < 0 ? 0 : kn(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let r = n.parentNode;
      if (!r || r.nodeType != 1)
        return !1;
      t = Hr(n) + (s < 0 ? 0 : 1), n = r;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[t + (s < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      t = s < 0 ? kn(n) : 0;
    } else
      return !1;
  }
}
h(M$, "Wc$1");
y(M$, "scanFor");
function kn(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
h(kn, "rt$1");
y(kn, "maxOffset");
function vy(n, t) {
  let e = t ? n.left : n.right;
  return { left: e, right: e, top: n.top, bottom: n.bottom };
}
h(vy, "pn$1");
y(vy, "flattenRect");
function hQ(n) {
  let t = n.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
h(hQ, "Ug$1");
y(hQ, "windowRect");
function Gk(n, t) {
  let e = t.width / n.offsetWidth, i = t.height / n.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - n.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - n.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
h(Gk, "Fd$1");
y(Gk, "getScale");
function dQ(n, t, e, i, s, r, a, o) {
  let l = n.ownerDocument, c = l.defaultView || window;
  for (let d = n, p = !1; d && !p; )
    if (d.nodeType == 1) {
      let f, m = d == l.body, w = 1, b = 1;
      if (m)
        f = hQ(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(d).position) && (p = !0), d.scrollHeight <= d.clientHeight && d.scrollWidth <= d.clientWidth) {
          d = d.assignedSlot || d.parentNode;
          continue;
        }
        let P = d.getBoundingClientRect();
        ({ scaleX: w, scaleY: b } = Gk(d, P)), f = {
          left: P.left,
          right: P.left + d.clientWidth * w,
          top: P.top,
          bottom: P.top + d.clientHeight * b
        };
      }
      let x = 0, O = 0;
      if (s == "nearest")
        t.top < f.top ? (O = t.top - (f.top + a), e > 0 && t.bottom > f.bottom + O && (O = t.bottom - f.bottom + a)) : t.bottom > f.bottom && (O = t.bottom - f.bottom + a, e < 0 && t.top - O < f.top && (O = t.top - (f.top + a)));
      else {
        let P = t.bottom - t.top, A = f.bottom - f.top;
        O = (s == "center" && P <= A ? t.top + P / 2 - A / 2 : s == "start" || s == "center" && e < 0 ? t.top - a : t.bottom - A + a) - f.top;
      }
      if (i == "nearest" ? t.left < f.left ? (x = t.left - (f.left + r), e > 0 && t.right > f.right + x && (x = t.right - f.right + r)) : t.right > f.right && (x = t.right - f.right + r, e < 0 && t.left < f.left + x && (x = t.left - (f.left + r))) : x = (i == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : i == "start" == o ? t.left - r : t.right - (f.right - f.left) + r) - f.left, x || O)
        if (m)
          c.scrollBy(x, O);
        else {
          let P = 0, A = 0;
          if (O) {
            let R = d.scrollTop;
            d.scrollTop += O / b, A = (d.scrollTop - R) * b;
          }
          if (x) {
            let R = d.scrollLeft;
            d.scrollLeft += x / w, P = (d.scrollLeft - R) * w;
          }
          t = {
            left: t.left - P,
            top: t.top - A,
            right: t.right - P,
            bottom: t.bottom - A
          }, P && Math.abs(P - x) < 1 && (i = "nearest"), A && Math.abs(A - O) < 1 && (s = "nearest");
        }
      if (m)
        break;
      (t.top < f.top || t.bottom > f.bottom || t.left < f.left || t.right > f.right) && (t = {
        left: Math.max(t.left, f.left),
        right: Math.min(t.right, f.right),
        top: Math.max(t.top, f.top),
        bottom: Math.min(t.bottom, f.bottom)
      }), d = d.assignedSlot || d.parentNode;
    } else if (d.nodeType == 11)
      d = d.host;
    else
      break;
}
h(dQ, "Wg$1");
y(dQ, "scrollRectIntoView");
function uQ(n) {
  let t = n.ownerDocument, e, i;
  for (let s = n.parentNode; s && !(s == t.body || e && i); )
    if (s.nodeType == 1)
      !i && s.scrollHeight > s.clientHeight && (i = s), !e && s.scrollWidth > s.clientWidth && (e = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: e, y: i };
}
h(uQ, "Xg$1");
y(uQ, "scrollableParents");
var ch;
const pQ = (ch = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? kn(e) : 0), i, Math.min(t.focusOffset, i ? kn(i) : 0));
  }
  set(t, e, i, s) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = s;
  }
}, h(ch, "Gh"), ch);
y(pQ, "DOMSelectionState");
let EZ = pQ, Gl = null;
function Kk(n) {
  if (n.setActive)
    return n.setActive();
  if (Gl)
    return n.focus(Gl);
  let t = [];
  for (let e = n; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (n.focus(Gl == null ? {
    get preventScroll() {
      return Gl = { preventScroll: !0 }, !0;
    }
  } : void 0), !Gl) {
    Gl = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], s = t[e++], r = t[e++];
      i.scrollTop != s && (i.scrollTop = s), i.scrollLeft != r && (i.scrollLeft = r);
    }
  }
}
h(Kk, "Kd");
y(Kk, "focusPreventScroll");
let DC;
function Yr(n, t, e = t) {
  let i = DC || (DC = document.createRange());
  return i.setEnd(n, e), i.setStart(n, t), i;
}
h(Yr, "ri$1");
y(Yr, "textRange");
function Ba(n, t, e, i) {
  let s = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = i);
  let r = new KeyboardEvent("keydown", s);
  r.synthetic = !0, n.dispatchEvent(r);
  let a = new KeyboardEvent("keyup", s);
  return a.synthetic = !0, n.dispatchEvent(a), r.defaultPrevented || a.defaultPrevented;
}
h(Ba, "$i$1");
y(Ba, "dispatchKey");
function fQ(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
h(fQ, "Yg$1");
y(fQ, "getRoot");
function Jk(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
h(Jk, "Jd");
y(Jk, "clearAttributes");
function yQ(n, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, kn(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let s = e.childNodes[i - 1];
      s.contentEditable == "false" ? i-- : (e = s, i = kn(e));
    } else {
      if (e == n)
        return !0;
      i = Hr(e), e = e.parentNode;
    }
}
h(yQ, "Ig$1");
y(yQ, "atElementStart");
function t5(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
h(t5, "eO");
y(t5, "isScrolledToBottom");
function e5(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = kn(e);
    } else if (e.parentNode && !hw(e))
      i = Hr(e), e = e.parentNode;
    else
      return null;
  }
}
h(e5, "tO");
y(e5, "textNodeBefore");
function i5(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !hw(e))
      i = Hr(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
h(i5, "iO");
y(i5, "textNodeAfter");
var Pr;
const mQ = (Pr = class {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new Pr(t.parentNode, Hr(t), e);
  }
  static after(t, e) {
    return new Pr(t.parentNode, Hr(t) + 1, e);
  }
}, h(Pr, "$r"), Pr);
y(mQ, "DOMPos");
let ji = mQ;
const n5 = [];
var Cr;
const wQ = (Cr = class {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let e = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return e;
      e += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, e) {
    if (this.flags & 2) {
      let i = this.dom, s = null, r;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (r = s ? s.nextSibling : i.firstChild)) {
            let o = Cr.get(r);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(r);
          }
          a.sync(t, e), a.flags &= -8;
        }
        if (r = s ? s.nextSibling : i.firstChild, e && !e.written && e.node == i && r != a.dom && (e.written = !0), a.dom.parentNode == i)
          for (; r && r != a.dom; )
            r = T$(r);
        else
          i.insertBefore(a.dom, r);
        s = a.dom;
      }
      for (r = s ? s.nextSibling : i.firstChild, r && e && e.node == i && (e.written = !0); r; )
        r = T$(r);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(t, e), i.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, e) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[e];
    else {
      let s = kn(t) == 0 ? 0 : e == 0 ? -1 : 1;
      for (; ; ) {
        let r = t.parentNode;
        if (r == this.dom)
          break;
        s == 0 && r.firstChild != r.lastChild && (t == r.firstChild ? s = -1 : s = 1), t = r;
      }
      s < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Cr.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let s = 0, r = 0; ; s++) {
      let a = this.children[s];
      if (a.dom == i)
        return r;
      r += a.length + a.breakAfter;
    }
  }
  domBoundsAround(t, e, i = 0) {
    let s = -1, r = -1, a = -1, o = -1;
    for (let l = 0, c = i, d = i; l < this.children.length; l++) {
      let p = this.children[l], f = c + p.length;
      if (c < t && f > e)
        return p.domBoundsAround(t, e, c);
      if (f >= t && s == -1 && (s = l, r = c), c > e && p.dom.parentNode == this.dom) {
        a = l, o = d;
        break;
      }
      d = f, c = f + p.breakAfter;
    }
    return {
      from: r,
      to: o < 0 ? i + this.length : o,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let e = this.parent; e; e = e.parent) {
      if (t && (e.flags |= 2), e.flags & 1)
        return;
      e.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let e = t.parent;
      if (!e)
        return t;
      t = e;
    }
  }
  replaceChildren(t, e, i = n5) {
    this.markDirty();
    for (let s = t; s < e; s++) {
      let r = this.children[s];
      r.parent == this && i.indexOf(r) < 0 && r.destroy();
    }
    i.length < 250 ? this.children.splice(t, e - t, ...i) : this.children = [].concat(this.children.slice(0, t), i, this.children.slice(e));
    for (let s = 0; s < i.length; s++)
      i[s].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new vQ(this.children, t, this.children.length);
  }
  childPos(t, e = 1) {
    return this.childCursor().findPos(t, e);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, e, i, s, r, a) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}, h(Cr, "vr"), Cr);
y(wQ, "ContentView");
let ne = wQ;
ne.prototype.breakAfter = 0;
function T$(n) {
  let t = n.nextSibling;
  return n.parentNode.removeChild(n), t;
}
h(T$, "Yc$1");
y(T$, "rm$1");
var hh;
const gQ = (hh = class {
  constructor(t, e, i) {
    this.children = t, this.pos = e, this.i = i, this.off = 0;
  }
  findPos(t, e = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (e > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}, h(hh, "Hh"), hh);
y(gQ, "ChildCursor");
let vQ = gQ;
function s5(n, t, e, i, s, r, a, o, l) {
  let { children: c } = n, d = c.length ? c[t] : null, p = r.length ? r[r.length - 1] : null, f = p ? p.breakAfter : a;
  if (!(t == i && d && !a && !f && r.length < 2 && d.merge(e, s, r.length ? p : null, e == 0, o, l))) {
    if (i < c.length) {
      let m = c[i];
      m && (s < m.length || m.breakAfter && p != null && p.breakAfter) ? (t == i && (m = m.split(s), s = 0), !f && p && m.merge(0, s, p, !0, 0, l) ? r[r.length - 1] = m : ((s || m.children.length && !m.children[0].length) && m.merge(0, s, null, !1, 0, l), r.push(m))) : m != null && m.breakAfter && (p ? p.breakAfter = 1 : a = 1), i++;
    }
    for (d && (d.breakAfter = a, e > 0 && (!a && r.length && d.merge(e, d.length, r[0], !1, o, 0) ? d.breakAfter = r.shift().breakAfter : (e < d.length || d.children.length && d.children[d.children.length - 1].length == 0) && d.merge(e, d.length, null, !1, o, 0), t++)); t < i && r.length; )
      if (c[i - 1].become(r[r.length - 1]))
        i--, r.pop(), l = r.length ? 0 : o;
      else if (c[t].become(r[0]))
        t++, r.shift(), o = r.length ? 0 : l;
      else
        break;
    !r.length && t && i < c.length && !c[t - 1].breakAfter && c[i].merge(0, 0, c[t - 1], !1, o, l) && t--, (t < i || r.length) && n.replaceChildren(t, i, r);
  }
}
h(s5, "rO");
y(s5, "replaceRange");
function r5(n, t, e, i, s, r) {
  let a = n.childCursor(), { i: o, off: l } = a.findPos(e, 1), { i: c, off: d } = a.findPos(t, -1), p = t - e;
  for (let f of i)
    p += f.length;
  n.length += p, s5(n, c, d, o, l, i, 0, s, r);
}
h(r5, "nO");
y(r5, "mergeChildrenInto");
let Si = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, A$ = typeof document < "u" ? document : { documentElement: { style: {} } };
const R$ = /* @__PURE__ */ /Edge\/(\d+)/.exec(Si.userAgent), bQ = /* @__PURE__ */ /MSIE \d/.test(Si.userAgent), E$ = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Si.userAgent), l0 = !!(bQ || E$ || R$), qC = !l0 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Si.userAgent), db = !l0 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Si.userAgent), zZ = "webkitFontSmoothing" in A$.documentElement.style, OQ = !l0 && /* @__PURE__ */ /Apple Computer/.test(Si.vendor), VC = OQ && (/* @__PURE__ */ /Mobile\/\w+/.test(Si.userAgent) || Si.maxTouchPoints > 2);
var rt = {
  mac: VC || /* @__PURE__ */ /Mac/.test(Si.platform),
  windows: /* @__PURE__ */ /Win/.test(Si.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Si.platform),
  ie: l0,
  ie_version: bQ ? A$.documentMode || 6 : E$ ? +E$[1] : R$ ? +R$[1] : 0,
  gecko: qC,
  gecko_version: qC ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Si.userAgent) || [0, 0])[1] : 0,
  chrome: !!db,
  chrome_version: db ? +db[1] : 0,
  ios: VC,
  android: /* @__PURE__ */ /Android\b/.test(Si.userAgent),
  safari: OQ,
  webkit_version: zZ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Si.userAgent) || [0, 0])[1] : 0,
  tabSize: A$.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const _Z = 256;
var Qr;
const $Q = (Qr = class extends ne {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, e, i) {
    return this.flags & 8 || i && (!(i instanceof Qr) || this.length - (e - t) + i.length > _Z || i.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0);
  }
  split(t) {
    let e = new Qr(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= this.flags & 8, e;
  }
  localPosFromDOM(t, e) {
    return t == this.dom ? e : e ? this.text.length : 0;
  }
  domAtPos(t) {
    return new ji(this.dom, t);
  }
  domBoundsAround(t, e, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, e) {
    return kQ(this.dom, t, e);
  }
}, h(Qr, "Tr"), Qr);
y($Q, "TextView");
let Gr = $Q;
var Mr;
const xQ = (Mr = class extends ne {
  constructor(t, e = [], i = 0) {
    super(), this.mark = t, this.children = e, this.length = i;
    for (let s of e)
      s.setParent(this);
  }
  setAttrs(t) {
    if (Jk(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let e in this.mark.attrs)
        t.setAttribute(e, this.mark.attrs[e]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e);
  }
  merge(t, e, i, s, r, a) {
    return i && (!(i instanceof Mr && i.mark.eq(this.mark)) || t && r <= 0 || e < this.length && a <= 0) ? !1 : (r5(this, t, e, i ? i.children.slice() : [], r - 1, a - 1), this.markDirty(), !0);
  }
  split(t) {
    let e = [], i = 0, s = -1, r = 0;
    for (let o of this.children) {
      let l = i + o.length;
      l > t && e.push(i < t ? o.split(t - i) : o), s < 0 && i >= t && (s = r), i = l, r++;
    }
    let a = this.length - t;
    return this.length = t, s > -1 && (this.children.length = s, this.markDirty()), new Mr(this.mark, e, a);
  }
  domAtPos(t) {
    return a5(this, t);
  }
  coordsAt(t, e) {
    return l5(this, t, e);
  }
}, h(Mr, "Ar"), Mr);
y(xQ, "MarkView");
let qf = xQ;
function kQ(n, t, e) {
  let i = n.nodeValue.length;
  t > i && (t = i);
  let s = t, r = t, a = 0;
  t == 0 && e < 0 || t == i && e >= 0 ? rt.chrome || rt.gecko || (t ? (s--, a = 1) : r < i && (r++, a = -1)) : e < 0 ? s-- : r < i && r++;
  let o = Yr(n, s, r).getClientRects();
  if (!o.length)
    return null;
  let l = o[(a ? a < 0 : e >= 0) ? 0 : o.length - 1];
  return rt.safari && !a && l.width == 0 && (l = Array.prototype.find.call(o, (c) => c.width) || l), a ? vy(l, a < 0) : l || null;
}
h(kQ, "Dg$1");
y(kQ, "textCoords");
var Hn;
const SQ = (Hn = class extends ne {
  static create(t, e, i) {
    return new Hn(t, e, i);
  }
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null;
  }
  split(t) {
    let e = Hn.create(this.widget, this.length - t, this.side);
    return this.length -= t, e;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, e, i, s, r, a) {
    return i && (!(i instanceof Hn) || !this.widget.compare(i.widget) || t > 0 && r <= 0 || e < this.length && a <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  become(t) {
    return t instanceof Hn && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Zt.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: e } = t, i = e && e.state.doc, s = this.posAtStart;
    return i ? i.slice(s, s + this.length) : Zt.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? ji.before(this.dom) : ji.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    if (i)
      return i;
    let s = this.dom.getClientRects(), r = null;
    if (!s.length)
      return null;
    let a = this.side ? this.side < 0 : t > 0;
    for (let o = a ? s.length - 1 : 0; r = s[o], !(t > 0 ? o == 0 : o == s.length - 1 || r.top < r.bottom); o += a ? -1 : 1)
      ;
    return vy(r, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, h(Hn, "jt"), Hn);
y(SQ, "WidgetView");
let PQ = SQ;
var Tr;
const CQ = (Tr = class extends ne {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Tr && t.side == this.side;
  }
  split() {
    return new Tr(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? ji.before(this.dom) : ji.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Zt.empty;
  }
  get isHidden() {
    return !0;
  }
}, h(Tr, "Zr"), Tr);
y(CQ, "WidgetBufferView");
let z$ = CQ;
Gr.prototype.children = PQ.prototype.children = z$.prototype.children = n5;
function a5(n, t) {
  let e = n.dom, { children: i } = n, s = 0;
  for (let r = 0; s < i.length; s++) {
    let a = i[s], o = r + a.length;
    if (!(o == r && a.getSide() <= 0)) {
      if (t > r && t < o && a.dom.parentNode == e)
        return a.domAtPos(t - r);
      if (t <= r)
        break;
      r = o;
    }
  }
  for (let r = s; r > 0; r--) {
    let a = i[r - 1];
    if (a.dom.parentNode == e)
      return a.domAtPos(a.length);
  }
  for (let r = s; r < i.length; r++) {
    let a = i[r];
    if (a.dom.parentNode == e)
      return a.domAtPos(0);
  }
  return new ji(e, 0);
}
h(a5, "lO");
y(a5, "inlineDOMAtPos");
function o5(n, t, e) {
  let i, { children: s } = n;
  e > 0 && t instanceof qf && s.length && (i = s[s.length - 1]) instanceof qf && i.mark.eq(t.mark) ? o5(i, t.children[0], e - 1) : (s.push(t), t.setParent(n)), n.length += t.length;
}
h(o5, "aO");
y(o5, "joinInlineInto");
function l5(n, t, e) {
  let i = null, s = -1, r = null, a = -1;
  function o(c, d) {
    for (let p = 0, f = 0; p < c.children.length && f <= d; p++) {
      let m = c.children[p], w = f + m.length;
      w >= d && (m.children.length ? o(m, d - f) : (!r || r.isHidden && (e > 0 || MQ(r, m))) && (w > d || f == w && m.getSide() > 0) ? (r = m, a = d - f) : (f < d || f == w && m.getSide() < 0 && !m.isHidden) && (i = m, s = d - f)), f = w;
    }
  }
  h(o, "l"), y(o, "scan"), o(n, t);
  let l = (e < 0 ? i : r) || i || r;
  return l ? l.coordsAt(Math.max(0, l == i ? s : a), e) : QQ(n);
}
h(l5, "hO");
y(l5, "coordsInChildren");
function QQ(n) {
  let t = n.dom.lastChild;
  if (!t)
    return n.dom.getBoundingClientRect();
  let e = Io(t);
  return e[e.length - 1] || null;
}
h(QQ, "Bg$1");
y(QQ, "fallbackRect");
function MQ(n, t) {
  let e = n.coordsAt(0, 1), i = t.coordsAt(0, 1);
  return e && i && i.top < e.bottom;
}
h(MQ, "zg$1");
y(MQ, "onSameLine");
function G1(n, t) {
  for (let e in n)
    e == "class" && t.class ? t.class += " " + n.class : e == "style" && t.style ? t.style += ";" + n.style : t[e] = n[e];
  return t;
}
h(G1, "wl$1");
y(G1, "combineAttrs");
const jC = /* @__PURE__ */ Object.create(null);
function dw(n, t, e) {
  if (n == t)
    return !0;
  n || (n = jC), t || (t = jC);
  let i = Object.keys(n), s = Object.keys(t);
  if (i.length - (e && i.indexOf(e) > -1 ? 1 : 0) != s.length - (e && s.indexOf(e) > -1 ? 1 : 0))
    return !1;
  for (let r of i)
    if (r != e && (s.indexOf(r) == -1 || n[r] !== t[r]))
      return !1;
  return !0;
}
h(dw, "os$2");
y(dw, "attrsEq");
function K1(n, t, e) {
  let i = !1;
  if (t)
    for (let s in t)
      e && s in e || (i = !0, s == "style" ? n.style.cssText = "" : n.removeAttribute(s));
  if (e)
    for (let s in e)
      t && t[s] == e[s] || (i = !0, s == "style" ? n.style.cssText = e[s] : n.setAttribute(s, e[s]));
  return i;
}
h(K1, "xl");
y(K1, "updateAttrs");
function TQ(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < n.attributes.length; e++) {
    let i = n.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
h(TQ, "Ng$1");
y(TQ, "getAttrs$1");
var dh;
const AQ = (dh = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}, h(dh, "Fh"), dh);
y(AQ, "WidgetType");
let by = AQ;
var ns = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(ns || (ns = {})), uh;
const RQ = (uh = class extends Lo {
  constructor(t, e, i, s) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new c5(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new Vf(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, s;
    if (t.isBlockGap)
      i = -5e8, s = 4e8;
    else {
      let { start: r, end: a } = d5(t, e);
      i = (r ? e ? -3e8 : -1 : 5e8) - 1, s = (a ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new Vf(t, i, s, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new h5(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return li.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}, h(uh, "Kh"), uh);
y(RQ, "Decoration");
let Jt = RQ;
Jt.none = li.empty;
var ro;
const EQ = (ro = class extends Jt {
  constructor(t) {
    let { start: e, end: i } = d5(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var e, i;
    return this == t || t instanceof ro && this.tagName == t.tagName && (this.class || ((e = this.attrs) === null || e === void 0 ? void 0 : e.class)) == (t.class || ((i = t.attrs) === null || i === void 0 ? void 0 : i.class)) && dw(this.attrs, t.attrs, "class");
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}, h(ro, "zs"), ro);
y(EQ, "MarkDecoration");
let c5 = EQ;
c5.prototype.point = !1;
var ao;
const zQ = (ao = class extends Jt {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof ao && this.spec.class == t.spec.class && dw(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}, h(ao, "Ns"), ao);
y(zQ, "LineDecoration");
let h5 = zQ;
h5.prototype.mapMode = mi.TrackBefore;
h5.prototype.point = !0;
var oo;
const _Q = (oo = class extends Jt {
  constructor(t, e, i, s, r, a) {
    super(e, i, r, t), this.block = s, this.isReplace = a, this.mapMode = s ? e <= 0 ? mi.TrackBefore : mi.TrackAfter : mi.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? ns.WidgetRange : this.startSide <= 0 ? ns.WidgetBefore : ns.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof oo && LQ(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}, h(oo, "Gs"), oo);
y(_Q, "PointDecoration");
let Vf = _Q;
Vf.prototype.point = !0;
function d5(n, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = n;
  return e == null && (e = n.inclusive), i == null && (i = n.inclusive), { start: e ?? t, end: i ?? t };
}
h(d5, "fO");
y(d5, "getInclusive");
function LQ(n, t) {
  return n == t || !!(n && t && n.compare(t));
}
h(LQ, "Gg$1");
y(LQ, "widgetsEq");
function Gm(n, t, e, i = 0) {
  let s = e.length - 1;
  s >= 0 && e[s] + i >= n ? e[s] = Math.max(e[s], t) : e.push(n, t);
}
h(Gm, "Dn$1");
y(Gm, "addRange");
var Yn;
const IQ = (Yn = class extends ne {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, e, i, s, r, a) {
    if (i) {
      if (!(i instanceof Yn))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return s && this.setDeco(i ? i.attrs : null), r5(this, t, e, i ? i.children.slice() : [], r, a), !0;
  }
  split(t) {
    let e = new Yn();
    if (e.breakAfter = this.breakAfter, this.length == 0)
      return e;
    let { i, off: s } = this.childPos(t);
    s && (e.append(this.children[i].split(s), 0), this.children[i].merge(s, this.children[i].length, null, !1, 0, 0), i++);
    for (let r = i; r < this.children.length; r++)
      e.append(this.children[r], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, e;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    dw(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, e) {
    o5(this, t, e);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let e = t.spec.attributes, i = t.spec.class;
    e && (this.attrs = G1(e, this.attrs || {})), i && (this.attrs = G1({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return a5(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    var i;
    this.dom ? this.flags & 4 && (Jk(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (K1(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e);
    let s = this.dom.lastChild;
    for (; s && ne.get(s) instanceof qf; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((i = ne.get(s)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!rt.ios || !this.children.some((r) => r instanceof Gr))) {
      let r = document.createElement("BR");
      r.cmIgnore = !0, this.dom.appendChild(r);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, e;
    for (let i of this.children) {
      if (!(i instanceof Gr) || /[^ -~]/.test(i.text))
        return null;
      let s = Io(i.dom);
      if (s.length != 1)
        return null;
      t += s[0].width, e = s[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: e
    } : null;
  }
  coordsAt(t, e) {
    let i = l5(this, t, e);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, r = i.bottom - i.top;
      if (Math.abs(r - s.lineHeight) < 2 && s.textHeight < r) {
        let a = (r - s.textHeight) / 2;
        return { top: i.top + a, bottom: i.bottom - a, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(t) {
    return t instanceof Yn && this.children.length == 0 && t.children.length == 0 && dw(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, e) {
    for (let i = 0, s = 0; i < t.children.length; i++) {
      let r = t.children[i], a = s + r.length;
      if (a >= e) {
        if (r instanceof Yn)
          return r;
        if (a > e)
          break;
      }
      s = a + r.breakAfter;
    }
    return null;
  }
}, h(Yn, "qt"), Yn);
y(IQ, "LineView");
let ui = IQ;
var Es;
const ZQ = (Es = class extends ne {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, e, i, s, r, a) {
    return i && (!(i instanceof Es) || !this.widget.compare(i.widget) || t > 0 && r <= 0 || e < this.length && a <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  domAtPos(t) {
    return t == 0 ? ji.before(this.dom) : ji.after(this.dom, t == this.length);
  }
  split(t) {
    let e = this.length - t;
    this.length = t;
    let i = new Es(this.widget, e, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return n5;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Zt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof Es && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, e) {
    return this.widget.coordsAt(this.dom, t, e) || (this.widget instanceof _$ ? null : vy(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: e, endSide: i } = this.deco;
    return e == i ? !1 : t < 0 ? e < 0 : i > 0;
  }
}, h(Es, "bi"), Es);
y(ZQ, "BlockWidgetView");
let Km = ZQ;
var ph;
const WQ = (ph = class extends by {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}, h(ph, "Jh"), ph);
y(WQ, "BlockGapWidget");
let _$ = WQ;
var lo;
const DQ = (lo = class {
  constructor(t, e, i, s) {
    this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof Km && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ui()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(lm(new z$(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof Km) && this.getLine();
  }
  buildText(t, e, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: r, lineBreak: a, done: o } = this.cursor.next(this.skip);
        if (this.skip = 0, o)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = r, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        t,
        512
        /* T.Chunk */
      );
      this.flushBuffer(e.slice(e.length - i)), this.getLine().append(lm(new Gr(this.text.slice(this.textOff, this.textOff + s)), e), i), this.atCursorPos = !0, this.textOff += s, t -= s, i = 0;
    }
  }
  span(t, e, i, s) {
    this.buildText(e - t, i, s), this.pos = e, this.openStart < 0 && (this.openStart = s);
  }
  point(t, e, i, s, r, a) {
    if (this.disallowBlockEffectsFor[a] && i instanceof Vf) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (e > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = e - t;
    if (i instanceof Vf)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Km(i.widget || jf.block, o, i));
      else {
        let l = PQ.create(i.widget || jf.inline, o, o ? 0 : i.startSide), c = this.atCursorPos && !l.isEditable && r <= s.length && (t < e || i.startSide > 0), d = !l.isEditable && (t < e || r > s.length || i.startSide <= 0), p = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), c && (p.append(lm(new z$(1), s), r), r = s.length + Math.max(0, r - s.length)), p.append(lm(l, s), r), this.atCursorPos = d, this.pendingBuffer = d ? t < e || r > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = r);
  }
  static build(t, e, i, s, r) {
    let a = new lo(t, e, i, r);
    return a.openEnd = li.spans(s, e, i, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}, h(lo, "Hs"), lo);
y(DQ, "ContentBuilder");
let ub = DQ;
function lm(n, t) {
  for (let e of t)
    n = new qf(e, [n], n.length);
  return n;
}
h(lm, "Rn$1");
y(lm, "wrapMarks");
var fh;
const qQ = (fh = class extends by {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}, h(fh, "ef"), fh);
y(qQ, "NullWidget");
let jf = qQ;
jf.inline = /* @__PURE__ */ new jf("span");
jf.block = /* @__PURE__ */ new jf("div");
var Pe = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(Pe || (Pe = {}));
const Zo = Pe.LTR, u5 = Pe.RTL;
function p5(n) {
  let t = [];
  for (let e = 0; e < n.length; e++)
    t.push(1 << +n[e]);
  return t;
}
h(p5, "cO");
y(p5, "dec");
const LZ = /* @__PURE__ */ p5("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), IZ = /* @__PURE__ */ p5("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), L$ = /* @__PURE__ */ Object.create(null), _n = [];
for (let n of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ n.charCodeAt(0), e = /* @__PURE__ */ n.charCodeAt(1);
  L$[t] = e, L$[e] = -t;
}
function f5(n) {
  return n <= 247 ? LZ[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? IZ[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
h(f5, "uO");
y(f5, "charType");
const ZZ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var yh;
const VQ = (yh = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? u5 : Zo;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, s) {
    let r = -1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      if (o.from <= e && o.to >= e) {
        if (o.level == i)
          return a;
        (r < 0 || (s != 0 ? s < 0 ? o.from < e : o.to > e : t[r].level > o.level)) && (r = a);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
}, h(yh, "tf"), yh);
y(VQ, "BidiSpan");
let vr = VQ;
function y5(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++) {
    let i = n[e], s = t[e];
    if (i.from != s.from || i.to != s.to || i.direction != s.direction || !y5(i.inner, s.inner))
      return !1;
  }
  return !0;
}
h(y5, "dO");
y(y5, "isolatesEq");
const Ut = [];
function jQ(n, t, e, i, s) {
  for (let r = 0; r <= i.length; r++) {
    let a = r ? i[r - 1].to : t, o = r < i.length ? i[r].from : e, l = r ? 256 : s;
    for (let c = a, d = l, p = l; c < o; c++) {
      let f = f5(n.charCodeAt(c));
      f == 512 ? f = d : f == 8 && p == 4 && (f = 16), Ut[c] = f == 4 ? 2 : f, f & 7 && (p = f), d = f;
    }
    for (let c = a, d = l, p = l; c < o; c++) {
      let f = Ut[c];
      if (f == 128)
        c < o - 1 && d == Ut[c + 1] && d & 24 ? f = Ut[c] = d : Ut[c] = 256;
      else if (f == 64) {
        let m = c + 1;
        for (; m < o && Ut[m] == 64; )
          m++;
        let w = c && d == 8 || m < e && Ut[m] == 8 ? p == 1 ? 1 : 8 : 256;
        for (let b = c; b < m; b++)
          Ut[b] = w;
        c = m - 1;
      } else f == 8 && p == 1 && (Ut[c] = 1);
      d = f, f & 7 && (p = f);
    }
  }
}
h(jQ, "Jg$1");
y(jQ, "computeCharTypes");
function FQ(n, t, e, i, s) {
  let r = s == 1 ? 2 : 1;
  for (let a = 0, o = 0, l = 0; a <= i.length; a++) {
    let c = a ? i[a - 1].to : t, d = a < i.length ? i[a].from : e;
    for (let p = c, f, m, w; p < d; p++)
      if (m = L$[f = n.charCodeAt(p)])
        if (m < 0) {
          for (let b = o - 3; b >= 0; b -= 3)
            if (_n[b + 1] == -m) {
              let x = _n[b + 2], O = x & 2 ? s : x & 4 ? x & 1 ? r : s : 0;
              O && (Ut[p] = Ut[_n[b]] = O), o = b;
              break;
            }
        } else {
          if (_n.length == 189)
            break;
          _n[o++] = p, _n[o++] = f, _n[o++] = l;
        }
      else if ((w = Ut[p]) == 2 || w == 1) {
        let b = w == s;
        l = b ? 0 : 1;
        for (let x = o - 3; x >= 0; x -= 3) {
          let O = _n[x + 2];
          if (O & 2)
            break;
          if (b)
            _n[x + 2] |= 2;
          else {
            if (O & 4)
              break;
            _n[x + 2] |= 4;
          }
        }
      }
  }
}
h(FQ, "e0$1");
y(FQ, "processBracketPairs");
function UQ(n, t, e, i) {
  for (let s = 0, r = i; s <= e.length; s++) {
    let a = s ? e[s - 1].to : n, o = s < e.length ? e[s].from : t;
    for (let l = a; l < o; ) {
      let c = Ut[l];
      if (c == 256) {
        let d = l + 1;
        for (; ; )
          if (d == o) {
            if (s == e.length)
              break;
            d = e[s++].to, o = s < e.length ? e[s].from : t;
          } else if (Ut[d] == 256)
            d++;
          else
            break;
        let p = r == 1, f = (d < t ? Ut[d] : i) == 1, m = p == f ? p ? 1 : 2 : i;
        for (let w = d, b = s, x = b ? e[b - 1].to : n; w > l; )
          w == x && (w = e[--b].from, x = b ? e[b - 1].to : n), Ut[--w] = m;
        l = d;
      } else
        r = c, l++;
    }
  }
}
h(UQ, "t0$1");
y(UQ, "processNeutrals");
function J1(n, t, e, i, s, r, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == s % 2)
    for (let l = t, c = 0; l < e; ) {
      let d = !0, p = !1;
      if (c == r.length || l < r[c].from) {
        let b = Ut[l];
        b != o && (d = !1, p = b == 16);
      }
      let f = !d && o == 1 ? [] : null, m = d ? i : i + 1, w = l;
      t: for (; ; )
        if (c < r.length && w == r[c].from) {
          if (p)
            break t;
          let b = r[c];
          if (!d)
            for (let x = b.to, O = c + 1; ; ) {
              if (x == e)
                break t;
              if (O < r.length && r[O].from == x)
                x = r[O++].to;
              else {
                if (Ut[x] == o)
                  break t;
                break;
              }
            }
          if (c++, f)
            f.push(b);
          else {
            b.from > l && a.push(new vr(l, b.from, m));
            let x = b.direction == Zo != !(m % 2);
            tv(n, x ? i + 1 : i, s, b.inner, b.from, b.to, a), l = b.to;
          }
          w = b.to;
        } else {
          if (w == e || (d ? Ut[w] != o : Ut[w] == o))
            break;
          w++;
        }
      f ? J1(n, l, w, i + 1, s, f, a) : l < w && a.push(new vr(l, w, m)), l = w;
    }
  else
    for (let l = e, c = r.length; l > t; ) {
      let d = !0, p = !1;
      if (!c || l > r[c - 1].to) {
        let b = Ut[l - 1];
        b != o && (d = !1, p = b == 16);
      }
      let f = !d && o == 1 ? [] : null, m = d ? i : i + 1, w = l;
      t: for (; ; )
        if (c && w == r[c - 1].to) {
          if (p)
            break t;
          let b = r[--c];
          if (!d)
            for (let x = b.from, O = c; ; ) {
              if (x == t)
                break t;
              if (O && r[O - 1].to == x)
                x = r[--O].from;
              else {
                if (Ut[x - 1] == o)
                  break t;
                break;
              }
            }
          if (f)
            f.push(b);
          else {
            b.to < l && a.push(new vr(b.to, l, m));
            let x = b.direction == Zo != !(m % 2);
            tv(n, x ? i + 1 : i, s, b.inner, b.from, b.to, a), l = b.from;
          }
          w = b.from;
        } else {
          if (w == t || (d ? Ut[w - 1] != o : Ut[w - 1] == o))
            break;
          w--;
        }
      f ? J1(n, w, l, i + 1, s, f, a) : w < l && a.push(new vr(w, l, m)), l = w;
    }
}
h(J1, "kl$1");
y(J1, "emitSpans");
function tv(n, t, e, i, s, r, a) {
  let o = t % 2 ? 2 : 1;
  jQ(n, s, r, i, o), FQ(n, s, r, i, o), UQ(s, r, i, o), J1(n, s, r, t, e, i, a);
}
h(tv, "Rl$1");
y(tv, "computeSectionOrder");
function BQ(n, t, e) {
  if (!n)
    return [new vr(0, 0, t == u5 ? 1 : 0)];
  if (t == Zo && !e.length && !ZZ.test(n))
    return m5(n.length);
  if (e.length)
    for (; n.length > Ut.length; )
      Ut[Ut.length] = 256;
  let i = [], s = t == Zo ? 0 : 1;
  return tv(n, s, s, e, 0, n.length, i), i;
}
h(BQ, "i0$1");
y(BQ, "computeOrder");
function m5(n) {
  return [new vr(0, n, 0)];
}
h(m5, "OO");
y(m5, "trivialOrder");
let XQ = "";
function NQ(n, t, e, i, s) {
  var r;
  let a = i.head - n.from, o = vr.find(t, a, (r = i.bidiLevel) !== null && r !== void 0 ? r : -1, i.assoc), l = t[o], c = l.side(s, e);
  if (a == c) {
    let f = o += s ? 1 : -1;
    if (f < 0 || f >= t.length)
      return null;
    l = t[o = f], a = l.side(!s, e), c = l.side(s, e);
  }
  let d = gn(n.text, a, l.forward(s, e));
  (d < l.from || d > l.to) && (d = c), XQ = n.text.slice(Math.min(a, d), Math.max(a, d));
  let p = o == (s ? t.length - 1 : 0) ? null : t[o + (s ? 1 : -1)];
  return p && d == c && p.level + (s ? 0 : 1) < l.level ? it.cursor(p.side(!s, e) + n.from, p.forward(s, e) ? 1 : -1, p.level) : it.cursor(d + n.from, l.forward(s, e) ? -1 : 1, l.level);
}
h(NQ, "r0$1");
y(NQ, "moveVisually");
function HQ(n, t, e) {
  for (let i = t; i < e; i++) {
    let s = f5(n.charCodeAt(i));
    if (s == 1)
      return Zo;
    if (s == 2 || s == 4)
      return u5;
  }
  return Zo;
}
h(HQ, "n0$1");
y(HQ, "autoDirection");
const YQ = /* @__PURE__ */ gt.define(), GQ = /* @__PURE__ */ gt.define(), KQ = /* @__PURE__ */ gt.define(), JQ = /* @__PURE__ */ gt.define(), I$ = /* @__PURE__ */ gt.define(), t7 = /* @__PURE__ */ gt.define(), e7 = /* @__PURE__ */ gt.define(), w5 = /* @__PURE__ */ gt.define(), g5 = /* @__PURE__ */ gt.define(), i7 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => n.some((t) => t), "combine")
}), WZ = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => n.some((t) => t), "combine")
}), n7 = /* @__PURE__ */ gt.define();
var Ar;
const s7 = (Ar = class {
  constructor(t, e = "nearest", i = "nearest", s = 5, r = 5, a = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = s, this.xMargin = r, this.isSnapshot = a;
  }
  map(t) {
    return t.empty ? this : new Ar(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Ar(it.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, h(Ar, "Lr"), Ar);
y(s7, "ScrollTarget");
let pb = s7;
const Cg = /* @__PURE__ */ Bt.define({ map: /* @__PURE__ */ y((n, t) => n.map(t), "map") }), r7 = /* @__PURE__ */ Bt.define();
function Ci(n, t, e) {
  let i = n.facet(JQ);
  i.length ? i[0](t) : window.onerror && window.onerror(String(t), e, void 0, void 0, t) || (e ? console.error(e + ":", t) : console.error(t));
}
h(Ci, "$e$2");
y(Ci, "logException");
const ks = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ y((n) => n.length ? n[0] : !0, "combine") });
let DZ = 0;
const Ac = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.filter((t, e) => {
      for (let i = 0; i < e; i++)
        if (n[i].plugin == t.plugin)
          return !1;
      return !0;
    });
  }
});
var Rr;
const a7 = (Rr = class {
  constructor(t, e, i, s, r) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = s, this.baseExtensions = r(this), this.extension = this.baseExtensions.concat(Ac.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(t) {
    return this.baseExtensions.concat(Ac.of({ plugin: this, arg: t }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: s, provide: r, decorations: a } = e || {};
    return new Rr(DZ++, t, i, s, (o) => {
      let l = [];
      return a && l.push(uw.of((c) => {
        let d = c.plugin(o);
        return d ? a(d) : Jt.none;
      })), r && l.push(r(o)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return Rr.define((i, s) => new t(i, s), e);
  }
}, h(Rr, "Mr"), Rr);
y(a7, "ViewPlugin");
let Ds = a7;
var mh;
const o7 = (mh = class {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (Ci(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(t, this.spec.arg);
      } catch (e) {
        Ci(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Ci(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, h(mh, "rf"), mh);
y(o7, "PluginInstance");
let fb = o7;
const l7 = /* @__PURE__ */ gt.define(), v5 = /* @__PURE__ */ gt.define(), uw = /* @__PURE__ */ gt.define(), c7 = /* @__PURE__ */ gt.define(), b5 = /* @__PURE__ */ gt.define(), h7 = /* @__PURE__ */ gt.define();
function Z$(n, t) {
  let e = n.state.facet(h7);
  if (!e.length)
    return e;
  let i = e.map((r) => r instanceof Function ? r(n) : r), s = [];
  return li.spans(i, t.from, t.to, {
    point() {
    },
    span(r, a, o, l) {
      let c = r - t.from, d = a - t.from, p = s;
      for (let f = o.length - 1; f >= 0; f--, l--) {
        let m = o[f].spec.bidiIsolate, w;
        if (m == null && (m = HQ(t.text, c, d)), l > 0 && p.length && (w = p[p.length - 1]).to == c && w.direction == m)
          w.to = d, p = w.inner;
        else {
          let b = { from: c, to: d, direction: m, inner: [] };
          p.push(b), p = b.inner;
        }
      }
    }
  }), s;
}
h(Z$, "Dc$1");
y(Z$, "getIsolatedRanges");
const d7 = /* @__PURE__ */ gt.define();
function c0(n) {
  let t = 0, e = 0, i = 0, s = 0;
  for (let r of n.state.facet(d7)) {
    let a = r(n);
    a && (a.left != null && (t = Math.max(t, a.left)), a.right != null && (e = Math.max(e, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (s = Math.max(s, a.bottom)));
  }
  return { left: t, right: e, top: i, bottom: s };
}
h(c0, "oh");
y(c0, "getScrollMargins");
const cm = /* @__PURE__ */ gt.define();
var zs;
const u7 = (zs = class {
  constructor(t, e, i, s) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = s;
  }
  join(t) {
    return new zs(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let s = t[e - 1];
      if (!(s.fromA > i.toA)) {
        if (s.toA < i.fromA)
          break;
        i = i.join(s), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let s = 0, r = 0, a = 0, o = 0; ; s++) {
      let l = s == t.length ? null : t[s], c = a - o, d = l ? l.fromB : 1e9;
      for (; r < e.length && e[r] < d; ) {
        let p = e[r], f = e[r + 1], m = Math.max(o, p), w = Math.min(d, f);
        if (m <= w && new zs(m + c, w + c, m, w).addToSet(i), f > d)
          break;
        r += 2;
      }
      if (!l)
        return i;
      new zs(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), a = l.toA, o = l.toB;
    }
  }
}, h(zs, "Si"), zs);
y(u7, "ChangedRange");
let $r = u7;
var co;
const p7 = (co = class {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = xn.empty(this.startState.doc.length);
    for (let r of i)
      this.changes = this.changes.compose(r.changes);
    let s = [];
    this.changes.iterChangedRanges((r, a, o, l) => s.push(new $r(r, a, o, l))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new co(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}, h(co, "Fs"), co);
y(p7, "ViewUpdate");
let FC = p7;
var wh;
const f7 = (wh = class extends ne {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Jt.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new ui()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new $r(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: d }) => d < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? s = this.domChanged.newSel.head : !b7(t.changes, this.hasComposition) && !t.selectionSet && (s = t.state.selection.main.head));
    let r = s > -1 ? m7(this.view, t.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: d } = this.hasComposition;
      i = new $r(c, d, t.changes.mapPos(c, -1), t.changes.mapPos(d, 1)).addToSet(i.slice());
    }
    this.hasComposition = r ? { from: r.range.fromB, to: r.range.toB } : null, (rt.ie || rt.chrome) && !r && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.updateDeco(), l = g7(a, o, t.changes);
    return i = $r.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, t.startState.doc.length, r), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = rt.chrome || rt.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || s.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let r = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof Km && a.widget instanceof _$ && r.push(a.dom);
    s.updateGaps(r);
  }
  updateChildren(t, e, i) {
    let s = i ? i.range.addToSet(t.slice()) : t, r = this.childCursor(e);
    for (let a = s.length - 1; ; a--) {
      let o = a >= 0 ? s[a] : null;
      if (!o)
        break;
      let { fromA: l, toA: c, fromB: d, toB: p } = o, f, m, w, b;
      if (i && i.range.fromB < p && i.range.toB > d) {
        let R = ub.build(this.view.state.doc, d, i.range.fromB, this.decorations, this.dynamicDecorationMap), T = ub.build(this.view.state.doc, i.range.toB, p, this.decorations, this.dynamicDecorationMap);
        m = R.breakAtStart, w = R.openStart, b = T.openEnd;
        let I = this.compositionView(i);
        T.breakAtStart ? I.breakAfter = 1 : T.content.length && I.merge(I.length, I.length, T.content[0], !1, T.openStart, 0) && (I.breakAfter = T.content[0].breakAfter, T.content.shift()), R.content.length && I.merge(0, 0, R.content[R.content.length - 1], !0, 0, R.openEnd) && R.content.pop(), f = R.content.concat(I).concat(T.content);
      } else
        ({ content: f, breakAtStart: m, openStart: w, openEnd: b } = ub.build(this.view.state.doc, d, p, this.decorations, this.dynamicDecorationMap));
      let { i: x, off: O } = r.findPos(c, 1), { i: P, off: A } = r.findPos(l, -1);
      s5(this, P, A, x, O, f, m, w, b);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(r7) && (this.editContextFormatting = i.value);
  }
  compositionView(t) {
    let e = new Gr(t.text.nodeValue);
    e.flags |= 8;
    for (let { deco: s } of t.marks)
      e = new qf(s, [e], e.length);
    let i = new ui();
    return i.append(e, 0), i;
  }
  fixCompositionDOM(t) {
    let e = /* @__PURE__ */ y((r, a) => {
      a.flags |= 8 | (a.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let o = ne.get(r);
      o && o != a && (o.dom = null), a.setDOM(r);
    }, "fix"), i = this.childPos(t.range.fromB, 1), s = this.children[i.i];
    e(t.line, s);
    for (let r = t.marks.length - 1; r >= -1; r--)
      i = s.childPos(i.off, 1), s = s.children[i.i], e(r >= 0 ? t.marks[r].node : t.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, s = i == this.dom, r = !s && !(this.view.state.facet(ks) || this.dom.tabIndex > -1) && Ym(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(s || e || r))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let o = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(o.anchor)), c = o.empty ? l : this.moveToLine(this.domAtPos(o.head));
    if (rt.gecko && o.empty && !this.hasComposition && y7(l)) {
      let p = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(p, l.node.childNodes[l.offset] || null)), l = c = new ji(p, 0), a = !0;
    }
    let d = this.view.observer.selectionRange;
    (a || !d.focusNode || (!Lc(l.node, l.offset, d.anchorNode, d.anchorOffset) || !Lc(c.node, c.offset, d.focusNode, d.focusOffset)) && !this.suppressWidgetCursorChange(d, o)) && (this.view.observer.ignore(() => {
      rt.android && rt.chrome && this.dom.contains(d.focusNode) && v7(d.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let p = Df(this.view.root);
      if (p) if (o.empty) {
        if (rt.gecko) {
          let f = w7(l.node, l.offset);
          if (f && f != 3) {
            let m = (f == 1 ? e5 : i5)(l.node, l.offset);
            m && (l = new ji(m.node, m.offset));
          }
        }
        p.collapse(l.node, l.offset), o.bidiLevel != null && p.caretBidiLevel !== void 0 && (p.caretBidiLevel = o.bidiLevel);
      } else if (p.extend) {
        p.collapse(l.node, l.offset);
        try {
          p.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        o.anchor > o.head && ([l, c] = [c, l]), f.setEnd(c.node, c.offset), f.setStart(l.node, l.offset), p.removeAllRanges(), p.addRange(f);
      }
      r && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new ji(d.anchorNode, d.anchorOffset), this.impreciseHead = c.precise ? null : new ji(d.focusNode, d.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && Lc(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = Df(t.root), { anchorNode: s, anchorOffset: r } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let a = ui.find(this, e.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (e.head == o || e.head == o + a.length)
      return;
    let l = this.coordsAt(e.head, -1), c = this.coordsAt(e.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let d = this.domAtPos(e.head + e.assoc);
    i.collapse(d.node, d.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let p = t.observer.selectionRange;
    t.docView.posFromDOM(p.anchorNode, p.anchorOffset) != e.from && i.collapse(s, r);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let e = this.dom, i;
    if (t.node != e)
      return t;
    for (let s = t.offset; !i && s < e.childNodes.length; s++) {
      let r = ne.get(e.childNodes[s]);
      r instanceof ui && (i = r.domAtPos(0));
    }
    for (let s = t.offset - 1; !i && s >= 0; s--) {
      let r = ne.get(e.childNodes[s]);
      r instanceof ui && (i = r.domAtPos(r.length));
    }
    return i ? new ji(i.node, i.offset, !0) : t;
  }
  nearest(t) {
    for (let e = t; e; ) {
      let i = ne.get(e);
      if (i && i.rootView == this)
        return i;
      e = e.parentNode;
    }
    return null;
  }
  posFromDOM(t, e) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, e) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: e, off: i } = this.childCursor().findPos(t, -1);
    for (; e < this.children.length - 1; ) {
      let s = this.children[e];
      if (i < s.length || s instanceof ui)
        break;
      e++, i = 0;
    }
    return this.children[e].domAtPos(i);
  }
  coordsAt(t, e) {
    let i = null, s = 0;
    for (let r = this.length, a = this.children.length - 1; a >= 0; a--) {
      let o = this.children[a], l = r - o.breakAfter, c = l - o.length;
      if (l < t)
        break;
      if (c <= t && (c < t || o.covers(-1)) && (l > t || o.covers(1)) && (!i || o instanceof ui && !(i instanceof ui && e >= 0)))
        i = o, s = c;
      else if (i && c == t && l == t && o instanceof Km && Math.abs(e) < 2) {
        if (o.deco.startSide < 0)
          break;
        a && (i = null);
      }
      r = c;
    }
    return i ? i.coordsAt(t - s, e) : null;
  }
  coordsForChar(t) {
    let { i: e, off: i } = this.childPos(t, 1), s = this.children[e];
    if (!(s instanceof ui))
      return null;
    for (; s.children.length; ) {
      let { i: o, off: l } = s.childPos(i, 1);
      for (; ; o++) {
        if (o == s.children.length)
          return null;
        if ((s = s.children[o]).length)
          break;
      }
      i = l;
    }
    if (!(s instanceof Gr))
      return null;
    let r = gn(s.text, i);
    if (r == i)
      return null;
    let a = Yr(s.dom, i, r).getClientRects();
    for (let o = 0; o < a.length; o++) {
      let l = a[o];
      if (o == a.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: s } = t, r = this.view.contentDOM.clientWidth, a = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, l = this.view.textDirection == Pe.LTR;
    for (let c = 0, d = 0; d < this.children.length; d++) {
      let p = this.children[d], f = c + p.length;
      if (f > s)
        break;
      if (c >= i) {
        let m = p.dom.getBoundingClientRect();
        if (e.push(m.height), a) {
          let w = p.dom.lastChild, b = w ? Io(w) : [];
          if (b.length) {
            let x = b[b.length - 1], O = l ? x.right - m.left : m.right - x.left;
            O > o && (o = O, this.minWidth = r, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + p.breakAfter;
    }
    return e;
  }
  textDirectionAt(t) {
    let { i: e } = this.childPos(t, 1);
    return getComputedStyle(this.children[e].dom).direction == "rtl" ? Pe.RTL : Pe.LTR;
  }
  measureTextSize() {
    for (let r of this.children)
      if (r instanceof ui) {
        let a = r.measureTextSize();
        if (a)
          return a;
      }
    let t = document.createElement("div"), e, i, s;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let r = Io(t.firstChild)[0];
      e = t.getBoundingClientRect().height, i = r ? r.width / 27 : 7, s = r ? r.height : e, t.remove();
    }), { lineHeight: e, charWidth: i, textHeight: s };
  }
  childCursor(t = this.length) {
    let e = this.children.length;
    return e && (t -= this.children[--e].length), new vQ(this.children, t, e);
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, s = 0; ; s++) {
      let r = s == e.viewports.length ? null : e.viewports[s], a = r ? r.from - 1 : this.length;
      if (a > i) {
        let o = (e.lineBlockAt(a).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(Jt.replace({
          widget: new _$(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!r)
        break;
      i = r.to + 1;
    }
    return Jt.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(uw).map((r) => (this.dynamicDecorationMap[t++] = typeof r == "function") ? r(this.view) : r), i = !1, s = this.view.state.facet(c7).map((r, a) => {
      let o = typeof r == "function";
      return o && (i = !0), o ? r(this.view) : r;
    });
    for (s.length && (this.dynamicDecorationMap[t++] = i, e.push(li.join(s))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = c.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let c of this.view.state.facet(n7))
      try {
        if (c(this.view, t.range, t))
          return !0;
      } catch (d) {
        Ci(this.view.state, d, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), s;
    if (!i)
      return;
    !e.empty && (s = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, s.left),
      top: Math.min(i.top, s.top),
      right: Math.max(i.right, s.right),
      bottom: Math.max(i.bottom, s.bottom)
    });
    let r = c0(this.view), a = {
      left: i.left - r.left,
      top: i.top - r.top,
      right: i.right + r.right,
      bottom: i.bottom + r.bottom
    }, { offsetWidth: o, offsetHeight: l } = this.view.scrollDOM;
    dQ(this.view.scrollDOM, a, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, o), -o), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == Pe.LTR);
  }
}, h(wh, "nf"), wh);
y(f7, "DocView");
let UC = f7;
function y7(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
h(y7, "l0$1");
y(y7, "betweenUneditable");
function O5(n, t) {
  let e = n.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = e5(e.focusNode, e.focusOffset), s = i5(e.focusNode, e.focusOffset), r = i || s;
  if (s && i && s.node != i.node) {
    let o = ne.get(s.node);
    if (!o || o instanceof Gr && o.text != s.node.nodeValue)
      r = s;
    else if (n.docView.lastCompositionAfterCursor) {
      let l = ne.get(i.node);
      !l || l instanceof Gr && l.text != i.node.nodeValue || (r = s);
    }
  }
  if (n.docView.lastCompositionAfterCursor = r != i, !r)
    return null;
  let a = t - r.offset;
  return { from: a, to: a + r.node.nodeValue.length, node: r.node };
}
h(O5, "TO");
y(O5, "findCompositionNode");
function m7(n, t, e) {
  let i = O5(n, e);
  if (!i)
    return null;
  let { node: s, from: r, to: a } = i, o = s.nodeValue;
  if (/[\n\r]/.test(o) || n.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let l = t.invertedDesc, c = new $r(l.mapPos(r), l.mapPos(a), r, a), d = [];
  for (let p = s.parentNode; ; p = p.parentNode) {
    let f = ne.get(p);
    if (f instanceof qf)
      d.push({ node: p, deco: f.mark });
    else {
      if (f instanceof ui || p.nodeName == "DIV" && p.parentNode == n.contentDOM)
        return { range: c, text: s, marks: d, line: p };
      if (p != n.contentDOM)
        d.push({ node: p, deco: new c5({
          inclusive: !0,
          attributes: TQ(p),
          tagName: p.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
h(m7, "a0$1");
y(m7, "findCompositionRange");
function w7(n, t) {
  return n.nodeType != 1 ? 0 : (t && n.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < n.childNodes.length && n.childNodes[t].contentEditable == "false" ? 2 : 0);
}
h(w7, "h0$1");
y(w7, "nextToUneditable");
var yb, gh;
let qZ = (yb = (gh = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    Gm(t, e, this.changes);
  }
  comparePoint(t, e) {
    Gm(t, e, this.changes);
  }
  boundChange(t) {
    Gm(t, t, this.changes);
  }
}, h(gh, "Ai$1"), gh), y(yb, "DecorationComparator"), yb);
function g7(n, t, e) {
  let i = new qZ();
  return li.compare(n, t, e, i), i.changes;
}
h(g7, "c0$1");
y(g7, "findChangedDeco");
function v7(n, t) {
  for (let e = n; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
h(v7, "u0$1");
y(v7, "inUneditable");
function b7(n, t) {
  let e = !1;
  return t && n.iterChangedRanges((i, s) => {
    i < t.to && s > t.from && (e = !0);
  }), e;
}
h(b7, "d0$1");
y(b7, "touchesComposition");
function O7(n, t, e = 1) {
  let i = n.charCategorizer(t), s = n.doc.lineAt(t), r = t - s.from;
  if (s.length == 0)
    return it.cursor(t);
  r == 0 ? e = 1 : r == s.length && (e = -1);
  let a = r, o = r;
  e < 0 ? a = gn(s.text, r, !1) : o = gn(s.text, r);
  let l = i(s.text.slice(a, o));
  for (; a > 0; ) {
    let c = gn(s.text, a, !1);
    if (i(s.text.slice(c, a)) != l)
      break;
    a = c;
  }
  for (; o < s.length; ) {
    let c = gn(s.text, o);
    if (i(s.text.slice(o, c)) != l)
      break;
    o = c;
  }
  return it.range(a + s.from, o + s.from);
}
h(O7, "O0$1");
y(O7, "groupAt");
function $7(n, t) {
  return t.left > n ? t.left - n : Math.max(0, n - t.right);
}
h($7, "p0$1");
y($7, "getdx");
function x7(n, t) {
  return t.top > n ? t.top - n : Math.max(0, n - t.bottom);
}
h(x7, "m0$1");
y(x7, "getdy");
function Jg(n, t) {
  return n.top < t.bottom - 1 && n.bottom > t.top + 1;
}
h(Jg, "vo$1");
y(Jg, "yOverlap");
function W$(n, t) {
  return t < n.top ? { top: t, left: n.left, right: n.right, bottom: n.bottom } : n;
}
h(W$, "Bc$1");
y(W$, "upTop");
function D$(n, t) {
  return t > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: t } : n;
}
h(D$, "zc$1");
y(D$, "upBot");
function ev(n, t, e) {
  let i, s, r, a, o = !1, l, c, d, p;
  for (let w = n.firstChild; w; w = w.nextSibling) {
    let b = Io(w);
    for (let x = 0; x < b.length; x++) {
      let O = b[x];
      s && Jg(s, O) && (O = W$(D$(O, s.bottom), s.top));
      let P = $7(t, O), A = x7(e, O);
      if (P == 0 && A == 0)
        return w.nodeType == 3 ? q$(w, t, e) : ev(w, t, e);
      (!i || a > A || a == A && r > P) && (i = w, s = O, r = P, a = A, o = P ? t < O.left ? x > 0 : x < b.length - 1 : !0), P == 0 ? e > O.bottom && (!d || d.bottom < O.bottom) ? (l = w, d = O) : e < O.top && (!p || p.top > O.top) && (c = w, p = O) : d && Jg(d, O) ? d = D$(d, O.bottom) : p && Jg(p, O) && (p = W$(p, O.top));
    }
  }
  if (d && d.bottom >= e ? (i = l, s = d) : p && p.top <= e && (i = c, s = p), !i)
    return { node: n, offset: 0 };
  let f = Math.max(s.left, Math.min(s.right, t));
  if (i.nodeType == 3)
    return q$(i, f, e);
  if (o && i.contentEditable != "false")
    return ev(i, f, e);
  let m = Array.prototype.indexOf.call(n.childNodes, i) + (t >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: n, offset: m };
}
h(ev, "vl$1");
y(ev, "domPosAtCoords");
function q$(n, t, e) {
  let i = n.nodeValue.length, s = -1, r = 1e9, a = 0;
  for (let o = 0; o < i; o++) {
    let l = Yr(n, o, o + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let d = l[c];
      if (d.top == d.bottom)
        continue;
      a || (a = t - d.left);
      let p = (d.top > e ? d.top - e : e - d.bottom) - 1;
      if (d.left - 1 <= t && d.right + 1 >= t && p < r) {
        let f = t >= (d.left + d.right) / 2, m = f;
        if ((rt.chrome || rt.gecko) && Yr(n, o).getBoundingClientRect().left == d.right && (m = !f), p <= 0)
          return { node: n, offset: o + (m ? 1 : 0) };
        s = o + (m ? 1 : 0), r = p;
      }
    }
  }
  return { node: n, offset: s > -1 ? s : a > 0 ? n.nodeValue.length : 0 };
}
h(q$, "Nc$1");
y(q$, "domPosInText");
function $5(n, t, e, i = -1) {
  var s, r;
  let a = n.contentDOM.getBoundingClientRect(), o = a.top + n.viewState.paddingTop, l, { docHeight: c } = n.viewState, { x: d, y: p } = t, f = p - o;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let R = n.viewState.heightOracle.textHeight / 2, T = !1; l = n.elementAtHeight(f), l.type != ns.Text; )
    for (; f = i > 0 ? l.bottom + R : l.top - R, !(f >= 0 && f <= c); ) {
      if (T)
        return e ? null : 0;
      T = !0, i = -i;
    }
  p = o + f;
  let m = l.from;
  if (m < n.viewport.from)
    return n.viewport.from == 0 ? 0 : e ? null : V$(n, a, l, d, p);
  if (m > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : e ? null : V$(n, a, l, d, p);
  let w = n.dom.ownerDocument, b = n.root.elementFromPoint ? n.root : w, x = b.elementFromPoint(d, p);
  x && !n.contentDOM.contains(x) && (x = null), x || (d = Math.max(a.left + 1, Math.min(a.right - 1, d)), x = b.elementFromPoint(d, p), x && !n.contentDOM.contains(x) && (x = null));
  let O, P = -1;
  if (x && ((s = n.docView.nearest(x)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (w.caretPositionFromPoint) {
      let R = w.caretPositionFromPoint(d, p);
      R && ({ offsetNode: O, offset: P } = R);
    } else if (w.caretRangeFromPoint) {
      let R = w.caretRangeFromPoint(d, p);
      R && ({ startContainer: O, startOffset: P } = R, (!n.contentDOM.contains(O) || rt.safari && k7(O, P, d) || rt.chrome && S7(O, P, d)) && (O = void 0));
    }
    O && (P = Math.min(kn(O), P));
  }
  if (!O || !n.docView.dom.contains(O)) {
    let R = ui.find(n.docView, m);
    if (!R)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: P } = ev(R.dom, d, p));
  }
  let A = n.docView.nearest(O);
  if (!A)
    return null;
  if (A.isWidget && ((r = A.dom) === null || r === void 0 ? void 0 : r.nodeType) == 1) {
    let R = A.dom.getBoundingClientRect();
    return t.y < R.top || t.y <= R.bottom && t.x <= (R.left + R.right) / 2 ? A.posAtStart : A.posAtEnd;
  } else
    return A.localPosFromDOM(O, P) + A.posAtStart;
}
h($5, "AO");
y($5, "posAtCoords");
function V$(n, t, e, i, s) {
  let r = Math.round((i - t.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && e.height > n.defaultLineHeight * 1.5) {
    let o = n.viewState.heightOracle.textHeight, l = Math.floor((s - e.top - (n.defaultLineHeight - o) * 0.5) / o);
    r += l * n.viewState.heightOracle.lineLength;
  }
  let a = n.state.sliceDoc(e.from, e.to);
  return e.from + aQ(a, r, n.state.tabSize);
}
h(V$, "Gc$1");
y(V$, "posAtCoordsImprecise");
function k7(n, t, e) {
  let i, s = n;
  if (n.nodeType != 3 || t != (i = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let r = s.nextSibling;
    if (r) {
      if (r.nodeName == "BR")
        break;
      return !1;
    } else {
      let a = s.parentNode;
      if (!a || a.nodeName == "DIV")
        break;
      s = a;
    }
  }
  return Yr(n, i - 1, i).getBoundingClientRect().right > e;
}
h(k7, "g0$1");
y(k7, "isSuspiciousSafariCaretResult");
function S7(n, t, e) {
  if (t != 0)
    return !1;
  for (let s = n; ; ) {
    let r = s.parentNode;
    if (!r || r.nodeType != 1 || r.firstChild != s)
      return !1;
    if (r.classList.contains("cm-line"))
      break;
    s = r;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : Yr(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return e - i.left > 5;
}
h(S7, "y0$1");
y(S7, "isSuspiciousChromeCaretResult");
function P7(n, t, e) {
  let i = n.lineBlockAt(t);
  if (Array.isArray(i.type)) {
    let s;
    for (let r of i.type) {
      if (r.from > t)
        break;
      if (!(r.to < t)) {
        if (r.from < t && r.to > t)
          return r;
        (!s || r.type == ns.Text && (s.type != r.type || (e < 0 ? r.from < t : r.to > t))) && (s = r);
      }
    }
    return s || i;
  }
  return i;
}
h(P7, "b0$1");
y(P7, "blockAt");
function C7(n, t, e, i) {
  let s = P7(n, t.head, t.assoc || -1), r = !i || s.type != ns.Text || !(n.lineWrapping || s.widgetLineBreaks) ? null : n.coordsAtPos(t.assoc < 0 && t.head > s.from ? t.head - 1 : t.head);
  if (r) {
    let a = n.dom.getBoundingClientRect(), o = n.textDirectionAt(s.from), l = n.posAtCoords({
      x: e == (o == Pe.LTR) ? a.right - 1 : a.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (l != null)
      return it.cursor(l, e ? -1 : 1);
  }
  return it.cursor(e ? s.to : s.from, e ? -1 : 1);
}
h(C7, "S0$1");
y(C7, "moveToLineBoundary");
function j$(n, t, e, i) {
  let s = n.state.doc.lineAt(t.head), r = n.bidiSpans(s), a = n.textDirectionAt(s.from);
  for (let o = t, l = null; ; ) {
    let c = NQ(s, r, a, o, e), d = XQ;
    if (!c) {
      if (s.number == (e ? n.state.doc.lines : 1))
        return o;
      d = `
`, s = n.state.doc.line(s.number + (e ? 1 : -1)), r = n.bidiSpans(s), c = n.visualLineSide(s, !e);
    }
    if (l) {
      if (!l(d))
        return o;
    } else {
      if (!i)
        return c;
      l = i(d);
    }
    o = c;
  }
}
h(j$, "Hc$1");
y(j$, "moveByChar");
function Q7(n, t, e) {
  let i = n.state.charCategorizer(t), s = i(e);
  return (r) => {
    let a = i(r);
    return s == Cs.Space && (s = a), s == a;
  };
}
h(Q7, "Q0$1");
y(Q7, "byGroup");
function M7(n, t, e, i) {
  let s = t.head, r = e ? 1 : -1;
  if (s == (e ? n.state.doc.length : 0))
    return it.cursor(s, t.assoc);
  let a = t.goalColumn, o, l = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(s, t.assoc || -1), d = n.documentTop;
  if (c)
    a == null && (a = c.left - l.left), o = r < 0 ? c.top : c.bottom;
  else {
    let m = n.viewState.lineBlockAt(s);
    a == null && (a = Math.min(l.right - l.left, n.defaultCharacterWidth * (s - m.from))), o = (r < 0 ? m.top : m.bottom) + d;
  }
  let p = l.left + a, f = i ?? n.viewState.heightOracle.textHeight >> 1;
  for (let m = 0; ; m += 10) {
    let w = o + (f + m) * r, b = $5(n, { x: p, y: w }, !1, r);
    if (w < l.top || w > l.bottom || (r < 0 ? b < s : b > s)) {
      let x = n.docView.coordsForChar(b), O = !x || w < x.top ? -1 : 1;
      return it.cursor(b, O, void 0, a);
    }
  }
}
h(M7, "w0$1");
y(M7, "moveVertically");
function Jm(n, t, e) {
  for (; ; ) {
    let i = 0;
    for (let s of n)
      s.between(t - 1, t + 1, (r, a, o) => {
        if (t > r && t < a) {
          let l = i || e || (t - r < a - t ? -1 : 1);
          t = l < 0 ? r : a, i = l;
        }
      });
    if (!i)
      return t;
  }
}
h(Jm, "Bn$1");
y(Jm, "skipAtomicRanges");
function t1(n, t, e) {
  let i = Jm(n.state.facet(b5).map((s) => s(n)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : it.cursor(i, i < e.from ? 1 : -1);
}
h(t1, "To$1");
y(t1, "skipAtoms");
const hm = "￿";
var vh;
const T7 = (vh = class {
  constructor(t, e) {
    this.points = t, this.text = "", this.lineSeparator = e.facet(ze.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += hm;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let s = t; ; ) {
      this.findPointBefore(i, s);
      let r = this.text.length;
      this.readNode(s);
      let a = s.nextSibling;
      if (a == e)
        break;
      let o = ne.get(s), l = ne.get(a);
      (o && l ? o.breakAfter : (o ? o.breakAfter : hw(s)) || hw(a) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > r) && this.lineBreak(), s = a;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, a = 1, o;
      if (this.lineSeparator ? (r = e.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = s.exec(e)) && (r = o.index, a = o[0].length), this.append(e.slice(i, r < 0 ? e.length : r)), r < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= a - 1);
      i = r + a;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let e = ne.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let s = i.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (A7(t, i.node, i.offset) ? e : 0));
  }
}, h(vh, "sf"), vh);
y(T7, "DOMReader");
let VZ = T7;
function A7(n, t, e) {
  for (; ; ) {
    if (!t || e < kn(t))
      return !1;
    if (t == n)
      return !0;
    e = Hr(t) + 1, t = t.parentNode;
  }
}
h(A7, "x0$1");
y(A7, "isAtEnd");
var bh;
const R7 = (bh = class {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}, h(bh, "of"), bh);
y(R7, "DOMPoint");
let BC = R7;
var Oh;
const E7 = (Oh = class {
  constructor(t, e, i, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: r, impreciseAnchor: a } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = t.docView.domBoundsAround(e, i, 0))) {
      let o = r || a ? [] : L7(t), l = new VZ(o, t.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = I7(o, this.bounds.from);
    } else {
      let o = t.observer.selectionRange, l = r && r.node == o.focusNode && r.offset == o.focusOffset || !Y1(t.contentDOM, o.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(o.focusNode, o.focusOffset), c = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !Y1(t.contentDOM, o.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(o.anchorNode, o.anchorOffset), d = t.viewport;
      if ((rt.ios || rt.chrome) && t.state.selection.main.empty && l != c && (d.from > 0 || d.to < t.state.doc.length)) {
        let p = Math.min(l, c), f = Math.max(l, c), m = d.from - p, w = d.to - f;
        (m == 0 || m == 1 || p == 0) && (w == 0 || w == -1 || f == t.state.doc.length) && (l = 0, c = t.state.doc.length);
      }
      this.newSel = it.single(c, l);
    }
  }
}, h(Oh, "lf"), Oh);
y(E7, "DOMChange");
let jZ = E7;
function x5(n, t) {
  let e, { newSel: i } = t, s = n.state.selection.main, r = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: a, to: o } = t.bounds, l = s.from, c = null;
    (r === 8 || rt.android && t.text.length < o - a) && (l = s.to, c = "end");
    let d = _7(n.state.doc.sliceString(a, o, hm), t.text, l - a, c);
    d && (rt.chrome && r == 13 && d.toB == d.from + 2 && t.text.slice(d.from, d.toB) == hm + hm && d.toB--, e = {
      from: a + d.from,
      to: a + d.toA,
      insert: Zt.of(t.text.slice(d.from, d.toB).split(hm))
    });
  } else i && (!n.hasFocus && n.state.facet(ks) || i.main.eq(s)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !s.empty && i && i.main.empty ? e = { from: s.from, to: s.to, insert: n.state.doc.slice(s.from, s.to) } : (rt.mac || rt.android) && e && e.from == e.to && e.from == s.head - 1 && /^\. ?$/.test(e.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = it.single(i.main.anchor - 1, i.main.head - 1)), e = { from: e.from, to: e.to, insert: Zt.of([e.insert.toString().replace(".", " ")]) }) : e && e.from >= s.from && e.to <= s.to && (e.from != s.from || e.to != s.to) && s.to - s.from - (e.to - e.from) <= 4 ? e = {
    from: s.from,
    to: s.to,
    insert: n.state.doc.slice(s.from, e.from).append(e.insert).append(n.state.doc.slice(e.to, s.to))
  } : rt.chrome && e && e.from == e.to && e.from == s.head && e.insert.toString() == `
 ` && n.lineWrapping && (i && (i = it.single(i.main.anchor - 1, i.main.head - 1)), e = { from: s.from, to: s.to, insert: Zt.of([" "]) }), e)
    return h0(n, e, i, r);
  if (i && !i.main.eq(s)) {
    let a = !1, o = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (a = !0), o = n.inputState.lastSelectionOrigin), n.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
h(x5, "ZO");
y(x5, "applyDOMChange");
function h0(n, t, e, i = -1) {
  if (rt.ios && n.inputState.flushIOSKey(t))
    return !0;
  let s = n.state.selection.main;
  if (rt.android && (t.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == s.from || t.from == s.from - 1 && n.state.sliceDoc(t.from, s.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && Ba(n.contentDOM, "Enter", 13) || (t.from == s.from - 1 && t.to == s.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > s.head) && Ba(n.contentDOM, "Backspace", 8) || t.from == s.from && t.to == s.to + 1 && t.insert.length == 0 && Ba(n.contentDOM, "Delete", 46)))
    return !0;
  let r = t.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let a, o = /* @__PURE__ */ y(() => a || (a = z7(n, t, e)), "defaultInsert");
  return n.state.facet(t7).some((l) => l(n, t.from, t.to, r, o)) || n.dispatch(o()), !0;
}
h(h0, "lh");
y(h0, "applyDOMChangeInner");
function z7(n, t, e) {
  let i, s = n.state, r = s.selection.main;
  if (t.from >= r.from && t.to <= r.to && t.to - t.from >= (r.to - r.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && n.inputState.composing < 0) {
    let o = r.from < t.from ? s.sliceDoc(r.from, t.from) : "", l = r.to > t.to ? s.sliceDoc(t.to, r.to) : "";
    i = s.replaceSelection(n.state.toText(o + t.insert.sliceString(0, void 0, n.state.lineBreak) + l));
  } else {
    let o = s.changes(t), l = e && e.main.to <= o.newLength ? e.main : void 0;
    if (s.selection.ranges.length > 1 && n.inputState.composing >= 0 && t.to <= r.to && t.to >= r.to - 10) {
      let c = n.state.sliceDoc(t.from, t.to), d, p = e && O5(n, e.main.head);
      if (p) {
        let w = t.insert.length - (t.to - t.from);
        d = { from: p.from, to: p.to - w };
      } else
        d = n.state.doc.lineAt(r.head);
      let f = r.to - t.to, m = r.to - r.from;
      i = s.changeByRange((w) => {
        if (w.from == r.from && w.to == r.to)
          return { changes: o, range: l || w.map(o) };
        let b = w.to - f, x = b - c.length;
        if (w.to - w.from != m || n.state.sliceDoc(x, b) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        w.to >= d.from && w.from <= d.to)
          return { range: w };
        let O = s.changes({ from: x, to: b, insert: t.insert }), P = w.to - r.to;
        return {
          changes: O,
          range: l ? it.range(Math.max(0, l.anchor + P), Math.max(0, l.head + P)) : w.map(O)
        };
      });
    } else
      i = {
        changes: o,
        selection: l && s.selection.replaceRange(l)
      };
  }
  let a = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, a += ".compose", n.inputState.compositionFirstChange && (a += ".start", n.inputState.compositionFirstChange = !1)), s.update(i, { userEvent: a, scrollIntoView: !0 });
}
h(z7, "P0$1");
y(z7, "applyDefaultInsert");
function _7(n, t, e, i) {
  let s = Math.min(n.length, t.length), r = 0;
  for (; r < s && n.charCodeAt(r) == t.charCodeAt(r); )
    r++;
  if (r == s && n.length == t.length)
    return null;
  let a = n.length, o = t.length;
  for (; a > 0 && o > 0 && n.charCodeAt(a - 1) == t.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let l = Math.max(0, r - Math.min(a, o));
    e -= a + l - r;
  }
  if (a < r && n.length < t.length) {
    let l = e <= r && e >= a ? r - e : 0;
    r -= l, o = r + (o - a), a = r;
  } else if (o < r) {
    let l = e <= r && e >= o ? r - e : 0;
    r -= l, a = r + (a - o), o = r;
  }
  return { from: r, toA: a, toB: o };
}
h(_7, "k0$1");
y(_7, "findDiff");
function L7(n) {
  let t = [];
  if (n.root.activeElement != n.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: r } = n.observer.selectionRange;
  return e && (t.push(new BC(e, i)), (s != e || r != i) && t.push(new BC(s, r))), t;
}
h(L7, "R0$1");
y(L7, "selectionPoints");
function I7(n, t) {
  if (n.length == 0)
    return null;
  let e = n[0].pos, i = n.length == 2 ? n[1].pos : e;
  return e > -1 && i > -1 ? it.single(e + t, i + t) : null;
}
h(I7, "$0$1");
y(I7, "selectionFromPoints");
var $h;
const Z7 = ($h = class {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, rt.safari && t.contentDOM.addEventListener("input", () => null), rt.gecko && i8(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !X7(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(t.type, t)) : this.runHandlers(t.type, t));
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let s of i.observers)
        s(this.view, e);
      for (let s of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (s(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = W7(t), i = this.handlers, s = this.view.contentDOM;
    for (let r in e)
      if (r != "scroll") {
        let a = !e[r].handlers.length, o = i[r];
        o && a != !o.handlers.length && (s.removeEventListener(r, this.handleEvent), o = null), o || s.addEventListener(r, this.handleEvent, { passive: a });
      }
    for (let r in i)
      r != "scroll" && !e[r] && s.removeEventListener(r, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && q7.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), rt.android && rt.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return rt.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = D7.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || UZ.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Ba(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : rt.safari && !rt.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}, h($h, "af"), $h);
y(Z7, "InputState");
let FZ = Z7;
function F$(n, t) {
  return (e, i) => {
    try {
      return t.call(n, i, e);
    } catch (s) {
      Ci(e.state, s);
    }
  };
}
h(F$, "Fc$1");
y(F$, "bindHandler");
function W7(n) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  h(e, "t"), y(e, "record");
  for (let i of n) {
    let s = i.spec, r = s && s.plugin.domEventHandlers, a = s && s.plugin.domEventObservers;
    if (r)
      for (let o in r) {
        let l = r[o];
        l && e(o).handlers.push(F$(i.value, l));
      }
    if (a)
      for (let o in a) {
        let l = a[o];
        l && e(o).observers.push(F$(i.value, l));
      }
  }
  for (let i in Sn)
    e(i).handlers.push(Sn[i]);
  for (let i in rn)
    e(i).observers.push(rn[i]);
  return t;
}
h(W7, "v0$1");
y(W7, "computeHandlers");
const D7 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], UZ = "dthko", q7 = [16, 17, 18, 20, 91, 92, 224, 225], Qg = 6;
function dm(n) {
  return Math.max(0, n) * 0.7 + 8;
}
h(dm, "Tn$1");
y(dm, "dragScrollSpeed");
function V7(n, t) {
  return Math.max(Math.abs(n.clientX - t.clientX), Math.abs(n.clientY - t.clientY));
}
h(V7, "A0$1");
y(V7, "dist");
var xh;
const j7 = (xh = class {
  constructor(t, e, i, s) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = uQ(t.contentDOM), this.atoms = t.state.facet(b5).map((a) => a(t));
    let r = t.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(ze.allowMultipleSelections) && F7(t, e), this.dragging = B7(t, e) && S5(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && V7(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, s = 0, r = 0, a = this.view.win.innerWidth, o = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: r, bottom: o } = this.scrollParents.y.getBoundingClientRect());
    let l = c0(this.view);
    t.clientX - l.left <= s + Qg ? e = -dm(s - t.clientX) : t.clientX + l.right >= a - Qg && (e = dm(t.clientX - a)), t.clientY - l.top <= r + Qg ? i = -dm(r - t.clientY) : t.clientY + l.bottom >= o - Qg && (i = dm(t.clientY - o)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let e = null;
    for (let i = 0; i < t.ranges.length; i++) {
      let s = t.ranges[i], r = null;
      if (s.empty) {
        let a = Jm(this.atoms, s.from, 0);
        a != s.from && (r = it.cursor(a, -1));
      } else {
        let a = Jm(this.atoms, s.from, -1), o = Jm(this.atoms, s.to, 1);
        (a != s.from || o != s.to) && (r = it.range(s.from == s.anchor ? a : o, s.from == s.head ? a : o));
      }
      r && (e || (e = t.ranges.slice()), e[i] = r);
    }
    return e ? it.create(e, t.mainIndex) : t;
  }
  select(t) {
    let { view: e } = this, i = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, h(xh, "hf"), xh);
y(j7, "MouseSelection");
let BZ = j7;
function F7(n, t) {
  let e = n.state.facet(YQ);
  return e.length ? e[0](t) : rt.mac ? t.metaKey : t.ctrlKey;
}
h(F7, "Z0$1");
y(F7, "addsSelectionRange");
function U7(n, t) {
  let e = n.state.facet(GQ);
  return e.length ? e[0](t) : rt.mac ? !t.altKey : !t.ctrlKey;
}
h(U7, "L0$1");
y(U7, "dragMovesSelection");
function B7(n, t) {
  let { main: e } = n.state.selection;
  if (e.empty)
    return !1;
  let i = Df(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let s = i.getRangeAt(0).getClientRects();
  for (let r = 0; r < s.length; r++) {
    let a = s[r];
    if (a.left <= t.clientX && a.right >= t.clientX && a.top <= t.clientY && a.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
h(B7, "M0$1");
y(B7, "isInPrimarySelection");
function X7(n, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != n.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = ne.get(e)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
h(X7, "_0$1");
y(X7, "eventBelongsToEditor");
const Sn = /* @__PURE__ */ Object.create(null), rn = /* @__PURE__ */ Object.create(null), N7 = rt.ie && rt.ie_version < 15 || rt.ios && rt.webkit_version < 604;
function H7(n) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    n.focus(), e.remove(), k5(n, e.value);
  }, 50);
}
h(H7, "C0$1");
y(H7, "capturePaste");
function Gw(n, t, e) {
  for (let i of n.facet(t))
    e = i(e, n);
  return e;
}
h(Gw, "yo$1");
y(Gw, "textFilter");
function k5(n, t) {
  t = Gw(n.state, w5, t);
  let { state: e } = n, i, s = 1, r = e.toText(t), a = r.lines == e.selection.ranges.length;
  if (N$ != null && e.selection.ranges.every((o) => o.empty) && N$ == r.toString()) {
    let o = -1;
    i = e.changeByRange((l) => {
      let c = e.doc.lineAt(l.from);
      if (c.from == o)
        return { range: l };
      o = c.from;
      let d = e.toText((a ? r.line(s++).text : t) + e.lineBreak);
      return {
        changes: { from: c.from, insert: d },
        range: it.cursor(l.from + d.length)
      };
    });
  } else a ? i = e.changeByRange((o) => {
    let l = r.line(s++);
    return {
      changes: { from: o.from, to: o.to, insert: l.text },
      range: it.cursor(o.from + l.length)
    };
  }) : i = e.replaceSelection(r);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
h(k5, "CO");
y(k5, "doPaste");
rn.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
Sn.keydown = (n, t) => (n.inputState.setSelectionOrigin("select"), t.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
rn.touchstart = (n, t) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
rn.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Sn.mousedown = (n, t) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of n.state.facet(KQ))
    if (e = i(n, t), e)
      break;
  if (!e && t.button == 0 && (e = G7(n, t)), e) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new BZ(n, t, e, i)), i && n.observer.ignore(() => {
      Kk(n.contentDOM);
      let r = n.root.activeElement;
      r && !r.contains(n.contentDOM) && r.blur();
    });
    let s = n.inputState.mouseSelection;
    if (s)
      return s.start(t), s.dragging === !1;
  }
  return !1;
};
function U$(n, t, e, i) {
  if (i == 1)
    return it.cursor(t, e);
  if (i == 2)
    return O7(n.state, t, e);
  {
    let s = ui.find(n.docView, t), r = n.state.doc.lineAt(s ? s.posAtEnd : t), a = s ? s.posAtStart : r.from, o = s ? s.posAtEnd : r.to;
    return o < n.state.doc.length && o == r.to && o++, it.range(a, o);
  }
}
h(U$, "Kc$1");
y(U$, "rangeForClick");
let XC = /* @__PURE__ */ y((n, t, e) => t >= e.top && t <= e.bottom && n >= e.left && n <= e.right, "inside");
function Y7(n, t, e, i) {
  let s = ui.find(n.docView, t);
  if (!s)
    return 1;
  let r = t - s.posAtStart;
  if (r == 0)
    return 1;
  if (r == s.length)
    return -1;
  let a = s.coordsAt(r, -1);
  if (a && XC(e, i, a))
    return -1;
  let o = s.coordsAt(r, 1);
  return o && XC(e, i, o) ? 1 : a && a.bottom >= i ? -1 : 1;
}
h(Y7, "E0$1");
y(Y7, "findPositionSide");
function B$(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: e, bias: Y7(n, e, t.clientX, t.clientY) };
}
h(B$, "eu$1");
y(B$, "queryPos");
const XZ = rt.ie && rt.ie_version <= 11;
let NC = null, HC = 0, YC = 0;
function S5(n) {
  if (!XZ)
    return n.detail;
  let t = NC, e = YC;
  return NC = n, YC = Date.now(), HC = !t || e > Date.now() - 400 && Math.abs(t.clientX - n.clientX) < 2 && Math.abs(t.clientY - n.clientY) < 2 ? (HC + 1) % 3 : 1;
}
h(S5, "EO");
y(S5, "getClickType");
function G7(n, t) {
  let e = B$(n, t), i = S5(t), s = n.state.selection;
  return {
    update(r) {
      r.docChanged && (e.pos = r.changes.mapPos(e.pos), s = s.map(r.changes));
    },
    get(r, a, o) {
      let l = B$(n, r), c, d = U$(n, l.pos, l.bias, i);
      if (e.pos != l.pos && !a) {
        let p = U$(n, e.pos, e.bias, i), f = Math.min(p.from, d.from), m = Math.max(p.to, d.to);
        d = f < d.from ? it.range(f, m) : it.range(m, f);
      }
      return a ? s.replaceRange(s.main.extend(d.from, d.to)) : o && i == 1 && s.ranges.length > 1 && (c = K7(s, l.pos)) ? c : o ? s.addRange(d) : it.create([d]);
    }
  };
}
h(G7, "U0$1");
y(G7, "basicMouseSelection");
function K7(n, t) {
  for (let e = 0; e < n.ranges.length; e++) {
    let { from: i, to: s } = n.ranges[e];
    if (i <= t && s >= t)
      return it.create(n.ranges.slice(0, e).concat(n.ranges.slice(e + 1)), n.mainIndex == e ? 0 : n.mainIndex - (n.mainIndex > e ? 1 : 0));
  }
  return null;
}
h(K7, "W0$1");
y(K7, "removeRangeAround");
Sn.dragstart = (n, t) => {
  let { selection: { main: e } } = n.state;
  if (t.target.draggable) {
    let s = n.docView.nearest(t.target);
    if (s && s.isWidget) {
      let r = s.posAtStart, a = r + s.length;
      (r >= e.to || a <= e.from) && (e = it.range(r, a));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", Gw(n.state, g5, n.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
Sn.dragend = (n) => (n.inputState.draggedContent = null, !1);
function X$(n, t, e, i) {
  if (e = Gw(n.state, w5, e), !e)
    return;
  let s = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: r } = n.inputState, a = i && r && U7(n, t) ? { from: r.from, to: r.to } : null, o = { from: s, insert: e }, l = n.state.changes(a ? [a, o] : o);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(s, -1), head: l.mapPos(s, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
h(X$, "nu$1");
y(X$, "dropText");
Sn.drop = (n, t) => {
  if (!t.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), s = 0, r = /* @__PURE__ */ y(() => {
      ++s == e.length && X$(n, t, i.filter((a) => a != null).join(n.state.lineBreak), !1);
    }, "finishFile");
    for (let a = 0; a < e.length; a++) {
      let o = new FileReader();
      o.onerror = r, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), r();
      }, o.readAsText(e[a]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return X$(n, t, i, !0), !0;
  }
  return !1;
};
Sn.paste = (n, t) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let e = N7 ? null : t.clipboardData;
  return e ? (k5(n, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (H7(n), !1);
};
function J7(n, t) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
h(J7, "X0$1");
y(J7, "captureCopy");
function t8(n) {
  let t = [], e = [], i = !1;
  for (let s of n.selection.ranges)
    s.empty || (t.push(n.sliceDoc(s.from, s.to)), e.push(s));
  if (!t.length) {
    let s = -1;
    for (let { from: r } of n.selection.ranges) {
      let a = n.doc.lineAt(r);
      a.number > s && (t.push(a.text), e.push({ from: a.from, to: Math.min(n.doc.length, a.to + 1) })), s = a.number;
    }
    i = !0;
  }
  return { text: Gw(n, g5, t.join(n.lineBreak)), ranges: e, linewise: i };
}
h(t8, "Y0$1");
y(t8, "copiedRange");
let N$ = null;
Sn.copy = Sn.cut = (n, t) => {
  let { text: e, ranges: i, linewise: s } = t8(n.state);
  if (!e && !s)
    return !1;
  N$ = s ? e : null, t.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let r = N7 ? null : t.clipboardData;
  return r ? (r.clearData(), r.setData("text/plain", e), !0) : (J7(n, e), !1);
};
const e8 = /* @__PURE__ */ Ys.define();
function P5(n, t) {
  let e = [];
  for (let i of n.facet(e7)) {
    let s = i(n, t);
    s && e.push(s);
  }
  return e.length ? n.update({ effects: e, annotations: e8.of(!0) }) : null;
}
h(P5, "UO");
y(P5, "focusChangeTransaction");
function C5(n) {
  setTimeout(() => {
    let t = n.hasFocus;
    if (t != n.inputState.notifiedFocused) {
      let e = P5(n.state, t);
      e ? n.dispatch(e) : n.update([]);
    }
  }, 10);
}
h(C5, "WO");
y(C5, "updateForFocusChange");
rn.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), C5(n);
};
rn.blur = (n) => {
  n.observer.clearSelectionRange(), C5(n);
};
rn.compositionstart = rn.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
rn.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, rt.chrome && rt.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
rn.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
Sn.beforeinput = (n, t) => {
  var e, i;
  if (t.inputType == "insertReplacementText" && n.observer.editContext) {
    let r = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), a = t.getTargetRanges();
    if (r && a.length) {
      let o = a[0], l = n.posAtDOM(o.startContainer, o.startOffset), c = n.posAtDOM(o.endContainer, o.endOffset);
      return h0(n, { from: l, to: c, insert: n.state.toText(r) }, null), !0;
    }
  }
  let s;
  if (rt.chrome && rt.android && (s = D7.find((r) => r.inputType == t.inputType)) && (n.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let r = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > r + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return rt.ios && t.inputType == "deleteContentForward" && n.observer.flushSoon(), rt.safari && t.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => rn.compositionend(n, t), 20), !1;
};
const GC = /* @__PURE__ */ new Set();
function i8(n) {
  GC.has(n) || (GC.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
h(i8, "I0$1");
y(i8, "firefoxCopyCutHack");
const KC = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Ff = !1;
function H$() {
  Ff = !1;
}
h(H$, "lu$1");
y(H$, "clearHeightChangeFlag");
var kh;
const n8 = (kh = class {
  constructor(t) {
    this.lineWrapping = t, this.doc = Zt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return KC.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      s < 0 ? i++ : this.heightSamples[Math.floor(s * 10)] || (e = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, s, r, a) {
    let o = KC.indexOf(t) > -1, l = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = e, this.charWidth = i, this.textHeight = s, this.lineLength = r, l) {
      this.heightSamples = {};
      for (let c = 0; c < a.length; c++) {
        let d = a[c];
        d < 0 ? c++ : this.heightSamples[Math.floor(d * 10)] = !0;
      }
    }
    return l;
  }
}, h(kh, "ff"), kh);
y(n8, "HeightOracle");
let NZ = n8;
var Sh;
const s8 = (Sh = class {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, h(Sh, "cf"), Sh);
y(s8, "MeasuredHeights");
let HZ = s8;
var ho;
const r8 = (ho = class {
  /**
  @internal
  */
  constructor(t, e, i, s, r) {
    this.from = t, this.length = e, this.top = i, this.height = s, this._content = r;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? ns.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Vf ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new ho(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}, h(ho, "Ks"), ho);
y(r8, "BlockInfo");
let mr = r8;
var Kt = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(Kt || (Kt = {}));
const e1 = 1e-3;
var _s;
const a8 = (_s = class {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > e1 && (Ff = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return _s.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, s) {
    let r = this, a = i.doc;
    for (let o = s.length - 1; o >= 0; o--) {
      let { fromA: l, toA: c, fromB: d, toB: p } = s[o], f = r.lineAt(l, Kt.ByPosNoHeight, i.setDoc(e), 0, 0), m = f.to >= c ? f : r.lineAt(c, Kt.ByPosNoHeight, i, 0, 0);
      for (p += m.to - c, c = m.to; o > 0 && f.from <= s[o - 1].toA; )
        l = s[o - 1].fromA, d = s[o - 1].fromB, o--, l < f.from && (f = r.lineAt(l, Kt.ByPosNoHeight, i, 0, 0));
      d += f.from - l, l = f.from;
      let w = KZ.build(i.setDoc(a), t, d, p);
      r = pw(r, r.replace(l, c, w));
    }
    return r.updateHeight(i, 0);
  }
  static empty() {
    return new Fn(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, s = 0, r = 0;
    for (; ; )
      if (e == i)
        if (s > r * 2) {
          let o = t[e - 1];
          o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, s -= o.size;
        } else if (r > s * 2) {
          let o = t[i];
          o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, r -= o.size;
        } else
          break;
      else if (s < r) {
        let o = t[e++];
        o && (s += o.size);
      } else {
        let o = t[--i];
        o && (r += o.size);
      }
    let a = 0;
    return t[e - 1] == null ? (a = 1, e--) : t[e] == null && (a = 1, i++), new YZ(_s.of(t.slice(0, e)), a, _s.of(t.slice(i)));
  }
}, h(_s, "Qi"), _s);
y(a8, "HeightMap");
let bn = a8;
function pw(n, t) {
  return n == t ? n : (n.constructor != t.constructor && (Ff = !0), t);
}
h(pw, "hs$2");
y(pw, "replace");
bn.prototype.size = 1;
var Ph;
const o8 = (Ph = class extends bn {
  constructor(t, e, i) {
    super(t, e), this.deco = i;
  }
  blockAt(t, e, i, s) {
    return new mr(s, this.length, i, this.height, this.deco || 0);
  }
  lineAt(t, e, i, s, r) {
    return this.blockAt(0, i, s, r);
  }
  forEachLine(t, e, i, s, r, a) {
    t <= r + this.length && e >= r && a(this.blockAt(0, i, s, r));
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, h(Ph, "uf"), Ph);
y(o8, "HeightMapBlock");
let l8 = o8;
var Er;
const c8 = (Er = class extends l8 {
  constructor(t, e) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, e, i, s) {
    return new mr(s, this.length, i, this.height, this.breaks);
  }
  replace(t, e, i) {
    let s = i[0];
    return i.length == 1 && (s instanceof Er || s instanceof Ic && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof Ic ? s = new Er(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : bn.of(i);
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more ? this.setHeight(s.heights[s.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, h(Er, "_r"), Er);
y(c8, "HeightMapText");
let Fn = c8;
var ai;
const h8 = (ai = class extends bn {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, s = t.doc.lineAt(e + this.length).number, r = s - i + 1, a, o = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * r);
      a = l / r, this.length > r + 1 && (o = (this.height - l) / (this.length - r - 1));
    } else
      a = this.height / r;
    return { firstLine: i, lastLine: s, perLine: a, perChar: o };
  }
  blockAt(t, e, i, s) {
    let { firstLine: r, lastLine: a, perLine: o, perChar: l } = this.heightMetrics(e, s);
    if (e.lineWrapping) {
      let c = s + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), d = e.doc.lineAt(c), p = o + d.length * l, f = Math.max(i, t - p / 2);
      return new mr(d.from, d.length, f, p, 0);
    } else {
      let c = Math.max(0, Math.min(a - r, Math.floor((t - i) / o))), { from: d, length: p } = e.doc.line(r + c);
      return new mr(d, p, i + o * c, o, 0);
    }
  }
  lineAt(t, e, i, s, r) {
    if (e == Kt.ByHeight)
      return this.blockAt(t, i, s, r);
    if (e == Kt.ByPosNoHeight) {
      let { from: m, to: w } = i.doc.lineAt(t);
      return new mr(m, w - m, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: l } = this.heightMetrics(i, r), c = i.doc.lineAt(t), d = o + c.length * l, p = c.number - a, f = s + o * p + l * (c.from - r - p);
    return new mr(c.from, c.length, Math.max(s, Math.min(f, s + this.height - d)), d, 0);
  }
  forEachLine(t, e, i, s, r, a) {
    t = Math.max(t, r), e = Math.min(e, r + this.length);
    let { firstLine: o, perLine: l, perChar: c } = this.heightMetrics(i, r);
    for (let d = t, p = s; d <= e; ) {
      let f = i.doc.lineAt(d);
      if (d == t) {
        let w = f.number - o;
        p += l * w + c * (t - r - w);
      }
      let m = l + c * f.length;
      a(new mr(f.from, f.length, p, m, 0)), p += m, d = f.to + 1;
    }
  }
  replace(t, e, i) {
    let s = this.length - e;
    if (s > 0) {
      let r = i[i.length - 1];
      r instanceof ai ? i[i.length - 1] = new ai(r.length + s) : i.push(null, new ai(s - 1));
    }
    if (t > 0) {
      let r = i[0];
      r instanceof ai ? i[0] = new ai(t + r.length) : i.unshift(new ai(t - 1), null);
    }
    return bn.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new ai(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new ai(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, s) {
    let r = e + this.length;
    if (s && s.from <= e + this.length && s.more) {
      let a = [], o = Math.max(e, s.from), l = -1;
      for (s.from > e && a.push(new ai(s.from - e - 1).updateHeight(t, e)); o <= r && s.more; ) {
        let d = t.doc.lineAt(o).length;
        a.length && a.push(null);
        let p = s.heights[s.index++];
        l == -1 ? l = p : Math.abs(p - l) >= e1 && (l = -2);
        let f = new Fn(d, p);
        f.outdated = !1, a.push(f), o += d + 1;
      }
      o <= r && a.push(null, new ai(r - o).updateHeight(t, o));
      let c = bn.of(a);
      return (l < 0 || Math.abs(c.height - this.height) >= e1 || Math.abs(l - this.heightMetrics(t, e).perLine) >= e1) && (Ff = !0), pw(this, c);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, h(ai, "ke"), ai);
y(h8, "HeightMapGap");
let Ic = h8;
var Ch;
const d8 = (Ch = class extends bn {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, s) {
    let r = i + this.left.height;
    return t < r ? this.left.blockAt(t, e, i, s) : this.right.blockAt(t, e, r, s + this.left.length + this.break);
  }
  lineAt(t, e, i, s, r) {
    let a = s + this.left.height, o = r + this.left.length + this.break, l = e == Kt.ByHeight ? t < a : t < o, c = l ? this.left.lineAt(t, e, i, s, r) : this.right.lineAt(t, e, i, a, o);
    if (this.break || (l ? c.to < o : c.from > o))
      return c;
    let d = e == Kt.ByPosNoHeight ? Kt.ByPosNoHeight : Kt.ByPos;
    return l ? c.join(this.right.lineAt(o, d, i, a, o)) : this.left.lineAt(o, d, i, s, r).join(c);
  }
  forEachLine(t, e, i, s, r, a) {
    let o = s + this.left.height, l = r + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, e, i, s, r, a), e >= l && this.right.forEachLine(t, e, i, o, l, a);
    else {
      let c = this.lineAt(l, Kt.ByPos, i, s, r);
      t < c.from && this.left.forEachLine(t, c.from - 1, i, s, r, a), c.to >= t && c.from <= e && a(c), e > c.to && this.right.forEachLine(c.to + 1, e, i, o, l, a);
    }
  }
  replace(t, e, i) {
    let s = this.left.length + this.break;
    if (e < s)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - s, e - s, i));
    let r = [];
    t > 0 && this.decomposeLeft(t, r);
    let a = r.length;
    for (let o of i)
      r.push(o);
    if (t > 0 && Y$(r, a - 1), e < this.length) {
      let o = r.length;
      this.decomposeRight(e, r), Y$(r, o);
    }
    return bn.of(r);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, s = i + this.break;
    if (t >= s)
      return this.right.decomposeRight(t - s, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < s && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? bn.of(this.break ? [t, null, e] : [t, e]) : (this.left = pw(this.left, t), this.right = pw(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, s) {
    let { left: r, right: a } = this, o = e + r.length + this.break, l = null;
    return s && s.from <= e + r.length && s.more ? l = r = r.updateHeight(t, e, i, s) : r.updateHeight(t, e, i), s && s.from <= o + a.length && s.more ? l = a = a.updateHeight(t, o, i, s) : a.updateHeight(t, o, i), l ? this.balanced(r, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}, h(Ch, "df"), Ch);
y(d8, "HeightMapBranch");
let YZ = d8;
function Y$(n, t) {
  let e, i;
  n[t] == null && (e = n[t - 1]) instanceof Ic && (i = n[t + 1]) instanceof Ic && n.splice(t - 1, 3, new Ic(e.length + 1 + i.length));
}
h(Y$, "au$1");
y(Y$, "mergeGaps");
const GZ = 5;
var uo;
const u8 = (uo = class {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof Fn ? s.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Fn(i - this.pos, -1)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let s = i.widget ? i.widget.estimatedHeight : 0, r = i.widget ? i.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let a = e - t;
      i.block ? this.addBlock(new l8(a, s, i)) : (a || r || s >= GZ) && this.addLineDeco(s, r, a);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new Fn(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new Ic(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof Fn)
      return t;
    let e = new Fn(0, -1);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let s = this.ensureLine();
    s.length += i, s.collapsed += i, s.widgetHeight = Math.max(s.widgetHeight, t), s.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof Fn) && !this.isCovered ? this.nodes.push(new Fn(0, -1)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let s of this.nodes)
      s instanceof Fn && s.updateHeight(this.oracle, i), i += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, s) {
    let r = new uo(i, t);
    return li.spans(e, i, s, r, 0), r.finish(i);
  }
}, h(uo, "Js"), uo);
y(u8, "NodeBuilder");
let KZ = u8;
function p8(n, t, e) {
  let i = new JZ();
  return li.compare(n, t, e, i, 0), i.changes;
}
h(p8, "q0$1");
y(p8, "heightRelevantDecoChanges");
var Qh;
const f8 = (Qh = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, s) {
    (t < e || i && i.heightRelevant || s && s.heightRelevant) && Gm(t, e, this.changes, 5);
  }
}, h(Qh, "Of"), Qh);
y(f8, "DecorationComparator");
let JZ = f8;
function y8(n, t) {
  let e = n.getBoundingClientRect(), i = n.ownerDocument, s = i.defaultView || window, r = Math.max(0, e.left), a = Math.min(s.innerWidth, e.right), o = Math.max(0, e.top), l = Math.min(s.innerHeight, e.bottom);
  for (let c = n.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let d = c, p = window.getComputedStyle(d);
      if ((d.scrollHeight > d.clientHeight || d.scrollWidth > d.clientWidth) && p.overflow != "visible") {
        let f = d.getBoundingClientRect();
        r = Math.max(r, f.left), a = Math.min(a, f.right), o = Math.max(o, f.top), l = Math.min(c == n.parentNode ? s.innerHeight : l, f.bottom);
      }
      c = p.position == "absolute" || p.position == "fixed" ? d.offsetParent : d.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: r - e.left,
    right: Math.max(r, a) - e.left,
    top: o - (e.top + t),
    bottom: Math.max(o, l) - (e.top + t)
  };
}
h(y8, "D0$1");
y(y8, "visiblePixelRange");
function m8(n) {
  let t = n.getBoundingClientRect(), e = n.ownerDocument.defaultView || window;
  return t.left < e.innerWidth && t.right > 0 && t.top < e.innerHeight && t.bottom > 0;
}
h(m8, "B0$1");
y(m8, "inWindow");
function w8(n, t) {
  let e = n.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
h(w8, "z0$1");
y(w8, "fullPixelRange");
var Mh;
const g8 = (Mh = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.size = i, this.displaySize = s;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i], r = e[i];
      if (s.from != r.from || s.to != r.to || s.size != r.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return Jt.replace({
      widget: new tW(this.displaySize * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}, h(Mh, "pf"), Mh);
y(g8, "LineGap");
let mb = g8;
var Th;
const v8 = (Th = class extends by {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, h(Th, "mf"), Th);
y(v8, "LineGapWidget");
let tW = v8;
var Ah;
const b8 = (Ah = class {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = t4, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Pe.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(v5).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new NZ(e), this.stateDeco = t.facet(uw).filter((i) => typeof i != "function"), this.heightMap = bn.empty().applyChanges(this.stateDeco, Zt.empty, this.heightOracle.setDoc(t.doc), [new $r(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Jt.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let s = i ? e.head : e.anchor;
      if (!t.some(({ from: r, to: a }) => s >= r && s <= a)) {
        let { from: r, to: a } = this.lineBlockAt(s);
        t.push(new Mg(r, a));
      }
    }
    return this.viewports = t.sort((i, s) => i.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? t4 : new eW(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(Rc(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(uw).filter((d) => typeof d != "function");
    let s = t.changedRanges, r = $r.extendWithRanges(s, p8(i, this.stateDeco, t ? t.changes : xn.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    H$(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), r), (this.heightMap.height != a || Ff) && (t.flags |= 2), o ? (this.scrollAnchorPos = t.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let l = r.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < l.from || e.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, t.flags |= this.updateForViewport(), (c || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(WZ) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), s = this.heightOracle, r = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Pe.RTL : Pe.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(r), o = e.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let c = 0, d = 0;
    if (o.width && o.height) {
      let { scaleX: R, scaleY: T } = Gk(e, o);
      (R > 5e-3 && Math.abs(this.scaleX - R) > 5e-3 || T > 5e-3 && Math.abs(this.scaleY - T) > 5e-3) && (this.scaleX = R, this.scaleY = T, c |= 16, a = l = !0);
    }
    let p = (parseInt(i.paddingTop) || 0) * this.scaleY, f = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != p || this.paddingBottom != f) && (this.paddingTop = p, this.paddingBottom = f, c |= 18), this.editorWidth != t.scrollDOM.clientWidth && (s.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, c |= 16);
    let m = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != m && (this.scrollAnchorHeight = -1, this.scrollTop = m), this.scrolledToBottom = t5(t.scrollDOM);
    let w = (this.printing ? w8 : y8)(e, this.paddingTop), b = w.top - this.pixelViewport.top, x = w.bottom - this.pixelViewport.bottom;
    this.pixelViewport = w;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (l = !0)), !this.inView && !this.scrollTarget && !m8(t.dom))
      return 0;
    let P = o.width;
    if ((this.contentDOMWidth != P || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, c |= 16), l) {
      let R = t.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(R) && (a = !0), a || s.lineWrapping && Math.abs(P - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: T, charWidth: I, textHeight: Z } = t.docView.measureTextSize();
        a = T > 0 && s.refresh(r, T, I, Z, P / I, R), a && (t.docView.minWidth = 0, c |= 16);
      }
      b > 0 && x > 0 ? d = Math.max(b, x) : b < 0 && x < 0 && (d = Math.min(b, x)), H$();
      for (let T of this.viewports) {
        let I = T.from == this.viewport.from ? R : t.docView.measureVisibleLineHeights(T);
        this.heightMap = (a ? bn.empty().applyChanges(this.stateDeco, Zt.empty, this.heightOracle, [new $r(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(s, 0, a, new HZ(T.from, I));
      }
      Ff && (c |= 2);
    }
    let A = !this.viewportIsAppropriate(this.viewport, d) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return A && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(d, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || A) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, t)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), s = this.heightMap, r = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, l = new Mg(s.lineAt(a - i * 1e3, Kt.ByHeight, r, 0, 0).from, s.lineAt(o + (1 - i) * 1e3, Kt.ByHeight, r, 0, 0).to);
    if (e) {
      let { head: c } = e.range;
      if (c < l.from || c > l.to) {
        let d = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = s.lineAt(c, Kt.ByPos, r, 0, 0), f;
        e.y == "center" ? f = (p.top + p.bottom) / 2 - d / 2 : e.y == "start" || e.y == "nearest" && c < l.from ? f = p.top : f = p.bottom - d, l = new Mg(s.lineAt(f - 1e3 / 2, Kt.ByHeight, r, 0, 0).from, s.lineAt(f + d + 1e3 / 2, Kt.ByHeight, r, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), s = e.mapPos(t.to, 1);
    return new Mg(this.heightMap.lineAt(i, Kt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Kt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(t, Kt.ByPos, this.heightOracle, 0, 0), { bottom: r } = this.heightMap.lineAt(e, Kt.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (t == 0 || s <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || r >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && s > a - 2 * 1e3 && r < o + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let s of t)
      e.touchesRange(s.from, s.to) || i.push(new mb(e.mapPos(s.from), e.mapPos(s.to), s.size, s.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, s = i ? 1e4 : 2e3, r = s >> 1, a = s << 1;
    if (this.defaultTextDirection != Pe.LTR && !i)
      return [];
    let o = [], l = /* @__PURE__ */ y((d, p, f, m) => {
      if (p - d < r)
        return;
      let w = this.state.selection.main, b = [w.from];
      w.empty || b.push(w.to);
      for (let O of b)
        if (O > d && O < p) {
          l(d, O - 10, f, m), l(O + 10, p, f, m);
          return;
        }
      let x = x8(t, (O) => O.from >= f.from && O.to <= f.to && Math.abs(O.from - d) < r && Math.abs(O.to - p) < r && !b.some((P) => O.from < P && O.to > P));
      if (!x) {
        if (p < f.to && e && i && e.visibleRanges.some((A) => A.from <= p && A.to >= p)) {
          let A = e.moveToLineBoundary(it.cursor(p), !1, !0).head;
          A > d && (p = A);
        }
        let O = this.gapSize(f, d, p, m), P = i || O < 2e6 ? O : 2e6;
        x = new mb(d, p, O, P);
      }
      o.push(x);
    }, "addGap"), c = /* @__PURE__ */ y((d) => {
      if (d.length < a || d.type != ns.Text)
        return;
      let p = $8(d.from, d.to, this.stateDeco);
      if (p.total < a)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, m, w;
      if (i) {
        let b = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, x, O;
        if (f != null) {
          let P = pm(p, f), A = ((this.visibleBottom - this.visibleTop) / 2 + b) / d.height;
          x = P - A, O = P + A;
        } else
          x = (this.visibleTop - d.top - b) / d.height, O = (this.visibleBottom - d.top + b) / d.height;
        m = um(p, x), w = um(p, O);
      } else {
        let b = p.total * this.heightOracle.charWidth, x = s * this.heightOracle.charWidth, O = 0;
        if (b > 2e6)
          for (let I of t)
            I.from >= d.from && I.from < d.to && I.size != I.displaySize && I.from * this.heightOracle.charWidth + O < this.pixelViewport.left && (O = I.size - I.displaySize);
        let P = this.pixelViewport.left + O, A = this.pixelViewport.right + O, R, T;
        if (f != null) {
          let I = pm(p, f), Z = ((A - P) / 2 + x) / b;
          R = I - Z, T = I + Z;
        } else
          R = (P - x) / b, T = (A + x) / b;
        m = um(p, R), w = um(p, T);
      }
      m > d.from && l(d.from, m, d, p), w < d.to && l(w, d.to, d, p);
    }, "checkLine");
    for (let d of this.viewportLines)
      Array.isArray(d.type) ? d.type.forEach(c) : c(d);
    return o;
  }
  gapSize(t, e, i, s) {
    let r = pm(s, i) - pm(s, e);
    return this.heightOracle.lineWrapping ? t.height * r : s.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(t) {
    mb.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = Jt.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    li.spans(e, this.viewport.from, this.viewport.to, {
      span(r, a) {
        i.push({ from: r, to: a });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (i.length != this.visibleRanges.length)
      s = 12;
    else
      for (let r = 0; r < i.length && !(s & 8); r++) {
        let a = this.visibleRanges[r], o = i[r];
        (a.from != o.from || a.to != o.to) && (s |= 4, t && t.mapPos(a.from, -1) == o.from && t.mapPos(a.to, 1) == o.to || (s |= 8));
      }
    return this.visibleRanges = i, s;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || Rc(this.heightMap.lineAt(t, Kt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || Rc(this.heightMap.lineAt(this.scaler.fromDOM(t), Kt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return Rc(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, h(Ah, "gf"), Ah);
y(b8, "ViewState");
let JC = b8;
var Rh;
const O8 = (Rh = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, h(Rh, "yf"), Rh);
y(O8, "Viewport");
let Mg = O8;
function $8(n, t, e) {
  let i = [], s = n, r = 0;
  return li.spans(e, n, t, {
    span() {
    },
    point(a, o) {
      a > s && (i.push({ from: s, to: a }), r += a - s), s = o;
    }
  }, 20), s < t && (i.push({ from: s, to: t }), r += t - s), { total: r, ranges: i };
}
h($8, "N0$1");
y($8, "lineStructure");
function um({ total: n, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(n * e);
  for (let s = 0; ; s++) {
    let { from: r, to: a } = t[s], o = a - r;
    if (i <= o)
      return r + i;
    i -= o;
  }
}
h(um, "An$1");
y(um, "findPosition");
function pm(n, t) {
  let e = 0;
  for (let { from: i, to: s } of n.ranges) {
    if (t <= s) {
      e += t - i;
      break;
    }
    e += s - i;
  }
  return e / n.total;
}
h(pm, "Zn$1");
y(pm, "findFraction");
function x8(n, t) {
  for (let e of n)
    if (t(e))
      return e;
}
h(x8, "G0$1");
y(x8, "find");
const t4 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
var po;
const k8 = (po = class {
  constructor(t, e, i) {
    let s = 0, r = 0, a = 0;
    this.viewports = i.map(({ from: o, to: l }) => {
      let c = e.lineAt(o, Kt.ByPos, t, 0, 0).top, d = e.lineAt(l, Kt.ByPos, t, 0, 0).bottom;
      return s += d - c, { from: o, to: l, top: c, bottom: d, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (e.height - s);
    for (let o of this.viewports)
      o.domTop = a + (o.top - r) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), r = o.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.top)
        return s + (t - i) * this.scale;
      if (t <= r.bottom)
        return r.domTop + (t - r.top);
      i = r.bottom, s = r.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.domTop)
        return i + (t - s) / this.scale;
      if (t <= r.domBottom)
        return r.top + (t - r.domTop);
      i = r.bottom, s = r.domBottom;
    }
  }
  eq(t) {
    return t instanceof po ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}, h(po, "eo"), po);
y(k8, "BigScaler");
let eW = k8;
function Rc(n, t) {
  if (t.scale == 1)
    return n;
  let e = t.toDOM(n.top), i = t.toDOM(n.bottom);
  return new mr(n.from, n.length, e, i - e, Array.isArray(n._content) ? n._content.map((s) => Rc(s, t)) : n._content);
}
h(Rc, "dr$1");
y(Rc, "scaleBlock");
const Tg = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ y((n) => n.join(" "), "combine") }), G$ = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ y((n) => n.indexOf(!0) > -1, "combine") }), K$ = /* @__PURE__ */ Xr.newName(), S8 = /* @__PURE__ */ Xr.newName(), P8 = /* @__PURE__ */ Xr.newName(), C8 = { "&light": "." + S8, "&dark": "." + P8 };
function iv(n, t, e) {
  return new Xr(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (s) => {
        if (s == "&")
          return n;
        if (!e || !e[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return e[s];
      }) : n + " " + i;
    }
  });
}
h(iv, "jl$1");
y(iv, "buildTheme");
const iW = /* @__PURE__ */ iv("." + K$, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, C8), nW = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, wb = rt.ie && rt.ie_version <= 11;
var Eh;
const Q8 = (Eh = class {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new EZ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (rt.ie && rt.ie_version <= 11 || rt.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(rt.chrome && rt.chrome_version < 126) && (this.editContext = new rW(t), t.state.facet(ks) && (t.contentDOM.editContext = this.editContext.editContext)), wb && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, s = this.selectionRange;
    if (i.state.facet(ks) ? i.root.activeElement != this.dom : !Ym(this.dom, s))
      return;
    let r = s.anchorNode && i.docView.nearest(s.anchorNode);
    if (r && r.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (rt.ie && rt.ie_version <= 11 || rt.android && rt.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && Lc(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = Df(t.root);
    if (!e)
      return !1;
    let i = rt.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && M8(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let s = Ym(this.dom, i);
    return s && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && yQ(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, nW), wb && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), wb && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let s = /* @__PURE__ */ y(() => {
        let r = this.delayedAndroidKey;
        r && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = r.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && r.force && Ba(this.dom, r.key, r.keyCode));
      }, "flush");
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, s = !1;
    for (let r of t) {
      let a = this.readMutation(r);
      a && (a.typeOver && (s = !0), e == -1 ? { from: e, to: i } = a : (e = Math.min(a.from, e), i = Math.max(a.to, i)));
    }
    return { from: e, to: i, typeOver: s };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), s = this.selectionChanged && Ym(this.dom, this.selectionRange);
    if (t < 0 && !s)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let r = new jZ(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: r.newSel ? r.newSel.main : null }, r;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, s = x5(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !e.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(t) {
    let e = this.view.docView.nearest(t.target);
    if (!e || e.ignoreMutation(t))
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "attributes" && (e.flags |= 4), t.type == "childList") {
      let i = J$(e, t.previousSibling || t.target.previousSibling, -1), s = J$(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: s ? e.posBefore(s) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(ks) != t.state.facet(ks) && (t.view.contentDOM.editContext = t.state.facet(ks) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}, h(Eh, "bf"), Eh);
y(Q8, "DOMObserver");
let sW = Q8;
function J$(n, t, e) {
  for (; t; ) {
    let i = ne.get(t);
    if (i && i.parent == n)
      return i;
    let s = t.parentNode;
    t = s != n.dom ? s : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
h(J$, "fu$1");
y(J$, "findChild");
function tx(n, t) {
  let e = t.startContainer, i = t.startOffset, s = t.endContainer, r = t.endOffset, a = n.docView.domAtPos(n.state.selection.main.anchor);
  return Lc(a.node, a.offset, s, r) && ([e, i, s, r] = [s, r, e, i]), { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: r };
}
h(tx, "cu$1");
y(tx, "buildSelectionRangeFromRange");
function M8(n, t) {
  if (t.getComposedRanges) {
    let s = t.getComposedRanges(n.root)[0];
    if (s)
      return tx(n, s);
  }
  let e = null;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), e = s.getTargetRanges()[0];
  }
  return h(i, "i"), y(i, "read"), n.contentDOM.addEventListener("beforeinput", i, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", i, !0), e ? tx(n, e) : null;
}
h(M8, "K0$1");
y(M8, "safariSelectionRangeHack");
var zh;
const T8 = (zh = class {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let s = t.state.selection.main, { anchor: r, head: a } = s, o = this.toEditorPos(i.updateRangeStart), l = this.toEditorPos(i.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let c = { from: o, to: l, insert: Zt.of(i.text.split(`
`)) };
      if (c.from == this.from && r < this.from ? c.from = r : c.to == this.to && r > this.to && (c.to = r), c.from == c.to && !c.insert.length) {
        let d = it.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        d.main.eq(s) || t.dispatch({ selection: d, userEvent: "select" });
        return;
      }
      if ((rt.mac || rt.android) && c.from == a - 1 && /^\. ?$/.test(i.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: o, to: l, insert: Zt.of([i.text.replace(".", " ")]) }), this.pendingContextChange = c, !t.state.readOnly) {
        let d = this.to - this.from + (c.to - c.from + c.insert.length);
        h0(t, c, it.single(this.toEditorPos(i.selectionStart, d), this.toEditorPos(i.selectionEnd, d)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state));
    }, this.handlers.characterboundsupdate = (i) => {
      let s = [], r = null;
      for (let a = this.toEditorPos(i.rangeStart), o = this.toEditorPos(i.rangeEnd); a < o; a++) {
        let l = t.coordsForChar(a);
        r = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || r || new DOMRect(), s.push(r);
      }
      e.updateCharacterBounds(i.rangeStart, s);
    }, this.handlers.textformatupdate = (i) => {
      let s = [];
      for (let r of i.getTextFormats()) {
        let a = r.underlineStyle, o = r.underlineThickness;
        if (a != "None" && o != "None") {
          let l = this.toEditorPos(r.rangeStart), c = this.toEditorPos(r.rangeEnd);
          if (l < c) {
            let d = `text-decoration: underline ${a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${o == "Thin" ? 1 : 2}px`;
            s.push(Jt.mark({ attributes: { style: d } }).range(l, c));
          }
        }
      }
      t.dispatch({ effects: r7.of(Jt.set(s)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(t.state);
      }
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: /* @__PURE__ */ y((i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let s = Df(i.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    }, "read") };
  }
  applyEdits(t) {
    let e = 0, i = !1, s = this.pendingContextChange;
    return t.changes.iterChanges((r, a, o, l, c) => {
      if (i)
        return;
      let d = c.length - (a - r);
      if (s && a >= s.to)
        if (s.from == r && s.to == a && s.insert.eq(c)) {
          s = this.pendingContextChange = null, e += d, this.to += d;
          return;
        } else
          s = null, this.revertPending(t.state);
      if (r += e, a += e, a <= this.from)
        this.from += d, this.to += d;
      else if (r < this.to) {
        if (r < this.from || a > this.to || this.to - this.from + c.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(r), this.toContextPos(a), c.toString()), this.to += d;
      }
      e += d;
    }), s && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange, i = t.startState.selection.main;
    this.composing && (this.composing.drifted || !t.changes.touchesRange(i.from, i.to) && t.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), s = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != s) && this.editContext.updateSelection(i, s);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, e = this.to - this.from) {
    t = Math.min(t, e);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (t - i.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let e = this.composing;
    return e && e.drifted ? e.contextBase + (t - e.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}, h(zh, "Sf"), zh);
y(T8, "EditContextManager");
let rW = T8;
var zr;
const A8 = (zr = class {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((s) => s.forEach((r) => i(r, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = t.root || fQ(t.parent) || document, this.viewState = new JC(t.state || ze.create(t)), t.scrollTo && t.scrollTo.is(Cg) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Ac).map((s) => new fb(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new sW(this), this.inputState = new FZ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new UC(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof wi ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, s, r = this.state;
    for (let f of t) {
      if (f.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    let a = this.hasFocus, o = 0, l = null;
    t.some((f) => f.annotation(e8)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = P5(r, a), l || (o = 1));
    let c = this.observer.delayedAndroidKey, d = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), d = this.observer.readChange(), (d && !this.state.doc.eq(r.doc) || !this.state.selection.eq(r.selection)) && (d = null)) : this.observer.clear(), r.facet(ze.phrases) != this.state.facet(ze.phrases))
      return this.setState(r);
    s = FC.create(this, r, t), s.flags |= o;
    let p = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of t) {
        if (p && (p = p.map(f.changes)), f.scrollIntoView) {
          let { main: m } = f.state.selection;
          p = new pb(m.empty ? m : it.cursor(m.head, m.head > m.anchor ? -1 : 1));
        }
        for (let m of f.effects)
          m.is(Cg) && (p = m.value.clip(this.state));
      }
      this.viewState.update(s, p), this.bidiCache = i4.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), e = this.docView.update(s), this.state.facet(cm) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(Tg) != s.state.facet(Tg) && (this.viewState.mustMeasureContent = !0), (e || i || p || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !s.empty)
      for (let f of this.state.facet(I$))
        try {
          f(s);
        } catch (m) {
          Ci(this.state, m, "update listener");
        }
    (l || d) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), d && !x5(this, d) && c.force && Ba(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new JC(t), this.plugins = t.facet(Ac).map((i) => new fb(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new UC(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(Ac), i = t.state.facet(Ac);
    if (e != i) {
      let s = [];
      for (let r of i) {
        let a = e.indexOf(r);
        if (a < 0)
          s.push(new fb(r));
        else {
          let o = this.plugins[a];
          o.mustUpdate = t, s.push(o);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != t && r.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = t;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          Ci(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, s = i.scrollTop * this.scaleY, { scrollAnchorPos: r, scrollAnchorHeight: a } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (t5(i))
            r = -1, a = this.viewState.heightMap.height;
          else {
            let m = this.viewState.scrollAnchorAt(s);
            r = m.from, a = m.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let d = c.map((m) => {
          try {
            return m.read(this);
          } catch (w) {
            return Ci(this.state, w), e4;
          }
        }), p = FC.create(this, this.state, []), f = !1;
        p.flags |= l, e ? e.flags |= l : e = p, this.updateState = 2, p.empty || (this.updatePlugins(p), this.inputState.update(p), this.updateAttrs(), f = this.docView.update(p), f && this.docViewUpdate());
        for (let m = 0; m < c.length; m++)
          if (d[m] != e4)
            try {
              let w = c[m];
              w.write && w.write(d[m], this);
            } catch (w) {
              Ci(this.state, w);
            }
        if (f && this.docView.updateSelection(!0), !p.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let m = (r < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(r).top) - a;
              if (m > 1 || m < -1) {
                s = s + m, i.scrollTop = s / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let o of this.state.facet(I$))
        o(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return K$ + " " + (this.state.facet(G$) ? P8 : S8) + " " + this.state.facet(Tg);
  }
  updateAttrs() {
    let t = ex(this, l7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(ks) ? "true" : "false",
      class: "cm-content",
      style: `${rt.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), ex(this, v5, e);
    let i = this.observer.ignore(() => {
      let s = K1(this.contentDOM, this.contentAttrs, e), r = K1(this.dom, this.editorAttrs, t);
      return s || r;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let s of i.effects)
        if (s.is(zr.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(cm);
    let t = this.state.facet(zr.cspNonce);
    Xr.mount(this.root, this.styleModules.concat(iW).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.plugin != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.plugin == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return t1(this, t, j$(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return t1(this, t, j$(this, t, e, (i) => Q7(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), s = this.textDirectionAt(t.from), r = i[e ? i.length - 1 : 0];
    return it.cursor(r.side(e, s) + t.from, r.forward(!e, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return C7(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return t1(this, t, M7(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    return this.readMeasured(), $5(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let s = this.state.doc.lineAt(t), r = this.bidiSpans(s), a = r[vr.find(r, t - s.from, -1, e)];
    return vy(i, a.dir == Pe.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(i7) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > aW)
      return m5(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let r of this.bidiCache)
      if (r.from == t.from && r.dir == e && (r.fresh || y5(r.isolates, i = Z$(this, t))))
        return r.order;
    i || (i = Z$(this, t));
    let s = BQ(t.text, e, i);
    return this.bidiCache.push(new i4(t.from, t.to, e, i, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || rt.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Kk(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return Cg.of(new pb(typeof t == "number" ? it.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return Cg.of(new pb(it.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return Ds.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return Ds.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = Xr.newName(), s = [Tg.of(i), cm.of(iv(`.${i}`, t))];
    return e && e.dark && s.push(G$.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return rl.lowest(cm.of(iv("." + K$, t, C8)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content"), s = i && ne.get(i) || ne.get(t);
    return ((e = s == null ? void 0 : s.rootView) === null || e === void 0 ? void 0 : e.view) || null;
  }
}, h(zr, "Cr"), zr);
y(A8, "EditorView");
let kt = A8;
kt.styleModule = cm;
kt.inputHandler = t7;
kt.clipboardInputFilter = w5;
kt.clipboardOutputFilter = g5;
kt.scrollHandler = n7;
kt.focusChangeEffect = e7;
kt.perLineTextDirection = i7;
kt.exceptionSink = JQ;
kt.updateListener = I$;
kt.editable = ks;
kt.mouseSelectionStyle = KQ;
kt.dragMovesSelection = GQ;
kt.clickAddsSelectionRange = YQ;
kt.decorations = uw;
kt.outerDecorations = c7;
kt.atomicRanges = b5;
kt.bidiIsolatedRanges = h7;
kt.scrollMargins = d7;
kt.darkTheme = G$;
kt.cspNonce = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ y((n) => n.length ? n[0] : "", "combine") });
kt.contentAttributes = v5;
kt.editorAttributes = l7;
kt.lineWrapping = /* @__PURE__ */ kt.contentAttributes.of({ class: "cm-lineWrapping" });
kt.announce = /* @__PURE__ */ Bt.define();
const aW = 4096, e4 = {};
var fo;
const R8 = (fo = class {
  constructor(t, e, i, s, r, a) {
    this.from = t, this.to = e, this.dir = i, this.isolates = s, this.fresh = r, this.order = a;
  }
  static update(t, e) {
    if (e.empty && !t.some((r) => r.fresh))
      return t;
    let i = [], s = t.length ? t[t.length - 1].dir : Pe.LTR;
    for (let r = Math.max(0, t.length - 10); r < t.length; r++) {
      let a = t[r];
      a.dir == s && !e.touchesRange(a.from, a.to) && i.push(new fo(e.mapPos(a.from, 1), e.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}, h(fo, "to"), fo);
y(R8, "CachedOrder");
let i4 = R8;
function ex(n, t, e) {
  for (let i = n.state.facet(t), s = i.length - 1; s >= 0; s--) {
    let r = i[s], a = typeof r == "function" ? r(n) : r;
    a && G1(a, e);
  }
  return e;
}
h(ex, "du$1");
y(ex, "attrsFromFacet");
const oW = rt.mac ? "mac" : rt.windows ? "win" : rt.linux ? "linux" : "key";
function E8(n, t) {
  const e = n.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let s, r, a, o;
  for (let l = 0; l < e.length - 1; ++l) {
    const c = e[l];
    if (/^(cmd|meta|m)$/i.test(c))
      o = !0;
    else if (/^a(lt)?$/i.test(c))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      r = !0;
    else if (/^s(hift)?$/i.test(c))
      a = !0;
    else if (/^mod$/i.test(c))
      t == "mac" ? o = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return s && (i = "Alt-" + i), r && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
h(E8, "ty");
y(E8, "normalizeKeyName");
function fm(n, t, e) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e !== !1 && t.shiftKey && (n = "Shift-" + n), n;
}
h(fm, "Mn$1");
y(fm, "modifiers");
const lW = /* @__PURE__ */ rl.default(/* @__PURE__ */ kt.domEventHandlers({
  keydown(n, t) {
    return L8(z8(t.state), n, t, "editor");
  }
})), d0 = /* @__PURE__ */ gt.define({ enables: lW }), n4 = /* @__PURE__ */ new WeakMap();
function z8(n) {
  let t = n.facet(d0), e = n4.get(t);
  return e || n4.set(t, e = _8(t.reduce((i, s) => i.concat(s), []))), e;
}
h(z8, "ry$1");
y(z8, "getKeymap");
let wr = null;
const cW = 4e3;
function _8(n, t = oW) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ y((a, o) => {
    let l = i[a];
    if (l == null)
      i[a] = o;
    else if (l != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, "checkPrefix"), r = /* @__PURE__ */ y((a, o, l, c, d) => {
    var p, f;
    let m = e[a] || (e[a] = /* @__PURE__ */ Object.create(null)), w = o.split(/ (?!$)/).map((O) => E8(O, t));
    for (let O = 1; O < w.length; O++) {
      let P = w.slice(0, O).join(" ");
      s(P, !0), m[P] || (m[P] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(A) => {
          let R = wr = { view: A, prefix: P, scope: a };
          return setTimeout(() => {
            wr == R && (wr = null);
          }, cW), !0;
        }]
      });
    }
    let b = w.join(" ");
    s(b, !1);
    let x = m[b] || (m[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (p = m._any) === null || p === void 0 ? void 0 : p.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && x.run.push(l), c && (x.preventDefault = !0), d && (x.stopPropagation = !0);
  }, "add");
  for (let a of n) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let c of o) {
        let d = e[c] || (e[c] = /* @__PURE__ */ Object.create(null));
        d._any || (d._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: p } = a;
        for (let f in d)
          d[f].run.push((m) => p(m, ix));
      }
    let l = a[t] || a.key;
    if (l)
      for (let c of o)
        r(c, l, a.run, a.preventDefault, a.stopPropagation), a.shift && r(c, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return e;
}
h(_8, "sy$1");
y(_8, "buildKeymap");
let ix = null;
function L8(n, t, e, i) {
  ix = t;
  let s = cQ(t), r = ur(s, 0), a = Da(r) == s.length && s != " ", o = "", l = !1, c = !1, d = !1;
  wr && wr.view == e && wr.scope == i && (o = wr.prefix + " ", q7.indexOf(t.keyCode) < 0 && (c = !0, wr = null));
  let p = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ y((x) => {
    if (x) {
      for (let O of x.run)
        if (!p.has(O) && (p.add(O), O(e)))
          return x.stopPropagation && (d = !0), !0;
      x.preventDefault && (x.stopPropagation && (d = !0), c = !0);
    }
    return !1;
  }, "runFor"), m = n[i], w, b;
  return m && (f(m[o + fm(s, t, !a)]) ? l = !0 : a && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(rt.windows && t.ctrlKey && t.altKey) && (w = Nr[t.keyCode]) && w != s ? (f(m[o + fm(w, t, !0)]) || t.shiftKey && (b = cw[t.keyCode]) != s && b != w && f(m[o + fm(b, t, !1)])) && (l = !0) : a && t.shiftKey && f(m[o + fm(s, t, !0)]) && (l = !0), !l && f(m._any) && (l = !0)), c && (l = !0), l && d && t.stopPropagation(), ix = null, l;
}
h(L8, "oy$1");
y(L8, "runHandlers");
const I8 = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n == null ? null : t.mapPos(n);
  }
}), ym = /* @__PURE__ */ Hs.define({
  create() {
    return null;
  },
  update(n, t) {
    return n != null && (n = t.changes.mapPos(n)), t.effects.reduce((e, i) => i.is(I8) ? i.value : e, n);
  }
}), hW = /* @__PURE__ */ Ds.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var t;
    let e = n.state.field(ym);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(ym) != e || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, t = n.state.field(ym), e = t != null && n.coordsAtPos(t);
    if (!e)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: e.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      n ? (this.cursor.style.left = n.left / t + "px", this.cursor.style.top = n.top / e + "px", this.cursor.style.height = n.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(ym) != n && this.view.dispatch({ effects: I8.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dW() {
  return [ym, hW];
}
h(dW, "ay$1");
y(dW, "dropCursor");
function nx(n, t, e, i, s) {
  t.lastIndex = 0;
  for (let r = n.iterRange(e, i), a = e, o; !r.next().done; a += r.value.length)
    if (!r.lineBreak)
      for (; o = t.exec(r.value); )
        s(a + o.index, o);
}
h(nx, "pu$1");
y(nx, "iterMatches");
function Z8(n, t) {
  let e = n.visibleRanges;
  if (e.length == 1 && e[0].from == n.viewport.from && e[0].to == n.viewport.to)
    return e;
  let i = [];
  for (let { from: s, to: r } of e)
    s = Math.max(n.state.doc.lineAt(s).from, s - t), r = Math.min(n.state.doc.lineAt(r).to, r + t), i.length && i[i.length - 1].to >= s ? i[i.length - 1].to = r : i.push({ from: s, to: r });
  return i;
}
h(Z8, "hy$1");
y(Z8, "matchRanges");
var _h;
const W8 = (_h = class {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: s, boundary: r, maxLength: a = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, s)
      this.addMatch = (o, l, c, d) => s(d, c, c + o[0].length, o, l);
    else if (typeof i == "function")
      this.addMatch = (o, l, c, d) => {
        let p = i(o, l, c);
        p && d(c, c + o[0].length, p);
      };
    else if (i)
      this.addMatch = (o, l, c, d) => d(c, c + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new N1(), i = e.add.bind(e);
    for (let { from: s, to: r } of Z8(t, this.maxLength))
      nx(t.state.doc, this.regexp, s, r, (a, o) => this.addMatch(o, t, a, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, s = -1;
    return t.docChanged && t.changes.iterChanges((r, a, o, l) => {
      l >= t.view.viewport.from && o <= t.view.viewport.to && (i = Math.min(o, i), s = Math.max(l, s));
    }), t.viewportMoved || s - i > 1e3 ? this.createDeco(t.view) : s > -1 ? this.updateRange(t.view, e.map(t.changes), i, s) : e;
  }
  updateRange(t, e, i, s) {
    for (let r of t.visibleRanges) {
      let a = Math.max(r.from, i), o = Math.min(r.to, s);
      if (o >= a) {
        let l = t.state.doc.lineAt(a), c = l.to < o ? t.state.doc.lineAt(o) : l, d = Math.max(r.from, l.from), p = Math.min(r.to, c.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              d = a;
              break;
            }
          for (; o < c.to; o++)
            if (this.boundary.test(c.text[o - c.from])) {
              p = o;
              break;
            }
        }
        let f = [], m, w = /* @__PURE__ */ y((b, x, O) => f.push(O.range(b, x)), "add");
        if (l == c)
          for (this.regexp.lastIndex = d - l.from; (m = this.regexp.exec(l.text)) && m.index < p - l.from; )
            this.addMatch(m, t, m.index + l.from, w);
        else
          nx(t.state.doc, this.regexp, d, p, (b, x) => this.addMatch(x, t, b, w));
        e = e.update({ filterFrom: d, filterTo: p, filter: /* @__PURE__ */ y((b, x) => b < d || x > p, "filter"), add: f });
      }
    }
    return e;
  }
}, h(_h, "Qf"), _h);
y(W8, "MatchDecorator");
let uW = W8;
var Lh;
const D8 = (Lh = class extends by {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(t) {
    let e = t.firstChild ? Io(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), s = vy(e[0], i.direction != "rtl"), r = parseInt(i.lineHeight);
    return s.bottom - s.top > r * 1.5 ? { left: s.left, right: s.right, top: s.top, bottom: s.top + r } : s;
  }
  ignoreEvent() {
    return !1;
  }
}, h(Lh, "wf"), Lh);
y(D8, "Placeholder");
let pW = D8;
function fW(n) {
  let t = Ds.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = n ? Jt.set([Jt.widget({ widget: new pW(n), side: 1 }).range(0)]) : Jt.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Jt.none : this.placeholder;
    }
  }, { decorations: /* @__PURE__ */ y((e) => e.decorations, "decorations") });
  return typeof n == "string" ? [
    t,
    kt.contentAttributes.of({ "aria-placeholder": n })
  ] : t;
}
h(fW, "fy$1");
y(fW, "placeholder");
const _y = "-10000px";
var Ih;
const q8 = (Ih = class {
  constructor(t, e, i, s) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = s, this.input = t.state.facet(e), this.tooltips = this.input.filter((a) => a);
    let r = null;
    this.tooltipViews = this.tooltips.map((a) => r = i(a, r));
  }
  update(t, e) {
    var i;
    let s = t.state.facet(this.facet), r = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let a = [], o = e ? [] : null;
    for (let l = 0; l < r.length; l++) {
      let c = r[l], d = -1;
      if (c) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let f = this.tooltips[p];
          f && f.create == c.create && (d = p);
        }
        if (d < 0)
          a[l] = this.createTooltipView(c, l ? a[l - 1] : null), o && (o[l] = !!c.above);
        else {
          let p = a[l] = this.tooltipViews[d];
          o && (o[l] = e[d]), p.update && p.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return e && (o.forEach((l, c) => e[c] = l), e.length = o.length), this.input = s, this.tooltips = r, this.tooltipViews = a, !0;
  }
}, h(Ih, "xf"), Ih);
y(q8, "TooltipViewManager");
let yW = q8;
function V8(n) {
  let t = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: t.clientHeight, right: t.clientWidth };
}
h(V8, "cy$1");
y(V8, "windowSpace");
const gb = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => {
    var t, e, i;
    return {
      position: rt.ios ? "absolute" : ((t = n.find((s) => s.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = n.find((s) => s.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = n.find((s) => s.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || V8
    };
  }, "combine")
}), s4 = /* @__PURE__ */ new WeakMap(), j8 = /* @__PURE__ */ Ds.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = n.state.facet(gb);
    this.position = t.position, this.parent = t.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new yW(n, F8, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(n, this.above);
    t && this.observeIntersection();
    let e = t || n.geometryChanged, i = n.state.facet(gb);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(n, t) {
    let e = n.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", e.dom.appendChild(s);
    }
    return e.dom.style.position = this.position, e.dom.style.top = _y, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var n, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, t = 1, e = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (rt.gecko)
        e = r.offsetParent != this.container.ownerDocument.body;
      else if (r.style.top == _y && r.style.left == "0px") {
        let a = r.getBoundingClientRect();
        e = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      }
    }
    if (e || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (n = r.width / this.parent.offsetWidth, t = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: t } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), s = c0(this.view);
    return {
      visible: {
        left: i.left + s.left,
        top: i.top + s.top,
        right: i.right - s.right,
        bottom: i.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((r, a) => {
        let o = this.manager.tooltipViews[a];
        return o.getCoords ? o.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(gb).tooltipSpace(this.view),
      scaleX: n,
      scaleY: t,
      makeAbsolute: e
    };
  }
  writeMeasure(n) {
    var t;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { visible: e, space: i, scaleX: s, scaleY: r } = n, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let l = this.manager.tooltips[o], c = this.manager.tooltipViews[o], { dom: d } = c, p = n.pos[o], f = n.size[o];
      if (!p || l.clip !== !1 && (p.bottom <= Math.max(e.top, i.top) || p.top >= Math.min(e.bottom, i.bottom) || p.right < Math.max(e.left, i.left) - 0.1 || p.left > Math.min(e.right, i.right) + 0.1)) {
        d.style.top = _y;
        continue;
      }
      let m = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, w = m ? 7 : 0, b = f.right - f.left, x = (t = s4.get(c)) !== null && t !== void 0 ? t : f.bottom - f.top, O = c.offset || wW, P = this.view.textDirection == Pe.LTR, A = f.width > i.right - i.left ? P ? i.left : i.right - f.width : P ? Math.max(i.left, Math.min(p.left - (m ? 14 : 0) + O.x, i.right - b)) : Math.min(Math.max(i.left, p.left - b + (m ? 14 : 0) - O.x), i.right - b), R = this.above[o];
      !l.strictSide && (R ? p.top - x - w - O.y < i.top : p.bottom + x + w + O.y > i.bottom) && R == i.bottom - p.bottom > p.top - i.top && (R = this.above[o] = !R);
      let T = (R ? p.top - i.top : i.bottom - p.bottom) - w;
      if (T < x && c.resize !== !1) {
        if (T < this.view.defaultLineHeight) {
          d.style.top = _y;
          continue;
        }
        s4.set(c, x), d.style.height = (x = T) / r + "px";
      } else d.style.height && (d.style.height = "");
      let I = R ? p.top - x - w - O.y : p.bottom + w + O.y, Z = A + b;
      if (c.overlap !== !0)
        for (let W of a)
          W.left < Z && W.right > A && W.top < I + x && W.bottom > I && (I = R ? W.top - x - 2 - w : W.bottom + w + 2);
      if (this.position == "absolute" ? (d.style.top = (I - n.parent.top) / r + "px", sx(d, (A - n.parent.left) / s)) : (d.style.top = I / r + "px", sx(d, A / s)), m) {
        let W = p.left + (P ? O.x : -O.x) - (A + 14 - 7);
        m.style.left = W / s + "px";
      }
      c.overlap !== !0 && a.push({ left: A, top: I, right: Z, bottom: I + x }), d.classList.toggle("cm-tooltip-above", R), d.classList.toggle("cm-tooltip-below", !R), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = _y;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function sx(n, t) {
  let e = parseInt(n.style.left, 10);
  (isNaN(e) || Math.abs(t - e) > 1) && (n.style.left = t + "px");
}
h(sx, "gu$1");
y(sx, "setLeftStyle");
const mW = /* @__PURE__ */ kt.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), wW = { x: 0, y: 0 }, F8 = /* @__PURE__ */ gt.define({
  enables: [j8, mW]
});
function Q5(n, t) {
  let e = n.plugin(j8);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
h(Q5, "BO");
y(Q5, "getTooltip");
var Zh;
const U8 = (Zh = class extends Lo {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}, h(Zh, "Pf"), Zh);
y(U8, "GutterMarker");
let Uf = U8;
Uf.prototype.elementClass = "";
Uf.prototype.toDOM = void 0;
Uf.prototype.mapMode = mi.TrackBefore;
Uf.prototype.startSide = Uf.prototype.endSide = -1;
Uf.prototype.point = !0;
const B8 = 1024;
let gW = 0;
var Wh;
const X8 = (Wh = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, h(Wh, "kf"), Wh);
y(X8, "Range");
let tn = X8;
var Dh;
const N8 = (Dh = class {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = gW++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = Fe.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}, h(Dh, "Rf"), Dh);
y(N8, "NodeProp");
let xt = N8;
xt.closedBy = new xt({ deserialize: /* @__PURE__ */ y((n) => n.split(" "), "deserialize") });
xt.openedBy = new xt({ deserialize: /* @__PURE__ */ y((n) => n.split(" "), "deserialize") });
xt.group = new xt({ deserialize: /* @__PURE__ */ y((n) => n.split(" "), "deserialize") });
xt.isolate = new xt({ deserialize: /* @__PURE__ */ y((n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
}, "deserialize") });
xt.contextHash = new xt({ perNode: !0 });
xt.lookAhead = new xt({ perNode: !0 });
xt.mounted = new xt({ perNode: !0 });
var qh;
const H8 = (qh = class {
  constructor(t, e, i) {
    this.tree = t, this.overlay = e, this.parser = i;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[xt.mounted.id];
  }
}, h(qh, "$f"), qh);
y(H8, "MountedTree");
let fw = H8;
const vW = /* @__PURE__ */ Object.create(null);
var yo;
const Y8 = (yo = class {
  /**
  @internal
  */
  constructor(t, e, i, s = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : vW, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), s = new yo(t.name || "", e, t.id, i);
    if (t.props) {
      for (let r of t.props)
        if (Array.isArray(r) || (r = r(s)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[r[0].id] = r[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(xt.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let s of i.split(" "))
        e[s] = t[i];
    return (i) => {
      for (let s = i.prop(xt.group), r = -1; r < (s ? s.length : 0); r++) {
        let a = e[r < 0 ? i.name : s[r]];
        if (a)
          return a;
      }
    };
  }
}, h(yo, "io"), yo);
y(Y8, "NodeType");
let Fe = Y8;
Fe.none = new Fe(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var mo;
const G8 = (mo = class {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let s = null;
      for (let r of t) {
        let a = r(i);
        a && (s || (s = Object.assign({}, i.props)), s[a[0].id] = a[1]);
      }
      e.push(s ? new Fe(i.name, s, i.id, i.flags) : i);
    }
    return new mo(e);
  }
}, h(mo, "ro"), mo);
y(G8, "NodeSet");
let u0 = G8;
const Ag = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
var Yt;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Yt || (Yt = {}));
var _r;
const K8 = (_r = class {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, e, i, s, r) {
    if (this.type = t, this.children = e, this.positions = i, this.length = s, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of r)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = fw.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let s = i.toString();
      s && (e && (e += ","), e += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new sv(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, e = 0, i = 0) {
    let s = Ag.get(this) || this.topNode, r = new sv(s);
    return r.moveTo(t, e), Ag.set(this, r._tree), r;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new an(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, e = 0) {
    let i = Xf(Ag.get(this) || this.topNode, t, e, !1);
    return Ag.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, e = 0) {
    let i = Xf(r4.get(this) || this.topNode, t, e, !0);
    return r4.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, e = 0) {
    return o6(this, t, e);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: e, leave: i, from: s = 0, to: r = this.length } = t, a = t.mode || 0, o = (a & Yt.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Yt.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= r && l.to >= s && (!o && l.type.isAnonymous || e(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : f0(Fe.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, s) => new _r(this.type, e, i, s, this.propValues), t.makeTree || ((e, i, s) => new _r(Fe.none, e, i, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return c6(t);
  }
}, h(_r, "Er"), _r);
y(K8, "Tree");
let _t = K8;
_t.empty = new _t(Fe.none, [], [], 0);
var wo;
const J8 = (wo = class {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new wo(this.buffer, this.index);
  }
}, h(wo, "no"), wo);
y(J8, "FlatBufferCursor");
let bW = J8;
var go;
const t6 = (go = class {
  /**
  Create a tree buffer.
  */
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return Fe.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], s = this.set.types[e], r = s.name;
    if (/\W/.test(r) && !s.isError && (r = JSON.stringify(r)), t += 4, i == t)
      return r;
    let a = [];
    for (; t < i; )
      a.push(this.childString(t)), t = this.buffer[t + 3];
    return r + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, e, i, s, r) {
    let { buffer: a } = this, o = -1;
    for (let l = t; l != e && !(M5(r, s, a[l + 1], a[l + 2]) && (o = l, i > 0)); l = a[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(t, e, i) {
    let s = this.buffer, r = new Uint16Array(e - t), a = 0;
    for (let o = t, l = 0; o < e; ) {
      r[l++] = s[o++], r[l++] = s[o++] - i;
      let c = r[l++] = s[o++] - i;
      r[l++] = s[o++] - t, a = Math.max(a, c);
    }
    return new go(r, a, this.set);
  }
}, h(go, "so"), go);
y(t6, "TreeBuffer");
let Bf = t6;
function M5(n, t, e, i) {
  switch (n) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
h(M5, "NO");
y(M5, "checkSide");
function Xf(n, t, e, i) {
  for (var s; n.from == n.to || (e < 1 ? n.from >= t : n.from > t) || (e > -1 ? n.to <= t : n.to < t); ) {
    let a = !i && n instanceof an && n.index < 0 ? null : n.parent;
    if (!a)
      return n;
    n = a;
  }
  let r = i ? 0 : Yt.IgnoreOverlays;
  if (i)
    for (let a = n, o = a.parent; o; a = o, o = a.parent)
      a instanceof an && a.index < 0 && ((s = o.enter(t, e, r)) === null || s === void 0 ? void 0 : s.from) != a.from && (n = o);
  for (; ; ) {
    let a = n.enter(t, e, r);
    if (!a)
      return n;
    n = a;
  }
}
h(Xf, "nn$1");
y(Xf, "resolveNode");
var Vh;
const e6 = (Vh = class {
  cursor(t = 0) {
    return new sv(this, t);
  }
  getChild(t, e = null, i = null) {
    let s = rx(this, t, e, i);
    return s.length ? s[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return rx(this, t, e, i);
  }
  resolve(t, e = 0) {
    return Xf(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return Xf(this, t, e, !0);
  }
  matchContext(t) {
    return nv(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let e = this.childBefore(t), i = this;
    for (; e; ) {
      let s = e.lastChild;
      if (!s || s.to != e.to)
        break;
      s.type.isError && s.from == s.to ? (i = e, e = s.prevSibling) : e = s;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}, h(Vh, "vf"), Vh);
y(e6, "BaseNode");
let i6 = e6;
var Ls;
const n6 = (Ls = class extends i6 {
  constructor(t, e, i, s) {
    super(), this._tree = t, this.from = e, this.index = i, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, s, r = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: l } = a._tree, c = e > 0 ? o.length : -1; t != c; t += e) {
        let d = o[t], p = l[t] + a.from;
        if (M5(s, i, p, p + d.length)) {
          if (d instanceof Bf) {
            if (r & Yt.ExcludeBuffers)
              continue;
            let f = d.findChild(0, d.buffer.length, e, i - p, s);
            if (f > -1)
              return new yw(new OW(a, d, t, p), null, f);
          } else if (r & Yt.IncludeAnonymous || !d.type.isAnonymous || p0(d)) {
            let f;
            if (!(r & Yt.IgnoreMounts) && (f = fw.get(d)) && !f.overlay)
              return new Ls(f.tree, p, t, a);
            let m = new Ls(d, p, t, a);
            return r & Yt.IncludeAnonymous || !m.type.isAnonymous ? m : m.nextChild(e < 0 ? d.children.length - 1 : 0, e, i, s);
          }
        }
      }
      if (r & Yt.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? t = a.index + e : t = e < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    let s;
    if (!(i & Yt.IgnoreOverlays) && (s = fw.get(this._tree)) && s.overlay) {
      let r = t - this.from;
      for (let { from: a, to: o } of s.overlay)
        if ((e > 0 ? a <= r : a < r) && (e < 0 ? o >= r : o > r))
          return new Ls(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}, h(Ls, "wi"), Ls);
y(n6, "TreeNode");
let an = n6;
function rx(n, t, e, i) {
  let s = n.cursor(), r = [];
  if (!s.firstChild())
    return r;
  if (e != null) {
    for (let a = !1; !a; )
      if (a = s.type.is(e), !s.nextSibling())
        return r;
  }
  for (; ; ) {
    if (i != null && s.type.is(i))
      return r;
    if (s.type.is(t) && r.push(s.node), !s.nextSibling())
      return i == null ? r : [];
  }
}
h(rx, "bu$1");
y(rx, "getChildren");
function nv(n, t, e = t.length - 1) {
  for (let i = n; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
h(nv, "Fl$1");
y(nv, "matchNodeContext");
var jh;
const s6 = (jh = class {
  constructor(t, e, i, s) {
    this.parent = t, this.buffer = e, this.index = i, this.start = s;
  }
}, h(jh, "Tf"), jh);
y(s6, "BufferContext");
let OW = s6;
var Gn;
const r6 = (Gn = class extends i6 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, e, i) {
    super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, e, i) {
    let { buffer: s } = this.context, r = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.context.start, i);
    return r < 0 ? null : new Gn(this.context, this, r);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    if (i & Yt.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, r = s.findChild(this.index + 4, s.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return r < 0 ? null : new Gn(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Gn(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new Gn(this.context, this._parent, t.findChild(
      e,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, s = this.index + 4, r = i.buffer[this.index + 3];
    if (r > s) {
      let a = i.buffer[this.index + 1];
      t.push(i.slice(s, r, a)), e.push(0);
    }
    return new _t(this.type, t, e, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}, h(Gn, "Dt"), Gn);
y(r6, "BufferNode");
let yw = r6;
function T5(n) {
  if (!n.length)
    return null;
  let t = 0, e = n[0];
  for (let r = 1; r < n.length; r++) {
    let a = n[r];
    (a.from > e.from || a.to < e.to) && (e = a, t = r);
  }
  let i = e instanceof an && e.index < 0 ? null : e.parent, s = n.slice();
  return i ? s[t] = i : s.splice(t, 1), new $W(s, e);
}
h(T5, "GO");
y(T5, "iterStack");
var Fh;
const a6 = (Fh = class {
  constructor(t, e) {
    this.heads = t, this.node = e;
  }
  get next() {
    return T5(this.heads);
  }
}, h(Fh, "Af"), Fh);
y(a6, "StackIterator");
let $W = a6;
function o6(n, t, e) {
  let i = n.resolveInner(t, e), s = null;
  for (let r = i instanceof an ? i : i.context.parent; r; r = r.parent)
    if (r.index < 0) {
      let a = r.parent;
      (s || (s = [i])).push(a.resolve(t, e)), r = a;
    } else {
      let a = fw.get(r.tree);
      if (a && a.overlay && a.overlay[0].from <= t && a.overlay[a.overlay.length - 1].to >= t) {
        let o = new an(a.tree, a.overlay[0].from + r.from, -1, r);
        (s || (s = [i])).push(Xf(o, t, e, !1));
      }
    }
  return s ? T5(s) : i;
}
h(o6, "my$1");
y(o6, "stackIterator");
var Uh;
const l6 = (Uh = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, e = 0) {
    if (this.mode = e, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof an)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: s } = this.buffer;
    return this.type = e || s.set.types[s.buffer[t]], this.from = i + s.buffer[t + 1], this.to = i + s.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof an ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: s } = this.buffer, r = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.buffer.start, i);
    return r < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(r));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, e, i = this.mode) {
    return this.buffer ? i & Yt.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Yt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Yt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let s = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != s)
        return this.yieldBuf(e.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = e.buffer[this.index + 3];
      if (s < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(s);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: s } = this;
    if (s) {
      if (t > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let r = 0; r < this.index; r++)
          if (s.buffer.buffer[r + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = s);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let r = e + t, a = t < 0 ? -1 : i._tree.children.length; r != a; r += t) {
          let o = i._tree.children[r];
          if (this.mode & Yt.IncludeAnonymous || o instanceof Bf || !o.type.isAnonymous || p0(o))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer)
      t: for (let s = this.index, r = this.stack.length; r >= 0; ) {
        for (let a = t; a; a = a._parent)
          if (a.index == s) {
            if (s == this.index)
              return a;
            e = a, i = r + 1;
            break t;
          }
        s = this.stack[--r];
      }
    for (let s = i; s < this.stack.length; s++)
      e = new yw(this.buffer, e, this.stack[s]);
    return this.bufferNode = new yw(this.buffer, e, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, e) {
    for (let i = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && e && e(this), s = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return nv(this.node.parent, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let s = t.length - 1, r = this.stack.length - 1; s >= 0; r--) {
      if (r < 0)
        return nv(this._tree, t, s);
      let a = i[e.buffer[this.stack[r]]];
      if (!a.isAnonymous) {
        if (t[s] && t[s] != a.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}, h(Uh, "Zf"), Uh);
y(l6, "TreeCursor");
let sv = l6;
function p0(n) {
  return n.children.some((t) => t instanceof Bf || !t.type.isAnonymous || p0(t));
}
h(p0, "ah");
y(p0, "hasChild");
function c6(n) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: s = B8, reused: r = [], minRepeatType: a = i.types.length } = n, o = Array.isArray(e) ? new bW(e, e.length) : e, l = i.types, c = 0, d = 0;
  function p(T, I, Z, W, V, Y) {
    let { id: G, start: X, end: st, size: tt } = o, Qt = d, vt = c;
    for (; tt < 0; )
      if (o.next(), tt == -1) {
        let Ee = r[G];
        Z.push(Ee), W.push(X - T);
        return;
      } else if (tt == -3) {
        c = G;
        return;
      } else if (tt == -4) {
        d = G;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${tt}`);
    let It = l[G], Wt, Dt, bi = X - T;
    if (st - X <= s && (Dt = x(o.pos - I, V))) {
      let Ee = new Uint16Array(Dt.size - Dt.skip), le = o.pos - Dt.size, ee = Ee.length;
      for (; o.pos > le; )
        ee = O(Dt.start, Ee, ee);
      Wt = new Bf(Ee, st - Dt.start, i), bi = Dt.start - T;
    } else {
      let Ee = o.pos - tt;
      o.next();
      let le = [], ee = [], fe = G >= a ? G : -1, Oi = 0, _i = st;
      for (; o.pos > Ee; )
        fe >= 0 && o.id == fe && o.size >= 0 ? (o.end <= _i - s && (w(le, ee, X, Oi, o.end, _i, fe, Qt, vt), Oi = le.length, _i = o.end), o.next()) : Y > 2500 ? f(X, Ee, le, ee) : p(X, Ee, le, ee, fe, Y + 1);
      if (fe >= 0 && Oi > 0 && Oi < le.length && w(le, ee, X, Oi, X, _i, fe, Qt, vt), le.reverse(), ee.reverse(), fe > -1 && Oi > 0) {
        let Hi = m(It, vt);
        Wt = f0(It, le, ee, 0, le.length, 0, st - X, Hi, Hi);
      } else
        Wt = b(It, le, ee, st - X, Qt - st, vt);
    }
    Z.push(Wt), W.push(bi);
  }
  h(p, "u"), y(p, "takeNode");
  function f(T, I, Z, W) {
    let V = [], Y = 0, G = -1;
    for (; o.pos > I; ) {
      let { id: X, start: st, end: tt, size: Qt } = o;
      if (Qt > 4)
        o.next();
      else {
        if (G > -1 && st < G)
          break;
        G < 0 && (G = tt - s), V.push(X, st, tt), Y++, o.next();
      }
    }
    if (Y) {
      let X = new Uint16Array(Y * 4), st = V[V.length - 2];
      for (let tt = V.length - 3, Qt = 0; tt >= 0; tt -= 3)
        X[Qt++] = V[tt], X[Qt++] = V[tt + 1] - st, X[Qt++] = V[tt + 2] - st, X[Qt++] = Qt;
      Z.push(new Bf(X, V[2] - st, i)), W.push(st - T);
    }
  }
  h(f, "d"), y(f, "takeFlatNode");
  function m(T, I) {
    return (Z, W, V) => {
      let Y = 0, G = Z.length - 1, X, st;
      if (G >= 0 && (X = Z[G]) instanceof _t) {
        if (!G && X.type == T && X.length == V)
          return X;
        (st = X.prop(xt.lookAhead)) && (Y = W[G] + X.length + st);
      }
      return b(T, Z, W, V, Y, I);
    };
  }
  h(m, "O"), y(m, "makeBalanced");
  function w(T, I, Z, W, V, Y, G, X, st) {
    let tt = [], Qt = [];
    for (; T.length > W; )
      tt.push(T.pop()), Qt.push(I.pop() + Z - V);
    T.push(b(i.types[G], tt, Qt, Y - V, X - Y, st)), I.push(V - Z);
  }
  h(w, "p"), y(w, "makeRepeatLeaf");
  function b(T, I, Z, W, V, Y, G) {
    if (Y) {
      let X = [xt.contextHash, Y];
      G = G ? [X].concat(G) : [X];
    }
    if (V > 25) {
      let X = [xt.lookAhead, V];
      G = G ? [X].concat(G) : [X];
    }
    return new _t(T, I, Z, W, G);
  }
  h(b, "m"), y(b, "makeTree");
  function x(T, I) {
    let Z = o.fork(), W = 0, V = 0, Y = 0, G = Z.end - s, X = { size: 0, start: 0, skip: 0 };
    t: for (let st = Z.pos - T; Z.pos > st; ) {
      let tt = Z.size;
      if (Z.id == I && tt >= 0) {
        X.size = W, X.start = V, X.skip = Y, Y += 4, W += 4, Z.next();
        continue;
      }
      let Qt = Z.pos - tt;
      if (tt < 0 || Qt < st || Z.start < G)
        break;
      let vt = Z.id >= a ? 4 : 0, It = Z.start;
      for (Z.next(); Z.pos > Qt; ) {
        if (Z.size < 0)
          if (Z.size == -3)
            vt += 4;
          else
            break t;
        else Z.id >= a && (vt += 4);
        Z.next();
      }
      V = It, W += tt, Y += vt;
    }
    return (I < 0 || W == T) && (X.size = W, X.start = V, X.skip = Y), X.size > 4 ? X : void 0;
  }
  h(x, "y"), y(x, "findBufferSize");
  function O(T, I, Z) {
    let { id: W, start: V, end: Y, size: G } = o;
    if (o.next(), G >= 0 && W < a) {
      let X = Z;
      if (G > 4) {
        let st = o.pos - (G - 4);
        for (; o.pos > st; )
          Z = O(T, I, Z);
      }
      I[--Z] = X, I[--Z] = Y - T, I[--Z] = V - T, I[--Z] = W;
    } else G == -3 ? c = W : G == -4 && (d = W);
    return Z;
  }
  h(O, "b"), y(O, "copyToBuffer");
  let P = [], A = [];
  for (; o.pos > 0; )
    p(n.start || 0, n.bufferStart || 0, P, A, -1, 0);
  let R = (t = n.length) !== null && t !== void 0 ? t : P.length ? A[0] + P[0].length : 0;
  return new _t(l[n.topID], P.reverse(), A.reverse(), R);
}
h(c6, "gy$1");
y(c6, "buildTree");
const a4 = /* @__PURE__ */ new WeakMap();
function tw(n, t) {
  if (!n.isAnonymous || t instanceof Bf || t.type != n)
    return 1;
  let e = a4.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != n || !(i instanceof _t)) {
        e = 1;
        break;
      }
      e += tw(n, i);
    }
    a4.set(t, e);
  }
  return e;
}
h(tw, "Nn$1");
y(tw, "nodeSize");
function f0(n, t, e, i, s, r, a, o, l) {
  let c = 0;
  for (let w = i; w < s; w++)
    c += tw(n, t[w]);
  let d = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], f = [];
  function m(w, b, x, O, P) {
    for (let A = x; A < O; ) {
      let R = A, T = b[A], I = tw(n, w[A]);
      for (A++; A < O; A++) {
        let Z = tw(n, w[A]);
        if (I + Z >= d)
          break;
        I += Z;
      }
      if (A == R + 1) {
        if (I > d) {
          let Z = w[R];
          m(Z.children, Z.positions, 0, Z.children.length, b[R] + P);
          continue;
        }
        p.push(w[R]);
      } else {
        let Z = b[A - 1] + w[A - 1].length - T;
        p.push(f0(n, w, b, R, A, T, Z, null, l));
      }
      f.push(T + P - r);
    }
  }
  return h(m, "O"), y(m, "divide"), m(t, e, i, s, 0), (o || l)(p, f, a);
}
h(f0, "hh");
y(f0, "balanceRange");
var Bh;
const h6 = (Bh = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, e, i) {
    let s = this.map.get(t);
    s || this.map.set(t, s = /* @__PURE__ */ new Map()), s.set(e, i);
  }
  getBuffer(t, e) {
    let i = this.map.get(t);
    return i && i.get(e);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, e) {
    t instanceof yw ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof an && this.map.set(t.tree, e);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof yw ? this.getBuffer(t.context.buffer, t.index) : t instanceof an ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, e) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}, h(Bh, "Lf"), Bh);
y(h6, "NodeWeakMap");
let d6 = h6;
var Lr;
const u6 = (Lr = class {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, e, i, s, r = !1, a = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = s, this.open = (r ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, e = [], i = !1) {
    let s = [new Lr(0, t.length, t, 0, !1, i)];
    for (let r of e)
      r.to > t.length && s.push(r);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let s = [], r = 1, a = t.length ? t[0] : null;
    for (let o = 0, l = 0, c = 0; ; o++) {
      let d = o < e.length ? e[o] : null, p = d ? d.fromA : 1e9;
      if (p - l >= i)
        for (; a && a.from < p; ) {
          let f = a;
          if (l >= f.from || p <= f.to || c) {
            let m = Math.max(f.from, l) - c, w = Math.min(f.to, p) - c;
            f = m >= w ? null : new Lr(m, w, f.tree, f.offset + c, o > 0, !!d);
          }
          if (f && s.push(f), a.to > p)
            break;
          a = r < t.length ? t[r++] : null;
        }
      if (!d)
        break;
      l = d.toA, c = d.toA - d.toB;
    }
    return s;
  }
}, h(Lr, "Vr"), Lr);
y(u6, "TreeFragment");
let Zc = u6;
var Xh;
const p6 = (Xh = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, i) {
    return typeof t == "string" && (t = new xW(t)), i = i ? i.length ? i.map((s) => new tn(s.from, s.to)) : [new tn(0, 0)] : [new tn(0, t.length)], this.createParse(t, e || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, i) {
    let s = this.startParse(t, e, i);
    for (; ; ) {
      let r = s.advance();
      if (r)
        return r;
    }
  }
}, h(Xh, "Mf"), Xh);
y(p6, "Parser");
let y0 = p6;
var Nh;
const f6 = (Nh = class {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}, h(Nh, "_f"), Nh);
y(f6, "StringInput");
let xW = f6;
function A5(n) {
  return (t, e, i, s) => new SW(t, n, e, i, s);
}
h(A5, "HO");
y(A5, "parseMixed");
var Hh;
const y6 = (Hh = class {
  constructor(t, e, i, s, r) {
    this.parser = t, this.parse = e, this.overlay = i, this.target = s, this.from = r;
  }
}, h(Hh, "Cf"), Hh);
y(y6, "InnerParse");
let o4 = y6;
function ax(n) {
  if (!n.length || n.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
h(ax, "Qu$1");
y(ax, "checkRanges");
var Yh;
const m6 = (Yh = class {
  constructor(t, e, i, s, r, a, o) {
    this.parser = t, this.predicate = e, this.mounts = i, this.index = s, this.start = r, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
}, h(Yh, "Ef"), Yh);
y(m6, "ActiveOverlay");
let kW = m6;
const ox = new xt({ perNode: !0 });
var Gh;
const w6 = (Gh = class {
  constructor(t, e, i, s, r) {
    this.nest = e, this.input = i, this.fragments = s, this.ranges = r, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new _t(i.type, i.children, i.positions, i.length, i.propValues.concat([[ox, this.stoppedAt]]))), i;
    }
    let t = this.inner[this.innerDone], e = t.parse.advance();
    if (e) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      i[xt.mounted.id] = new fw(e, t.overlay, t.parser), t.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let e = this.innerDone; e < this.inner.length; e++)
      this.inner[e].from < t && (t = Math.min(t, this.inner[e].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let e = this.innerDone; e < this.inner.length; e++)
        this.inner[e].parse.stopAt(t);
  }
  startInner() {
    let t = new PW(this.fragments), e = null, i = null, s = new sv(new an(this.baseTree, this.ranges[0].from, 0, null), Yt.IncludeAnonymous | Yt.IgnoreMounts);
    t: for (let r, a; ; ) {
      let o = !0, l;
      if (this.stoppedAt != null && s.from >= this.stoppedAt)
        o = !1;
      else if (t.hasNode(s)) {
        if (e) {
          let c = e.mounts.find((d) => d.frag.from <= s.from && d.frag.to >= s.to && d.mount.overlay);
          if (c)
            for (let d of c.mount.overlay) {
              let p = d.from + c.pos, f = d.to + c.pos;
              p >= s.from && f <= s.to && !e.ranges.some((m) => m.from < f && m.to > p) && e.ranges.push({ from: p, to: f });
            }
        }
        o = !1;
      } else if (i && (a = g6(i.ranges, s.from, s.to)))
        o = a != 2;
      else if (!s.type.isAnonymous && (r = this.nest(s, this.input)) && (s.from < s.to || !r.overlay)) {
        s.tree || v6(s);
        let c = t.findMounts(s.from, r.parser);
        if (typeof r.overlay == "function")
          e = new kW(r.parser, r.overlay, c, this.inner.length, s.from, s.tree, e);
        else {
          let d = cx(this.ranges, r.overlay || (s.from < s.to ? [new tn(s.from, s.to)] : []));
          d.length && ax(d), (d.length || !r.overlay) && this.inner.push(new o4(r.parser, d.length ? r.parser.startParse(this.input, hx(c, d), d) : r.parser.startParse(""), r.overlay ? r.overlay.map((p) => new tn(p.from - s.from, p.to - s.from)) : null, s.tree, d.length ? d[0].from : s.from)), r.overlay ? d.length && (i = { ranges: d, depth: 0, prev: i }) : o = !1;
        }
      } else if (e && (l = e.predicate(s)) && (l === !0 && (l = new tn(s.from, s.to)), l.from < l.to)) {
        let c = e.ranges.length - 1;
        c >= 0 && e.ranges[c].to == l.from ? e.ranges[c] = { from: e.ranges[c].from, to: l.to } : e.ranges.push(l);
      }
      if (o && s.firstChild())
        e && e.depth++, i && i.depth++;
      else
        for (; !s.nextSibling(); ) {
          if (!s.parent())
            break t;
          if (e && !--e.depth) {
            let c = cx(this.ranges, e.ranges);
            c.length && (ax(c), this.inner.splice(e.index, 0, new o4(e.parser, e.parser.startParse(this.input, hx(e.mounts, c), c), e.ranges.map((d) => new tn(d.from - e.start, d.to - e.start)), e.target, c[0].from))), e = e.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}, h(Gh, "Vf"), Gh);
y(w6, "MixedParse");
let SW = w6;
function g6(n, t, e) {
  for (let i of n) {
    if (i.from >= e)
      break;
    if (i.to > t)
      return i.from <= t && i.to >= e ? 2 : 1;
  }
  return 0;
}
h(g6, "yy$1");
y(g6, "checkCover");
function lx(n, t, e, i, s, r) {
  if (t < e) {
    let a = n.buffer[t + 1];
    i.push(n.slice(t, e, a)), s.push(a - r);
  }
}
h(lx, "wu$1");
y(lx, "sliceBuf");
function v6(n) {
  let { node: t } = n, e = [], i = t.context.buffer;
  do
    e.push(n.index), n.parent();
  while (!n.tree);
  let s = n.tree, r = s.children.indexOf(i), a = s.children[r], o = a.buffer, l = [r];
  function c(d, p, f, m, w, b) {
    let x = e[b], O = [], P = [];
    lx(a, d, x, O, P, m);
    let A = o[x + 1], R = o[x + 2];
    l.push(O.length);
    let T = b ? c(x + 4, o[x + 3], a.set.types[o[x]], A, R - A, b - 1) : t.toTree();
    return O.push(T), P.push(A - m), lx(a, o[x + 3], p, O, P, m), new _t(f, O, P, w);
  }
  h(c, "h"), y(c, "split"), s.children[r] = c(0, o.length, Fe.none, 0, a.length, e.length - 1);
  for (let d of l) {
    let p = n.tree.children[d], f = n.tree.positions[d];
    n.yield(new an(p, f + n.from, d, n._tree));
  }
}
h(v6, "by$1");
y(v6, "materialize");
var Kh;
const b6 = (Kh = class {
  constructor(t, e) {
    this.offset = e, this.done = !1, this.cursor = t.cursor(Yt.IncludeAnonymous | Yt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: e } = this, i = t - this.offset;
    for (; !this.done && e.from < i; )
      e.to >= t && e.enter(i, 1, Yt.IgnoreOverlays | Yt.ExcludeBuffers) || e.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let e = this.cursor.tree; ; ) {
        if (e == t.tree)
          return !0;
        if (e.children.length && e.positions[0] == 0 && e.children[0] instanceof _t)
          e = e.children[0];
        else
          break;
      }
    return !1;
  }
}, h(Kh, "Uf"), Kh);
y(b6, "StructureCursor");
let l4 = b6;
var vb, Jh;
let PW = (vb = (Jh = class {
  constructor(t) {
    var e;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let i = this.curFrag = t[0];
      this.curTo = (e = i.tree.prop(ox)) !== null && e !== void 0 ? e : i.to, this.inner = new l4(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let e = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = e.tree.prop(ox)) !== null && t !== void 0 ? t : e.to, this.inner = new l4(e.tree, -e.offset);
    }
  }
  findMounts(t, e) {
    var i;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let r = this.inner.cursor.node; r; r = r.parent) {
        let a = (i = r.tree) === null || i === void 0 ? void 0 : i.prop(xt.mounted);
        if (a && a.parser == e)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= r.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: r.from - l.offset,
              mount: a
            });
          }
      }
    }
    return s;
  }
}, h(Jh, "Zi$1"), Jh), y(vb, "FragmentCursor"), vb);
function cx(n, t) {
  let e = null, i = t;
  for (let s = 1, r = 0; s < n.length; s++) {
    let a = n[s - 1].to, o = n[s].from;
    for (; r < i.length; r++) {
      let l = i[r];
      if (l.from >= o)
        break;
      l.to <= a || (e || (i = e = t.slice()), l.from < a ? (e[r] = new tn(l.from, a), l.to > o && e.splice(r + 1, 0, new tn(o, l.to))) : l.to > o ? e[r--] = new tn(o, l.to) : e.splice(r--, 1));
    }
  }
  return i;
}
h(cx, "xu$1");
y(cx, "punchRanges");
function O6(n, t, e, i) {
  let s = 0, r = 0, a = !1, o = !1, l = -1e9, c = [];
  for (; ; ) {
    let d = s == n.length ? 1e9 : a ? n[s].to : n[s].from, p = r == t.length ? 1e9 : o ? t[r].to : t[r].from;
    if (a != o) {
      let f = Math.max(l, e), m = Math.min(d, p, i);
      f < m && c.push(new tn(f, m));
    }
    if (l = Math.min(d, p), l == 1e9)
      break;
    d == l && (a ? (a = !1, s++) : a = !0), p == l && (o ? (o = !1, r++) : o = !0);
  }
  return c;
}
h(O6, "Qy$1");
y(O6, "findCoverChanges");
function hx(n, t) {
  let e = [];
  for (let { pos: i, mount: s, frag: r } of n) {
    let a = i + (s.overlay ? s.overlay[0].from : 0), o = a + s.tree.length, l = Math.max(r.from, a), c = Math.min(r.to, o);
    if (s.overlay) {
      let d = s.overlay.map((f) => new tn(f.from + i, f.to + i)), p = O6(t, d, l, c);
      for (let f = 0, m = l; ; f++) {
        let w = f == p.length, b = w ? c : p[f].from;
        if (b > m && e.push(new Zc(m, b, s.tree, -a, r.from >= m || r.openStart, r.to <= b || r.openEnd)), w)
          break;
        m = p[f].to;
      }
    } else
      e.push(new Zc(l, c, s.tree, -a, r.from >= a || r.openStart, r.to <= o || r.openEnd));
  }
  return e;
}
h(hx, "Pu$1");
y(hx, "enterFragments");
let CW = 0;
var Ir;
const $6 = (Ir = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.name = t, this.set = e, this.base = i, this.modified = s, this.id = CW++;
  }
  toString() {
    let { name: t } = this;
    for (let e of this.modified)
      e.name && (t = `${e.name}(${t})`);
    return t;
  }
  static define(t, e) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof Ir && (e = t), e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let s = new Ir(i, [], null, []);
    if (s.set.push(s), e)
      for (let r of e.set)
        s.set.push(r);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let e = new c4(t);
    return (i) => i.modified.indexOf(e) > -1 ? i : c4.get(i.base || i, i.modified.concat(e).sort((s, r) => s.id - r.id));
  }
}, h(Ir, "Ur"), Ir);
y($6, "Tag");
let Un = $6, QW = 0;
var vo;
const x6 = (vo = class {
  constructor(t) {
    this.name = t, this.instances = [], this.id = QW++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((o) => o.base == t && k6(e, o.modified));
    if (i)
      return i;
    let s = [], r = new Un(t.name, s, t, e);
    for (let o of e)
      o.instances.push(r);
    let a = S6(e);
    for (let o of t.set)
      if (!o.modified.length)
        for (let l of a)
          s.push(vo.get(o, l));
    return r;
  }
}, h(vo, "oo"), vo);
y(x6, "Modifier");
let c4 = x6;
function k6(n, t) {
  return n.length == t.length && n.every((e, i) => e == t[i]);
}
h(k6, "Py$1");
y(k6, "sameArray");
function S6(n) {
  let t = [[]];
  for (let e = 0; e < n.length; e++)
    for (let i = 0, s = t.length; i < s; i++)
      t.push(t[i].concat(n[e]));
  return t.sort((e, i) => i.length - e.length);
}
h(S6, "ky$1");
y(S6, "powerSet");
function al(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in n) {
    let i = n[e];
    Array.isArray(i) || (i = [i]);
    for (let s of e.split(" "))
      if (s) {
        let r = [], a = 2, o = s;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == s.length) {
            a = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!f)
            throw new RangeError("Invalid path: " + s);
          if (r.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), p += f[0].length, p == s.length)
            break;
          let m = s[p++];
          if (p == s.length && m == "!") {
            a = 0;
            break;
          }
          if (m != "/")
            throw new RangeError("Invalid path: " + s);
          o = s.slice(p);
        }
        let l = r.length - 1, c = r[l];
        if (!c)
          throw new RangeError("Invalid path: " + s);
        let d = new rv(i, a, l > 0 ? r.slice(0, l) : null);
        t[c] = d.sort(t[c]);
      }
  }
  return P6.add(t);
}
h(al, "Ji$1");
y(al, "styleTags");
const P6 = new xt();
var bb, td;
let rv = (bb = (td = class {
  constructor(t, e, i, s) {
    this.tags = t, this.mode = e, this.context = i, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}, h(td, "Li"), td), y(bb, "Rule"), bb);
rv.empty = new rv([], 2, null);
function R5(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r of n)
    if (!Array.isArray(r.tag))
      e[r.tag.id] = r.class;
    else
      for (let a of r.tag)
        e[a.id] = r.class;
  let { scope: i, all: s = null } = t || {};
  return {
    style: /* @__PURE__ */ y((r) => {
      let a = s;
      for (let o of r)
        for (let l of o.set) {
          let c = e[l.id];
          if (c) {
            a = a ? a + " " + c : c;
            break;
          }
        }
      return a;
    }, "style"),
    scope: i
  };
}
h(R5, "KO");
y(R5, "tagHighlighter");
function C6(n, t) {
  let e = null;
  for (let i of n) {
    let s = i.style(t);
    s && (e = e ? e + " " + s : s);
  }
  return e;
}
h(C6, "Ry$1");
y(C6, "highlightTags");
function Q6(n, t, e, i = 0, s = n.length) {
  let r = new MW(i, Array.isArray(t) ? t : [t], e);
  r.highlightRange(n.cursor(), i, s, "", r.highlighters), r.flush(s);
}
h(Q6, "$y$1");
y(Q6, "highlightTree");
var ed;
const M6 = (ed = class {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, s, r) {
    let { type: a, from: o, to: l } = t;
    if (o >= i || l <= e)
      return;
    a.isTop && (r = this.highlighters.filter((m) => !m.scope || m.scope(a)));
    let c = s, d = T6(t) || rv.empty, p = C6(r, d.tags);
    if (p && (c && (c += " "), c += p, d.mode == 1 && (s += (s ? " " : "") + p)), this.startSpan(Math.max(e, o), c), d.opaque)
      return;
    let f = t.tree && t.tree.prop(xt.mounted);
    if (f && f.overlay) {
      let m = t.node.enter(f.overlay[0].from + o, 1), w = this.highlighters.filter((x) => !x.scope || x.scope(f.tree.type)), b = t.firstChild();
      for (let x = 0, O = o; ; x++) {
        let P = x < f.overlay.length ? f.overlay[x] : null, A = P ? P.from + o : l, R = Math.max(e, O), T = Math.min(i, A);
        if (R < T && b)
          for (; t.from < T && (this.highlightRange(t, R, T, s, r), this.startSpan(Math.min(T, t.to), c), !(t.to >= A || !t.nextSibling())); )
            ;
        if (!P || A > i)
          break;
        O = P.to + o, O > e && (this.highlightRange(m.cursor(), Math.max(e, P.from + o), Math.min(i, O), "", w), this.startSpan(Math.min(i, O), c));
      }
      b && t.parent();
    } else if (t.firstChild()) {
      f && (s = "");
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, s, r), this.startSpan(Math.min(i, t.to), c);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}, h(ed, "Wf"), ed);
y(M6, "HighlightBuilder");
let MW = M6;
function T6(n) {
  let t = n.type.prop(P6);
  for (; t && t.context && !n.matchContext(t.context); )
    t = t.next;
  return t || null;
}
h(T6, "vy$1");
y(T6, "getStyleTags");
const K = Un.define, Rg = K(), pr = K(), h4 = K(pr), d4 = K(pr), fr = K(), Eg = K(fr), Ob = K(fr), qn = K(), $a = K(qn), Ln = K(), In = K(), dx = K(), Ly = K(dx), zg = K(), M = {
  /**
  A comment.
  */
  comment: Rg,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: K(Rg),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: K(Rg),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: K(Rg),
  /**
  Any kind of identifier.
  */
  name: pr,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: K(pr),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: h4,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: K(h4),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: d4,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: K(d4),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: K(pr),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: K(pr),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: K(pr),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: K(pr),
  /**
  A literal value.
  */
  literal: fr,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Eg,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: K(Eg),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: K(Eg),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: K(Eg),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Ob,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: K(Ob),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: K(Ob),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: K(fr),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: K(fr),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: K(fr),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: K(fr),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: K(fr),
  /**
  A language keyword.
  */
  keyword: Ln,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: K(Ln),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: K(Ln),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: K(Ln),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: K(Ln),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: K(Ln),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: K(Ln),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: K(Ln),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: K(Ln),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: K(Ln),
  /**
  An operator.
  */
  operator: In,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: K(In),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: K(In),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: K(In),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: K(In),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: K(In),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: K(In),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: K(In),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: K(In),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: K(In),
  /**
  Program or markup punctuation.
  */
  punctuation: dx,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: K(dx),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Ly,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: K(Ly),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: K(Ly),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: K(Ly),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: K(Ly),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: qn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: $a,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: K($a),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: K($a),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: K($a),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: K($a),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: K($a),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: K($a),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: K(qn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: K(qn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: K(qn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: K(qn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: K(qn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: K(qn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: K(qn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: K(qn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: K(),
  /**
  Deleted text.
  */
  deleted: K(),
  /**
  Changed text.
  */
  changed: K(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: K(),
  /**
  Metadata or meta-instruction.
  */
  meta: zg,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: K(zg),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: K(zg),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: K(zg),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Un.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Un.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Un.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Un.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Un.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Un.defineModifier("special")
};
for (let n in M) {
  let t = M[n];
  t instanceof Un && (t.name = n);
}
R5([
  { tag: M.link, class: "tok-link" },
  { tag: M.heading, class: "tok-heading" },
  { tag: M.emphasis, class: "tok-emphasis" },
  { tag: M.strong, class: "tok-strong" },
  { tag: M.keyword, class: "tok-keyword" },
  { tag: M.atom, class: "tok-atom" },
  { tag: M.bool, class: "tok-bool" },
  { tag: M.url, class: "tok-url" },
  { tag: M.labelName, class: "tok-labelName" },
  { tag: M.inserted, class: "tok-inserted" },
  { tag: M.deleted, class: "tok-deleted" },
  { tag: M.literal, class: "tok-literal" },
  { tag: M.string, class: "tok-string" },
  { tag: M.number, class: "tok-number" },
  { tag: [M.regexp, M.escape, M.special(M.string)], class: "tok-string2" },
  { tag: M.variableName, class: "tok-variableName" },
  { tag: M.local(M.variableName), class: "tok-variableName tok-local" },
  { tag: M.definition(M.variableName), class: "tok-variableName tok-definition" },
  { tag: M.special(M.variableName), class: "tok-variableName2" },
  { tag: M.definition(M.propertyName), class: "tok-propertyName tok-definition" },
  { tag: M.typeName, class: "tok-typeName" },
  { tag: M.namespace, class: "tok-namespace" },
  { tag: M.className, class: "tok-className" },
  { tag: M.macroName, class: "tok-macroName" },
  { tag: M.propertyName, class: "tok-propertyName" },
  { tag: M.operator, class: "tok-operator" },
  { tag: M.comment, class: "tok-comment" },
  { tag: M.meta, class: "tok-meta" },
  { tag: M.invalid, class: "tok-invalid" },
  { tag: M.punctuation, class: "tok-punctuation" }
]);
var $b;
const br = /* @__PURE__ */ new xt();
function Kw(n) {
  return gt.define({
    combine: n ? (t) => t.concat(n) : void 0
  });
}
h(Kw, "bo$1");
y(Kw, "defineLanguageFacet");
const E5 = /* @__PURE__ */ new xt();
var id;
const A6 = (id = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, e, i = [], s = "") {
    this.data = t, this.name = s, ze.prototype.hasOwnProperty("tree") || Object.defineProperty(ze.prototype, "tree", { get() {
      return ce(this);
    } }), this.parser = e, this.extension = [
      Nf.of(this),
      ze.languageData.of((r, a, o) => {
        let l = ux(r, a, o), c = l.type.prop(br);
        if (!c)
          return [];
        let d = r.facet(c), p = l.type.prop(E5);
        if (p) {
          let f = l.resolve(a - l.from, o);
          for (let m of p)
            if (m.test(f, r)) {
              let w = r.facet(m.facet);
              return m.type == "replace" ? w : w.concat(d);
            }
        }
        return d;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, e, i = -1) {
    return ux(t, e, i).type.prop(br) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let e = t.facet(Nf);
    if ((e == null ? void 0 : e.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], s = /* @__PURE__ */ y((r, a) => {
      if (r.prop(br) == this.data) {
        i.push({ from: a, to: a + r.length });
        return;
      }
      let o = r.prop(xt.mounted);
      if (o) {
        if (o.tree.prop(br) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + a, to: l.to + a });
          else
            i.push({ from: a, to: a + r.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (s(o.tree, o.overlay[0].from + a), i.length > l)
            return;
        }
      }
      for (let l = 0; l < r.children.length; l++) {
        let c = r.children[l];
        c instanceof _t && s(c, r.positions[l] + a);
      }
    }, "explore");
    return s(ce(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}, h(id, "Xf"), id);
y(A6, "Language");
let Fi = A6;
Fi.setState = /* @__PURE__ */ Bt.define();
function ux(n, t, e) {
  let i = n.facet(Nf), s = ce(n).topNode;
  if (!i || i.allowsNesting)
    for (let r = s; r; r = r.enter(t, e, Yt.ExcludeBuffers))
      r.type.isTop && (s = r);
  return s;
}
h(ux, "$u$1");
y(ux, "topNodeAt");
var Zr;
const R6 = (Zr = class extends Fi {
  constructor(t, e, i) {
    super(t, e, [], i), this.parser = e;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let e = Kw(t.languageData);
    return new Zr(e, t.parser.configure({
      props: [br.add((i) => i.isTop ? e : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, e) {
    return new Zr(this.data, this.parser.configure(t), e || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}, h(Zr, "Wr"), Zr);
y(R6, "LRLanguage");
let z5 = R6;
function ce(n) {
  let t = n.field(Fi.state, !1);
  return t ? t.tree : _t.empty;
}
h(ce, "J$1");
y(ce, "syntaxTree");
var nd;
const E6 = (nd = class {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}, h(nd, "Yf"), nd);
y(E6, "DocInput");
let TW = E6, Iy = null;
var Wr;
const z6 = (Wr = class {
  constructor(t, e, i = [], s, r, a, o, l) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = s, this.treeLen = r, this.viewport = a, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Wr(t, e, [], _t.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new TW(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != _t.empty && this.isDone(e ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let s = Date.now() + t;
        t = /* @__PURE__ */ y(() => Date.now() > s, "until");
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(Zc.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (e ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(Zc.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = Iy;
    Iy = this;
    try {
      return t();
    } finally {
      Iy = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = px(t, e.from, e.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, e) {
    let { fragments: i, tree: s, treeLen: r, viewport: a, skipped: o } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((c, d, p, f) => l.push({ fromA: c, toA: d, fromB: p, toB: f })), i = Zc.applyChanges(i, l), s = _t.empty, r = 0, a = { from: t.mapPos(a.from, -1), to: t.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let c of this.skipped) {
          let d = t.mapPos(c.from, 1), p = t.mapPos(c.to, -1);
          d < p && o.push({ from: d, to: p });
        }
      }
    }
    return new Wr(this.parser, e, i, s, r, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: s, to: r } = this.skipped[i];
      s < t.to && r > t.from && (this.fragments = px(this.fragments, s, r), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends y0 {
      createParse(e, i, s) {
        let r = s[0].from, a = s[s.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let o = Iy;
            if (o) {
              for (let l of s)
                o.tempSkipped.push(l);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = a, new _t(Fe.none, [], [], a - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Iy;
  }
}, h(Wr, "Xr"), Wr);
y(z6, "ParseContext");
let av = z6;
function px(n, t, e) {
  return Zc.applyChanges(n, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
h(px, "vu$1");
y(px, "cutFragments");
var Dr;
const _6 = (Dr = class {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new Dr(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = av.create(t.facet(Nf).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new Dr(i);
  }
}, h(Dr, "Yr"), Dr);
y(_6, "LanguageState");
let fx = _6;
Fi.state = /* @__PURE__ */ Hs.define({
  create: fx.init,
  update(n, t) {
    for (let e of t.effects)
      if (e.is(Fi.setState))
        return e.value;
    return t.startState.facet(Nf) != t.state.facet(Nf) ? fx.init(t.state) : n.apply(t);
  }
});
let L6 = /* @__PURE__ */ y((n) => {
  let t = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
}, "requestIdle");
typeof requestIdleCallback < "u" && (L6 = /* @__PURE__ */ y((n) => {
  let t = -1, e = setTimeout(
    () => {
      t = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
}, "requestIdle"));
const xb = typeof navigator < "u" && !(($b = navigator.scheduling) === null || $b === void 0) && $b.isInputPending ? () => navigator.scheduling.isInputPending() : null;
var kb, sd;
const AW = /* @__PURE__ */ Ds.fromClass((kb = (sd = class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Fi.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Fi.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = L6(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: s } } = this.view, r = i.field(Fi.state);
    if (r.tree == r.context.tree && r.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, t && !xb ? Math.max(25, t.timeRemaining() - 5) : 1e9), o = r.context.treeLen < s && i.doc.length > s + 1e3, l = r.context.work(() => xb && xb() || Date.now() > a, s + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (l || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: Fi.setState.of(new fx(r.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Ci(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, h(sd, "Mi$1"), sd), y(kb, "ParseWorker"), kb), {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Nf = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: /* @__PURE__ */ y((n) => [
    Fi.state,
    AW,
    kt.contentAttributes.compute([n], (t) => {
      let e = t.facet(n);
      return e && e.name ? { "data-language": e.name } : {};
    })
  ], "enables")
});
var rd;
const I6 = (rd = class {
  /**
  Create a language support object.
  */
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}, h(rd, "If"), rd);
y(I6, "LanguageSupport");
let Hf = I6;
var bo;
const Z6 = (bo = class {
  constructor(t, e, i, s, r, a = void 0) {
    this.name = t, this.alias = e, this.extensions = i, this.filename = s, this.loadFunc = r, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((t) => this.support = t, (t) => {
      throw this.loading = null, t;
    }));
  }
  /**
  Create a language description.
  */
  static of(t) {
    let { load: e, support: i } = t;
    if (!e) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      e = /* @__PURE__ */ y(() => Promise.resolve(i), "load");
    }
    return new bo(t.name, (t.alias || []).concat(t.name).map((s) => s.toLowerCase()), t.extensions || [], t.filename, e, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(t, e) {
    for (let s of t)
      if (s.filename && s.filename.test(e))
        return s;
    let i = /\.([^.]+)$/.exec(e);
    if (i) {
      for (let s of t)
        if (s.extensions.indexOf(i[1]) > -1)
          return s;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(t, e, i = !0) {
    e = e.toLowerCase();
    for (let s of t)
      if (s.alias.some((r) => r == e))
        return s;
    if (i)
      for (let s of t)
        for (let r of s.alias) {
          let a = e.indexOf(r);
          if (a > -1 && (r.length > 2 || !/\w/.test(e[a - 1]) && !/\w/.test(e[a + r.length])))
            return s;
        }
    return null;
  }
}, h(bo, "lo"), bo);
y(Z6, "LanguageDescription");
let u4 = Z6;
const RW = /* @__PURE__ */ gt.define(), m0 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ y((n) => {
    if (!n.length)
      return "  ";
    let t = n[0];
    if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return t;
  }, "combine")
});
function mw(n) {
  let t = n.facet(m0);
  return t.charCodeAt(0) == 9 ? n.tabSize * t.length : t.length;
}
h(mw, "li$1");
y(mw, "getIndentUnit");
function yx(n, t) {
  let e = "", i = n.tabSize, s = n.facet(m0)[0];
  if (s == "	") {
    for (; t >= i; )
      e += "	", t -= i;
    s = " ";
  }
  for (let r = 0; r < t; r++)
    e += s;
  return e;
}
h(yx, "bs$1");
y(yx, "indentString");
function W6(n, t) {
  n instanceof ze && (n = new _5(n));
  for (let i of n.state.facet(RW)) {
    let s = i(n, t);
    if (s !== void 0)
      return s;
  }
  let e = ce(n.state);
  return e.length >= t ? q6(n, e, t) : null;
}
h(W6, "ep$1");
y(W6, "getIndentation");
var ad;
const D6 = (ad = class {
  /**
  Create an indent context.
  */
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = mw(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: s, simulateDoubleBreak: r } = this.options;
    return s != null && s >= i.from && s <= i.to ? r && s == t ? { text: "", from: t } : (e < 0 ? s < t : s <= t) ? { text: i.text.slice(s - i.from), from: s } : { text: i.text.slice(0, s - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: s } = this.lineAt(t, e);
    return i.slice(t - s, Math.min(i.length, t + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), r = this.countColumn(i, t - s), a = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return a > -1 && (r += a - this.countColumn(i, i.search(/\S|$/))), r;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, e = t.length) {
    return Br(t, this.state.tabSize, e);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), r = this.options.overrideIndentation;
    if (r) {
      let a = r(s);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}, h(ad, "jf"), ad);
y(D6, "IndentContext");
let _5 = D6;
const Oy = /* @__PURE__ */ new xt();
function q6(n, t, e) {
  let i = t.resolveStack(e), s = t.resolveInner(e, -1).resolve(e, 0).enterUnfinishedNodesBefore(e);
  if (s != i.node) {
    let r = [];
    for (let a = s; a && !(a.from < i.node.from || a.to > i.node.to || a.from == i.node.from && a.type == i.node.type); a = a.parent)
      r.push(a);
    for (let a = r.length - 1; a >= 0; a--)
      i = { node: r[a], next: i };
  }
  return L5(i, n, e);
}
h(q6, "Zy$1");
y(q6, "syntaxIndentation");
function L5(n, t, e) {
  for (let i = n; i; i = i.next) {
    let s = j6(i.node);
    if (s)
      return s(EW.create(t, e, i));
  }
  return 0;
}
h(L5, "tp$1");
y(L5, "indentFor");
function V6(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
h(V6, "Ly$1");
y(V6, "ignoreClosed");
function j6(n) {
  let t = n.type.prop(Oy);
  if (t)
    return t;
  let e = n.firstChild, i;
  if (e && (i = e.type.prop(xt.closedBy))) {
    let s = n.lastChild, r = s && i.indexOf(s.name) > -1;
    return (a) => I5(a, !0, 1, void 0, r && !V6(a) ? s.from : void 0);
  }
  return n.parent == null ? F6 : null;
}
h(j6, "My$1");
y(j6, "indentStrategy");
function F6() {
  return 0;
}
h(F6, "_y$1");
y(F6, "topIndent");
var Oo;
const U6 = (Oo = class extends _5 {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Oo(t, e, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let e = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (B6(i, t))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return L5(this.context.next, this.base, this.pos);
  }
}, h(Oo, "ao"), Oo);
y(U6, "TreeIndentContext");
let EW = U6;
function B6(n, t) {
  for (let e = t; e; e = e.parent)
    if (n == e)
      return !0;
  return !1;
}
h(B6, "Cy$1");
y(B6, "isParent");
function X6(n) {
  let t = n.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let s = n.options.simulateBreak, r = n.state.doc.lineAt(e.from), a = s == null || s <= r.from ? r.to : Math.min(r.to, s);
  for (let o = e.to; ; ) {
    let l = t.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= a)
        return null;
      let c = /^ */.exec(r.text.slice(e.to - r.from))[0].length;
      return { from: e.from, to: e.to + c };
    }
    o = l.to;
  }
}
h(X6, "Ey$1");
y(X6, "bracketedAligned");
function N6({ closing: n, align: t = !0, units: e = 1 }) {
  return (i) => I5(i, t, e, n);
}
h(N6, "Vy$1");
y(N6, "delimitedIndent");
function I5(n, t, e, i, s) {
  let r = n.textAfter, a = r.match(/^\s*/)[0].length, o = i && r.slice(a, a + i.length) == i || s == n.pos + a, l = t ? X6(n) : null;
  return l ? o ? n.column(l.from) : n.column(l.to) : n.baseIndent + (o ? 0 : n.unit * e);
}
h(I5, "ip$1");
y(I5, "delimitedStrategy");
const zW = /* @__PURE__ */ y((n) => n.baseIndent, "flatIndent");
function ew({ except: n, units: t = 1 } = {}) {
  return (e) => {
    let i = n && n.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
h(ew, "Gn$1");
y(ew, "continuedIndent");
const _W = /* @__PURE__ */ gt.define(), Jw = /* @__PURE__ */ new xt();
function Z5(n) {
  let t = n.firstChild, e = n.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? n.to : e.from } : null;
}
h(Z5, "rp$1");
y(Z5, "foldInside");
var $o;
const H6 = ($o = class {
  constructor(t, e) {
    this.specs = t;
    let i;
    function s(o) {
      let l = Xr.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    h(s, "n"), y(s, "def");
    const r = typeof e.all == "string" ? e.all : e.all ? s(e.all) : void 0, a = e.scope;
    this.scope = a instanceof Fi ? (o) => o.prop(br) == a.data : a ? (o) => o == a : void 0, this.style = R5(t.map((o) => ({
      tag: o.tag,
      class: o.class || s(Object.assign({}, o, { tag: null }))
    })), {
      all: r
    }).style, this.module = i ? new Xr(i) : null, this.themeType = e.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, e) {
    return new $o(t, e || {});
  }
}, h($o, "ho"), $o);
y(H6, "HighlightStyle");
let Y6 = H6;
const mx = /* @__PURE__ */ gt.define(), G6 = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function i1(n) {
  let t = n.facet(mx);
  return t.length ? t : n.facet(G6);
}
h(i1, "Co$1");
y(i1, "getHighlighters");
function LW(n, t) {
  let e = [ZW], i;
  return n instanceof Y6 && (n.module && e.push(kt.styleModule.of(n.module)), i = n.themeType), t != null && t.fallback ? e.push(G6.of(n)) : i ? e.push(mx.computeN([kt.darkTheme], (s) => s.facet(kt.darkTheme) == (i == "dark") ? [n] : [])) : e.push(mx.of(n)), e;
}
h(LW, "Xy$1");
y(LW, "syntaxHighlighting");
var od;
const K6 = (od = class {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ce(t.state), this.decorations = this.buildDeco(t, i1(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let e = ce(t.state), i = i1(t.state), s = i != i1(t.startState), { viewport: r } = t.view, a = t.changes.mapPos(this.decoratedTo, 1);
    e.length < r.to && !s && e.type == this.tree.type && a >= r.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = a) : (e != this.tree || t.viewportChanged || s) && (this.tree = e, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = r.to);
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return Jt.none;
    let i = new N1();
    for (let { from: s, to: r } of t.visibleRanges)
      Q6(this.tree, e, (a, o, l) => {
        i.add(a, o, this.markCache[l] || (this.markCache[l] = Jt.mark({ class: l })));
      }, s, r);
    return i.finish();
  }
}, h(od, "qf"), od);
y(K6, "TreeHighlighter");
let IW = K6;
const ZW = /* @__PURE__ */ rl.high(/* @__PURE__ */ Ds.fromClass(IW, {
  decorations: /* @__PURE__ */ y((n) => n.decorations, "decorations")
})), WW = 1e4, DW = "()[]{}", J6 = /* @__PURE__ */ new xt();
function ov(n, t, e) {
  let i = n.prop(t < 0 ? xt.openedBy : xt.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let s = e.indexOf(n.name);
    if (s > -1 && s % 2 == (t < 0 ? 1 : 0))
      return [e[s + t]];
  }
  return null;
}
h(ov, "fa$1");
y(ov, "matchingNodes");
function lv(n) {
  let t = n.type.prop(J6);
  return t ? t(n.node) : n;
}
h(lv, "ca$1");
y(lv, "findHandle");
function Va(n, t, e, i = {}) {
  let s = i.maxScanDistance || WW, r = i.brackets || DW, a = ce(n), o = a.resolveInner(t, e);
  for (let l = o; l; l = l.parent) {
    let c = ov(l.type, e, r);
    if (c && l.from < l.to) {
      let d = lv(l);
      if (d && (e > 0 ? t >= d.from && t < d.to : t > d.from && t <= d.to))
        return tM(n, t, e, l, d, c, r);
    }
  }
  return eM(n, t, e, a, o.type, s, r);
}
h(Va, "gi$1");
y(Va, "matchBrackets");
function tM(n, t, e, i, s, r, a) {
  let o = i.parent, l = { from: s.from, to: s.to }, c = 0, d = o == null ? void 0 : o.cursor();
  if (d && (e < 0 ? d.childBefore(i.from) : d.childAfter(i.to)))
    do
      if (e < 0 ? d.to <= i.from : d.from >= i.to) {
        if (c == 0 && r.indexOf(d.type.name) > -1 && d.from < d.to) {
          let p = lv(d);
          return { start: l, end: p ? { from: p.from, to: p.to } : void 0, matched: !0 };
        } else if (ov(d.type, e, a))
          c++;
        else if (ov(d.type, -e, a)) {
          if (c == 0) {
            let p = lv(d);
            return {
              start: l,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (e < 0 ? d.prevSibling() : d.nextSibling());
  return { start: l, matched: !1 };
}
h(tM, "qy$1");
y(tM, "matchMarkedBrackets");
function eM(n, t, e, i, s, r, a) {
  let o = e < 0 ? n.sliceDoc(t - 1, t) : n.sliceDoc(t, t + 1), l = a.indexOf(o);
  if (l < 0 || l % 2 == 0 != e > 0)
    return null;
  let c = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, d = n.doc.iterRange(t, e > 0 ? n.doc.length : 0), p = 0;
  for (let f = 0; !d.next().done && f <= r; ) {
    let m = d.value;
    e < 0 && (f += m.length);
    let w = t + f * e;
    for (let b = e > 0 ? 0 : m.length - 1, x = e > 0 ? m.length : -1; b != x; b += e) {
      let O = a.indexOf(m[b]);
      if (!(O < 0 || i.resolveInner(w + b, 1).type != s))
        if (O % 2 == 0 == e > 0)
          p++;
        else {
          if (p == 1)
            return { start: c, end: { from: w + b, to: w + b + 1 }, matched: O >> 1 == l >> 1 };
          p--;
        }
    }
    e > 0 && (f += m.length);
  }
  return d.done ? { start: c, matched: !1 } : null;
}
h(eM, "Dy$1");
y(eM, "matchPlainBrackets");
function wx(n, t, e, i = 0, s = 0) {
  t == null && (t = n.search(/[^\s\u00a0]/), t == -1 && (t = n.length));
  let r = s;
  for (let a = i; a < t; a++)
    n.charCodeAt(a) == 9 ? r += e - r % e : r++;
  return r;
}
h(wx, "Tu$1");
y(wx, "countCol");
var ld;
const iM = (ld = class {
  /**
  Create a stream.
  */
  constructor(t, e, i, s) {
    this.string = t, this.tabSize = e, this.indentUnit = i, this.overrideIndent = s, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(t) {
    let e = this.string.charAt(this.pos), i;
    if (typeof t == "string" ? i = e == t : i = e && (t instanceof RegExp ? t.test(e) : t(e)), i)
      return ++this.pos, e;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(t) {
    let e = this.pos;
    for (; this.eat(t); )
      ;
    return this.pos > e;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let t = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > t;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(t) {
    let e = this.string.indexOf(t, this.pos);
    if (e > -1)
      return this.pos = e, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(t) {
    this.pos -= t;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = wx(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var t;
    return (t = this.overrideIndent) !== null && t !== void 0 ? t : wx(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(t, e, i) {
    if (typeof t == "string") {
      let s = /* @__PURE__ */ y((a) => i ? a.toLowerCase() : a, "cased"), r = this.string.substr(this.pos, t.length);
      return s(r) == s(t) ? (e !== !1 && (this.pos += t.length), !0) : null;
    } else {
      let s = this.string.slice(this.pos).match(t);
      return s && s.index > 0 ? null : (s && e !== !1 && (this.pos += s[0].length), s);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}, h(ld, "Df"), ld);
y(iM, "StringStream");
let nM = iM;
function sM(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || rM,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || q5,
    mergeTokens: n.mergeTokens !== !1
  };
}
h(sM, "By$1");
y(sM, "fullParser");
function rM(n) {
  if (typeof n != "object")
    return n;
  let t = {};
  for (let e in n) {
    let i = n[e];
    t[e] = i instanceof Array ? i.slice() : i;
  }
  return t;
}
h(rM, "zy$1");
y(rM, "defaultCopyState");
const p4 = /* @__PURE__ */ new WeakMap();
var xo;
const aM = (xo = class extends Fi {
  constructor(t) {
    let e = Kw(t.languageData), i = sM(t), s, r = new class extends y0 {
      createParse(a, o, l) {
        return new VW(s, a, o, l);
      }
    }();
    super(e, r, [], t.name), this.topNode = dM(e, this), s = this, this.streamParser = i, this.stateAfter = new xt({ perNode: !0 }), this.tokenTable = t.tokenTable ? new hM(i.tokenTable) : FW;
  }
  /**
  Define a stream language.
  */
  static define(t) {
    return new xo(t);
  }
  /**
  @internal
  */
  getIndent(t) {
    let e, { overrideIndentation: i } = t.options;
    i && (e = p4.get(t.state), e != null && e < t.pos - 1e4 && (e = void 0));
    let s = w0(this, t.node.tree, t.node.from, t.node.from, e ?? t.pos), r, a;
    if (s ? (a = s.state, r = s.pos + 1) : (a = this.streamParser.startState(t.unit), r = t.node.from), t.pos - r > 1e4)
      return null;
    for (; r < t.pos; ) {
      let l = t.state.doc.lineAt(r), c = Math.min(t.pos, l.to);
      if (l.length) {
        let d = i ? i(l.from) : -1, p = new nM(l.text, t.state.tabSize, t.unit, d < 0 ? void 0 : d);
        for (; p.pos < c - l.from; )
          D5(this.streamParser.token, p, a);
      } else
        this.streamParser.blankLine(a, t.unit);
      if (c == t.pos)
        break;
      r = l.to + 1;
    }
    let o = t.lineAt(t.pos);
    return i && e == null && p4.set(t.state, o.from), this.streamParser.indent(a, /^\s*(.*)/.exec(o.text)[1], t);
  }
  get allowsNesting() {
    return !1;
  }
}, h(xo, "fo"), xo);
y(aM, "StreamLanguage");
let qW = aM;
function w0(n, t, e, i, s) {
  let r = e >= i && e + t.length <= s && t.prop(n.stateAfter);
  if (r)
    return { state: n.streamParser.copyState(r), pos: e + t.length };
  for (let a = t.children.length - 1; a >= 0; a--) {
    let o = t.children[a], l = e + t.positions[a], c = o instanceof _t && l < s && w0(n, o, l, i, s);
    if (c)
      return c;
  }
  return null;
}
h(w0, "ch");
y(w0, "findState");
function W5(n, t, e, i, s) {
  if (s && e <= 0 && i >= t.length)
    return t;
  !s && e == 0 && t.type == n.topNode && (s = !0);
  for (let r = t.children.length - 1; r >= 0; r--) {
    let a = t.positions[r], o = t.children[r], l;
    if (a < i && o instanceof _t) {
      if (!(l = W5(n, o, e - a, i - a, s)))
        break;
      return s ? new _t(t.type, t.children.slice(0, r).concat(l), t.positions.slice(0, r + 1), a + l.length) : l;
    }
  }
  return null;
}
h(W5, "op$1");
y(W5, "cutTree");
function oM(n, t, e, i, s) {
  for (let r of t) {
    let a = r.from + (r.openStart ? 25 : 0), o = r.to - (r.openEnd ? 25 : 0), l = a <= e && o > e && w0(n, r.tree, 0 - r.offset, e, o), c;
    if (l && l.pos <= i && (c = W5(n, r.tree, e + r.offset, l.pos + r.offset, !1)))
      return { state: l.state, tree: c };
  }
  return { state: n.streamParser.startState(s ? mw(s) : 4), tree: _t.empty };
}
h(oM, "Ny$1");
y(oM, "findStartInFragments");
var Sb, cd;
let VW = (Sb = (cd = class {
  constructor(t, e, i, s) {
    this.lang = t, this.input = e, this.fragments = i, this.ranges = s, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = s[s.length - 1].to;
    let r = av.get(), a = s[0].from, { state: o, tree: l } = oM(t, i, a, this.to, r == null ? void 0 : r.state);
    this.state = o, this.parsedPos = this.chunkStart = a + l.length;
    for (let c = 0; c < l.children.length; c++)
      this.chunks.push(l.children[c]), this.chunkPos.push(l.positions[c]);
    r && this.parsedPos < r.viewport.from - 1e5 && s.some((c) => c.from <= r.viewport.from && c.to >= r.viewport.from) && (this.state = this.lang.streamParser.startState(mw(r.state)), r.skipUntilInView(this.parsedPos, r.viewport.from), this.parsedPos = r.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let t = av.get(), e = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      e,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    for (t && (i = Math.min(i, t.viewport.to)); this.parsedPos < i; )
      this.parseLine(t);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= e ? this.finish() : t && this.parsedPos >= t.viewport.to ? (t.skipUntilInView(this.parsedPos, e), this.finish()) : null;
  }
  stopAt(t) {
    this.stoppedAt = t;
  }
  lineAfter(t) {
    let e = this.input.chunk(t);
    if (this.input.lineChunks)
      e == `
` && (e = "");
    else {
      let i = e.indexOf(`
`);
      i > -1 && (e = e.slice(0, i));
    }
    return t + e.length <= this.to ? e : e.slice(0, this.to - t);
  }
  nextLine() {
    let t = this.parsedPos, e = this.lineAfter(t), i = t + e.length;
    for (let s = this.rangeIndex; ; ) {
      let r = this.ranges[s].to;
      if (r >= i || (e = e.slice(0, r - (i - e.length)), s++, s == this.ranges.length))
        break;
      let a = this.ranges[s].from, o = this.lineAfter(a);
      e += o, i = a + o.length;
    }
    return { line: e, end: i };
  }
  skipGapsTo(t, e, i) {
    for (; ; ) {
      let s = this.ranges[this.rangeIndex].to, r = t + e;
      if (i > 0 ? s > r : s >= r)
        break;
      let a = this.ranges[++this.rangeIndex].from;
      e += a - s;
    }
    return e;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(t, e, i, s) {
    let r = 4;
    if (this.ranges.length > 1) {
      s = this.skipGapsTo(e, s, 1), e += s;
      let o = this.chunk.length;
      s = this.skipGapsTo(i, s, -1), i += s, r += this.chunk.length - o;
    }
    let a = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && r == 4 && a >= 0 && this.chunk[a] == t && this.chunk[a + 2] == e ? this.chunk[a + 2] = i : this.chunk.push(t, e, i, r), s;
  }
  parseLine(t) {
    let { line: e, end: i } = this.nextLine(), s = 0, { streamParser: r } = this.lang, a = new nM(e, t ? t.state.tabSize : 4, t ? mw(t.state) : 2);
    if (a.eol())
      r.blankLine(this.state, a.indentUnit);
    else
      for (; !a.eol(); ) {
        let o = D5(r.token, a, this.state);
        if (o && (s = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + a.start, this.parsedPos + a.pos, s)), a.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let t = _t.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: jW,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    t = new _t(t.type, t.children, t.positions, t.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(t), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new _t(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}, h(cd, "_i$1"), cd), y(Sb, "Parse"), Sb);
function D5(n, t, e) {
  t.start = t.pos;
  for (let i = 0; i < 10; i++) {
    let s = n(t, e);
    if (t.pos > t.start)
      return s;
  }
  throw new Error("Stream parser failed to advance stream.");
}
h(D5, "lp$1");
y(D5, "readToken$1");
const q5 = /* @__PURE__ */ Object.create(null), ww = [Fe.none], jW = /* @__PURE__ */ new u0(ww), f4 = [], y4 = /* @__PURE__ */ Object.create(null), lM = /* @__PURE__ */ Object.create(null);
for (let [n, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  lM[n] = /* @__PURE__ */ V5(q5, t);
var hd;
const cM = (hd = class {
  constructor(t) {
    this.extra = t, this.table = Object.assign(/* @__PURE__ */ Object.create(null), lM);
  }
  resolve(t) {
    return t ? this.table[t] || (this.table[t] = V5(this.extra, t)) : 0;
  }
}, h(hd, "Bf"), hd);
y(cM, "TokenTable");
let hM = cM;
const FW = /* @__PURE__ */ new hM(q5);
function n1(n, t) {
  f4.indexOf(n) > -1 || (f4.push(n), console.warn(t));
}
h(n1, "Eo$1");
y(n1, "warnForPart");
function V5(n, t) {
  let e = [];
  for (let o of t.split(" ")) {
    let l = [];
    for (let c of o.split(".")) {
      let d = n[c] || M[c];
      d ? typeof d == "function" ? l.length ? l = l.map(d) : n1(c, `Modifier ${c} used at start of tag`) : l.length ? n1(c, `Tag ${c} used as modifier`) : l = Array.isArray(d) ? d : [d] : n1(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      e.push(c);
  }
  if (!e.length)
    return 0;
  let i = t.replace(/ /g, "_"), s = i + " " + e.map((o) => o.id), r = y4[s];
  if (r)
    return r.id;
  let a = y4[s] = Fe.define({
    id: ww.length,
    name: i,
    props: [al({ [i]: e })]
  });
  return ww.push(a), a.id;
}
h(V5, "hp$1");
y(V5, "createTokenType");
function dM(n, t) {
  let e = Fe.define({ id: ww.length, name: "Document", props: [
    br.add(() => n),
    Oy.add(() => (i) => t.getIndent(i))
  ], top: !0 });
  return ww.push(e), e;
}
h(dM, "Ky$1");
y(dM, "docID");
Pe.RTL, Pe.LTR;
var dd;
const uM = (dd = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, e, i, s) {
    this.state = t, this.pos = e, this.explicit = i, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let e = ce(this.state).resolveInner(this.pos, -1);
    for (; e && t.indexOf(e.name) < 0; )
      e = e.parent;
    return e ? {
      from: e.from,
      to: this.pos,
      text: this.state.sliceDoc(e.from, this.pos),
      type: e.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), s = e.text.slice(i - e.from, this.pos - e.from), r = s.search(U5(t, !1));
    return r < 0 ? null : { from: i + r, to: this.pos, text: s.slice(r) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, e, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(e), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}, h(dd, "zf"), dd);
y(uM, "CompletionContext");
let j5 = uM;
function gx(n) {
  let t = Object.keys(n).join(""), e = /\w/.test(t);
  return e && (t = t.replace(/\w/g, "")), `[${e ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
h(gx, "Mu$1");
y(gx, "toSet");
function pM(n) {
  let t = /* @__PURE__ */ Object.create(null), e = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of n) {
    t[s[0]] = !0;
    for (let r = 1; r < s.length; r++)
      e[s[r]] = !0;
  }
  let i = gx(t) + gx(e) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
h(pM, "Jy$1");
y(pM, "prefixMatch");
function F5(n) {
  let t = n.map((s) => typeof s == "string" ? { label: s } : s), [e, i] = t.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : pM(t);
  return (s) => {
    let r = s.matchBefore(i);
    return r || s.explicit ? { from: r ? r.from : s.pos, options: t, validFor: e } : null;
  };
}
h(F5, "fp$1");
y(F5, "completeFromList");
function fM(n, t) {
  return (e) => {
    for (let i = ce(e.state).resolveInner(e.pos, -1); i; i = i.parent) {
      if (n.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(e);
  };
}
h(fM, "eb$1");
y(fM, "ifNotIn");
var ud;
const yM = (ud = class {
  constructor(t, e, i, s) {
    this.completion = t, this.source = e, this.match = i, this.score = s;
  }
}, h(ud, "Nf"), ud);
y(yM, "Option");
let m4 = yM;
function xr(n) {
  return n.selection.main.from;
}
h(xr, "Kt$2");
y(xr, "cur");
function U5(n, t) {
  var e;
  let { source: i } = n, s = t && i[0] != "^", r = i[i.length - 1] != "$";
  return !s && !r ? n : new RegExp(`${s ? "^" : ""}(?:${i})${r ? "$" : ""}`, (e = n.flags) !== null && e !== void 0 ? e : n.ignoreCase ? "i" : "");
}
h(U5, "cp$1");
y(U5, "ensureAnchor");
const B5 = /* @__PURE__ */ Ys.define();
function mM(n, t, e, i) {
  let { main: s } = n.selection, r = e - s.from, a = i - s.from;
  return Object.assign(Object.assign({}, n.changeByRange((o) => {
    if (o != s && e != i && n.sliceDoc(o.from + r, o.from + a) != n.sliceDoc(e, i))
      return { range: o };
    let l = n.toText(t);
    return {
      changes: { from: o.from + r, to: i == s.from ? o.to : o.from + a, insert: l },
      range: it.cursor(o.from + r + l.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
h(mM, "tb$1");
y(mM, "insertCompletionText");
const w4 = /* @__PURE__ */ new WeakMap();
function wM(n) {
  if (!Array.isArray(n))
    return n;
  let t = w4.get(n);
  return t || w4.set(n, t = F5(n)), t;
}
h(wM, "ib$1");
y(wM, "asSource");
const cv = /* @__PURE__ */ Bt.define(), gw = /* @__PURE__ */ Bt.define();
var pd;
const gM = (pd = class {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e = 0; e < t.length; ) {
      let i = ur(t, e), s = Da(i);
      this.chars.push(i);
      let r = t.slice(e, e + s), a = r.toUpperCase();
      this.folded.push(ur(a == r ? r.toLowerCase() : a, 0)), e += s;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, e) {
    return this.score = t, this.matched = e, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: e, folded: i, any: s, precise: r, byWord: a } = this;
    if (e.length == 1) {
      let P = ur(t, 0), A = Da(P), R = A == t.length ? 0 : -100;
      if (P != e[0]) if (P == i[0])
        R += -200;
      else
        return null;
      return this.ret(R, [0, A]);
    }
    let o = t.indexOf(this.pattern);
    if (o == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = e.length, c = 0;
    if (o < 0) {
      for (let P = 0, A = Math.min(t.length, 200); P < A && c < l; ) {
        let R = ur(t, P);
        (R == e[c] || R == i[c]) && (s[c++] = P), P += Da(R);
      }
      if (c < l)
        return null;
    }
    let d = 0, p = 0, f = !1, m = 0, w = -1, b = -1, x = /[a-z]/.test(t), O = !0;
    for (let P = 0, A = Math.min(t.length, 200), R = 0; P < A && p < l; ) {
      let T = ur(t, P);
      o < 0 && (d < l && T == e[d] && (r[d++] = P), m < l && (T == e[m] || T == i[m] ? (m == 0 && (w = P), b = P + 1, m++) : m = 0));
      let I, Z = T < 255 ? T >= 48 && T <= 57 || T >= 97 && T <= 122 ? 2 : T >= 65 && T <= 90 ? 1 : 0 : (I = w9(T)) != I.toLowerCase() ? 1 : I != I.toUpperCase() ? 2 : 0;
      (!P || Z == 1 && x || R == 0 && Z != 0) && (e[p] == T || i[p] == T && (f = !0) ? a[p++] = P : a.length && (O = !1)), R = Z, P += Da(T);
    }
    return p == l && a[0] == 0 && O ? this.result(-100 + (f ? -200 : 0), a, t) : m == l && w == 0 ? this.ret(-200 - t.length + (b == t.length ? 0 : -100), [0, b]) : o > -1 ? this.ret(-700 - t.length, [o, o + this.pattern.length]) : m == l ? this.ret(-900 - t.length, [w, b]) : p == l ? this.result(-100 + (f ? -200 : 0) + -700 + (O ? 0 : -1100), a, t) : e.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, t);
  }
  result(t, e, i) {
    let s = [], r = 0;
    for (let a of e) {
      let o = a + (this.astral ? Da(ur(i, a)) : 1);
      r && s[r - 1] == a ? s[r - 1] = o : (s[r++] = a, s[r++] = o);
    }
    return this.ret(t - i.length, s);
  }
}, h(pd, "Gf"), pd);
y(gM, "FuzzyMatcher");
let UW = gM;
var fd;
const vM = (fd = class {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let e = t.slice(0, this.pattern.length), i = e == this.pattern ? 0 : e.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, e.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}, h(fd, "Hf"), fd);
y(vM, "StrictMatcher");
let BW = vM;
const Ve = /* @__PURE__ */ gt.define({
  combine(n) {
    return Yk(n, {
      activateOnTyping: !0,
      activateOnCompletion: /* @__PURE__ */ y(() => !1, "activateOnCompletion"),
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: /* @__PURE__ */ y(() => "", "tooltipClass"),
      optionClass: /* @__PURE__ */ y(() => "", "optionClass"),
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: bM,
      filterStrict: !1,
      compareCompletions: /* @__PURE__ */ y((t, e) => t.label.localeCompare(e.label), "compareCompletions"),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: /* @__PURE__ */ y((t, e) => t && e, "defaultKeymap"),
      closeOnBlur: /* @__PURE__ */ y((t, e) => t && e, "closeOnBlur"),
      icons: /* @__PURE__ */ y((t, e) => t && e, "icons"),
      tooltipClass: /* @__PURE__ */ y((t, e) => (i) => vx(t(i), e(i)), "tooltipClass"),
      optionClass: /* @__PURE__ */ y((t, e) => (i) => vx(t(i), e(i)), "optionClass"),
      addToOptions: /* @__PURE__ */ y((t, e) => t.concat(e), "addToOptions"),
      filterStrict: /* @__PURE__ */ y((t, e) => t || e, "filterStrict")
    });
  }
});
function vx(n, t) {
  return n ? t ? n + " " + t : n : t;
}
h(vx, "Cu$1");
y(vx, "joinClass");
function bM(n, t, e, i, s, r) {
  let a = n.textDirection == Pe.RTL, o = a, l = !1, c = "top", d, p, f = t.left - s.left, m = s.right - t.right, w = i.right - i.left, b = i.bottom - i.top;
  if (o && f < Math.min(w, m) ? o = !1 : !o && m < Math.min(w, f) && (o = !0), w <= (o ? f : m))
    d = Math.max(s.top, Math.min(e.top, s.bottom - b)) - t.top, p = Math.min(400, o ? f : m);
  else {
    l = !0, p = Math.min(
      400,
      (a ? t.right : s.right - t.left) - 30
      /* Info.Margin */
    );
    let P = s.bottom - t.bottom;
    P >= b || P > t.top ? d = e.bottom - t.top : (c = "bottom", d = t.bottom - e.top);
  }
  let x = (t.bottom - t.top) / r.offsetHeight, O = (t.right - t.left) / r.offsetWidth;
  return {
    style: `${c}: ${d / x}px; max-width: ${p / O}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
h(bM, "rb$1");
y(bM, "defaultPositionInfo");
function OM(n) {
  let t = n.addToOptions.slice();
  return n.icons && t.push({
    render(e) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), e.type && i.classList.add(...e.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(e, i, s, r) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = e.displayLabel || e.label, l = 0;
      for (let c = 0; c < r.length; ) {
        let d = r[c++], p = r[c++];
        d > l && a.appendChild(document.createTextNode(o.slice(l, d)));
        let f = a.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(o.slice(d, p))), f.className = "cm-completionMatchedText", l = p;
      }
      return l < o.length && a.appendChild(document.createTextNode(o.slice(l))), a;
    },
    position: 50
  }, {
    render(e) {
      if (!e.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = e.detail, i;
    },
    position: 80
  }), t.sort((e, i) => e.position - i.position).map((e) => e.render);
}
h(OM, "nb$1");
y(OM, "optionContent");
function s1(n, t, e) {
  if (n <= e)
    return { from: 0, to: n };
  if (t < 0 && (t = 0), t <= n >> 1) {
    let s = Math.floor(t / e);
    return { from: s * e, to: (s + 1) * e };
  }
  let i = Math.floor((n - t) / e);
  return { from: n - (i + 1) * e, to: n - i * e };
}
h(s1, "Vo$1");
y(s1, "rangeAroundSelected");
var yd;
const $M = (yd = class {
  constructor(t, e, i) {
    this.view = t, this.stateField = e, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: /* @__PURE__ */ y(() => this.measureInfo(), "read"),
      write: /* @__PURE__ */ y((l) => this.placeInfo(l), "write"),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = t.state.field(e), { options: r, selected: a } = s.open, o = t.state.facet(Ve);
    this.optionContent = OM(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = s1(r.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = t.state.field(e).open;
      for (let d = l.target, p; d && d != this.dom; d = d.parentNode)
        if (d.nodeName == "LI" && (p = /-(\d+)$/.exec(d.id)) && +p[1] < c.length) {
          this.applyCompletion(t, c[+p[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = t.state.field(this.stateField, !1);
      c && c.tooltip && t.state.facet(Ve).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: gw.of(null) });
    }), this.showOptions(r, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, e) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var e;
    let i = t.state.field(this.stateField), s = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != s) {
      let { options: r, selected: a, disabled: o } = i.open;
      (!s.open || s.open.options != r) && (this.range = s1(r.length, a, t.state.facet(Ve).maxRenderedOptions), this.showOptions(r, i.id)), this.updateSel(), o != ((e = s.open) === null || e === void 0 ? void 0 : e.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(t) {
    let e = this.tooltipClass(t);
    if (e != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of e.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = e;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), e = t.open;
    if ((e.selected > -1 && e.selected < this.range.from || e.selected >= this.range.to) && (this.range = s1(e.options.length, e.selected, this.view.state.facet(Ve).maxRenderedOptions), this.showOptions(e.options, t.id)), this.updateSelectedOption(e.selected)) {
      this.destroyInfo();
      let { completion: i } = e.options[e.selected], { info: s } = i;
      if (!s)
        return;
      let r = typeof s == "string" ? document.createTextNode(s) : s(i);
      if (!r)
        return;
      "then" in r ? r.then((a) => {
        a && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(a, i);
      }).catch((a) => Ci(this.view.state, a, "completion info")) : this.addInfoPane(r, i);
    }
  }
  addInfoPane(t, e) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: s, destroy: r } = t;
      i.appendChild(s), this.infoDestroy = r || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let e = null;
    for (let i = this.list.firstChild, s = this.range.from; i; i = i.nextSibling, s++)
      i.nodeName != "LI" || !i.id ? s-- : s == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), e = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return e && kM(this.list, e), e;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let e = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), s = t.getBoundingClientRect(), r = this.space;
    if (!r) {
      let a = this.dom.ownerDocument.documentElement;
      r = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return s.top > Math.min(r.bottom, e.bottom) - 10 || s.bottom < Math.max(r.top, e.top) + 10 ? null : this.view.state.facet(Ve).positionInfo(this.view, e, s, i, r, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, e, i) {
    const s = document.createElement("ul");
    s.id = e, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (a) => {
      a.target == s && a.preventDefault();
    });
    let r = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: l } = t[a], { section: c } = o;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != r && (a > i.from || i.from == 0))
          if (r = f, typeof c != "string" && c.header)
            s.appendChild(c.header(c));
          else {
            let m = s.appendChild(document.createElement("completion-section"));
            m.textContent = f;
          }
      }
      const d = s.appendChild(document.createElement("li"));
      d.id = e + "-" + a, d.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (d.className = p);
      for (let f of this.optionContent) {
        let m = f(o, this.view.state, this.view, l);
        m && d.appendChild(m);
      }
    }
    return i.from && s.classList.add("cm-completionListIncompleteTop"), i.to < t.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}, h(yd, "Ff"), yd);
y($M, "CompletionTooltip");
let XW = $M;
function xM(n, t) {
  return (e) => new XW(e, n, t);
}
h(xM, "sb$1");
y(xM, "completionTooltip");
function kM(n, t) {
  let e = n.getBoundingClientRect(), i = t.getBoundingClientRect(), s = e.height / n.offsetHeight;
  i.top < e.top ? n.scrollTop -= (e.top - i.top) / s : i.bottom > e.bottom && (n.scrollTop += (i.bottom - e.bottom) / s);
}
h(kM, "ob$1");
y(kM, "scrollIntoView");
function bx(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
h(bx, "Eu$1");
y(bx, "score");
function SM(n, t) {
  let e = [], i = null, s = /* @__PURE__ */ y((c) => {
    e.push(c);
    let { section: d } = c.completion;
    if (d) {
      i || (i = []);
      let p = typeof d == "string" ? d : d.name;
      i.some((f) => f.name == p) || i.push(typeof d == "string" ? { name: p } : d);
    }
  }, "addOption"), r = t.facet(Ve);
  for (let c of n)
    if (c.hasResult()) {
      let d = c.result.getMatch;
      if (c.result.filter === !1)
        for (let p of c.result.options)
          s(new m4(p, c.source, d ? d(p) : [], 1e9 - e.length));
      else {
        let p = t.sliceDoc(c.from, c.to), f, m = r.filterStrict ? new BW(p) : new UW(p);
        for (let w of c.result.options)
          if (f = m.match(w.label)) {
            let b = w.displayLabel ? d ? d(w, f.matched) : [] : f.matched;
            s(new m4(w, c.source, b, f.score + (w.boost || 0)));
          }
      }
    }
  if (i) {
    let c = /* @__PURE__ */ Object.create(null), d = 0, p = /* @__PURE__ */ y((f, m) => {
      var w, b;
      return ((w = f.rank) !== null && w !== void 0 ? w : 1e9) - ((b = m.rank) !== null && b !== void 0 ? b : 1e9) || (f.name < m.name ? -1 : 1);
    }, "cmp");
    for (let f of i.sort(p))
      d -= 1e5, c[f.name] = d;
    for (let f of e) {
      let { section: m } = f.completion;
      m && (f.score += c[typeof m == "string" ? m : m.name]);
    }
  }
  let a = [], o = null, l = r.compareCompletions;
  for (let c of e.sort((d, p) => p.score - d.score || l(d.completion, p.completion))) {
    let d = c.completion;
    !o || o.label != d.label || o.detail != d.detail || o.type != null && d.type != null && o.type != d.type || o.apply != d.apply || o.boost != d.boost ? a.push(c) : bx(c.completion) > bx(o) && (a[a.length - 1] = c), o = c.completion;
  }
  return a;
}
h(SM, "lb$1");
y(SM, "sortOptions");
var Kn;
const PM = (Kn = class {
  constructor(t, e, i, s, r, a) {
    this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = s, this.selected = r, this.disabled = a;
  }
  setSelected(t, e) {
    return t == this.selected || t >= this.options.length ? this : new Kn(this.options, Ox(e, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, e, i, s, r, a) {
    if (s && !a && t.some((c) => c.isPending))
      return s.setDisabled();
    let o = SM(t, e);
    if (!o.length)
      return s && t.some((c) => c.isPending) ? s.setDisabled() : null;
    let l = e.facet(Ve).selectOnOpen ? 0 : -1;
    if (s && s.selected != l && s.selected != -1) {
      let c = s.options[s.selected].completion;
      for (let d = 0; d < o.length; d++)
        if (o[d].completion == c) {
          l = d;
          break;
        }
    }
    return new Kn(o, Ox(i, l), {
      pos: t.reduce((c, d) => d.hasResult() ? Math.min(c, d.from) : c, 1e8),
      create: JW,
      above: r.aboveCursor
    }, s ? s.timestamp : Date.now(), l, !1);
  }
  map(t) {
    return new Kn(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Kn(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}, h(Kn, "Bt"), Kn);
y(PM, "CompletionDialog");
let NW = PM;
var qr;
const CM = (qr = class {
  constructor(t, e, i) {
    this.active = t, this.id = e, this.open = i;
  }
  static start() {
    return new qr(KW, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: e } = t, i = e.facet(Ve), s = (i.override || e.languageDataAt("autocomplete", xr(e)).map(wM)).map((o) => (this.active.find((l) => l.source == o) || new ja(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    s.length == this.active.length && s.every((o, l) => o == this.active[l]) && (s = this.active);
    let r = this.open, a = t.effects.some((o) => o.is(N5));
    r && t.docChanged && (r = r.map(t.changes)), t.selection || s.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !QM(s, this.active) || a ? r = NW.build(s, e, this.id, r, i, a) : r && r.disabled && !s.some((o) => o.isPending) && (r = null), !r && s.every((o) => !o.isPending) && s.some((o) => o.hasResult()) && (s = s.map((o) => o.hasResult() ? new ja(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(EM) && (r = r && r.setSelected(o.value, this.id));
    return s == this.active && r == this.open ? this : new qr(s, this.id, r);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? YW : GW;
  }
}, h(qr, "Ir"), qr);
y(CM, "CompletionState");
let HW = CM;
function QM(n, t) {
  if (n == t)
    return !0;
  for (let e = 0, i = 0; ; ) {
    for (; e < n.length && !n[e].hasResult(); )
      e++;
    for (; i < t.length && !t[i].hasResult(); )
      i++;
    let s = e == n.length, r = i == t.length;
    if (s || r)
      return s == r;
    if (n[e++].result != t[i++].result)
      return !1;
  }
}
h(QM, "ab$1");
y(QM, "sameResults");
const YW = {
  "aria-autocomplete": "list"
}, GW = {};
function Ox(n, t) {
  let e = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return t > -1 && (e["aria-activedescendant"] = n + "-" + t), e;
}
h(Ox, "Vu$1");
y(Ox, "makeAttrs");
const KW = [];
function X5(n, t) {
  if (n.isUserEvent("input.complete")) {
    let i = n.annotation(B5);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let e = n.isUserEvent("input.type");
  return e && t.activateOnTyping ? 5 : e ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
h(X5, "up$1");
y(X5, "getUpdateType");
var Jn;
const MM = (Jn = class {
  constructor(t, e, i = !1) {
    this.source = t, this.state = e, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, e) {
    let i = X5(t, e), s = this;
    (i & 8 || i & 16 && this.touches(t)) && (s = new Jn(
      s.source,
      0
      /* State.Inactive */
    )), i & 4 && s.state == 0 && (s = new Jn(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(t, i);
    for (let r of t.effects)
      if (r.is(cv))
        s = new Jn(s.source, 1, r.value);
      else if (r.is(gw))
        s = new Jn(
          s.source,
          0
          /* State.Inactive */
        );
      else if (r.is(N5))
        for (let a of r.value)
          a.source == s.source && (s = a);
    return s;
  }
  updateFor(t, e) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(xr(t.state));
  }
}, h(Jn, "zt"), Jn);
y(MM, "ActiveSource");
let ja = MM;
var Is;
const TM = (Is = class extends ja {
  constructor(t, e, i, s, r, a) {
    super(t, 3, e), this.limit = i, this.result = s, this.from = r, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, e) {
    var i;
    if (!(e & 3))
      return this.map(t.changes);
    let s = this.result;
    s.map && !t.changes.empty && (s = s.map(s, t.changes));
    let r = t.changes.mapPos(this.from), a = t.changes.mapPos(this.to, 1), o = xr(t.state);
    if (o > a || !s || e & 2 && (xr(t.startState) == this.from || o < this.limit))
      return new ja(
        this.source,
        e & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = t.changes.mapPos(this.limit);
    return RM(s.validFor, t.state, r, a) ? new Is(this.source, this.explicit, l, s, r, a) : s.update && (s = s.update(s, r, a, new j5(t.state, o, !1))) ? new Is(this.source, this.explicit, l, s, s.from, (i = s.to) !== null && i !== void 0 ? i : xr(t.state)) : new ja(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new Is(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new ja(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}, h(Is, "xi"), Is);
y(TM, "ActiveResult");
let AM = TM;
function RM(n, t, e, i) {
  if (!n)
    return !1;
  let s = t.sliceDoc(e, i);
  return typeof n == "function" ? n(s, e, i, t) : U5(n, !0).test(s);
}
h(RM, "ub$1");
y(RM, "checkValid");
const N5 = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n.map((e) => e.map(t));
  }
}), EM = /* @__PURE__ */ Bt.define(), yi = /* @__PURE__ */ Hs.define({
  create() {
    return HW.start();
  },
  update(n, t) {
    return n.update(t);
  },
  provide: /* @__PURE__ */ y((n) => [
    F8.from(n, (t) => t.tooltip),
    kt.contentAttributes.from(n, (t) => t.attrs)
  ], "provide")
});
function g0(n, t) {
  const e = t.completion.apply || t.completion.label;
  let i = n.state.field(yi).active.find((s) => s.source == t.source);
  return i instanceof AM ? (typeof e == "string" ? n.dispatch(Object.assign(Object.assign({}, mM(n.state, e, i.from, i.to)), { annotations: B5.of(t.completion) })) : e(n, t.completion, i.from, i.to), !0) : !1;
}
h(g0, "ph");
y(g0, "applyCompletion");
const JW = /* @__PURE__ */ xM(yi, g0);
function mm(n, t = "option") {
  return (e) => {
    let i = e.state.field(yi, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < e.state.facet(Ve).interactionDelay)
      return !1;
    let s = 1, r;
    t == "page" && (r = Q5(e, i.open.tooltip)) && (s = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + s * (n ? 1 : -1) : n ? 0 : a - 1;
    return o < 0 ? o = t == "page" ? 0 : a - 1 : o >= a && (o = t == "page" ? a - 1 : 0), e.dispatch({ effects: EM.of(o) }), !0;
  };
}
h(mm, "Un$1");
y(mm, "moveCompletionSelection");
const tD = /* @__PURE__ */ y((n) => {
  let t = n.state.field(yi, !1);
  return n.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < n.state.facet(Ve).interactionDelay ? !1 : g0(n, t.open.options[t.open.selected]);
}, "acceptCompletion"), g4 = /* @__PURE__ */ y((n) => n.state.field(yi, !1) ? (n.dispatch({ effects: cv.of(!0) }), !0) : !1, "startCompletion"), eD = /* @__PURE__ */ y((n) => {
  let t = n.state.field(yi, !1);
  return !t || !t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: gw.of(null) }), !0);
}, "closeCompletion");
var md;
const zM = (md = class {
  constructor(t, e) {
    this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}, h(md, "Kf"), md);
y(zM, "RunningQuery");
let iD = zM;
const nD = 50, sD = 1e3, rD = /* @__PURE__ */ Ds.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of n.state.field(yi).active)
      t.isPending && this.startQuery(t);
  }
  update(n) {
    let t = n.state.field(yi), e = n.state.facet(Ve);
    if (!n.selectionSet && !n.docChanged && n.startState.field(yi) == t)
      return;
    let i = n.transactions.some((r) => {
      let a = X5(r, e);
      return a & 8 || (r.selection || r.docChanged) && !(a & 3);
    });
    for (let r = 0; r < this.running.length; r++) {
      let a = this.running[r];
      if (i || a.context.abortOnDocChange && n.docChanged || a.updates.length + n.transactions.length > nD && Date.now() - a.time > sD) {
        for (let o of a.context.abortListeners)
          try {
            o();
          } catch (l) {
            Ci(this.view.state, l);
          }
        a.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        a.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((r) => r.effects.some((a) => a.is(cv))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : e.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((r) => r.isPending && !this.running.some((a) => a.active.source == r.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let r of n.transactions)
        r.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, t = n.field(yi);
    for (let e of t.active)
      e.isPending && !this.running.some((i) => i.active.source == e.source) && this.startQuery(e);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ve).updateSyncTime));
  }
  startQuery(n) {
    let { state: t } = this.view, e = xr(t), i = new j5(t, e, n.explicit, this.view), s = new iD(n, i);
    this.running.push(s), Promise.resolve(n.source(i)).then((r) => {
      s.context.aborted || (s.done = r || null, this.scheduleAccept());
    }, (r) => {
      this.view.dispatch({ effects: gw.of(null) }), Ci(this.view.state, r);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ve).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], e = this.view.state.facet(Ve), i = this.view.state.field(yi);
    for (let s = 0; s < this.running.length; s++) {
      let r = this.running[s];
      if (r.done === void 0)
        continue;
      if (this.running.splice(s--, 1), r.done) {
        let o = xr(r.updates.length ? r.updates[0].startState : this.view.state), l = Math.min(o, r.done.from + (r.active.explicit ? 0 : 1)), c = new AM(r.active.source, r.active.explicit, l, r.done, r.done.from, (n = r.done.to) !== null && n !== void 0 ? n : o);
        for (let d of r.updates)
          c = c.update(d, e);
        if (c.hasResult()) {
          t.push(c);
          continue;
        }
      }
      let a = i.active.find((o) => o.source == r.active.source);
      if (a && a.isPending)
        if (r.done == null) {
          let o = new ja(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let l of r.updates)
            o = o.update(l, e);
          o.isPending || t.push(o);
        } else
          this.startQuery(a);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: N5.of(t) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let t = this.view.state.field(yi, !1);
      if (t && t.tooltip && this.view.state.facet(Ve).closeOnBlur) {
        let e = t.open && Q5(this.view, t.open.tooltip);
        (!e || !e.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: gw.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: cv.of(!1) }), 20), this.composing = 0;
    }
  }
}), aD = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), oD = /* @__PURE__ */ rl.highest(/* @__PURE__ */ kt.domEventHandlers({
  keydown(n, t) {
    let e = t.state.field(yi, !1);
    if (!e || !e.open || e.open.disabled || e.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(aD && n.altKey) || n.metaKey)
      return !1;
    let i = e.open.options[e.open.selected], s = e.active.find((a) => a.source == i.source), r = i.completion.commitCharacters || s.result.commitCharacters;
    return r && r.indexOf(n.key) > -1 && g0(t, i), !1;
  }
})), _M = /* @__PURE__ */ kt.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var wd;
const LM = (wd = class {
  constructor(t, e, i, s) {
    this.field = t, this.line = e, this.from = i, this.to = s;
  }
}, h(wd, "Jf"), wd);
y(LM, "FieldPos");
let lD = LM;
var ko;
const IM = (ko = class {
  constructor(t, e, i) {
    this.field = t, this.from = e, this.to = i;
  }
  map(t) {
    let e = t.mapPos(this.from, -1, mi.TrackDel), i = t.mapPos(this.to, 1, mi.TrackDel);
    return e == null || i == null ? null : new ko(this.field, e, i);
  }
}, h(ko, "co"), ko);
y(IM, "FieldRange");
let cD = IM;
var So;
const ZM = (So = class {
  constructor(t, e) {
    this.lines = t, this.fieldPositions = e;
  }
  instantiate(t, e) {
    let i = [], s = [e], r = t.doc.lineAt(e), a = /^\s*/.exec(r.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let c = a, d = /^\t*/.exec(l)[0].length;
        for (let p = 0; p < d; p++)
          c += t.facet(m0);
        s.push(e + c.length - d), l = c + l.slice(d);
      }
      i.push(l), e += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new cD(l.field, s[l.line] + l.from, s[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(t) {
    let e = [], i = [], s = [], r;
    for (let a of t.split(/\r\n?|\n/)) {
      for (; r = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(a); ) {
        let o = r[1] ? +r[1] : null, l = r[2] || r[3] || "", c = -1, d = l.replace(/\\[{}]/g, (p) => p[1]);
        for (let p = 0; p < e.length; p++)
          (o != null ? e[p].seq == o : d && e[p].name == d) && (c = p);
        if (c < 0) {
          let p = 0;
          for (; p < e.length && (o == null || e[p].seq != null && e[p].seq < o); )
            p++;
          e.splice(p, 0, { seq: o, name: d }), c = p;
          for (let f of s)
            f.field >= c && f.field++;
        }
        s.push(new lD(c, i.length, r.index, r.index + d.length)), a = a.slice(0, r.index) + l + a.slice(r.index + r[0].length);
      }
      a = a.replace(/\\([{}])/g, (o, l, c) => {
        for (let d of s)
          d.line == i.length && d.from > c && (d.from--, d.to--);
        return l;
      }), i.push(a);
    }
    return new So(i, s);
  }
}, h(So, "uo"), So);
y(ZM, "Snippet");
let hD = ZM, dD = /* @__PURE__ */ Jt.widget({ widget: /* @__PURE__ */ new class extends by {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), uD = /* @__PURE__ */ Jt.mark({ class: "cm-snippetField" });
var Po;
const WM = (Po = class {
  constructor(t, e) {
    this.ranges = t, this.active = e, this.deco = Jt.set(t.map((i) => (i.from == i.to ? dD : uD).range(i.from, i.to)));
  }
  map(t) {
    let e = [];
    for (let i of this.ranges) {
      let s = i.map(t);
      if (!s)
        return null;
      e.push(s);
    }
    return new Po(e, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((e) => this.ranges.some((i) => i.field == this.active && i.from <= e.from && i.to >= e.to));
  }
}, h(Po, "Oo"), Po);
y(WM, "ActiveSnippet");
let v0 = WM;
const tg = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n && n.map(t);
  }
}), pD = /* @__PURE__ */ Bt.define(), vw = /* @__PURE__ */ Hs.define({
  create() {
    return null;
  },
  update(n, t) {
    for (let e of t.effects) {
      if (e.is(tg))
        return e.value;
      if (e.is(pD) && n)
        return new v0(n.ranges, e.value);
    }
    return n && t.docChanged && (n = n.map(t.changes)), n && t.selection && !n.selectionInsideField(t.selection) && (n = null), n;
  },
  provide: /* @__PURE__ */ y((n) => kt.decorations.from(n, (t) => t ? t.deco : Jt.none), "provide")
});
function b0(n, t) {
  return it.create(n.filter((e) => e.field == t).map((e) => it.range(e.from, e.to)));
}
h(b0, "mh");
y(b0, "fieldSelection");
function DM(n) {
  let t = hD.parse(n);
  return (e, i, s, r) => {
    let { text: a, ranges: o } = t.instantiate(e.state, s), { main: l } = e.state.selection, c = {
      changes: { from: s, to: r == l.from ? l.to : r, insert: Zt.of(a) },
      scrollIntoView: !0,
      annotations: i ? [B5.of(i), wi.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (c.selection = b0(o, 0)), o.some((d) => d.field > 0)) {
      let d = new v0(o, 0), p = c.effects = [tg.of(d)];
      e.state.field(vw, !1) === void 0 && p.push(Bt.appendConfig.of([vw, gD, vD, _M]));
    }
    e.dispatch(e.state.update(c));
  };
}
h(DM, "xb$1");
y(DM, "snippet");
function H5(n) {
  return ({ state: t, dispatch: e }) => {
    let i = t.field(vw, !1);
    if (!i || n < 0 && i.active == 0)
      return !1;
    let s = i.active + n, r = n > 0 && !i.ranges.some((a) => a.field == s + n);
    return e(t.update({
      selection: b0(i.ranges, s),
      effects: tg.of(r ? null : new v0(i.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
h(H5, "mp$1");
y(H5, "moveField");
const fD = /* @__PURE__ */ y(({ state: n, dispatch: t }) => n.field(vw, !1) ? (t(n.update({ effects: tg.of(null) })), !0) : !1, "clearSnippet"), yD = /* @__PURE__ */ H5(1), mD = /* @__PURE__ */ H5(-1), wD = [
  { key: "Tab", run: yD, shift: mD },
  { key: "Escape", run: fD }
], v4 = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.length ? n[0] : wD;
  }
}), gD = /* @__PURE__ */ rl.highest(/* @__PURE__ */ d0.compute([v4], (n) => n.facet(v4)));
function di(n, t) {
  return Object.assign(Object.assign({}, t), { apply: DM(n) });
}
h(di, "me$2");
y(di, "snippetCompletion");
const vD = /* @__PURE__ */ kt.domEventHandlers({
  mousedown(n, t) {
    let e = t.state.field(vw, !1), i;
    if (!e || (i = t.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let s = e.ranges.find((r) => r.from <= i && r.to >= i);
    return !s || s.field == e.active ? !1 : (t.dispatch({
      selection: b0(e.ranges, s.field),
      effects: tg.of(e.ranges.some((r) => r.field > s.field) ? new v0(e.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), qM = /* @__PURE__ */ new class extends Lo {
}();
qM.startSide = 1;
qM.endSide = -1;
function bD(n = {}) {
  return [
    oD,
    yi,
    Ve.of(n),
    rD,
    $D,
    _M
  ];
}
h(bD, "Ab$1");
y(bD, "autocompletion");
const OD = [
  { key: "Ctrl-Space", run: g4 },
  { mac: "Alt-`", run: g4 },
  { key: "Escape", run: eD },
  { key: "ArrowDown", run: /* @__PURE__ */ mm(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ mm(!1) },
  { key: "PageDown", run: /* @__PURE__ */ mm(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ mm(!1, "page") },
  { key: "Enter", run: tD }
], $D = /* @__PURE__ */ rl.highest(/* @__PURE__ */ d0.computeN([Ve], (n) => n.facet(Ve).defaultKeymap ? [OD] : []));
function xD(n) {
  let t = n.field(yi, !1);
  return t && t.active.some((e) => e.isPending) ? "pending" : t && t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}
h(xD, "Mb$1");
y(xD, "completionStatus");
var Co;
const VM = (Co = class {
  static create(t, e, i, s, r) {
    let a = s + (s << 8) + t + (e << 4) | 0;
    return new Co(t, e, i, a, r, [], []);
  }
  constructor(t, e, i, s, r, a, o) {
    this.type = t, this.value = e, this.from = i, this.hash = s, this.end = r, this.children = a, this.positions = o, this.hashProp = [[xt.contextHash, s]];
  }
  addChild(t, e) {
    t.prop(xt.contextHash) != this.hash && (t = new _t(t.type, t.children, t.positions, t.length, this.hashProp)), this.children.push(t), this.positions.push(e);
  }
  toTree(t, e = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (e = Math.max(e, this.positions[i] + this.children[i].length + this.from)), new _t(t.types[this.type], this.children, this.positions, e - this.from).balance({
      makeTree: /* @__PURE__ */ y((s, r, a) => new _t(Fe.none, s, r, a, this.hashProp), "makeTree")
    });
  }
}, h(Co, "po"), Co);
y(VM, "CompositeBlock");
let b4 = VM;
var N;
(function(n) {
  n[n.Document = 1] = "Document", n[n.CodeBlock = 2] = "CodeBlock", n[n.FencedCode = 3] = "FencedCode", n[n.Blockquote = 4] = "Blockquote", n[n.HorizontalRule = 5] = "HorizontalRule", n[n.BulletList = 6] = "BulletList", n[n.OrderedList = 7] = "OrderedList", n[n.ListItem = 8] = "ListItem", n[n.ATXHeading1 = 9] = "ATXHeading1", n[n.ATXHeading2 = 10] = "ATXHeading2", n[n.ATXHeading3 = 11] = "ATXHeading3", n[n.ATXHeading4 = 12] = "ATXHeading4", n[n.ATXHeading5 = 13] = "ATXHeading5", n[n.ATXHeading6 = 14] = "ATXHeading6", n[n.SetextHeading1 = 15] = "SetextHeading1", n[n.SetextHeading2 = 16] = "SetextHeading2", n[n.HTMLBlock = 17] = "HTMLBlock", n[n.LinkReference = 18] = "LinkReference", n[n.Paragraph = 19] = "Paragraph", n[n.CommentBlock = 20] = "CommentBlock", n[n.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", n[n.Escape = 22] = "Escape", n[n.Entity = 23] = "Entity", n[n.HardBreak = 24] = "HardBreak", n[n.Emphasis = 25] = "Emphasis", n[n.StrongEmphasis = 26] = "StrongEmphasis", n[n.Link = 27] = "Link", n[n.Image = 28] = "Image", n[n.InlineCode = 29] = "InlineCode", n[n.HTMLTag = 30] = "HTMLTag", n[n.Comment = 31] = "Comment", n[n.ProcessingInstruction = 32] = "ProcessingInstruction", n[n.Autolink = 33] = "Autolink", n[n.HeaderMark = 34] = "HeaderMark", n[n.QuoteMark = 35] = "QuoteMark", n[n.ListMark = 36] = "ListMark", n[n.LinkMark = 37] = "LinkMark", n[n.EmphasisMark = 38] = "EmphasisMark", n[n.CodeMark = 39] = "CodeMark", n[n.CodeText = 40] = "CodeText", n[n.CodeInfo = 41] = "CodeInfo", n[n.LinkTitle = 42] = "LinkTitle", n[n.LinkLabel = 43] = "LinkLabel", n[n.URL = 44] = "URL";
})(N || (N = {}));
var gd;
const jM = (gd = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.start = t, this.content = e, this.marks = [], this.parsers = [];
  }
}, h(gd, "ec"), gd);
y(jM, "LeafBlock");
let kD = jM;
var vd;
const FM = (vd = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let t = this.skipSpace(this.basePos);
    this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(t) {
    return Wc(this.text, t);
  }
  /**
  @internal
  */
  reset(t) {
    for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(t) {
    this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(t) {
    this.baseIndent = t, this.basePos = this.findColumn(t);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(t) {
    this.markers.push(t);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(t, e = 0, i = 0) {
    for (let s = e; s < t; s++)
      i += this.text.charCodeAt(s) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(t) {
    let e = 0;
    for (let i = 0; e < this.text.length && i < t; e++)
      i += this.text.charCodeAt(e) == 9 ? 4 - i % 4 : 1;
    return e;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let t = "";
    for (let e = 0; e < this.basePos; e++)
      t += " ";
    return t + this.text.slice(this.basePos);
  }
}, h(vd, "tc"), vd);
y(FM, "Line");
let SD = FM;
function $x(n, t, e) {
  if (e.pos == e.text.length || n != t.block && e.indent >= t.stack[e.depth + 1].value + e.baseIndent)
    return !0;
  if (e.indent >= e.baseIndent + 4)
    return !1;
  let i = (n.type == N.OrderedList ? x0 : $0)(e, t, !1);
  return i > 0 && (n.type != N.BulletList || O0(e, t, !1) < 0) && e.text.charCodeAt(e.pos + i - 1) == n.value;
}
h($x, "Xu$1");
y($x, "skipForList");
const UM = {
  [N.Blockquote](n, t, e) {
    return e.next != 62 ? !1 : (e.markers.push(Rt(N.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1)), e.moveBase(e.pos + (Bi(e.text.charCodeAt(e.pos + 1)) ? 2 : 1)), n.end = t.lineStart + e.text.length, !0);
  },
  [N.ListItem](n, t, e) {
    return e.indent < e.baseIndent + n.value && e.next > -1 ? !1 : (e.moveBaseColumn(e.baseIndent + n.value), !0);
  },
  [N.OrderedList]: $x,
  [N.BulletList]: $x,
  [N.Document]() {
    return !0;
  }
};
function Bi(n) {
  return n == 32 || n == 9 || n == 10 || n == 13;
}
h(Bi, "Ve$2");
y(Bi, "space$2");
function Wc(n, t = 0) {
  for (; t < n.length && Bi(n.charCodeAt(t)); )
    t++;
  return t;
}
h(Wc, "wr$1");
y(Wc, "skipSpace");
function xx(n, t, e) {
  for (; t > e && Bi(n.charCodeAt(t - 1)); )
    t--;
  return t;
}
h(xx, "Yu$1");
y(xx, "skipSpaceBack");
function Y5(n) {
  if (n.next != 96 && n.next != 126)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  if (t < n.pos + 3)
    return -1;
  if (n.next == 96) {
    for (let e = t; e < n.text.length; e++)
      if (n.text.charCodeAt(e) == 96)
        return -1;
  }
  return t;
}
h(Y5, "bp$1");
y(Y5, "isFencedCode");
function G5(n) {
  return n.next != 62 ? -1 : n.text.charCodeAt(n.pos + 1) == 32 ? 2 : 1;
}
h(G5, "Sp$1");
y(G5, "isBlockquote");
function O0(n, t, e) {
  if (n.next != 42 && n.next != 45 && n.next != 95)
    return -1;
  let i = 1;
  for (let s = n.pos + 1; s < n.text.length; s++) {
    let r = n.text.charCodeAt(s);
    if (r == n.next)
      i++;
    else if (!Bi(r))
      return -1;
  }
  return e && n.next == 45 && tS(n) > -1 && n.depth == t.stack.length && t.parser.leafBlockParsers.indexOf(YM.SetextHeading) > -1 || i < 3 ? -1 : 1;
}
h(O0, "gh");
y(O0, "isHorizontalRule");
function K5(n, t) {
  for (let e = n.stack.length - 1; e >= 0; e--)
    if (n.stack[e].type == t)
      return !0;
  return !1;
}
h(K5, "Qp$1");
y(K5, "inList");
function $0(n, t, e) {
  return (n.next == 45 || n.next == 43 || n.next == 42) && (n.pos == n.text.length - 1 || Bi(n.text.charCodeAt(n.pos + 1))) && (!e || K5(t, N.BulletList) || n.skipSpace(n.pos + 2) < n.text.length) ? 1 : -1;
}
h($0, "yh");
y($0, "isBulletList");
function x0(n, t, e) {
  let i = n.pos, s = n.next;
  for (; s >= 48 && s <= 57; ) {
    if (i++, i == n.text.length)
      return -1;
    s = n.text.charCodeAt(i);
  }
  return i == n.pos || i > n.pos + 9 || s != 46 && s != 41 || i < n.text.length - 1 && !Bi(n.text.charCodeAt(i + 1)) || e && !K5(t, N.OrderedList) && (n.skipSpace(i + 1) == n.text.length || i > n.pos + 1 || n.next != 49) ? -1 : i + 1 - n.pos;
}
h(x0, "bh");
y(x0, "isOrderedList");
function J5(n) {
  if (n.next != 35)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == 35; )
    t++;
  if (t < n.text.length && n.text.charCodeAt(t) != 32)
    return -1;
  let e = t - n.pos;
  return e > 6 ? -1 : e;
}
h(J5, "wp$1");
y(J5, "isAtxHeading");
function tS(n) {
  if (n.next != 45 && n.next != 61 || n.indent >= n.baseIndent + 4)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  let e = t;
  for (; t < n.text.length && Bi(n.text.charCodeAt(t)); )
    t++;
  return t == n.text.length ? e : -1;
}
h(tS, "xp$1");
y(tS, "isSetextUnderline");
const kx = /^[ \t]*$/, BM = /-->/, XM = /\?>/, Sx = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, BM],
  [/^\s*<\?/, XM],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, kx],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, kx]
];
function eS(n, t, e) {
  if (n.next != 60)
    return -1;
  let i = n.text.slice(n.pos);
  for (let s = 0, r = Sx.length - (e ? 1 : 0); s < r; s++)
    if (Sx[s][0].test(i))
      return s;
  return -1;
}
h(eS, "Rp$1");
y(eS, "isHTMLBlock");
function Px(n, t) {
  let e = n.countIndent(t, n.pos, n.indent), i = n.countIndent(n.skipSpace(t), t, e);
  return i >= e + 5 ? e + 1 : i;
}
h(Px, "Iu$1");
y(Px, "getListIndent");
function lr(n, t, e) {
  let i = n.length - 1;
  i >= 0 && n[i].to == t && n[i].type == N.CodeText ? n[i].to = e : n.push(Rt(N.CodeText, t, e));
}
h(lr, "Ut$2");
y(lr, "addCodeText");
const _g = {
  LinkReference: void 0,
  IndentedCode(n, t) {
    let e = t.baseIndent + 4;
    if (t.indent < e)
      return !1;
    let i = t.findColumn(e), s = n.lineStart + i, r = n.lineStart + t.text.length, a = [], o = [];
    for (lr(a, s, r); n.nextLine() && t.depth >= n.stack.length; )
      if (t.pos == t.text.length) {
        lr(o, n.lineStart - 1, n.lineStart);
        for (let l of t.markers)
          o.push(l);
      } else {
        if (t.indent < e)
          break;
        {
          if (o.length) {
            for (let c of o)
              c.type == N.CodeText ? lr(a, c.from, c.to) : a.push(c);
            o = [];
          }
          lr(a, n.lineStart - 1, n.lineStart);
          for (let c of t.markers)
            a.push(c);
          r = n.lineStart + t.text.length;
          let l = n.lineStart + t.findColumn(t.baseIndent + 4);
          l < r && lr(a, l, r);
        }
      }
    return o.length && (o = o.filter((l) => l.type != N.CodeText), o.length && (t.markers = o.concat(t.markers))), n.addNode(n.buffer.writeElements(a, -s).finish(N.CodeBlock, r - s), s), !0;
  },
  FencedCode(n, t) {
    let e = Y5(t);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, s = t.next, r = e - t.pos, a = t.skipSpace(e), o = xx(t.text, t.text.length, a), l = [Rt(N.CodeMark, i, i + r)];
    a < o && l.push(Rt(N.CodeInfo, n.lineStart + a, n.lineStart + o));
    for (let c = !0; n.nextLine() && t.depth >= n.stack.length; c = !1) {
      let d = t.pos;
      if (t.indent - t.baseIndent < 4)
        for (; d < t.text.length && t.text.charCodeAt(d) == s; )
          d++;
      if (d - t.pos >= r && t.skipSpace(d) == t.text.length) {
        for (let p of t.markers)
          l.push(p);
        l.push(Rt(N.CodeMark, n.lineStart + t.pos, n.lineStart + d)), n.nextLine();
        break;
      } else {
        c || lr(l, n.lineStart - 1, n.lineStart);
        for (let m of t.markers)
          l.push(m);
        let p = n.lineStart + t.basePos, f = n.lineStart + t.text.length;
        p < f && lr(l, p, f);
      }
    }
    return n.addNode(n.buffer.writeElements(l, -i).finish(N.FencedCode, n.prevLineEnd() - i), i), !0;
  },
  Blockquote(n, t) {
    let e = G5(t);
    return e < 0 ? !1 : (n.startContext(N.Blockquote, t.pos), n.addNode(N.QuoteMark, n.lineStart + t.pos, n.lineStart + t.pos + 1), t.moveBase(t.pos + e), null);
  },
  HorizontalRule(n, t) {
    if (O0(t, n, !1) < 0)
      return !1;
    let e = n.lineStart + t.pos;
    return n.nextLine(), n.addNode(N.HorizontalRule, e), !0;
  },
  BulletList(n, t) {
    let e = $0(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != N.BulletList && n.startContext(N.BulletList, t.basePos, t.next);
    let i = Px(t, t.pos + 1);
    return n.startContext(N.ListItem, t.basePos, i - t.baseIndent), n.addNode(N.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  OrderedList(n, t) {
    let e = x0(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != N.OrderedList && n.startContext(N.OrderedList, t.basePos, t.text.charCodeAt(t.pos + e - 1));
    let i = Px(t, t.pos + e);
    return n.startContext(N.ListItem, t.basePos, i - t.baseIndent), n.addNode(N.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  ATXHeading(n, t) {
    let e = J5(t);
    if (e < 0)
      return !1;
    let i = t.pos, s = n.lineStart + i, r = xx(t.text, t.text.length, i), a = r;
    for (; a > i && t.text.charCodeAt(a - 1) == t.next; )
      a--;
    (a == r || a == i || !Bi(t.text.charCodeAt(a - 1))) && (a = t.text.length);
    let o = n.buffer.write(N.HeaderMark, 0, e).writeElements(n.parser.parseInline(t.text.slice(i + e + 1, a), s + e + 1), -s);
    a < t.text.length && o.write(N.HeaderMark, a - i, r - i);
    let l = o.finish(N.ATXHeading1 - 1 + e, t.text.length - i);
    return n.nextLine(), n.addNode(l, s), !0;
  },
  HTMLBlock(n, t) {
    let e = eS(t, n, !1);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, s = Sx[e][1], r = [], a = s != kx;
    for (; !s.test(t.text) && n.nextLine(); ) {
      if (t.depth < n.stack.length) {
        a = !1;
        break;
      }
      for (let c of t.markers)
        r.push(c);
    }
    a && n.nextLine();
    let o = s == BM ? N.CommentBlock : s == XM ? N.ProcessingInstructionBlock : N.HTMLBlock, l = n.prevLineEnd();
    return n.addNode(n.buffer.writeElements(r, -i).finish(o, l - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var bd;
const NM = (bd = class {
  constructor(t) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content);
  }
  nextLine(t, e, i) {
    if (this.stage == -1)
      return !1;
    let s = i.content + `
` + e.scrub(), r = this.advance(s);
    return r > -1 && r < s.length ? this.complete(t, i, r) : !1;
  }
  finish(t, e) {
    return (this.stage == 2 || this.stage == 3) && Wc(e.content, this.pos) == e.content.length ? this.complete(t, e, e.content.length) : !1;
  }
  complete(t, e, i) {
    return t.addLeafElement(e, Rt(N.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(t) {
    return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (t === !1 && (this.stage = -1), !1);
  }
  advance(t) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(rS(t, this.pos, this.start, !0)))
          return -1;
        if (t.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Rt(N.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(nS(t, Wc(t, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let e = Wc(t, this.pos), i = 0;
        if (e > this.pos) {
          let s = sS(t, e, this.start);
          if (s) {
            let r = r1(t, s.to - this.start);
            r > 0 && (this.nextStage(s), i = r);
          }
        }
        return i || (i = r1(t, this.pos)), i > 0 && i < t.length ? i : -1;
      } else
        return r1(t, this.pos);
    }
  }
}, h(bd, "ic"), bd);
y(NM, "LinkReferenceParser");
let PD = NM;
function r1(n, t) {
  for (; t < n.length; t++) {
    let e = n.charCodeAt(t);
    if (e == 10)
      break;
    if (!Bi(e))
      return -1;
  }
  return t;
}
h(r1, "Uo$1");
y(r1, "lineEnd");
var Od;
const HM = (Od = class {
  nextLine(t, e, i) {
    let s = e.depth < t.stack.length ? -1 : tS(e), r = e.next;
    if (s < 0)
      return !1;
    let a = Rt(N.HeaderMark, t.lineStart + e.pos, t.lineStart + s);
    return t.nextLine(), t.addLeafElement(i, Rt(r == 61 ? N.SetextHeading1 : N.SetextHeading2, i.start, t.prevLineEnd(), [
      ...t.parser.parseInline(i.content, i.start),
      a
    ])), !0;
  }
  finish() {
    return !1;
  }
}, h(Od, "rc"), Od);
y(HM, "SetextHeadingParser");
let CD = HM;
const YM = {
  LinkReference(n, t) {
    return t.content.charCodeAt(0) == 91 ? new PD(t) : null;
  },
  SetextHeading() {
    return new CD();
  }
}, QD = [
  (n, t) => J5(t) >= 0,
  (n, t) => Y5(t) >= 0,
  (n, t) => G5(t) >= 0,
  (n, t) => $0(t, n, !0) >= 0,
  (n, t) => x0(t, n, !0) >= 0,
  (n, t) => O0(t, n, !0) >= 0,
  (n, t) => eS(t, n, !0) >= 0
], MD = { text: "", end: 0 };
var $d;
const GM = ($d = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.line = new SD(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = s[s.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = s[0].from, this.block = b4.create(N.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new ED(i, e) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: t } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let s = t.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < t.markers.length && (!s || t.markers[i].from < s.end); ) {
          let r = t.markers[i++];
          this.addNode(r.type, r.from, r.to);
        }
        if (!s)
          break;
        this.finishContext();
      }
      if (t.pos < t.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(t.basePos))
      return null;
    t: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let s = i(this, t);
          if (s != !1) {
            if (s == !0)
              return null;
            t.forward();
            continue t;
          }
        }
      break;
    }
    let e = new kD(this.lineStart + t.pos, t.text.slice(t.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let s = i(this, e);
        s && e.parsers.push(s);
      }
    t: for (; this.nextLine() && t.pos != t.text.length; ) {
      if (t.indent < t.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, t, e))
            break t;
      }
      for (let i of e.parsers)
        if (i.nextLine(this, t, e))
          return null;
      e.content += `
` + t.scrub();
      for (let i of t.markers)
        e.marks.push(i);
    }
    return this.finishLeaf(e), null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  reuseFragment(t) {
    if (!this.fragments.moveTo(this.absoluteLineStart + t, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let e = this.fragments.takeNodes(this);
    return e ? (this.absoluteLineStart += e, this.lineStart = aS(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(t = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[t].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(t) {
    let e = MD;
    if (e.end = t, t >= this.to)
      e.text = "";
    else if (e.text = this.lineChunkAt(t), e.end += e.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, s = this.rangeI;
      for (; this.ranges[s].to < e.end; ) {
        s++;
        let r = this.ranges[s].from, a = this.lineChunkAt(r);
        e.end = r + a.length, e.text = e.text.slice(0, this.ranges[s - 1].to - i) + a, i = e.end - e.text.length;
      }
    }
    return e;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: t } = this, { text: e, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, t.reset(e); t.depth < this.stack.length; t.depth++) {
      let s = this.stack[t.depth], r = this.parser.skipContextMarkup[s.type];
      if (!r)
        throw new Error("Unhandled block context " + N[s.type]);
      if (!r(s, this, t))
        break;
      t.forward();
    }
  }
  lineChunkAt(t) {
    let e = this.input.chunk(t), i;
    if (this.input.lineChunks)
      i = e == `
` ? "" : e;
    else {
      let s = e.indexOf(`
`);
      i = s < 0 ? e : e.slice(0, s);
    }
    return t + i.length > this.to ? i.slice(0, this.to - t) : i;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(t, e, i = 0) {
    this.block = b4.create(t, i, this.lineStart + e, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(t, e, i = 0) {
    this.startContext(this.parser.getNodeType(t), e, i);
  }
  /**
  @internal
  */
  addNode(t, e, i) {
    typeof t == "number" && (t = new _t(this.parser.nodeSet.types[t], Yf, Yf, (i ?? this.prevLineEnd()) - e)), this.block.addChild(t, e - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(t) {
    this.block.addChild(t.toTree(this.parser.nodeSet), t.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(t, e) {
    this.addNode(this.buffer.writeElements(dv(e.children, t.marks), -e.from).finish(e.type, e.to - e.from), e.from);
  }
  /**
  @internal
  */
  finishContext() {
    let t = this.stack.pop(), e = this.stack[this.stack.length - 1];
    e.addChild(t.toTree(this.parser.nodeSet), t.from - e.from), this.block = e;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(t) {
    return this.ranges.length > 1 ? iS(this.ranges, 0, t.topNode, this.ranges[0].from, this.reusePlaceholders) : t;
  }
  /**
  @internal
  */
  finishLeaf(t) {
    for (let i of t.parsers)
      if (i.finish(this, t))
        return;
    let e = dv(this.parser.parseInline(t.content, t.start), t.marks);
    this.addNode(this.buffer.writeElements(e, -t.start).finish(N.Paragraph, t.content.length), t.start);
  }
  elt(t, e, i, s) {
    return typeof t == "string" ? Rt(this.parser.getNodeType(t), e, i, s) : new sT(t, e);
  }
  /**
  @internal
  */
  get buffer() {
    return new iT(this.parser.nodeSet);
  }
}, h($d, "nc"), $d);
y(GM, "BlockContext");
let TD = GM;
function iS(n, t, e, i, s) {
  let r = n[t].to, a = [], o = [], l = e.from + i;
  function c(d, p) {
    for (; p ? d >= r : d > r; ) {
      let f = n[t + 1].from - r;
      i += f, d += f, t++, r = n[t].to;
    }
  }
  h(c, "h"), y(c, "movePastNext");
  for (let d = e.firstChild; d; d = d.nextSibling) {
    c(d.from + i, !0);
    let p = d.from + i, f, m = s.get(d.tree);
    m ? f = m : d.to + i > r ? (f = iS(n, t, d, i, s), c(d.to + i, !1)) : f = d.toTree(), a.push(f), o.push(p - l);
  }
  return c(e.to + i, !1), new _t(e.type, a, o, e.to + i - l, e.tree ? e.tree.propValues : void 0);
}
h(iS, "vp$1");
y(iS, "injectGaps");
var Qo;
const KM = (Qo = class extends y0 {
  /**
  @internal
  */
  constructor(t, e, i, s, r, a, o, l, c) {
    super(), this.nodeSet = t, this.blockParsers = e, this.leafBlockParsers = i, this.blockNames = s, this.endLeafBlock = r, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = l, this.wrappers = c, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let d of t.types)
      this.nodeTypes[d.name] = d.id;
  }
  createParse(t, e, i) {
    let s = new TD(this, t, e, i);
    for (let r of this.wrappers)
      s = r(s, t, e, i);
    return s;
  }
  /**
  Reconfigure the parser.
  */
  configure(t) {
    let e = hv(t);
    if (!e)
      return this;
    let { nodeSet: i, skipContextMarkup: s } = this, r = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), l = this.inlineParsers.slice(), c = this.inlineNames.slice(), d = this.endLeafBlock.slice(), p = this.wrappers;
    if (cc(e.defineNodes)) {
      s = Object.assign({}, s);
      let f = i.types.slice(), m;
      for (let w of e.defineNodes) {
        let { name: b, block: x, composite: O, style: P } = typeof w == "string" ? { name: w } : w;
        if (f.some((T) => T.name == b))
          continue;
        O && (s[f.length] = (T, I, Z) => O(I, Z, T.value));
        let A = f.length, R = O ? ["Block", "BlockContext"] : x ? A >= N.ATXHeading1 && A <= N.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        f.push(Fe.define({
          id: A,
          name: b,
          props: R && [[xt.group, R]]
        })), P && (m || (m = {}), Array.isArray(P) || P instanceof Un ? m[b] = P : Object.assign(m, P));
      }
      i = new u0(f), m && (i = i.extend(al(m)));
    }
    if (cc(e.props) && (i = i.extend(...e.props)), cc(e.remove))
      for (let f of e.remove) {
        let m = this.blockNames.indexOf(f), w = this.inlineNames.indexOf(f);
        m > -1 && (r[m] = a[m] = void 0), w > -1 && (l[w] = void 0);
      }
    if (cc(e.parseBlock))
      for (let f of e.parseBlock) {
        let m = o.indexOf(f.name);
        if (m > -1)
          r[m] = f.parse, a[m] = f.leaf;
        else {
          let w = f.before ? wm(o, f.before) : f.after ? wm(o, f.after) + 1 : o.length - 1;
          r.splice(w, 0, f.parse), a.splice(w, 0, f.leaf), o.splice(w, 0, f.name);
        }
        f.endLeaf && d.push(f.endLeaf);
      }
    if (cc(e.parseInline))
      for (let f of e.parseInline) {
        let m = c.indexOf(f.name);
        if (m > -1)
          l[m] = f.parse;
        else {
          let w = f.before ? wm(c, f.before) : f.after ? wm(c, f.after) + 1 : c.length - 1;
          l.splice(w, 0, f.parse), c.splice(w, 0, f.name);
        }
      }
    return e.wrap && (p = p.concat(e.wrap)), new Qo(i, r, a, o, d, s, l, c, p);
  }
  /**
  @internal
  */
  getNodeType(t) {
    let e = this.nodeTypes[t];
    if (e == null)
      throw new RangeError(`Unknown node type '${t}'`);
    return e;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(t, e) {
    let i = new AD(this, t, e);
    t: for (let s = e; s < i.end; ) {
      let r = i.char(s);
      for (let a of this.inlineParsers)
        if (a) {
          let o = a(i, r, s);
          if (o >= 0) {
            s = o;
            continue t;
          }
        }
      s++;
    }
    return i.resolveMarkers(0);
  }
}, h(Qo, "mo"), Qo);
y(KM, "MarkdownParser");
let JM = KM;
function cc(n) {
  return n != null && n.length > 0;
}
h(cc, "lr$1");
y(cc, "nonEmpty");
function hv(n) {
  if (!Array.isArray(n))
    return n;
  if (n.length == 0)
    return null;
  let t = hv(n[0]);
  if (n.length == 1)
    return t;
  let e = hv(n.slice(1));
  if (!e || !t)
    return t || e;
  let i = /* @__PURE__ */ y((a, o) => (a || Yf).concat(o || Yf), "conc"), s = t.wrap, r = e.wrap;
  return {
    props: i(t.props, e.props),
    defineNodes: i(t.defineNodes, e.defineNodes),
    parseBlock: i(t.parseBlock, e.parseBlock),
    parseInline: i(t.parseInline, e.parseInline),
    remove: i(t.remove, e.remove),
    wrap: s ? r ? (a, o, l, c) => s(r(a, o, l, c), o, l, c) : s : r
  };
}
h(hv, "Ta$1");
y(hv, "resolveConfig");
function wm(n, t) {
  let e = n.indexOf(t);
  if (e < 0)
    throw new RangeError(`Position specified relative to unknown parser ${t}`);
  return e;
}
h(wm, "Xn$1");
y(wm, "findName");
let tT = [Fe.none];
for (let n = 1, t; t = N[n]; n++)
  tT[n] = Fe.define({
    id: n,
    name: t,
    props: n >= N.Escape ? [] : [[xt.group, n in UM ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: t == "Document"
  });
const Yf = [];
var xd;
const eT = (xd = class {
  constructor(t) {
    this.nodeSet = t, this.content = [], this.nodes = [];
  }
  write(t, e, i, s = 0) {
    return this.content.push(t, e, i, 4 + s * 4), this;
  }
  writeElements(t, e = 0) {
    for (let i of t)
      i.writeTo(this, e);
    return this;
  }
  finish(t, e) {
    return _t.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: t,
      length: e
    });
  }
}, h(xd, "sc"), xd);
y(eT, "Buffer");
let iT = eT;
var Pb, kd;
let bw = (Pb = (kd = class {
  /**
  @internal
  */
  constructor(t, e, i, s = Yf) {
    this.type = t, this.from = e, this.to = i, this.children = s;
  }
  /**
  @internal
  */
  writeTo(t, e) {
    let i = t.content.length;
    t.writeElements(this.children, e), t.content.push(this.type, this.from + e, this.to + e, t.content.length + 4 - i);
  }
  /**
  @internal
  */
  toTree(t) {
    return new iT(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}, h(kd, "Ci$1"), kd), y(Pb, "Element"), Pb);
var Sd;
const nT = (Sd = class {
  constructor(t, e) {
    this.tree = t, this.from = e;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Yf;
  }
  writeTo(t, e) {
    t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + e, this.to + e, -1);
  }
  toTree() {
    return this.tree;
  }
}, h(Sd, "oc"), Sd);
y(nT, "TreeElement");
let sT = nT;
function Rt(n, t, e, i) {
  return new bw(n, t, e, i);
}
h(Rt, "W$2");
y(Rt, "elt");
const rT = { resolve: "Emphasis", mark: "EmphasisMark" }, aT = { resolve: "Emphasis", mark: "EmphasisMark" }, hc = {}, Cx = {};
var Pd;
const oT = (Pd = class {
  constructor(t, e, i, s) {
    this.type = t, this.from = e, this.to = i, this.side = s;
  }
}, h(Pd, "lc"), Pd);
y(oT, "InlineDelimiter");
let Gi = oT;
const O4 = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Ow = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Ow = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const Cb = {
  Escape(n, t, e) {
    if (t != 92 || e == n.end - 1)
      return -1;
    let i = n.char(e + 1);
    for (let s = 0; s < O4.length; s++)
      if (O4.charCodeAt(s) == i)
        return n.append(Rt(N.Escape, e, e + 2));
    return -1;
  },
  Entity(n, t, e) {
    if (t != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(n.slice(e + 1, e + 31));
    return i ? n.append(Rt(N.Entity, e, e + 1 + i[0].length)) : -1;
  },
  InlineCode(n, t, e) {
    if (t != 96 || e && n.char(e - 1) == 96)
      return -1;
    let i = e + 1;
    for (; i < n.end && n.char(i) == 96; )
      i++;
    let s = i - e, r = 0;
    for (; i < n.end; i++)
      if (n.char(i) == 96) {
        if (r++, r == s && n.char(i + 1) != 96)
          return n.append(Rt(N.InlineCode, e, i + 1, [
            Rt(N.CodeMark, e, e + s),
            Rt(N.CodeMark, i + 1 - s, i + 1)
          ]));
      } else
        r = 0;
    return -1;
  },
  HTMLTag(n, t, e) {
    if (t != 60 || e == n.end - 1)
      return -1;
    let i = n.slice(e + 1, n.end), s = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (s)
      return n.append(Rt(N.Autolink, e, e + 1 + s[0].length, [
        Rt(N.LinkMark, e, e + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        Rt(N.URL, e + 1, e + s[0].length),
        Rt(N.LinkMark, e + s[0].length, e + 1 + s[0].length)
      ]));
    let r = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (r)
      return n.append(Rt(N.Comment, e, e + 1 + r[0].length));
    let a = /^\?[^]*?\?>/.exec(i);
    if (a)
      return n.append(Rt(N.ProcessingInstruction, e, e + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? n.append(Rt(N.HTMLTag, e, e + 1 + o[0].length)) : -1;
  },
  Emphasis(n, t, e) {
    if (t != 95 && t != 42)
      return -1;
    let i = e + 1;
    for (; n.char(i) == t; )
      i++;
    let s = n.slice(e - 1, e), r = n.slice(i, i + 1), a = Ow.test(s), o = Ow.test(r), l = /\s|^$/.test(s), c = /\s|^$/.test(r), d = !c && (!o || l || a), p = !l && (!a || c || o), f = d && (t == 42 || !p || a), m = p && (t == 42 || !d || o);
    return n.append(new Gi(t == 95 ? rT : aT, e, i, (f ? 1 : 0) | (m ? 2 : 0)));
  },
  HardBreak(n, t, e) {
    if (t == 92 && n.char(e + 1) == 10)
      return n.append(Rt(N.HardBreak, e, e + 2));
    if (t == 32) {
      let i = e + 1;
      for (; n.char(i) == 32; )
        i++;
      if (n.char(i) == 10 && i >= e + 2)
        return n.append(Rt(N.HardBreak, e, i + 1));
    }
    return -1;
  },
  Link(n, t, e) {
    return t == 91 ? n.append(new Gi(
      hc,
      e,
      e + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(n, t, e) {
    return t == 33 && n.char(e + 1) == 91 ? n.append(new Gi(
      Cx,
      e,
      e + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(n, t, e) {
    if (t != 93)
      return -1;
    for (let i = n.parts.length - 1; i >= 0; i--) {
      let s = n.parts[i];
      if (s instanceof Gi && (s.type == hc || s.type == Cx)) {
        if (!s.side || n.skipSpace(s.to) == e && !/[(\[]/.test(n.slice(e + 1, e + 2)))
          return n.parts[i] = null, -1;
        let r = n.takeContent(i), a = n.parts[i] = lT(n, r, s.type == hc ? N.Link : N.Image, s.from, e + 1);
        if (s.type == hc)
          for (let o = 0; o < i; o++) {
            let l = n.parts[o];
            l instanceof Gi && l.type == hc && (l.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function lT(n, t, e, i, s) {
  let { text: r } = n, a = n.char(s), o = s;
  if (t.unshift(Rt(N.LinkMark, i, i + (e == N.Image ? 2 : 1))), t.push(Rt(N.LinkMark, s - 1, s)), a == 40) {
    let l = n.skipSpace(s + 1), c = nS(r, l - n.offset, n.offset), d;
    c && (l = n.skipSpace(c.to), l != c.to && (d = sS(r, l - n.offset, n.offset), d && (l = n.skipSpace(d.to)))), n.char(l) == 41 && (t.push(Rt(N.LinkMark, s, s + 1)), o = l + 1, c && t.push(c), d && t.push(d), t.push(Rt(N.LinkMark, l, o)));
  } else if (a == 91) {
    let l = rS(r, s - n.offset, n.offset, !1);
    l && (t.push(l), o = l.to);
  }
  return Rt(e, i, o, t);
}
h(lT, "Eb$1");
y(lT, "finishLink");
function nS(n, t, e) {
  if (n.charCodeAt(t) == 60) {
    for (let i = t + 1; i < n.length; i++) {
      let s = n.charCodeAt(i);
      if (s == 62)
        return Rt(N.URL, t + e, i + 1 + e);
      if (s == 60 || s == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, s = t;
    for (let r = !1; s < n.length; s++) {
      let a = n.charCodeAt(s);
      if (Bi(a))
        break;
      if (r)
        r = !1;
      else if (a == 40)
        i++;
      else if (a == 41) {
        if (!i)
          break;
        i--;
      } else a == 92 && (r = !0);
    }
    return s > t ? Rt(N.URL, t + e, s + e) : s == n.length ? null : !1;
  }
}
h(nS, "Lp$1");
y(nS, "parseURL");
function sS(n, t, e) {
  let i = n.charCodeAt(t);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let s = i == 40 ? 41 : i;
  for (let r = t + 1, a = !1; r < n.length; r++) {
    let o = n.charCodeAt(r);
    if (a)
      a = !1;
    else {
      if (o == s)
        return Rt(N.LinkTitle, t + e, r + 1 + e);
      o == 92 && (a = !0);
    }
  }
  return null;
}
h(sS, "Mp$1");
y(sS, "parseLinkTitle");
function rS(n, t, e, i) {
  for (let s = !1, r = t + 1, a = Math.min(n.length, r + 999); r < a; r++) {
    let o = n.charCodeAt(r);
    if (s)
      s = !1;
    else {
      if (o == 93)
        return i ? !1 : Rt(N.LinkLabel, t + e, r + 1 + e);
      if (i && !Bi(o) && (i = !1), o == 91)
        return !1;
      o == 92 && (s = !0);
    }
  }
  return null;
}
h(rS, "_p$1");
y(rS, "parseLinkLabel");
var Cd;
const cT = (Cd = class {
  /**
  @internal
  */
  constructor(t, e, i) {
    this.parser = t, this.text = e, this.offset = i, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(t) {
    return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(t, e) {
    return this.text.slice(t - this.offset, e - this.offset);
  }
  /**
  @internal
  */
  append(t) {
    return this.parts.push(t), t.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(t, e, i, s, r) {
    return this.append(new Gi(t, e, i, (s ? 1 : 0) | (r ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let e = this.parts[t];
      if (e instanceof Gi && (e.type == hc || e.type == Cx))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(t) {
    return this.append(t);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(t) {
    for (let i = t; i < this.parts.length; i++) {
      let s = this.parts[i];
      if (!(s instanceof Gi && s.type.resolve && s.side & 2))
        continue;
      let r = s.type == rT || s.type == aT, a = s.to - s.from, o, l = i - 1;
      for (; l >= t; l--) {
        let w = this.parts[l];
        if (w instanceof Gi && w.side & 1 && w.type == s.type && // Ignore emphasis delimiters where the character count doesn't match
        !(r && (s.side & 1 || w.side & 2) && (w.to - w.from + a) % 3 == 0 && ((w.to - w.from) % 3 || a % 3))) {
          o = w;
          break;
        }
      }
      if (!o)
        continue;
      let c = s.type.resolve, d = [], p = o.from, f = s.to;
      if (r) {
        let w = Math.min(2, o.to - o.from, a);
        p = o.to - w, f = s.from + w, c = w == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && d.push(this.elt(o.type.mark, p, o.to));
      for (let w = l + 1; w < i; w++)
        this.parts[w] instanceof bw && d.push(this.parts[w]), this.parts[w] = null;
      s.type.mark && d.push(this.elt(s.type.mark, s.from, f));
      let m = this.elt(c, p, f, d);
      this.parts[l] = r && o.from != p ? new Gi(o.type, o.from, p, o.side) : null, (this.parts[i] = r && s.to != f ? new Gi(s.type, f, s.to, s.side) : null) ? this.parts.splice(i, 0, m) : this.parts[i] = m;
    }
    let e = [];
    for (let i = t; i < this.parts.length; i++) {
      let s = this.parts[i];
      s instanceof bw && e.push(s);
    }
    return e;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(t) {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let i = this.parts[e];
      if (i instanceof Gi && i.type == t)
        return e;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(t) {
    let e = this.resolveMarkers(t);
    return this.parts.length = t, e;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(t) {
    return Wc(this.text, t - this.offset) + this.offset;
  }
  elt(t, e, i, s) {
    return typeof t == "string" ? Rt(this.parser.getNodeType(t), e, i, s) : new sT(t, e);
  }
}, h(Cd, "ac"), Cd);
y(cT, "InlineContext");
let AD = cT;
function dv(n, t) {
  if (!t.length)
    return n;
  if (!n.length)
    return t;
  let e = n.slice(), i = 0;
  for (let s of t) {
    for (; i < e.length && e[i].to < s.to; )
      i++;
    if (i < e.length && e[i].from < s.from) {
      let r = e[i];
      r instanceof bw && (e[i] = new bw(r.type, r.from, r.to, dv(r.children, [s])));
    } else
      e.splice(i++, 0, s);
  }
  return e;
}
h(dv, "La$1");
y(dv, "injectMarks");
const RD = [N.CodeBlock, N.ListItem, N.OrderedList, N.BulletList];
var Qb, Qd;
let ED = (Qb = (Qd = class {
  constructor(t, e) {
    this.fragments = t, this.input = e, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(t, e) {
    for (; this.fragment && this.fragment.to <= t; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (t ? t - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let r = this.fragment.to;
      for (; r > 0 && this.input.read(r - 1, r) != `
`; )
        r--;
      this.fragmentEnd = r ? r - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let s = t + this.fragment.offset;
    for (; i.to <= s; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= s)
        return this.fragment.from <= e;
      if (!i.childAfter(s))
        return !1;
    }
  }
  matches(t) {
    let e = this.cursor.tree;
    return e && e.prop(xt.contextHash) == t;
  }
  takeNodes(t) {
    let e = this.cursor, i = this.fragment.offset, s = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), r = t.absoluteLineStart, a = r, o = t.block.children.length, l = a, c = o;
    for (; ; ) {
      if (e.to - i > s) {
        if (e.type.isAnonymous && e.firstChild())
          continue;
        break;
      }
      let d = aS(e.from - i, t.ranges);
      if (e.to - i <= t.ranges[t.rangeI].to)
        t.addNode(e.tree, d);
      else {
        let p = new _t(t.parser.nodeSet.types[N.Paragraph], [], [], 0, t.block.hashProp);
        t.reusePlaceholders.set(p, e.tree), t.addNode(p, d);
      }
      if (e.type.is("Block") && (RD.indexOf(e.type.id) < 0 ? (a = e.to - i, o = t.block.children.length) : (a = l, o = c, l = e.to - i, c = t.block.children.length)), !e.nextSibling())
        break;
    }
    for (; t.block.children.length > o; )
      t.block.children.pop(), t.block.positions.pop();
    return a - r;
  }
}, h(Qd, "Ei$1"), Qd), y(Qb, "FragmentCursor"), Qb);
function aS(n, t) {
  let e = n;
  for (let i = 1; i < t.length; i++) {
    let s = t[i - 1].to, r = t[i].from;
    s < n && (e -= r - s);
  }
  return e;
}
h(aS, "Cp$1");
y(aS, "toRelative");
const zD = al({
  "Blockquote/...": M.quote,
  HorizontalRule: M.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": M.heading1,
  "ATXHeading2/... SetextHeading2/...": M.heading2,
  "ATXHeading3/...": M.heading3,
  "ATXHeading4/...": M.heading4,
  "ATXHeading5/...": M.heading5,
  "ATXHeading6/...": M.heading6,
  "Comment CommentBlock": M.comment,
  Escape: M.escape,
  Entity: M.character,
  "Emphasis/...": M.emphasis,
  "StrongEmphasis/...": M.strong,
  "Link/... Image/...": M.link,
  "OrderedList/... BulletList/...": M.list,
  "BlockQuote/...": M.quote,
  "InlineCode CodeText": M.monospace,
  "URL Autolink": M.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": M.processingInstruction,
  "CodeInfo LinkLabel": M.labelName,
  LinkTitle: M.string,
  Paragraph: M.content
}), _D = new JM(new u0(tT).extend(zD), Object.keys(_g).map((n) => _g[n]), Object.keys(_g).map((n) => YM[n]), Object.keys(_g), QD, UM, Object.keys(Cb).map((n) => Cb[n]), Object.keys(Cb), []);
function hT(n, t, e) {
  let i = [];
  for (let s = n.firstChild, r = t; ; s = s.nextSibling) {
    let a = s ? s.from : e;
    if (a > r && i.push({ from: r, to: a }), !s)
      break;
    r = s.to;
  }
  return i;
}
h(hT, "Yb$1");
y(hT, "leftOverSpace");
function dT(n) {
  let { codeParser: t, htmlParser: e } = n;
  return { wrap: A5((i, s) => {
    let r = i.type.id;
    if (t && (r == N.CodeBlock || r == N.FencedCode)) {
      let a = "";
      if (r == N.FencedCode) {
        let l = i.node.getChild(N.CodeInfo);
        l && (a = s.read(l.from, l.to));
      }
      let o = t(a);
      if (o)
        return { parser: o, overlay: /* @__PURE__ */ y((l) => l.type.id == N.CodeText, "overlay") };
    } else if (e && (r == N.HTMLBlock || r == N.HTMLTag))
      return { parser: e, overlay: hT(i.node, i.from, i.to) };
    return null;
  }) };
}
h(dT, "Ib$1");
y(dT, "parseCode");
const LD = { resolve: "Strikethrough", mark: "StrikethroughMark" }, ID = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": M.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: M.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(n, t, e) {
      if (t != 126 || n.char(e + 1) != 126 || n.char(e + 2) == 126)
        return -1;
      let i = n.slice(e - 1, e), s = n.slice(e + 2, e + 3), r = /\s|^$/.test(i), a = /\s|^$/.test(s), o = Ow.test(i), l = Ow.test(s);
      return n.addDelimiter(LD, e, e + 2, !a && (!l || r || o), !r && (!o || a || l));
    },
    after: "Emphasis"
  }]
};
function Dc(n, t, e = 0, i, s = 0) {
  let r = 0, a = !0, o = -1, l = -1, c = !1, d = /* @__PURE__ */ y(() => {
    i.push(n.elt("TableCell", s + o, s + l, n.parser.parseInline(t.slice(o, l), s + o)));
  }, "parseCell");
  for (let p = e; p < t.length; p++) {
    let f = t.charCodeAt(p);
    f == 124 && !c ? ((!a || o > -1) && r++, a = !1, i && (o > -1 && d(), i.push(n.elt("TableDelimiter", p + s, p + s + 1))), o = l = -1) : (c || f != 32 && f != 9) && (o < 0 && (o = p), l = p + 1), c = !c && f == 92;
  }
  return o > -1 && (r++, i && d()), r;
}
h(Dc, "xr$1");
y(Dc, "parseRow");
function Qx(n, t) {
  for (let e = t; e < n.length; e++) {
    let i = n.charCodeAt(e);
    if (i == 124)
      return !0;
    i == 92 && e++;
  }
  return !1;
}
h(Qx, "qu$1");
y(Qx, "hasPipe");
const uT = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var Md;
const pT = (Md = class {
  constructor() {
    this.rows = null;
  }
  nextLine(t, e, i) {
    if (this.rows == null) {
      this.rows = !1;
      let s;
      if ((e.next == 45 || e.next == 58 || e.next == 124) && uT.test(s = e.text.slice(e.pos))) {
        let r = [];
        Dc(t, i.content, 0, r, i.start) == Dc(t, s, e.pos) && (this.rows = [
          t.elt("TableHeader", i.start, i.start + i.content.length, r),
          t.elt("TableDelimiter", t.lineStart + e.pos, t.lineStart + e.text.length)
        ]);
      }
    } else if (this.rows) {
      let s = [];
      Dc(t, e.text, e.pos, s, t.lineStart), this.rows.push(t.elt("TableRow", t.lineStart + e.pos, t.lineStart + e.text.length, s));
    }
    return !1;
  }
  finish(t, e) {
    return this.rows ? (t.addLeafElement(e, t.elt("Table", e.start, e.start + e.content.length, this.rows)), !0) : !1;
  }
}, h(Md, "hc"), Md);
y(pT, "TableParser");
let $4 = pT;
const ZD = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": M.heading } },
    "TableRow",
    { name: "TableCell", style: M.content },
    { name: "TableDelimiter", style: M.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(n, t) {
      return Qx(t.content, 0) ? new $4() : null;
    },
    endLeaf(n, t, e) {
      if (e.parsers.some((s) => s instanceof $4) || !Qx(t.text, t.basePos))
        return !1;
      let i = n.peekLine();
      return uT.test(i) && Dc(n, t.text, t.basePos) == Dc(n, i, t.basePos);
    },
    before: "SetextHeading"
  }]
};
var Td;
const fT = (Td = class {
  nextLine() {
    return !1;
  }
  finish(t, e) {
    return t.addLeafElement(e, t.elt("Task", e.start, e.start + e.content.length, [
      t.elt("TaskMarker", e.start, e.start + 3),
      ...t.parser.parseInline(e.content.slice(3), e.start + 3)
    ])), !0;
  }
}, h(Td, "fc"), Td);
y(fT, "TaskParser");
let WD = fT;
const DD = {
  defineNodes: [
    { name: "Task", block: !0, style: M.list },
    { name: "TaskMarker", style: M.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(n, t) {
      return /^\[[ xX]\][ \t]/.test(t.content) && n.parentType().name == "ListItem" ? new WD() : null;
    },
    after: "SetextHeading"
  }]
}, x4 = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, k4 = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, qD = /[\w-]+\.[\w-]+($|\/)/, S4 = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, P4 = /\/[a-zA-Z\d@.]+/gy;
function Mx(n, t, e, i) {
  let s = 0;
  for (let r = t; r < e; r++)
    n[r] == i && s++;
  return s;
}
h(Mx, "Gu$1");
y(Mx, "count");
function yT(n, t) {
  k4.lastIndex = t;
  let e = k4.exec(n);
  if (!e || qD.exec(e[0])[0].indexOf("_") > -1)
    return -1;
  let i = t + e[0].length;
  for (; ; ) {
    let s = n[i - 1], r;
    if (/[?!.,:*_~]/.test(s) || s == ")" && Mx(n, t, i, ")") > Mx(n, t, i, "("))
      i--;
    else if (s == ";" && (r = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(n.slice(t, i))))
      i = t + r.index;
    else
      break;
  }
  return i;
}
h(yT, "Nb$1");
y(yT, "autolinkURLEnd");
function Tx(n, t) {
  S4.lastIndex = t;
  let e = S4.exec(n);
  if (!e)
    return -1;
  let i = e[0][e[0].length - 1];
  return i == "_" || i == "-" ? -1 : t + e[0].length - (i == "." ? 1 : 0);
}
h(Tx, "Hu$1");
y(Tx, "autolinkEmailEnd");
const VD = {
  parseInline: [{
    name: "Autolink",
    parse(n, t, e) {
      let i = e - n.offset;
      if (i && /\w/.test(n.text[i - 1]))
        return -1;
      x4.lastIndex = i;
      let s = x4.exec(n.text), r = -1;
      if (!s)
        return -1;
      if (s[1] || s[2]) {
        if (r = yT(n.text, i + s[0].length), r > -1 && n.hasOpenLink) {
          let a = /([^\[\]]|\[[^\]]*\])*/.exec(n.text.slice(i, r));
          r = i + a[0].length;
        }
      } else s[3] ? r = Tx(n.text, i) : (r = Tx(n.text, i + s[0].length), r > -1 && s[0] == "xmpp:" && (P4.lastIndex = r, s = P4.exec(n.text), s && (r = s.index + s[0].length)));
      return r < 0 ? -1 : (n.addElement(n.elt("URL", e, r + n.offset)), r + n.offset);
    }
  }]
}, jD = [ZD, DD, ID, VD];
function oS(n, t, e) {
  return (i, s, r) => {
    if (s != n || i.char(r + 1) == n)
      return -1;
    let a = [i.elt(e, r, r + 1)];
    for (let o = r + 1; o < i.end; o++) {
      let l = i.char(o);
      if (l == n)
        return i.addElement(i.elt(t, r, o + 1, a.concat(i.elt(e, o, o + 1))));
      if (l == 92 && a.push(i.elt("Escape", o, o++ + 2)), Bi(l))
        break;
    }
    return -1;
  };
}
h(oS, "Vp$1");
y(oS, "parseSubSuper");
const FD = {
  defineNodes: [
    { name: "Superscript", style: M.special(M.content) },
    { name: "SuperscriptMark", style: M.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: oS(94, "Superscript", "SuperscriptMark")
  }]
}, UD = {
  defineNodes: [
    { name: "Subscript", style: M.special(M.content) },
    { name: "SubscriptMark", style: M.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: oS(126, "Subscript", "SubscriptMark")
  }]
}, BD = {
  defineNodes: [{ name: "Emoji", style: M.character }],
  parseInline: [{
    name: "Emoji",
    parse(n, t, e) {
      let i;
      return t != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(n.slice(e + 1, n.end))) ? -1 : n.addElement(n.elt("Emoji", e, e + 1 + i[0].length));
    }
  }]
};
var Vr;
const mT = (Vr = class {
  /**
  @internal
  */
  constructor(t, e, i, s, r, a, o, l, c, d = 0, p) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = s, this.pos = r, this.score = a, this.buffer = o, this.bufferBase = l, this.curContext = c, this.lookAhead = d, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, e, i = 0) {
    let s = t.parser.context;
    return new Vr(t, [], e, i, i, 0, [], 0, s ? new C4(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var e;
    let i = t >> 19, s = t & 65535, { parser: r } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let o = r.dynamicPrecedence(s);
    if (o && (this.score += o), i == 0) {
      this.pushState(r.getGoto(this.state, s, !0), this.reducePos), s < r.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), c = l ? this.stack[l - 2] : this.p.ranges[0].from, d = this.reducePos - c;
    d >= 2e3 && !(!((e = this.p.parser.nodeSet.types[s]) === null || e === void 0) && e.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = d) : this.p.lastBigReductionSize < d && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = d));
    let p = l ? this.stack[l - 1] : 0, f = this.bufferBase + this.buffer.length - p;
    if (s < r.minRepeatTerm || t & 131072) {
      let m = r.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, c, m, f + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[l];
    else {
      let m = this.stack[l - 3];
      this.state = r.getGoto(m, s, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(s, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, e, i, s = 4, r = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (e == i)
          return;
        if (a.buffer[o - 2] >= e) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!r || this.pos == i)
      this.buffer.push(t, e, i, s);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0) {
        let o = !1;
        for (let l = a; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            o = !0;
            break;
          }
        if (o)
          for (; a > 0 && this.buffer[a - 2] > i; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, s > 4 && (s -= 4);
      }
      this.buffer[a] = t, this.buffer[a + 1] = e, this.buffer[a + 2] = i, this.buffer[a + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, e, i, s) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let r = t, { parser: a } = this.p;
      (s > this.pos || e <= a.maxNode) && (this.pos = s, a.stateFlag(
        r,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(r, i), this.shiftContext(e, i), e <= a.maxNode && this.buffer.push(e, i, s, 4);
    } else
      this.pos = s, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, e, i, s) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let s = this.pos;
    this.reducePos = this.pos = s + t.length, this.pushState(e, s), this.buffer.push(
      i,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), s = t.bufferBase + e;
    for (; t && s == t.bufferBase; )
      t = t.parent;
    return new Vr(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, s, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let e = new ND(this); ; ) {
      let i = this.p.parser.stateSlot(
        e.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(e.state, t);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      e.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let r = 0, a; r < e.length; r += 2)
        (a = e[r + 1]) != this.state && this.p.parser.hasAction(a, t) && s.push(e[r], a);
      if (this.stack.length < 120)
        for (let r = 0; s.length < 8 && r < e.length; r += 2) {
          let a = e[r + 1];
          s.some((o, l) => l & 1 && o == a) || s.push(e[r], a);
        }
      e = s;
    }
    let i = [];
    for (let s = 0; s < e.length && i.length < 4; s += 2) {
      let r = e[s + 1];
      if (r == this.state)
        continue;
      let a = this.split();
      a.pushState(r, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(e[s], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, e = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((e & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, s = e & 65535, r = this.stack.length - i * 3;
      if (r < 0 || t.getGoto(this.stack[r], s, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        e = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, e = [], i = /* @__PURE__ */ y((s, r) => {
      if (!e.includes(s))
        return e.push(s), t.allActions(s, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let o = (a >> 19) - r;
            if (o > 1) {
              let l = a & 65535, c = this.stack.length - o * 3;
              if (c >= 0 && t.getGoto(this.stack[c], l, !1) >= 0)
                return o << 19 | 65536 | l;
            }
          } else {
            let o = i(a, r + 1);
            if (o != null)
              return o;
          }
        });
    }, "explore");
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new C4(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}, h(Vr, "jr"), Vr);
y(mT, "Stack");
let XD = mT;
var Ad;
const wT = (Ad = class {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}, h(Ad, "cc"), Ad);
y(wT, "StackContext");
let C4 = wT;
var Rd;
const gT = (Rd = class {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = s;
  }
}, h(Rd, "uc"), Rd);
y(gT, "SimulatedStack");
let ND = gT;
var jr;
const vT = (jr = class {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new jr(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new jr(this.stack, this.pos, this.index);
  }
}, h(jr, "qr"), jr);
y(vT, "StackBufferCursor");
let HD = vT;
function Ec(n, t = Uint16Array) {
  if (typeof n != "string")
    return n;
  let e = null;
  for (let i = 0, s = 0; i < n.length; ) {
    let r = 0;
    for (; ; ) {
      let a = n.charCodeAt(i++), o = !1;
      if (a == 126) {
        r = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, o = !0), r += l, o)
        break;
      r *= 46;
    }
    e ? e[s++] = r : e = new t(r);
  }
  return e;
}
h(Ec, "pr$1");
y(Ec, "decodeArray");
var Ed;
const bT = (Ed = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}, h(Ed, "dc"), Ed);
y(bT, "CachedToken");
let a1 = bT;
const Q4 = new a1();
var zd;
const OT = (zd = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Q4, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, e) {
    let i = this.range, s = this.rangeIndex, r = this.pos + t;
    for (; r < i.from; ) {
      if (!s)
        return null;
      let a = this.ranges[--s];
      r -= i.from - a.to, i = a;
    }
    for (; e < 0 ? r > i.to : r >= i.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let a = this.ranges[++s];
      r += a.from - i.to, i = a;
    }
    return r;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let e = this.chunkOff + t, i, s;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, s = this.chunk.charCodeAt(e);
    else {
      let r = this.resolveOffset(t, 1);
      if (r == null)
        return -1;
      if (i = r, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), s = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, e) {
    this.token.value = t, this.token.end = e;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = Q4, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let s of this.ranges) {
      if (s.from >= e)
        break;
      s.to > t && (i += this.input.read(Math.max(s.from, t), Math.min(s.to, e)));
    }
    return i;
  }
}, h(zd, "Oc"), zd);
y(OT, "InputStream");
let YD = OT;
var _d;
const $T = (_d = class {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    let { parser: i } = e.p;
    lS(this.data, t, e, this.id, i.data, i.tokenPrecTable);
  }
}, h(_d, "pc"), _d);
y($T, "TokenGroup");
let qc = $T;
qc.prototype.contextual = qc.prototype.fallback = qc.prototype.extend = !1;
var Ld;
const xT = (Ld = class {
  constructor(t, e, i) {
    this.precTable = e, this.elseToken = i, this.data = typeof t == "string" ? Ec(t) : t;
  }
  token(t, e) {
    let i = t.pos, s = 0;
    for (; ; ) {
      let r = t.next < 0, a = t.resolveOffset(1, 1);
      if (lS(this.data, t, e, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (r || s++, a == null)
        break;
      t.reset(a, t.token);
    }
    s && (t.reset(i, t.token), t.acceptToken(this.elseToken, s));
  }
}, h(Ld, "mc"), Ld);
y(xT, "LocalTokenGroup");
let uv = xT;
uv.prototype.contextual = qc.prototype.fallback = qc.prototype.extend = !1;
var Id;
const kT = (Id = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, e = {}) {
    this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend;
  }
}, h(Id, "gc"), Id);
y(kT, "ExternalTokenizer");
let un = kT;
function lS(n, t, e, i, s, r) {
  let a = 0, o = 1 << i, { dialect: l } = e.p.parser;
  t: for (; (o & n[a]) != 0; ) {
    let c = n[a + 1];
    for (let m = a + 3; m < c; m += 2)
      if ((n[m + 1] & o) > 0) {
        let w = n[m];
        if (l.allows(w) && (t.token.value == -1 || t.token.value == w || ST(w, t.token.value, s, r))) {
          t.acceptToken(w);
          break;
        }
      }
    let d = t.next, p = 0, f = n[a + 2];
    if (t.next < 0 && f > p && n[c + f * 3 - 3] == 65535) {
      a = n[c + f * 3 - 1];
      continue t;
    }
    for (; p < f; ) {
      let m = p + f >> 1, w = c + m + (m << 1), b = n[w], x = n[w + 1] || 65536;
      if (d < b)
        f = m;
      else if (d >= x)
        p = m + 1;
      else {
        a = n[w + 2], t.advance();
        continue t;
      }
    }
    break;
  }
}
h(lS, "Up$1");
y(lS, "readToken");
function Ax(n, t, e) {
  for (let i = t, s; (s = n[i]) != 65535; i++)
    if (s == e)
      return i - t;
  return -1;
}
h(Ax, "Ku$1");
y(Ax, "findOffset");
function ST(n, t, e, i) {
  let s = Ax(e, i, t);
  return s < 0 || Ax(e, i, n) < s;
}
h(ST, "e1$1");
y(ST, "overrides");
const Li = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Mb = null;
function Rx(n, t, e) {
  let i = n.cursor(Yt.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(n.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : n.length;
      }
}
h(Rx, "Ju$1");
y(Rx, "cutAt");
var Zd;
const PT = (Zd = class {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? Rx(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? Rx(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], s = this.index[e];
      if (s == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = i.children[s], a = this.start[e] + i.positions[s];
      if (a > t)
        return this.nextStart = a, null;
      if (r instanceof _t) {
        if (a == t) {
          if (a < this.safeFrom)
            return null;
          let o = a + r.length;
          if (o <= this.safeTo) {
            let l = r.prop(xt.lookAhead);
            if (!l || o + l < this.fragment.to)
              return r;
          }
        }
        this.index[e]++, a + r.length >= Math.max(this.safeFrom, t) && (this.trees.push(r), this.start.push(a), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = a + r.length;
    }
  }
}, h(Zd, "yc"), Zd);
y(PT, "FragmentCursor");
let GD = PT;
var Wd;
const CT = (Wd = class {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new a1());
  }
  getActions(t) {
    let e = 0, i = null, { parser: s } = t.p, { tokenizers: r } = s, a = s.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), o = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let c = 0; c < r.length; c++) {
      if ((1 << c & a) == 0)
        continue;
      let d = r[c], p = this.tokens[c];
      if (!(i && !d.fallback) && ((d.contextual || p.start != t.pos || p.mask != a || p.context != o) && (this.updateCachedToken(p, d, t), p.mask = a, p.context = o), p.lookAhead > p.end + 25 && (l = Math.max(p.lookAhead, l)), p.value != 0)) {
        let f = e;
        if (p.extended > -1 && (e = this.addActions(t, p.extended, p.end, e)), e = this.addActions(t, p.value, p.end, e), !d.extend && (i = p, e > f))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return l && t.setLookAhead(l), !i && t.pos == this.stream.end && (i = new a1(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new a1(), { pos: i, p: s } = t;
    return e.start = i, e.end = Math.min(i + 1, s.stream.end), e.value = i == s.stream.end ? s.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let s = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(s, t), i), t.value > -1) {
      let { parser: r } = i.p;
      for (let a = 0; a < r.specialized.length; a++)
        if (r.specialized[a] == t.value) {
          let o = r.specializers[a](this.stream.read(t.start, t.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            (o & 1) == 0 ? t.value = o >> 1 : t.extended = o >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(s + 1);
  }
  putAction(t, e, i, s) {
    for (let r = 0; r < s; r += 3)
      if (this.actions[r] == t)
        return s;
    return this.actions[s++] = t, this.actions[s++] = e, this.actions[s++] = i, s;
  }
  addActions(t, e, i, s) {
    let { state: r } = t, { parser: a } = t.p, { data: o } = a;
    for (let l = 0; l < 2; l++)
      for (let c = a.stateSlot(
        r,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (o[c] == 65535)
          if (o[c + 1] == 1)
            c = Bn(o, c + 2);
          else {
            s == 0 && o[c + 1] == 2 && (s = this.putAction(Bn(o, c + 2), e, i, s));
            break;
          }
        o[c] == e && (s = this.putAction(Bn(o, c + 1), e, i, s));
      }
    return s;
  }
}, h(Wd, "bc"), Wd);
y(CT, "TokenCache");
let KD = CT;
var Dd;
const QT = (Dd = class {
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new YD(e, s), this.tokens = new KD(t, this.stream), this.topTerm = t.top[1];
    let { from: r } = s[0];
    this.stacks = [XD.start(this, t.top[0], r)], this.fragments = i.length && this.stream.end - r > t.bufferLength * 4 ? new GD(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], s, r;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [a] = t;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > e)
          i.push(o);
        else {
          if (this.advanceStack(o, i, t))
            continue;
          {
            s || (s = [], r = []), s.push(o);
            let l = this.tokens.getMainToken(o);
            r.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = s && ET(s);
      if (a)
        return Li && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw Li && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let a = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, r, i);
      if (a)
        return Li && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, l) => l.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t: for (let a = 0; a < i.length - 1; a++) {
        let o = i[a];
        for (let l = a + 1; l < i.length; l++) {
          let c = i[l];
          if (o.sameState(c) || o.buffer.length > 500 && c.buffer.length > 500)
            if ((o.score - c.score || o.buffer.length - c.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(a--, 1);
              continue t;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, e, i) {
    let s = t.pos, { parser: r } = this, a = Li ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let c = t.curContext && t.curContext.tracker.strict, d = c ? t.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(s); p; ) {
        let f = this.parser.nodeSet.types[p.type.id] == p.type ? r.getGoto(t.state, p.type.id) : -1;
        if (f > -1 && p.length && (!c || (p.prop(xt.contextHash) || 0) == d))
          return t.useNode(p, f), Li && console.log(a + this.stackID(t) + ` (via reuse of ${r.getName(p.type.id)})`), !0;
        if (!(p instanceof _t) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let m = p.children[0];
        if (m instanceof _t && p.positions[0] == 0)
          p = m;
        else
          break;
      }
    }
    let o = r.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return t.reduce(o), Li && console.log(a + this.stackID(t) + ` (via always-reduce ${r.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let c = 0; c < l.length; ) {
      let d = l[c++], p = l[c++], f = l[c++], m = c == l.length || !i, w = m ? t : t.split(), b = this.tokens.mainToken;
      if (w.apply(d, p, b ? b.start : w.pos, f), Li && console.log(a + this.stackID(w) + ` (via ${(d & 65536) == 0 ? "shift" : `reduce of ${r.getName(
        d & 65535
        /* Action.ValueMask */
      )}`} for ${r.getName(p)} @ ${s}${w == t ? "" : ", split"})`), m)
        return !0;
      w.pos > s ? e.push(w) : i.push(w);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return Ex(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let s = null, r = !1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = e[a << 1], c = e[(a << 1) + 1], d = Li ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (r || (r = !0, o.restart(), Li && console.log(d + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let p = o.split(), f = d;
      for (let m = 0; p.forceReduce() && m < 10 && (Li && console.log(f + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); m++)
        Li && (f = this.stackID(p) + " -> ");
      for (let m of o.recoverByInsert(l))
        Li && console.log(d + this.stackID(m) + " (via recover-insert)"), this.advanceFully(m, i);
      this.stream.end > o.pos ? (c == o.pos && (c++, l = 0), o.recoverByDelete(l, c), Li && console.log(d + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), Ex(o, i)) : (!s || s.score < o.score) && (s = o);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), _t.build({
      buffer: HD.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (Mb || (Mb = /* @__PURE__ */ new WeakMap())).get(t);
    return e || Mb.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}, h(Dd, "Sc"), Dd);
y(QT, "Parse");
let JD = QT;
function Ex(n, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == n.pos && i.sameState(n)) {
      t[e].score < n.score && (t[e] = n);
      return;
    }
  }
  t.push(n);
}
h(Ex, "ed$1");
y(Ex, "pushStackDedup");
var qd;
const MT = (qd = class {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}, h(qd, "Qc"), qd);
y(MT, "Dialect");
let tq = MT;
const Tb = /* @__PURE__ */ y((n) => n, "id");
var Vd;
const TT = (Vd = class {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || Tb, this.reduce = t.reduce || Tb, this.reuse = t.reuse || Tb, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}, h(Vd, "wc"), Vd);
y(TT, "ContextTracker");
let AT = TT;
var Fr;
const RT = (Fr = class extends y0 {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let o = 0; o < t.repeatNodeCount; o++)
      e.push("");
    let i = Object.keys(t.topRules).map((o) => t.topRules[o][1]), s = [];
    for (let o = 0; o < e.length; o++)
      s.push([]);
    function r(o, l, c) {
      s[o].push([l, l.deserialize(String(c))]);
    }
    if (h(r, "s"), y(r, "setProp"), t.nodeProps)
      for (let o of t.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = xt[l]);
        for (let c = 1; c < o.length; ) {
          let d = o[c++];
          if (d >= 0)
            r(d, l, o[c++]);
          else {
            let p = o[c + -d];
            for (let f = -d; f > 0; f--)
              r(o[c++], l, p);
            c++;
          }
        }
      }
    this.nodeSet = new u0(e.map((o, l) => Fe.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: s[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = B8;
    let a = Ec(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(zx), this.states = Ec(t.states, Uint32Array), this.data = Ec(t.stateData), this.goto = Ec(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((o) => typeof o == "number" ? new qc(a, o) : o), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let s = new JD(this, t, e, i);
    for (let r of this.wrappers)
      s = r(s, t, e, i);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, e, i = !1) {
    let s = this.goto;
    if (e >= s[0])
      return -1;
    for (let r = s[e + 1]; ; ) {
      let a = s[r++], o = a & 1, l = s[r++];
      if (o && i)
        return l;
      for (let c = r + (a >> 1); r < c; r++)
        if (s[r] == t)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, e) {
    let i = this.data;
    for (let s = 0; s < 2; s++)
      for (let r = this.stateSlot(
        t,
        s ? 2 : 1
        /* ParseState.Actions */
      ), a; ; r += 3) {
        if ((a = i[r]) == 65535)
          if (i[r + 1] == 1)
            a = i[r = Bn(i, r + 2)];
          else {
            if (i[r + 1] == 2)
              return Bn(i, r + 2);
            break;
          }
        if (a == e || a == 0)
          return Bn(i, r + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  /**
  @internal
  */
  stateFlag(t, e) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & e) > 0;
  }
  /**
  @internal
  */
  validAction(t, e) {
    return !!this.allActions(t, (i) => i == e ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, e) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), s = i ? e(i) : void 0;
    for (let r = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); s == null; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Bn(this.data, r + 2);
        else
          break;
      s = e(Bn(this.data, r + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Bn(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let s = this.data[i + 1];
        e.some((r, a) => a & 1 && r == s) || e.push(this.data[i], s);
      }
    }
    return e;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let e = Object.assign(Object.create(Fr.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let s = t.tokenizers.find((r) => r.from == i);
      return s ? s.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, s) => {
      let r = t.specializers.find((o) => o.from == i.external);
      if (!r)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: r.to });
      return e.specializers[s] = zx(a), a;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let r of t.split(" ")) {
        let a = e.indexOf(r);
        a >= 0 && (i[a] = !0);
      }
    let s = null;
    for (let r = 0; r < e.length; r++)
      if (!i[r])
        for (let a = this.dialects[e[r]], o; (o = this.data[a++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new tq(t, i, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new Fr(t);
  }
}, h(Fr, "Dr"), Fr);
y(RT, "LRParser");
let cS = RT;
function Bn(n, t) {
  return n[t] | n[t + 1] << 16;
}
h(Bn, "at$2");
y(Bn, "pair");
function ET(n) {
  let t = null;
  for (let e of n) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(
      e.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
h(ET, "t1$1");
y(ET, "findFinished");
function zx(n) {
  if (n.external) {
    let t = n.extend ? 1 : 0;
    return (e, i) => n.external(e, i) << 1 | t;
  }
  return n.get;
}
h(zx, "td$1");
y(zx, "getSpecializer");
const eq = 54, iq = 1, nq = 55, sq = 2, rq = 56, aq = 3, M4 = 4, oq = 5, pv = 6, zT = 7, _T = 8, LT = 9, IT = 10, lq = 11, cq = 12, hq = 13, Ab = 57, dq = 14, T4 = 58, ZT = 20, uq = 22, WT = 23, pq = 24, _x = 26, DT = 27, fq = 28, yq = 31, mq = 34, wq = 36, gq = 37, vq = 0, bq = 1, Oq = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, $q = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, A4 = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function qT(n) {
  return n == 45 || n == 46 || n == 58 || n >= 65 && n <= 90 || n == 95 || n >= 97 && n <= 122 || n >= 161;
}
h(qT, "P1$1");
y(qT, "nameChar");
function hS(n) {
  return n == 9 || n == 10 || n == 13 || n == 32;
}
h(hS, "Bp$1");
y(hS, "isSpace");
let R4 = null, E4 = null, z4 = 0;
function fv(n, t) {
  let e = n.pos + t;
  if (z4 == e && E4 == n) return R4;
  let i = n.peek(t);
  for (; hS(i); ) i = n.peek(++t);
  let s = "";
  for (; qT(i); )
    s += String.fromCharCode(i), i = n.peek(++t);
  return E4 = n, z4 = e, R4 = s ? s.toLowerCase() : i == xq || i == kq ? void 0 : null;
}
h(fv, "ja$1");
y(fv, "tagNameAfter");
const VT = 60, yv = 62, dS = 47, xq = 63, kq = 33, Sq = 45;
function Lx(n, t) {
  this.name = n, this.parent = t;
}
h(Lx, "ad$1");
y(Lx, "ElementContext");
const Pq = [pv, IT, zT, _T, LT], Cq = new AT({
  start: null,
  shift(n, t, e, i) {
    return Pq.indexOf(t) > -1 ? new Lx(fv(i, 1) || "", n) : n;
  },
  reduce(n, t) {
    return t == ZT && n ? n.parent : n;
  },
  reuse(n, t, e, i) {
    let s = t.type.id;
    return s == pv || s == wq ? new Lx(fv(i, 1) || "", n) : n;
  },
  strict: !1
}), Qq = new un((n, t) => {
  if (n.next != VT) {
    n.next < 0 && t.context && n.acceptToken(Ab);
    return;
  }
  n.advance();
  let e = n.next == dS;
  e && n.advance();
  let i = fv(n, 0);
  if (i === void 0) return;
  if (!i) return n.acceptToken(e ? dq : pv);
  let s = t.context ? t.context.name : null;
  if (e) {
    if (i == s) return n.acceptToken(lq);
    if (s && $q[s]) return n.acceptToken(Ab, -2);
    if (t.dialectEnabled(vq)) return n.acceptToken(cq);
    for (let r = t.context; r; r = r.parent) if (r.name == i) return;
    n.acceptToken(hq);
  } else {
    if (i == "script") return n.acceptToken(zT);
    if (i == "style") return n.acceptToken(_T);
    if (i == "textarea") return n.acceptToken(LT);
    if (Oq.hasOwnProperty(i)) return n.acceptToken(IT);
    s && A4[s] && A4[s][i] ? n.acceptToken(Ab, -1) : n.acceptToken(pv);
  }
}, { contextual: !0 }), Mq = new un((n) => {
  for (let t = 0, e = 0; ; e++) {
    if (n.next < 0) {
      e && n.acceptToken(T4);
      break;
    }
    if (n.next == Sq)
      t++;
    else if (n.next == yv && t >= 2) {
      e >= 3 && n.acceptToken(T4, -2);
      break;
    } else
      t = 0;
    n.advance();
  }
});
function jT(n) {
  for (; n; n = n.parent)
    if (n.name == "svg" || n.name == "math") return !0;
  return !1;
}
h(jT, "L1$1");
y(jT, "inForeignElement");
const Tq = new un((n, t) => {
  if (n.next == dS && n.peek(1) == yv) {
    let e = t.dialectEnabled(bq) || jT(t.context);
    n.acceptToken(e ? oq : M4, 2);
  } else n.next == yv && n.acceptToken(M4, 1);
});
function k0(n, t, e) {
  let i = 2 + n.length;
  return new un((s) => {
    for (let r = 0, a = 0, o = 0; ; o++) {
      if (s.next < 0) {
        o && s.acceptToken(t);
        break;
      }
      if (r == 0 && s.next == VT || r == 1 && s.next == dS || r >= 2 && r < i && s.next == n.charCodeAt(r - 2))
        r++, a++;
      else if ((r == 2 || r == i) && hS(s.next))
        a++;
      else if (r == i && s.next == yv) {
        o > a ? s.acceptToken(t, -a) : s.acceptToken(e, -(a - 2));
        break;
      } else if ((s.next == 10 || s.next == 13) && o) {
        s.acceptToken(t, 1);
        break;
      } else
        r = a = 0;
      s.advance();
    }
  });
}
h(k0, "Qh$1");
y(k0, "contentTokenizer");
const Aq = k0("script", eq, iq), Rq = k0("style", nq, sq), Eq = k0("textarea", rq, aq), zq = al({
  "Text RawText": M.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": M.angleBracket,
  TagName: M.tagName,
  "MismatchedCloseTag/TagName": [M.tagName, M.invalid],
  AttributeName: M.attributeName,
  "AttributeValue UnquotedAttributeValue": M.attributeValue,
  Is: M.definitionOperator,
  "EntityReference CharacterReference": M.character,
  Comment: M.blockComment,
  ProcessingInst: M.processingInstruction,
  DoctypeDecl: M.documentMeta
}), _q = cS.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Cq,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [zq],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [Aq, Rq, Eq, Tq, Qq, Mq, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function uS(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let i of n.getChildren(WT)) {
    let s = i.getChild(pq), r = i.getChild(_x) || i.getChild(DT);
    s && (e[t.read(s.from, s.to)] = r ? r.type.id == _x ? t.read(r.from + 1, r.to - 1) : t.read(r.from, r.to) : "");
  }
  return e;
}
h(uS, "Np$1");
y(uS, "getAttrs");
function Ix(n, t) {
  let e = n.getChild(uq);
  return e ? t.read(e.from, e.to) : " ";
}
h(Ix, "hd$1");
y(Ix, "findTagName");
function o1(n, t, e) {
  let i;
  for (let s of e)
    if (!s.attrs || s.attrs(i || (i = uS(n.node.parent.firstChild, t))))
      return { parser: s.parser };
  return null;
}
h(o1, "jo$1");
y(o1, "maybeNest");
function pS(n = [], t = []) {
  let e = [], i = [], s = [], r = [];
  for (let o of n)
    (o.tag == "script" ? e : o.tag == "style" ? i : o.tag == "textarea" ? s : r).push(o);
  let a = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of t) (a[o.name] || (a[o.name] = [])).push(o);
  return A5((o, l) => {
    let c = o.type.id;
    if (c == fq) return o1(o, l, e);
    if (c == yq) return o1(o, l, i);
    if (c == mq) return o1(o, l, s);
    if (c == ZT && r.length) {
      let d = o.node, p = d.firstChild, f = p && Ix(p, l), m;
      if (f) {
        for (let w of r)
          if (w.tag == f && (!w.attrs || w.attrs(m || (m = uS(p, l))))) {
            let b = d.lastChild, x = b.type.id == gq ? b.from : d.to;
            if (x > p.to)
              return { parser: w.parser, overlay: [{ from: p.to, to: x }] };
          }
      }
    }
    if (a && c == WT) {
      let d = o.node, p;
      if (p = d.firstChild) {
        let f = a[l.read(p.from, p.to)];
        if (f) for (let m of f) {
          if (m.tagName && m.tagName != Ix(d.parent, l)) continue;
          let w = d.lastChild;
          if (w.type.id == _x) {
            let b = w.from + 1, x = w.lastChild, O = w.to - (x && x.isError ? 0 : 1);
            if (O > b) return { parser: m.parser, overlay: [{ from: b, to: O }] };
          } else if (w.type.id == DT)
            return { parser: m.parser, overlay: [{ from: w.from, to: w.to }] };
        }
      }
    }
    return null;
  });
}
h(pS, "Gp$1");
y(pS, "configureNesting");
const Lq = 100, _4 = 1, Iq = 101, Zq = 102, L4 = 2, FT = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Wq = 58, Dq = 40, UT = 95, qq = 91, l1 = 45, Vq = 46, jq = 35, Fq = 37, Uq = 38, Bq = 92, Xq = 10;
function Gf(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 161;
}
h(Gf, "dn$1");
y(Gf, "isAlpha");
function fS(n) {
  return n >= 48 && n <= 57;
}
h(fS, "Kp$1");
y(fS, "isDigit");
const Nq = new un((n, t) => {
  for (let e = !1, i = 0, s = 0; ; s++) {
    let { next: r } = n;
    if (Gf(r) || r == l1 || r == UT || e && fS(r))
      !e && (r != l1 || s > 0) && (e = !0), i === s && r == l1 && i++, n.advance();
    else if (r == Bq && n.peek(1) != Xq)
      n.advance(), n.next > -1 && n.advance(), e = !0;
    else {
      e && n.acceptToken(r == Dq ? Iq : i == 2 && t.canShift(L4) ? L4 : Zq);
      break;
    }
  }
}), Hq = new un((n) => {
  if (FT.includes(n.peek(-1))) {
    let { next: t } = n;
    (Gf(t) || t == UT || t == jq || t == Vq || t == qq || t == Wq && Gf(n.peek(1)) || t == l1 || t == Uq) && n.acceptToken(Lq);
  }
}), Yq = new un((n) => {
  if (!FT.includes(n.peek(-1))) {
    let { next: t } = n;
    if (t == Fq && (n.advance(), n.acceptToken(_4)), Gf(t)) {
      do
        n.advance();
      while (Gf(n.next) || fS(n.next));
      n.acceptToken(_4);
    }
  }
}), Gq = al({
  "AtKeyword import charset namespace keyframes media supports": M.definitionKeyword,
  "from to selector": M.keyword,
  NamespaceName: M.namespace,
  KeyframeName: M.labelName,
  KeyframeRangeName: M.operatorKeyword,
  TagName: M.tagName,
  ClassName: M.className,
  PseudoClassName: M.constant(M.className),
  IdName: M.labelName,
  "FeatureName PropertyName": M.propertyName,
  AttributeName: M.attributeName,
  NumberLiteral: M.number,
  KeywordQuery: M.keyword,
  UnaryQueryOp: M.operatorKeyword,
  "CallTag ValueName": M.atom,
  VariableName: M.variableName,
  Callee: M.operatorKeyword,
  Unit: M.unit,
  "UniversalSelector NestingSelector": M.definitionOperator,
  MatchOp: M.compareOperator,
  "ChildOp SiblingOp, LogicOp": M.logicOperator,
  BinOp: M.arithmeticOperator,
  Important: M.modifier,
  Comment: M.blockComment,
  ColorLiteral: M.color,
  "ParenthesizedContent StringLiteral": M.string,
  ":": M.punctuation,
  "PseudoOp #": M.derefOperator,
  "; ,": M.separator,
  "( )": M.paren,
  "[ ]": M.squareBracket,
  "{ }": M.brace
}), Kq = { __proto__: null, lang: 34, "nth-child": 34, "nth-last-child": 34, "nth-of-type": 34, "nth-last-of-type": 34, dir: 34, "host-context": 34, url: 62, "url-prefix": 62, domain: 62, regexp: 62, selector: 140 }, Jq = { __proto__: null, "@import": 120, "@media": 144, "@charset": 148, "@namespace": 152, "@keyframes": 158, "@supports": 170 }, tV = { __proto__: null, not: 134, only: 134 }, eV = cS.deserialize({
  version: 14,
  states: ":jQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#CiO$qQ[O'#DUO$vQ[O'#DXOOQP'#En'#EnO${QdO'#DhO%jQ[O'#DuO${QdO'#DwO%{Q[O'#DyO&WQ[O'#D|O&`Q[O'#ESO&nQ[O'#EUOOQS'#Em'#EmOOQS'#EX'#EXQYQ[OOO&uQXO'#CdO'jQWO'#DdO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@])C@]OOQP'#Ch'#ChOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E]O({QWO,58{O)TQ[O,59TO$qQ[O,59pO$vQ[O,59sO(aQ[O,59vO(aQ[O,59xO(aQ[O,59yO)`Q[O'#DcOOQS,58{,58{OOQP'#Cl'#ClOOQO'#DS'#DSOOQP,59T,59TO)gQWO,59TO)lQWO,59TOOQP'#DW'#DWOOQP,59p,59pOOQO'#DY'#DYO)qQ`O,59sOOQS'#Cq'#CqO${QdO'#CrO)yQvO'#CtO+ZQtO,5:SOOQO'#Cy'#CyO)lQWO'#CxO+oQWO'#CzO+tQ[O'#DPOOQS'#Ep'#EpOOQO'#Dk'#DkO+|Q[O'#DrO,[QWO'#EtO&`Q[O'#DpO,jQWO'#DsOOQO'#Eu'#EuO)OQWO,5:aO,oQpO,5:cOOQS'#D{'#D{O,wQWO,5:eO,|Q[O,5:eOOQO'#EO'#EOO-UQWO,5:hO-ZQWO,5:nO-cQWO,5:pOOQS-E8V-E8VO-kQdO,5:OO-{Q[O'#E_O.YQWO,5;_O.YQWO,5;_POOO'#EW'#EWP.eO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO/[QXO,5:wOOQO-E8Z-E8ZOOQS1G.g1G.gOOQP1G.o1G.oO)gQWO1G.oO)lQWO1G.oOOQP1G/[1G/[O/iQ`O1G/_O0SQXO1G/bO0jQXO1G/dO1QQXO1G/eO1hQWO,59}O1mQ[O'#DTO1tQdO'#CpOOQP1G/_1G/_O${QdO1G/_O1{QpO,59^OOQS,59`,59`O${QdO,59bO2TQWO1G/nOOQS,59d,59dO2YQ!bO,59fOOQS'#DQ'#DQOOQS'#EZ'#EZO2eQ[O,59kOOQS,59k,59kO2mQWO'#DkO2xQWO,5:WO2}QWO,5:^O&`Q[O,5:YO&`Q[O'#E`O3VQWO,5;`O3bQWO,5:[O(aQ[O,5:_OOQS1G/{1G/{OOQS1G/}1G/}OOQS1G0P1G0PO3sQWO1G0PO3xQdO'#EPOOQS1G0S1G0SOOQS1G0Y1G0YOOQS1G0[1G0[O4TQtO1G/jOOQO1G/j1G/jOOQO,5:y,5:yO4kQ[O,5:yOOQO-E8]-E8]O4xQWO1G0yPOOO-E8U-E8UPOOO1G.e1G.eOOQP7+$Z7+$ZOOQP7+$y7+$yO${QdO7+$yOOQS1G/i1G/iO5TQXO'#ErO5[QWO,59oO5aQtO'#EYO6XQdO'#EoO6cQWO,59[O6hQpO7+$yOOQS1G.x1G.xOOQS1G.|1G.|OOQS7+%Y7+%YOOQS1G/Q1G/QO6pQWO1G/QOOQS-E8X-E8XOOQS1G/V1G/VO${QdO1G/rOOQO1G/x1G/xOOQO1G/t1G/tO6uQWO,5:zOOQO-E8^-E8^O7TQXO1G/yOOQS7+%k7+%kO7[QYO'#CtOOQO'#ER'#ERO7gQ`O'#EQOOQO'#EQ'#EQO7rQWO'#EaO7zQdO,5:kOOQS,5:k,5:kO8VQtO'#E^O${QdO'#E^O9WQdO7+%UOOQO7+%U7+%UOOQO1G0e1G0eO9kQpO<<HeO9sQWO,5;^OOQP1G/Z1G/ZOOQS-E8W-E8WO${QdO'#E[O9{QWO,5;ZOOQT1G.v1G.vOOQP<<He<<HeOOQS7+$l7+$lO:TQdO7+%^OOQO7+%e7+%eOOQO,5:l,5:lO3{QdO'#EbO7rQWO,5:{OOQS,5:{,5:{OOQS-E8_-E8_OOQS1G0V1G0VO:[QtO,5:xOOQS-E8[-E8[OOQO<<Hp<<HpOOQPAN>PAN>PO;]QdO,5:vOOQO-E8Y-E8YOOQO<<Hx<<HxOOQO,5:|,5:|OOQO-E8`-E8`OOQS1G0g1G0g",
  stateData: ";o~O#[OS#]QQ~OUYOXYOZTO^VO_VOrXOyWO!]aO!^ZO!j[O!l]O!n^O!q_O!w`O#YRO~OQfOUYOXYOZTO^VO_VOrXOyWO!]aO!^ZO!j[O!l]O!n^O!q_O!w`O#YeO~O#V#gP~P!ZO#]jO~O#YlO~OZnO^qO_qOrsOuoOyrO!PtO!SvO#WuO~O!UwO~P#pOa}O#XzO#YyO~O#Y!OO~O#Y!QO~OQ![Oc!TOg![Oi![Oo!YOr!ZO#X!WO#Y!SO#e!UO~Oc!^O!e!`O!h!aO#Y!]O!U#hP~Oi!fOo!YO#Y!eO~Oi!hO#Y!hO~Oc!^O!e!`O!h!aO#Y!]O~O!Z#hP~P%jOZWX^WX^!XX_WXrWXuWXyWX!PWX!SWX!UWX#WWX~O^!mO~O!Z!nO#V#gX!T#gX~O#V#gX!T#gX~P!ZO#^!qO#_!qO#`!sO~OUYOXYOZTO^VO_VOrXOyWO#YRO~OuoO!UwO~Oa!zO#XzO#YyO~O!T#gP~P!ZOc#RO~Oc#SO~Oq#TO}#UO~OP#WOchXkhX!ZhX!ehX!hhX#YhXbhXQhXghXihXohXrhXuhX!YhX#VhX#XhX#ehXqhX!ThX~Oc!^Ok#XO!e!`O!h!aO#Y!]O!Z#hP~Oc#[O~Oq#`O#Y#]O~Oc!^O!e!`O!h!aO#Y#aO~Ou#eO!c#dO!U#hX!Z#hX~Oc#hO~Ok#XO!Z#jO~O!Z#kO~Oi#lOo!YO~O!U#mO~O!UwO!c#dO~O!UwO!Z#pO~O!Y#rO!Z!Wa#V!Wa!T!Wa~P${O!Z#RX#V#RX!T#RX~P!ZO!Z!nO#V#ga!T#ga~O#^!qO#_!qO#`#xO~OZnO^qO_qOrsOyrO!PtO!SvO#WuO~Ou#Pa!U#Pab#Pa~P.pOq#zO}#{O~OZnO^qO_qOrsOyrO~Ou!Oi!P!Oi!S!Oi!U!Oi#W!Oib!Oi~P/qOu!Qi!P!Qi!S!Qi!U!Qi#W!Qib!Qi~P/qOu!Ri!P!Ri!S!Ri!U!Ri#W!Rib!Ri~P/qO!T#|O~Ob#fP~P(aOb#cP~P${Ob$TOk#XO~O!Z$VO~Ob$WOi$XOp$XO~Oq$ZO#Y#]O~O^!aXb!_X!c!_X~O^$[O~Ob$]O!c#dO~Ou#eO!U#ha!Z#ha~O!c#dOu!da!U!da!Z!dab!da~O!Z$bO~O!T$iO#Y$dO#e$cO~Ok#XOu$kO!Y$mO!Z!Wi#V!Wi!T!Wi~P${O!Z#Ra#V#Ra!T#Ra~P!ZO!Z!nO#V#gi!T#gi~Ob#fX~P#pOb$qO~Ok#XOQ!|Xb!|Xc!|Xg!|Xi!|Xo!|Xr!|Xu!|X#X!|X#Y!|X#e!|X~Ou$sOb#cX~P${Ob$uO~Ok#XOq$vO~Ob$wO~O!c#dOu#Sa!U#Sa!Z#Sa~Ob$yO~P.pOP#WOuhX!UhX~O#e$cOu!tX!U!tX~Ou${O!UwO~O!T%PO#Y$dO#e$cO~Ok#XOQ#QXc#QXg#QXi#QXo#QXr#QXu#QX!Y#QX!Z#QX#V#QX#X#QX#Y#QX#e#QX!T#QX~Ou$kO!Y%SO!Z!Wq#V!Wq!T!Wq~P${Ok#XOq%TO~OuoOb#fa~Ou$sOb#ca~Ob%WO~P${Ok#XOQ#Qac#Qag#Qai#Qao#Qar#Qau#Qa!Y#Qa!Z#Qa#V#Qa#X#Qa#Y#Qa#e#Qa!T#Qa~Ob#Oau#Oa~P${O#[p#]#ek!S#e~",
  goto: "-g#jPPP#kP#nP#w$WP#wP$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+Z+v+yP,o,r,x-RRkQ_bOPdhw!n#tkYOPdhotuvw!n#R#h#tkSOPdhotuvw!n#R#h#tQmTR!tnQ{VR!xqQ!x}Q#Z!XR#y!zq![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UU$f#m$h${R$z$eq!XZ]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#y!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ$}$gR%Z$|SgPwQ!phQ#s!nR$n#tZfPhw!n#ta!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$g#m$hR%X${V$e#m$h${Q!rjR#w!rQdOShPwU!ldh#tR#t!nQ$Q#SU$r$Q$x%UQ$x$[R%U$sQ#_!ZR$Y#_Q$t$QR%V$tQpUS!vp$pR$p#}Q$l#qR%R$lQ!ogS#u!o#vR#v!pQ#f!_R$`#fQ$h#mR%O$hQ$|$gR%Y$|_cOPdhw!n#t^UOPdhw!n#tQ!uoQ!}tQ#OuQ#PvQ#}#RR$a#hR$R#SQ!VZQ!d]Q#V!TQ#q!m[$P#S$Q$[$s$x%UQ$S#UQ$U#XS$j#q$lQ$o#{R%Q$kR$O#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$^#dR$_#e",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 25, ""],
    ["openedBy", 18, "(", 33, "[", 51, "{"],
    ["closedBy", 19, ")", 34, "]", 52, "}"]
  ],
  propSources: [Gq],
  skippedNodes: [0, 3, 88],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSp`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#[~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#[~p`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUp`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Up`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUp`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Up`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUp`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Up`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUp`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Up`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!Y[p`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOi~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYyQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYp`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYp`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYg[p`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYg[p`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYp`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYg[p`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYp`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSg[p`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS}Sp`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSc^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOb~n9{UUQkWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWkW!SQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUp`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYp`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYp`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUp`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUp`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[p`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSu^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWkWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VUZQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTkWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSp`#]~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU^QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S_Qp`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Z^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS}SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!PQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!PQp`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!]Qp`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSr^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSq^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUp`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!cQp`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!UUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!T^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!SQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [Hq, Yq, Nq, 1, 2, 3, 4, new uv("m~RRYZ[z{a~~g~aO#_~~dP!P!Qg~lO#`~~", 28, 106)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 87] },
  specialized: [{ term: 101, get: /* @__PURE__ */ y((n) => Kq[n] || -1, "get") }, { term: 59, get: /* @__PURE__ */ y((n) => Jq[n] || -1, "get") }, { term: 102, get: /* @__PURE__ */ y((n) => tV[n] || -1, "get") }],
  tokenPrec: 1219
});
let Rb = null;
function c1() {
  if (!Rb && typeof document == "object" && document.body) {
    let { style: n } = document.body, t = [], e = /* @__PURE__ */ new Set();
    for (let i in n)
      i != "cssText" && i != "cssFloat" && typeof n[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase())), e.has(i) || (t.push(i), e.add(i)));
    Rb = t.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return Rb || [];
}
h(c1, "Do$1");
y(c1, "properties");
const I4 = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((n) => ({ type: "class", label: n })), Z4 = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((n) => ({ type: "keyword", label: n })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((n) => ({ type: "constant", label: n }))), iV = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((n) => ({ type: "type", label: n })), nV = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((n) => ({ type: "keyword", label: n })), ms = /^(\w[\w-]*|-\w[\w-]*|)$/, sV = /^-(-[\w-]*)?$/;
function BT(n, t) {
  var e;
  if ((n.name == "(" || n.type.isError) && (n = n.parent || n), n.name != "ArgList")
    return !1;
  let i = (e = n.parent) === null || e === void 0 ? void 0 : e.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? !1 : t.sliceString(i.from, i.to) == "var";
}
h(BT, "aS");
y(BT, "isVarArg");
const W4 = /* @__PURE__ */ new d6(), rV = ["Declaration"];
function XT(n) {
  for (let t = n; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return n;
  }
}
h(XT, "fS");
y(XT, "astTop");
function yS(n, t, e) {
  if (t.to - t.from > 4096) {
    let i = W4.get(t);
    if (i)
      return i;
    let s = [], r = /* @__PURE__ */ new Set(), a = t.cursor(Yt.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of yS(n, a.node, e))
          r.has(o.label) || (r.add(o.label), s.push(o));
      while (a.nextSibling());
    return W4.set(t, s), s;
  } else {
    let i = [], s = /* @__PURE__ */ new Set();
    return t.cursor().iterate((r) => {
      var a;
      if (e(r) && r.matchContext(rV) && ((a = r.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = n.sliceString(r.from, r.to);
        s.has(o) || (s.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
h(yS, "Jp");
y(yS, "variableNames");
const aV = /* @__PURE__ */ y((n) => (t) => {
  let { state: e, pos: i } = t, s = ce(e).resolveInner(i, -1), r = s.type.isError && s.from == s.to - 1 && e.doc.sliceString(s.from, s.to) == "-";
  if (s.name == "PropertyName" || (r || s.name == "TagName") && /^(Block|Styles)$/.test(s.resolve(s.to).name))
    return { from: s.from, options: c1(), validFor: ms };
  if (s.name == "ValueName")
    return { from: s.from, options: Z4, validFor: ms };
  if (s.name == "PseudoClassName")
    return { from: s.from, options: I4, validFor: ms };
  if (n(s) || (t.explicit || r) && BT(s, e.doc))
    return {
      from: n(s) || r ? s.from : i,
      options: yS(e.doc, XT(s), n),
      validFor: sV
    };
  if (s.name == "TagName") {
    for (let { parent: l } = s; l; l = l.parent)
      if (l.name == "Block")
        return { from: s.from, options: c1(), validFor: ms };
    return { from: s.from, options: iV, validFor: ms };
  }
  if (s.name == "AtKeyword")
    return { from: s.from, options: nV, validFor: ms };
  if (!t.explicit)
    return null;
  let a = s.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: I4, validFor: ms } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: Z4, validFor: ms } : a.name == "Block" || a.name == "Styles" ? { from: i, options: c1(), validFor: ms } : null;
}, "defineCSSCompletionSource"), oV = /* @__PURE__ */ aV((n) => n.name == "VariableName"), mv = /* @__PURE__ */ z5.define({
  name: "css",
  parser: /* @__PURE__ */ eV.configure({
    props: [
      /* @__PURE__ */ Oy.add({
        Declaration: /* @__PURE__ */ ew()
      }),
      /* @__PURE__ */ Jw.add({
        "Block KeyframeList": Z5
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function NT() {
  return new Hf(mv, mv.data.of({ autocomplete: oV }));
}
h(NT, "im$1");
y(NT, "css");
const lV = 314, cV = 315, D4 = 1, hV = 2, dV = 3, uV = 4, pV = 316, fV = 318, yV = 319, mV = 5, wV = 6, gV = 0, Zx = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], HT = 125, vV = 59, Wx = 47, bV = 42, OV = 43, $V = 45, xV = 60, kV = 44, SV = 63, PV = 46, CV = 91, QV = new AT({
  start: !1,
  shift(n, t) {
    return t == mV || t == wV || t == fV ? n : t == yV;
  },
  strict: !1
}), MV = new un((n, t) => {
  let { next: e } = n;
  (e == HT || e == -1 || t.context) && n.acceptToken(pV);
}, { contextual: !0, fallback: !0 }), TV = new un((n, t) => {
  let { next: e } = n, i;
  Zx.indexOf(e) > -1 || e == Wx && ((i = n.peek(1)) == Wx || i == bV) || e != HT && e != vV && e != -1 && !t.context && n.acceptToken(lV);
}, { contextual: !0 }), AV = new un((n, t) => {
  n.next == CV && !t.context && n.acceptToken(cV);
}, { contextual: !0 }), RV = new un((n, t) => {
  let { next: e } = n;
  if (e == OV || e == $V) {
    if (n.advance(), e == n.next) {
      n.advance();
      let i = !t.context && t.canShift(D4);
      n.acceptToken(i ? D4 : hV);
    }
  } else e == SV && n.peek(1) == PV && (n.advance(), n.advance(), (n.next < 48 || n.next > 57) && n.acceptToken(dV));
}, { contextual: !0 });
function h1(n, t) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !t && n >= 48 && n <= 57;
}
h(h1, "Bo$1");
y(h1, "identifierChar");
const EV = new un((n, t) => {
  if (n.next != xV || !t.dialectEnabled(gV) || (n.advance(), n.next == Wx)) return;
  let e = 0;
  for (; Zx.indexOf(n.next) > -1; )
    n.advance(), e++;
  if (h1(n.next, !0)) {
    for (n.advance(), e++; h1(n.next, !1); )
      n.advance(), e++;
    for (; Zx.indexOf(n.next) > -1; )
      n.advance(), e++;
    if (n.next == kV) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!h1(n.next, !0)) return;
        break;
      }
      if (n.next != "extends".charCodeAt(i)) break;
      n.advance(), e++;
    }
  }
  n.acceptToken(uV, -e);
}), zV = al({
  "get set async static": M.modifier,
  "for while do if else switch try catch finally return throw break continue default case": M.controlKeyword,
  "in of await yield void typeof delete instanceof": M.operatorKeyword,
  "let var const using function class extends": M.definitionKeyword,
  "import export from": M.moduleKeyword,
  "with debugger as new": M.keyword,
  TemplateString: M.special(M.string),
  super: M.atom,
  BooleanLiteral: M.bool,
  this: M.self,
  null: M.null,
  Star: M.modifier,
  VariableName: M.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": M.function(M.variableName),
  VariableDefinition: M.definition(M.variableName),
  Label: M.labelName,
  PropertyName: M.propertyName,
  PrivatePropertyName: M.special(M.propertyName),
  "CallExpression/MemberExpression/PropertyName": M.function(M.propertyName),
  "FunctionDeclaration/VariableDefinition": M.function(M.definition(M.variableName)),
  "ClassDeclaration/VariableDefinition": M.definition(M.className),
  "NewExpression/VariableName": M.className,
  PropertyDefinition: M.definition(M.propertyName),
  PrivatePropertyDefinition: M.definition(M.special(M.propertyName)),
  UpdateOp: M.updateOperator,
  "LineComment Hashbang": M.lineComment,
  BlockComment: M.blockComment,
  Number: M.number,
  String: M.string,
  Escape: M.escape,
  ArithOp: M.arithmeticOperator,
  LogicOp: M.logicOperator,
  BitOp: M.bitwiseOperator,
  CompareOp: M.compareOperator,
  RegExp: M.regexp,
  Equals: M.definitionOperator,
  Arrow: M.function(M.punctuation),
  ": Spread": M.punctuation,
  "( )": M.paren,
  "[ ]": M.squareBracket,
  "{ }": M.brace,
  "InterpolationStart InterpolationEnd": M.special(M.brace),
  ".": M.derefOperator,
  ", ;": M.separator,
  "@": M.meta,
  TypeName: M.typeName,
  TypeDefinition: M.definition(M.typeName),
  "type enum interface implements namespace module declare": M.definitionKeyword,
  "abstract global Privacy readonly override": M.modifier,
  "is keyof unique infer asserts": M.operatorKeyword,
  JSXAttributeValue: M.attributeValue,
  JSXText: M.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": M.angleBracket,
  "JSXIdentifier JSXNameSpacedName": M.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": M.attributeName,
  "JSXBuiltin/JSXIdentifier": M.standard(M.tagName)
}), _V = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, const: 52, extends: 56, this: 60, true: 68, false: 68, null: 80, void: 84, typeof: 88, super: 104, new: 138, delete: 150, yield: 159, await: 163, class: 168, public: 231, private: 231, protected: 231, readonly: 233, instanceof: 252, satisfies: 255, in: 256, import: 290, keyof: 347, unique: 351, infer: 357, asserts: 393, is: 395, abstract: 415, implements: 417, type: 419, let: 422, var: 424, using: 427, interface: 433, enum: 437, namespace: 443, module: 445, declare: 449, global: 453, for: 472, of: 481, while: 484, with: 488, do: 492, if: 496, else: 498, switch: 502, case: 508, try: 514, catch: 518, finally: 522, return: 526, throw: 530, break: 534, continue: 538, debugger: 542 }, LV = { __proto__: null, async: 125, get: 127, set: 129, declare: 191, public: 193, private: 193, protected: 193, static: 195, abstract: 197, override: 199, readonly: 205, accessor: 207, new: 399 }, IV = { __proto__: null, "<": 189 }, ZV = cS.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D_O.QQlO'#DeO.bQlO'#DpO%[QlO'#DxO0fQlO'#EQOOQ!0Lf'#EY'#EYO1PQ`O'#EVOOQO'#En'#EnOOQO'#Ij'#IjO1XQ`O'#GrO1dQ`O'#EmO1iQ`O'#EmO3hQ!0MxO'#JpO6[Q!0MxO'#JqO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#F{O9UQ`O'#FzOOQ!0Lf'#Jq'#JqOOQ!0Lb'#Jp'#JpO9ZQ`O'#GvOOQ['#K]'#K]O9fQ`O'#IWO9kQ!0LrO'#IXOOQ['#J^'#J^OOQ['#I]'#I]Q`QlOOQ`QlOOO9sQ!L^O'#DtO9zQlO'#D|O:RQlO'#EOO9aQ`O'#GrO:YQMhO'#CoO:hQ`O'#ElO:sQ`O'#EwO:xQMhO'#FdO;gQ`O'#GrOOQO'#K^'#K^O;lQ`O'#K^O;zQ`O'#GzO;zQ`O'#G{O;zQ`O'#G}O9aQ`O'#HQO<qQ`O'#HTO>YQ`O'#CeO>jQ`O'#HaO>rQ`O'#HgO>rQ`O'#HiO`QlO'#HkO>rQ`O'#HmO>rQ`O'#HpO>wQ`O'#HvO>|Q!0LsO'#H|O%[QlO'#IOO?XQ!0LsO'#IQO?dQ!0LsO'#ISO9kQ!0LrO'#IUO?oQ!0MxO'#CiO@qQpO'#DjQOQ`OOO%[QlO'#EOOAXQ`O'#ERO:YQMhO'#ElOAdQ`O'#ElOAoQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Do'#DoOOQ!0Lb'#Jt'#JtO%[QlO'#JtOOQO'#Jw'#JwOOQO'#If'#IfOBoQpO'#EeOOQ!0Lb'#Ed'#EdOOQ!0Lb'#J{'#J{OCkQ!0MSO'#EeOCuQpO'#EUOOQO'#Jv'#JvODZQpO'#JwOEhQpO'#EUOCuQpO'#EePEuO&2DjO'#CbPOOO)CD{)CD{OOOO'#I^'#I^OFQO#tO,59UOOQ!0Lh,59U,59UOOOO'#I_'#I_OF`O&jO,59UOFnQ!L^O'#DaOOOO'#Ia'#IaOFuO#@ItO,59yOOQ!0Lf,59y,59yOGTQlO'#IbOGhQ`O'#JrOIgQ!fO'#JrO+}QlO'#JrOInQ`O,5:POJUQ`O'#EnOJcQ`O'#KROJnQ`O'#KQOJnQ`O'#KQOJvQ`O,5;[OJ{Q`O'#KPOOQ!0Ln,5:[,5:[OKSQlO,5:[OMQQ!0MxO,5:dOMqQ`O,5:lON[Q!0LrO'#KOONcQ`O'#J}O9ZQ`O'#J}ONwQ`O'#J}O! PQ`O,5;ZO! UQ`O'#J}O!#ZQ!fO'#JqOOQ!0Lh'#Ci'#CiO%[QlO'#EQO!#yQ!fO,5:qOOQS'#Jx'#JxOOQO-E<h-E<hO9aQ`O,5=^O!$aQ`O,5=^O!$fQlO,5;XO!&iQMhO'#EiO!(SQ`O,5;XO!(XQlO'#DwO!(cQpO,5;bO!(kQpO,5;bO%[QlO,5;bOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cOOQ['#FY'#FYO!(yQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#InO!*|Q!0LrO,5<hO%[QlO,5;cO!&iQMhO,5;cO!+kQMhO,5;cO!-]QMhO'#E[O%[QlO,5;vOOQ!0Lf,5;z,5;zO!-dQ,UO'#FiO!.aQ,UO'#KVO!-{Q,UO'#KVO!.hQ,UO'#KVOOQO'#KV'#KVO!.|Q,UO,5<ROOOW,5<_,5<_O!/_QlO'#FuOOOW'#Im'#ImO7VO7dO,5<PO!/fQ,UO'#FwOOQ!0Lf,5<P,5<PO!0VQ$IUO'#CwOOQ!0Lh'#C{'#C{O!0jO#@ItO'#DPO!1WQMjO,5<dO!1_Q`O,5<gO!2zQ(CWO'#GWO!3XQ`O'#GXO!3^Q`O'#GXO!4|Q(CWO'#G]O!6RQpO'#GaOOQO'#Gm'#GmO!+rQMhO'#GlOOQO'#Go'#GoO!+rQMhO'#GnO!6tQ$IUO'#JjOOQ!0Lh'#Jj'#JjO!7OQ`O'#JiO!7^Q`O'#JhO!7fQ`O'#CuOOQ!0Lh'#Cy'#CyO!7qQ`O'#C{OOQ!0Lh'#DT'#DTOOQ!0Lh'#DV'#DVO1SQ`O'#DXO!+rQMhO'#GOO!+rQMhO'#GQO!7vQ`O'#GSO!7{Q`O'#GTO!3^Q`O'#GZO!+rQMhO'#G`O;zQ`O'#JiO!8QQ`O'#EoO!8oQ`O,5<fOOQ!0Lb'#Cr'#CrO!8wQ`O'#EpO!9qQpO'#EqOOQ!0Lb'#KP'#KPO!9xQ!0LrO'#K_O9kQ!0LrO,5=bO`QlO,5>rOOQ['#Jf'#JfOOQ[,5>s,5>sOOQ[-E<Z-E<ZO!;wQ!0MxO,5:`O!9lQpO,5:^O!>bQ!0MxO,5:hO%[QlO,5:hO!@xQ!0MxO,5:jOOQO,5@x,5@xO!AiQMhO,5=^O!AwQ!0LrO'#JgO9UQ`O'#JgO!BYQ!0LrO,59ZO!BeQpO,59ZO!BmQMhO,59ZO:YQMhO,59ZO!BxQ`O,5;XO!CQQ`O'#H`O!CfQ`O'#KbO%[QlO,5;|O!9lQpO,5<OO!CnQ`O,5=yO!CsQ`O,5=yO!CxQ`O,5=yO9kQ!0LrO,5=yO;zQ`O,5=iOOQO'#Cw'#CwO!DWQpO,5=fO!D`QMhO,5=gO!DkQ`O,5=iO!DpQ!bO,5=lO!DxQ`O'#K^O>wQ`O'#HVO9aQ`O'#HXO!D}Q`O'#HXO:YQMhO'#HZO!ESQ`O'#HZOOQ[,5=o,5=oO!EXQ`O'#H[O!EjQ`O'#CoO!EoQ`O,59PO!EyQ`O,59PO!HOQlO,59POOQ[,59P,59PO!H`Q!0LrO,59PO%[QlO,59PO!JkQlO'#HcOOQ['#Hd'#HdOOQ['#He'#HeO`QlO,5={O!KRQ`O,5={O`QlO,5>RO`QlO,5>TO!KWQ`O,5>VO`QlO,5>XO!K]Q`O,5>[O!KbQlO,5>bOOQ[,5>h,5>hO%[QlO,5>hO9kQ!0LrO,5>jOOQ[,5>l,5>lO# lQ`O,5>lOOQ[,5>n,5>nO# lQ`O,5>nOOQ[,5>p,5>pO#!YQpO'#D]O%[QlO'#JtO#!{QpO'#JtO##VQpO'#DkO##hQpO'#DkO#%yQlO'#DkO#&QQ`O'#JsO#&YQ`O,5:UO#&_Q`O'#ErO#&mQ`O'#KSO#&uQ`O,5;]O#&zQpO'#DkO#'XQpO'#ETOOQ!0Lf,5:m,5:mO%[QlO,5:mO#'`Q`O,5:mO>wQ`O,5;WO!BeQpO,5;WO!BmQMhO,5;WO:YQMhO,5;WO#'hQ`O,5@`O#'mQ07dO,5:qOOQO-E<d-E<dO#(sQ!0MSO,5;POCuQpO,5:pO#(}QpO,5:pOCuQpO,5;PO!BYQ!0LrO,5:pOOQ!0Lb'#Eh'#EhOOQO,5;P,5;PO%[QlO,5;PO#)[Q!0LrO,5;PO#)gQ!0LrO,5;PO!BeQpO,5:pOOQO,5;V,5;VO#)uQ!0LrO,5;PPOOO'#I['#I[P#*ZO&2DjO,58|POOO,58|,58|OOOO-E<[-E<[OOQ!0Lh1G.p1G.pOOOO-E<]-E<]OOOO,59{,59{O#*fQ!bO,59{OOOO-E<_-E<_OOQ!0Lf1G/e1G/eO#*kQ!fO,5>|O+}QlO,5>|OOQO,5?S,5?SO#*uQlO'#IbOOQO-E<`-E<`O#+SQ`O,5@^O#+[Q!fO,5@^O#+cQ`O,5@lOOQ!0Lf1G/k1G/kO%[QlO,5@mO#+kQ`O'#IhOOQO-E<f-E<fO#+cQ`O,5@lOOQ!0Lb1G0v1G0vOOQ!0Ln1G/v1G/vOOQ!0Ln1G0W1G0WO%[QlO,5@jO#,PQ!0LrO,5@jO#,bQ!0LrO,5@jO#,iQ`O,5@iO9ZQ`O,5@iO#,qQ`O,5@iO#-PQ`O'#IkO#,iQ`O,5@iOOQ!0Lb1G0u1G0uO!(cQpO,5:sO!(nQpO,5:sOOQS,5:u,5:uO#-qQdO,5:uO#-yQMhO1G2xO9aQ`O1G2xOOQ!0Lf1G0s1G0sO#.XQ!0MxO1G0sO#/^Q!0MvO,5;TOOQ!0Lh'#GV'#GVO#/zQ!0MzO'#JjO!$fQlO1G0sO#2VQ!fO'#JuO%[QlO'#JuO#2aQ`O,5:cOOQ!0Lh'#D]'#D]OOQ!0Lf1G0|1G0|O%[QlO1G0|OOQ!0Lf1G1e1G1eO#2fQ`O1G0|O#4zQ!0MxO1G0}O#5RQ!0MxO1G0}O#7iQ!0MxO1G0}O#7pQ!0MxO1G0}O#:WQ!0MxO1G0}O#<nQ!0MxO1G0}O#<uQ!0MxO1G0}O#<|Q!0MxO1G0}O#?dQ!0MxO1G0}O#?kQ!0MxO1G0}O#AxQ?MtO'#CiO#CsQ?MtO1G1_O#CzQ?MtO'#JqO#D_Q!0MxO,5?YOOQ!0Lb-E<l-E<lO#FlQ!0MxO1G0}O#GiQ!0MzO1G0}OOQ!0Lf1G0}1G0}O#HlQMjO'#JzO#HvQ`O,5:vO#H{Q!0MxO1G1bO#IoQ,UO,5<VO#IwQ,UO,5<WO#JPQ,UO'#FnO#JhQ`O'#FmOOQO'#KW'#KWOOQO'#Il'#IlO#JmQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#KOQ?MtO'#JpO#KYQ`O,5<aO!(yQlO,5<aOOOW-E<k-E<kOOQ!0Lf1G1k1G1kO#K_QpO'#KVOOQ!0Lf,5<c,5<cO#KgQpO,5<cO#KlQMhO'#DROOOO'#I`'#I`O#KsO#@ItO,59kOOQ!0Lh,59k,59kO%[QlO1G2OO!7{Q`O'#IpO#LOQ`O,5<yOOQ!0Lh,5<v,5<vO!+rQMhO'#IsO#LlQMjO,5=WO!+rQMhO'#IuO#M_QMjO,5=YO!&iQMhO,5=[OOQO1G2R1G2RO#MiQ!dO'#CrO#M|Q(CWO'#EpO$ RQpO'#GaO$ iQ!dO,5<rO$ pQ`O'#KYO9ZQ`O'#KYO$!OQ`O,5<tO!+rQMhO,5<sO$!TQ`O'#GYO$!fQ`O,5<sO$!kQ!dO'#GVO$!xQ!dO'#KZO$#SQ`O'#KZO!&iQMhO'#KZO$#XQ`O,5<wO$#^QlO'#JtO$#hQpO'#GbO##hQpO'#GbO$#yQ`O'#GfO!3^Q`O'#GjO$$OQ!0LrO'#IrO$$ZQpO,5<{OOQ!0Lp,5<{,5<{O$$bQpO'#GbO$$oQpO'#GcO$%QQpO'#GcO$%VQMjO,5=WO$%gQMjO,5=YOOQ!0Lh,5=],5=]O!+rQMhO,5@TO!+rQMhO,5@TO$%wQ`O'#IwO$&VQ`O,5@SO$&_Q`O,59aOOQ!0Lh,59g,59gO$'UQ$IYO,59sOOQ!0Lh'#Jn'#JnO$'wQMjO,5<jO$(jQMjO,5<lO@iQ`O,5<nOOQ!0Lh,5<o,5<oO$(tQ`O,5<uO$(yQMjO,5<zO$)ZQ`O,5@TO$)iQ`O'#J}O!$fQlO1G2QO$)nQ`O1G2QO9ZQ`O'#KQO9ZQ`O'#ErO%[QlO'#ErO9ZQ`O'#IyO$)sQ!0LrO,5@yOOQ[1G2|1G2|OOQ[1G4^1G4^OOQ!0Lf1G/z1G/zOOQ!0Lf1G/x1G/xO$+uQ!0MxO1G0SOOQ[1G2x1G2xO!&iQMhO1G2xO%[QlO1G2xO#-|Q`O1G2xO$-yQMhO'#EiOOQ!0Lb,5@R,5@RO$.WQ!0LrO,5@ROOQ[1G.u1G.uO!BYQ!0LrO1G.uO!BeQpO1G.uO!BmQMhO1G.uO$.iQ`O1G0sO$.nQ`O'#CiO$.yQ`O'#KcO$/RQ`O,5=zO$/WQ`O'#KcO$/]Q`O'#KcO$/kQ`O'#JPO$/yQ`O,5@|O$0RQ!fO1G1hOOQ!0Lf1G1j1G1jO9aQ`O1G3eO@iQ`O1G3eO$0YQ`O1G3eO$0_Q`O1G3eOOQ[1G3e1G3eO!DkQ`O1G3TO!&iQMhO1G3QO$0dQ`O1G3QOOQ[1G3R1G3RO!&iQMhO1G3RO$0iQ`O1G3RO$0qQpO'#HPOOQ[1G3T1G3TO!5|QpO'#I{O!DpQ!bO1G3WOOQ[1G3W1G3WOOQ[,5=q,5=qO$0yQMhO,5=sO9aQ`O,5=sO$#yQ`O,5=uO9UQ`O,5=uO!BeQpO,5=uO!BmQMhO,5=uO:YQMhO,5=uO$1XQ`O'#KaO$1dQ`O,5=vOOQ[1G.k1G.kO$1iQ!0LrO1G.kO@iQ`O1G.kO$1tQ`O1G.kO9kQ!0LrO1G.kO$3|Q!fO,5AOO$4ZQ`O,5AOO9ZQ`O,5AOO$4fQlO,5=}O$4mQ`O,5=}OOQ[1G3g1G3gO`QlO1G3gOOQ[1G3m1G3mOOQ[1G3o1G3oO>rQ`O1G3qO$4rQlO1G3sO$8vQlO'#HrOOQ[1G3v1G3vO$9TQ`O'#HxO>wQ`O'#HzOOQ[1G3|1G3|O$9]QlO1G3|O9kQ!0LrO1G4SOOQ[1G4U1G4UOOQ!0Lb'#G^'#G^O9kQ!0LrO1G4WO9kQ!0LrO1G4YO$=dQ`O,5@`O!(yQlO,5;^O9ZQ`O,5;^O>wQ`O,5:VO!(yQlO,5:VO!BeQpO,5:VO$=iQ?MtO,5:VOOQO,5;^,5;^O$=sQpO'#IcO$>ZQ`O,5@_OOQ!0Lf1G/p1G/pO$>cQpO'#IiO$>mQ`O,5@nOOQ!0Lb1G0w1G0wO##hQpO,5:VOOQO'#Ie'#IeO$>uQpO,5:oOOQ!0Ln,5:o,5:oO#'cQ`O1G0XOOQ!0Lf1G0X1G0XO%[QlO1G0XOOQ!0Lf1G0r1G0rO>wQ`O1G0rO!BeQpO1G0rO!BmQMhO1G0rOOQ!0Lb1G5z1G5zO!BYQ!0LrO1G0[OOQO1G0k1G0kO%[QlO1G0kO$>|Q!0LrO1G0kO$?XQ!0LrO1G0kO!BeQpO1G0[OCuQpO1G0[O$?gQ!0LrO1G0kOOQO1G0[1G0[O$?{Q!0MxO1G0kPOOO-E<Y-E<YPOOO1G.h1G.hOOOO1G/g1G/gO$@VQ!bO,5<hO$@_Q!fO1G4hOOQO1G4n1G4nO%[QlO,5>|O$@iQ`O1G5xO$@qQ`O1G6WO$@yQ!fO1G6XO9ZQ`O,5?SO$ATQ!0MxO1G6UO%[QlO1G6UO$AeQ!0LrO1G6UO$AvQ`O1G6TO$AvQ`O1G6TO9ZQ`O1G6TO$BOQ`O,5?VO9ZQ`O,5?VOOQO,5?V,5?VO$BdQ`O,5?VO$)iQ`O,5?VOOQO-E<i-E<iOOQS1G0_1G0_OOQS1G0a1G0aO#-tQ`O1G0aOOQ[7+(d7+(dO!&iQMhO7+(dO%[QlO7+(dO$BrQ`O7+(dO$B}QMhO7+(dO$C]Q!0MzO,5=WO$EhQ!0MzO,5=YO$GsQ!0MzO,5=WO$JUQ!0MzO,5=YO$LgQ!0MzO,59sO$NlQ!0MzO,5<jO%!wQ!0MzO,5<lO%%SQ!0MzO,5<zOOQ!0Lf7+&_7+&_O%'eQ!0MxO7+&_O%(XQlO'#IdO%(fQ`O,5@aO%(nQ!fO,5@aOOQ!0Lf1G/}1G/}O%(xQ`O7+&hOOQ!0Lf7+&h7+&hO%(}Q?MtO,5:dO%[QlO7+&yO%)XQ?MtO,5:`O%)fQ?MtO,5:hO%)pQ?MtO,5:jO%)zQMhO'#IgO%*UQ`O,5@fOOQ!0Lh1G0b1G0bOOQO1G1q1G1qOOQO1G1r1G1rO%*^Q!jO,5<YO!(yQlO,5<XOOQO-E<j-E<jOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%*iQ`O1G1{OOQ!0Lf1G1}1G1}OOOO,59m,59mO%*nQ!dO,59mOOOO-E<^-E<^OOQ!0Lh1G/V1G/VO%*uQ!0MxO7+'jOOQ!0Lh,5?[,5?[O%+iQMhO1G2eP%+pQ`O'#IpPOQ!0Lh-E<n-E<nO%,^QMjO,5?_OOQ!0Lh-E<q-E<qO%-PQMjO,5?aOOQ!0Lh-E<s-E<sO%-ZQ!dO1G2vO%-bQ!dO'#CrO%-xQMhO'#KQO$#^QlO'#JtOOQ!0Lh1G2^1G2^O%.PQ`O'#IoO%.eQ`O,5@tO%.eQ`O,5@tO%.mQ`O,5@tO%.xQ`O,5@tOOQO1G2`1G2`O%/WQMjO1G2_O!+rQMhO1G2_O%/hQ(CWO'#IqO%/uQ`O,5@uO!&iQMhO,5@uO%/}Q!dO,5@uOOQ!0Lh1G2c1G2cO%2_Q!fO'#CiO%2iQ`O,5=OOOQ!0Lb,5<|,5<|O%2qQpO,5<|OOQ!0Lb,5<},5<}OCfQ`O,5<|O%2|QpO,5<|OOQ!0Lb,5=Q,5=QO$)iQ`O,5=UOOQO,5?^,5?^OOQO-E<p-E<pOOQ!0Lp1G2g1G2gO##hQpO,5<|O$#^QlO,5=OO%3[Q`O,5<}O%3gQpO,5<}O!+rQMhO'#IsO%4aQMjO1G2rO!+rQMhO'#IuO%5SQMjO1G2tO%5^QMjO1G5oO%5hQMjO1G5oOOQO,5?c,5?cOOQO-E<u-E<uOOQO1G.{1G.{O!9lQpO,59uO%[QlO,59uOOQ!0Lh,5<i,5<iO%5uQ`O1G2YO!+rQMhO1G2aO!+rQMhO1G5oO!+rQMhO1G5oO%5zQ!0MxO7+'lOOQ!0Lf7+'l7+'lO!$fQlO7+'lO%6nQ`O,5;^OOQ!0Lb,5?e,5?eOOQ!0Lb-E<w-E<wO%6sQ!dO'#K[O#'cQ`O7+(dO4UQ!fO7+(dO$BuQ`O7+(dO%6}Q!0MvO'#CiO%7nQ!0LrO,5=RO%8PQ!0MvO,5=RO%8dQ`O,5=ROOQ!0Lb1G5m1G5mOOQ[7+$a7+$aO!BYQ!0LrO7+$aO!BeQpO7+$aO!$fQlO7+&_O%8lQ`O'#JOO%9TQ`O,5@}OOQO1G3f1G3fO9aQ`O,5@}O%9TQ`O,5@}O%9]Q`O,5@}OOQO,5?k,5?kOOQO-E<}-E<}OOQ!0Lf7+'S7+'SO%9bQ`O7+)PO9kQ!0LrO7+)PO9aQ`O7+)PO@iQ`O7+)POOQ[7+(o7+(oO%9gQ!0MvO7+(lO!&iQMhO7+(lO!DfQ`O7+(mOOQ[7+(m7+(mO!&iQMhO7+(mO%9qQ`O'#K`O%9|Q`O,5=kOOQO,5?g,5?gOOQO-E<y-E<yOOQ[7+(r7+(rO%;`QpO'#HYOOQ[1G3_1G3_O!&iQMhO1G3_O%[QlO1G3_O%;gQ`O1G3_O%;rQMhO1G3_O9kQ!0LrO1G3aO$#yQ`O1G3aO9UQ`O1G3aO!BeQpO1G3aO!BmQMhO1G3aO%<QQ`O'#I}O%<fQ`O,5@{O%<nQpO,5@{OOQ!0Lb1G3b1G3bOOQ[7+$V7+$VO@iQ`O7+$VO9kQ!0LrO7+$VO%<yQ`O7+$VO%[QlO1G6jO%[QlO1G6kO%=OQ!0LrO1G6jO%=YQlO1G3iO%=aQ`O1G3iO%=fQlO1G3iOOQ[7+)R7+)RO9kQ!0LrO7+)]O`QlO7+)_OOQ['#Kf'#KfOOQ['#JQ'#JQO%=mQlO,5>^OOQ[,5>^,5>^O%[QlO'#HsO%=zQ`O'#HuOOQ[,5>d,5>dO9ZQ`O,5>dOOQ[,5>f,5>fOOQ[7+)h7+)hOOQ[7+)n7+)nOOQ[7+)r7+)rOOQ[7+)t7+)tO%>PQpO1G5zO%>kQ?MtO1G0xO%>uQ`O1G0xOOQO1G/q1G/qO%?QQ?MtO1G/qO>wQ`O1G/qO!(yQlO'#DkOOQO,5>},5>}OOQO-E<a-E<aOOQO,5?T,5?TOOQO-E<g-E<gO!BeQpO1G/qOOQO-E<c-E<cOOQ!0Ln1G0Z1G0ZOOQ!0Lf7+%s7+%sO#'cQ`O7+%sOOQ!0Lf7+&^7+&^O>wQ`O7+&^O!BeQpO7+&^OOQO7+%v7+%vO$?{Q!0MxO7+&VOOQO7+&V7+&VO%[QlO7+&VO%?[Q!0LrO7+&VO!BYQ!0LrO7+%vO!BeQpO7+%vO%?gQ!0LrO7+&VO%?uQ!0MxO7++pO%[QlO7++pO%@VQ`O7++oO%@VQ`O7++oOOQO1G4q1G4qO9ZQ`O1G4qO%@_Q`O1G4qOOQS7+%{7+%{O#'cQ`O<<LOO4UQ!fO<<LOO%@mQ`O<<LOOOQ[<<LO<<LOO!&iQMhO<<LOO%[QlO<<LOO%@uQ`O<<LOO%AQQ!0MzO,5?_O%C]Q!0MzO,5?aO%EhQ!0MzO1G2_O%GyQ!0MzO1G2rO%JUQ!0MzO1G2tO%LaQ!fO,5?OO%[QlO,5?OOOQO-E<b-E<bO%LkQ`O1G5{OOQ!0Lf<<JS<<JSO%LsQ?MtO1G0sO%NzQ?MtO1G0}O& RQ?MtO1G0}O&#SQ?MtO1G0}O&#ZQ?MtO1G0}O&%[Q?MtO1G0}O&']Q?MtO1G0}O&'dQ?MtO1G0}O&'kQ?MtO1G0}O&)lQ?MtO1G0}O&)sQ?MtO1G0}O&)zQ!0MxO<<JeO&+rQ?MtO1G0}O&,oQ?MvO1G0}O&-rQ?MvO'#JjO&/xQ?MtO1G1bO&0VQ?MtO1G0SO&0aQMjO,5?ROOQO-E<e-E<eO!(yQlO'#FpOOQO'#KX'#KXOOQO1G1t1G1tO&0kQ`O1G1sO&0pQ?MtO,5?YOOOW7+'g7+'gOOOO1G/X1G/XO&0zQ!dO1G4vOOQ!0Lh7+(P7+(PP!&iQMhO,5?[O!+rQMhO7+(bO&1RQ`O,5?ZO9ZQ`O,5?ZOOQO-E<m-E<mO&1aQ`O1G6`O&1aQ`O1G6`O&1iQ`O1G6`O&1tQMjO7+'yO&2UQ!dO,5?]O&2`Q`O,5?]O!&iQMhO,5?]OOQO-E<o-E<oO&2eQ!dO1G6aO&2oQ`O1G6aO&2wQ`O1G2jO!&iQMhO1G2jOOQ!0Lb1G2h1G2hOOQ!0Lb1G2i1G2iO%2qQpO1G2hO!BeQpO1G2hOCfQ`O1G2hOOQ!0Lb1G2p1G2pO&2|QpO1G2hO&3[Q`O1G2jO$)iQ`O1G2iOCfQ`O1G2iO$#^QlO1G2jO&3dQ`O1G2iO&4WQMjO,5?_OOQ!0Lh-E<r-E<rO&4yQMjO,5?aOOQ!0Lh-E<t-E<tO!+rQMhO7++ZOOQ!0Lh1G/a1G/aO&5TQ`O1G/aOOQ!0Lh7+'t7+'tO&5YQMjO7+'{O&5jQMjO7++ZO&5tQMjO7++ZO&6RQ!0MxO<<KWOOQ!0Lf<<KW<<KWO&6uQ`O1G0xO!&iQMhO'#IxO&6zQ`O,5@vO&8|Q!fO<<LOO!&iQMhO1G2mO&9TQ!0LrO1G2mOOQ[<<G{<<G{O!BYQ!0LrO<<G{O&9fQ!0MxO<<IyOOQ!0Lf<<Iy<<IyOOQO,5?j,5?jO&:YQ`O,5?jO&:_Q`O,5?jOOQO-E<|-E<|O&:mQ`O1G6iO&:mQ`O1G6iO9aQ`O1G6iO@iQ`O<<LkOOQ[<<Lk<<LkO&:uQ`O<<LkO9kQ!0LrO<<LkOOQ[<<LW<<LWO%9gQ!0MvO<<LWOOQ[<<LX<<LXO!DfQ`O<<LXO&:zQpO'#IzO&;VQ`O,5@zO!(yQlO,5@zOOQ[1G3V1G3VOOQO'#I|'#I|O9kQ!0LrO'#I|O&;_QpO,5=tOOQ[,5=t,5=tO&;fQpO'#EeO&;mQpO'#GdO&;rQ`O7+(yO&;wQ`O7+(yOOQ[7+(y7+(yO!&iQMhO7+(yO%[QlO7+(yO&<PQ`O7+(yOOQ[7+({7+({O9kQ!0LrO7+({O$#yQ`O7+({O9UQ`O7+({O!BeQpO7+({O&<[Q`O,5?iOOQO-E<{-E<{OOQO'#H]'#H]O&<gQ`O1G6gO9kQ!0LrO<<GqOOQ[<<Gq<<GqO@iQ`O<<GqO&<oQ`O7+,UO&<tQ`O7+,VO%[QlO7+,UO%[QlO7+,VOOQ[7+)T7+)TO&<yQ`O7+)TO&=OQlO7+)TO&=VQ`O7+)TOOQ[<<Lw<<LwOOQ[<<Ly<<LyOOQ[-E=O-E=OOOQ[1G3x1G3xO&=[Q`O,5>_OOQ[,5>a,5>aO&=aQ`O1G4OO9ZQ`O7+&dO!(yQlO7+&dOOQO7+%]7+%]O&=fQ?MtO1G6XO>wQ`O7+%]OOQ!0Lf<<I_<<I_OOQ!0Lf<<Ix<<IxO>wQ`O<<IxOOQO<<Iq<<IqO$?{Q!0MxO<<IqO%[QlO<<IqOOQO<<Ib<<IbO!BYQ!0LrO<<IbO&=pQ!0LrO<<IqO&={Q!0MxO<= [O&>]Q`O<= ZOOQO7+*]7+*]O9ZQ`O7+*]OOQ[ANAjANAjO&>eQ!fOANAjO!&iQMhOANAjO#'cQ`OANAjO4UQ!fOANAjO&>lQ`OANAjO%[QlOANAjO&>tQ!0MzO7+'yO&AVQ!0MzO,5?_O&CbQ!0MzO,5?aO&EmQ!0MzO7+'{O&HOQ!fO1G4jO&HYQ?MtO7+&_O&J^Q?MvO,5=WO&LeQ?MvO,5=YO&LuQ?MvO,5=WO&MVQ?MvO,5=YO&MgQ?MvO,59sO' mQ?MvO,5<jO'#pQ?MvO,5<lO'&UQ?MvO,5<zO''zQ?MtO7+'jO'(XQ?MtO7+'lO'(fQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*b7+*bO'(kQMjO<<K|OOQO1G4u1G4uO'(rQ`O1G4uO'(}Q`O1G4uO')]Q`O7++zO')]Q`O7++zO!&iQMhO1G4wO')eQ!dO1G4wO')oQ`O7++{O')wQ`O7+(UO'*SQ!dO7+(UOOQ!0Lb7+(S7+(SOOQ!0Lb7+(T7+(TO!BeQpO7+(SOCfQ`O7+(SO'*^Q`O7+(UO!&iQMhO7+(UO$)iQ`O7+(TO'*cQ`O7+(UOCfQ`O7+(TO'*kQMjO<<NuOOQ!0Lh7+${7+${O!+rQMhO<<NuO'*uQ!dO,5?dOOQO-E<v-E<vO'+PQ!0MvO7+(XO!&iQMhO7+(XOOQ[AN=gAN=gO9aQ`O1G5UOOQO1G5U1G5UO'+aQ`O1G5UO'+fQ`O7+,TO'+fQ`O7+,TO9kQ!0LrOANBVO@iQ`OANBVOOQ[ANBVANBVOOQ[ANArANArOOQ[ANAsANAsO'+nQ`O,5?fOOQO-E<x-E<xO'+yQ?MtO1G6fOOQO,5?h,5?hOOQO-E<z-E<zOOQ[1G3`1G3`O',TQ`O,5=OOOQ[<<Le<<LeO!&iQMhO<<LeO&;rQ`O<<LeO',YQ`O<<LeO%[QlO<<LeOOQ[<<Lg<<LgO9kQ!0LrO<<LgO$#yQ`O<<LgO9UQ`O<<LgO',bQpO1G5TO',mQ`O7+,ROOQ[AN=]AN=]O9kQ!0LrOAN=]OOQ[<= p<= pOOQ[<= q<= qO',uQ`O<= pO',zQ`O<= qOOQ[<<Lo<<LoO'-PQ`O<<LoO'-UQlO<<LoOOQ[1G3y1G3yO>wQ`O7+)jO'-]Q`O<<JOO'-hQ?MtO<<JOOOQO<<Hw<<HwOOQ!0LfAN?dAN?dOOQOAN?]AN?]O$?{Q!0MxOAN?]OOQOAN>|AN>|O%[QlOAN?]OOQO<<Mw<<MwOOQ[G27UG27UO!&iQMhOG27UO#'cQ`OG27UO'-rQ!fOG27UO4UQ!fOG27UO'-yQ`OG27UO'.RQ?MtO<<JeO'.`Q?MvO1G2_O'0UQ?MvO,5?_O'2XQ?MvO,5?aO'4[Q?MvO1G2rO'6_Q?MvO1G2tO'8bQ?MtO<<KWO'8oQ?MtO<<IyOOQO1G1v1G1vO!+rQMhOANAhOOQO7+*a7+*aO'8|Q`O7+*aO'9XQ`O<= fO'9aQ!dO7+*cOOQ!0Lb<<Kp<<KpO$)iQ`O<<KpOCfQ`O<<KpO'9kQ`O<<KpO!&iQMhO<<KpOOQ!0Lb<<Kn<<KnO!BeQpO<<KnO'9vQ!dO<<KpOOQ!0Lb<<Ko<<KoO':QQ`O<<KpO!&iQMhO<<KpO$)iQ`O<<KoO':VQMjOANDaO':aQ!0MvO<<KsOOQO7+*p7+*pO9aQ`O7+*pO':qQ`O<= oOOQ[G27qG27qO9kQ!0LrOG27qO!(yQlO1G5QO':yQ`O7+,QO';RQ`O1G2jO&;rQ`OANBPOOQ[ANBPANBPO!&iQMhOANBPO';WQ`OANBPOOQ[ANBRANBRO9kQ!0LrOANBRO$#yQ`OANBROOQO'#H^'#H^OOQO7+*o7+*oOOQ[G22wG22wOOQ[ANE[ANE[OOQ[ANE]ANE]OOQ[ANBZANBZO';`Q`OANBZOOQ[<<MU<<MUO!(yQlOAN?jOOQOG24wG24wO$?{Q!0MxOG24wO#'cQ`OLD,pOOQ[LD,pLD,pO!&iQMhOLD,pO';eQ!fOLD,pO';lQ?MvO7+'yO'=bQ?MvO,5?_O'?eQ?MvO,5?aO'AhQ?MvO7+'{O'C^QMjOG27SOOQO<<M{<<M{OOQ!0LbANA[ANA[O$)iQ`OANA[OCfQ`OANA[O'CnQ!dOANA[OOQ!0LbANAYANAYO'CuQ`OANA[O!&iQMhOANA[O'DQQ!dOANA[OOQ!0LbANAZANAZOOQO<<N[<<N[OOQ[LD-]LD-]O'D[Q?MtO7+*lOOQO'#Ge'#GeOOQ[G27kG27kO&;rQ`OG27kO!&iQMhOG27kOOQ[G27mG27mO9kQ!0LrOG27mOOQ[G27uG27uO'DfQ?MtOG25UOOQOLD*cLD*cOOQ[!$(![!$(![O#'cQ`O!$(![O!&iQMhO!$(![O'DpQ!0MzOG27SOOQ!0LbG26vG26vO$)iQ`OG26vO'GRQ`OG26vOCfQ`OG26vO'G^Q!dOG26vO!&iQMhOG26vOOQ[LD-VLD-VO&;rQ`OLD-VOOQ[LD-XLD-XOOQ[!)9Ev!)9EvO#'cQ`O!)9EvOOQ!0LbLD,bLD,bO$)iQ`OLD,bOCfQ`OLD,bO'GeQ`OLD,bO'GpQ!dOLD,bOOQ[!$(!q!$(!qOOQ[!.K;b!.K;bO'GwQ?MvOG27SOOQ!0Lb!$( |!$( |O$)iQ`O!$( |OCfQ`O!$( |O'ImQ`O!$( |OOQ!0Lb!)9Eh!)9EhO$)iQ`O!)9EhOCfQ`O!)9EhOOQ!0Lb!.K;S!.K;SO$)iQ`O!.K;SOOQ!0Lb!4/0n!4/0nO!(yQlO'#DxO1PQ`O'#EVO'IxQ!fO'#JpO'JPQ!L^O'#DtO'JWQlO'#D|O'J_Q!fO'#CiO'LuQ!fO'#CiO!(yQlO'#EOO'MVQlO,5;XO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO'#InO( YQ`O,5<hO!(yQlO,5;cO( bQMhO,5;cO(!{QMhO,5;cO!(yQlO,5;vO!&iQMhO'#GlO( bQMhO'#GlO!&iQMhO'#GnO( bQMhO'#GnO1SQ`O'#DXO1SQ`O'#DXO!&iQMhO'#GOO( bQMhO'#GOO!&iQMhO'#GQO( bQMhO'#GQO!&iQMhO'#G`O( bQMhO'#G`O!(yQlO,5:hO(#SQpO'#D]O(#^QpO'#JtO!(yQlO,5@mO'MVQlO1G0sO(#hQ?MtO'#CiO!(yQlO1G2OO!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO(#rQ!dO'#CrO!&iQMhO,5<sO( bQMhO,5<sO'MVQlO1G2QO!(yQlO7+&yO!&iQMhO1G2_O( bQMhO1G2_O!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO!&iQMhO1G2aO( bQMhO1G2aO'MVQlO7+'lO'MVQlO7+&_O!&iQMhOANAhO( bQMhOANAhO($VQ`O'#EmO($[Q`O'#EmO($dQ`O'#F[O($iQ`O'#EwO($nQ`O'#KRO($yQ`O'#KPO(%UQ`O,5;XO(%ZQMjO,5<dO(%bQ`O'#GXO(%gQ`O'#GXO(%lQ`O,5<fO(%tQ`O,5;XO(%|Q?MtO1G1_O(&TQ`O,5<sO(&YQ`O,5<sO(&_Q`O,5<uO(&dQ`O,5<uO(&iQ`O1G2QO(&nQ`O1G0sO(&sQMjO<<K|O(&zQMjO<<K|O7eQMhO'#F{O9UQ`O'#FzOAdQ`O'#ElO!(yQlO,5;sO!3^Q`O'#GXO!3^Q`O'#GXO!3^Q`O'#GZO!3^Q`O'#GZO!+rQMhO7+(bO!+rQMhO7+(bO%-ZQ!dO1G2vO%-ZQ!dO1G2vO!&iQMhO,5=[O!&iQMhO,5=[",
  stateData: "((P~O'zOS'{OSTOS'|RQ~OPYOQYOSfOY!VOaqOdzOeyOj!POnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!swO!vxO!z]O$V|O$miO%g}O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO&U!WO&[!XO&^!YO&`!ZO&b![O&e!]O&k!^O&q!_O&s!`O&u!aO&w!bO&y!cO(RSO(TTO(WUO(_VO(m[O~OWtO~P`OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa!wOq!nO!Q!oO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!xO#U!pO#V!pO#Y!zO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O'|!{O~OP]XR]X[]Xa]Xp]X!O]X!Q]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X'x]X(_]X(p]X(w]X(x]X~O!e%QX~P(qO_!}O(T#PO(U!}O(V#PO~O_#QO(V#PO(W#PO(X#QO~Ov#SO!S#TO(`#TO(a#VO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R;{O(TTO(WUO(_VO(m[O~O!Y#ZO!Z#WO!W(fP!W(tP~P+}O![#cO~P`OPYOQYOSfOd!jOe!iOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(TTO(WUO(_VO(m[O~On#mO!Y#iO!z]O#g#lO#h#iO(R;|O!i(qP~P.iO!j#oO(R#nO~O!v#sO!z]O%g#tO~O#i#uO~O!e#vO#i#uO~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z$_O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa(dX'x(dX'u(dX!i(dX!W(dX!](dX%h(dX!e(dX~P1qO#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX!](eX%h(eX~Oa(eX'x(eX'u(eX!W(eX!i(eXt(eX!e(eX~P4UO#^$eO~O$[$hO$^$gO$e$mO~OSfO!]$nO$h$oO$j$qO~Oh%VOj%cOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R$sO(TTO(WUO(_$uO(w$}O(x%POg([P~O!j%dO~O!Q%gO!]%hO(R%fO~O!e%lO~Oa%mO'x%mO~O!O%qO~P%[O(S!lO~P%[O%m%uO~P%[Oh%VO!j%dO(R%fO(S!lO~Oe%|O!j%dO(R%fO~O#t$RO~O!O&RO!]&OO!j&QO%i&UO(R%fO(S!lO(TTO(WUO`)UP~O!v#sO~O%r&WO!Q)QX!])QX(R)QX~O(R&XO~Oj!PO!s&^O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO~Od&cOe&bO!v&`O%g&aO%z&_O~P<POd&fOeyOj!PO!]&eO!s&^O!vxO!z]O%g}O%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO~Ob&iO#^&lO%i&gO(S!lO~P=UO!j&mO!s&qO~O!j#oO~O!]XO~Oa%mO'v&yO'x%mO~Oa%mO'v&|O'x%mO~Oa%mO'v'OO'x%mO~O'u]X!W]Xt]X!i]X&Y]X!]]X%h]X!e]X~P(qO!`']O!a'UO!b'UO(S!lO(TTO(WUO~Oq'SO!Q'RO!Y'VO(c'QO![(gP![(vP~P@]Ol'`O!]'^O(R%fO~Oe'eO!j%dO(R%fO~O!O&RO!j&QO~Oq!nO!Q!oO!z;wO#R!pO#S!pO#U!pO#V!pO(S!lO(TTO(WUO(c!mO(m!sO~O!`'kO!a'jO!b'jO#T!pO#Y'lO#Z'lO~PAwOa%mOh%VO!e#vO!j%dO'x%mO(p'nO~O!n'rO#^'pO~PCVOq!nO!Q!oO(TTO(WUO(c!mO(m!sO~O!]XOq(kX!Q(kX!`(kX!a(kX!b(kX!z(kX#R(kX#S(kX#T(kX#U(kX#V(kX#Y(kX#Z(kX(S(kX(T(kX(W(kX(c(kX(m(kX~O!a'jO!b'jO(S!lO~PCuO'}'vO(O'vO(P'xO~O_!}O(T'zO(U!}O(V'zO~O_#QO(V'zO(W'zO(X#QO~Ot'|O~P%[Ov#SO!S#TO(`#TO(a(PO~O!Y(RO!W'UX!W'[X!Z'UX!Z'[X~P+}O!Z(TO!W(fX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z(TO!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~O!W(fX~PGpO!W(YO~O!W(sX!Z(sX!e(sX!i(sX(p(sX~O#^(sX#i#bX![(sX~PIsO#^(ZO!W(uX!Z(uX~O!Z([O!W(tX~O!W(_O~O#^$eO~PIsO![(`O~P`OR#zO!O#yO!Q#{O!j#xO(_VOP!la[!lap!la!Z!la!n!la#P!la#l!la#m!la#n!la#o!la#p!la#q!la#r!la#s!la#t!la#u!la#w!la#y!la#z!la(p!la(w!la(x!la~Oa!la'x!la'u!la!W!la!i!lat!la!]!la%h!la!e!la~PKZO!i(aO~O!e#vO#^(bO(p'nO!Z(rXa(rX'x(rX~O!i(rX~PMvO!Q%gO!]%hO!z]O#g(gO#h(fO(R%fO~O!Z(hO!i(qX~O!i(jO~O!Q%gO!]%hO#h(fO(R%fO~OP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O!e#vO!i(eX~P! dOR(lO!O(kO!j#xO#Q$dO!z!ya!Q!ya~O!v!ya%g!ya!]!ya#g!ya#h!ya(R!ya~P!#eO!v(pO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~O#i(vO~O!Y(xO!i(iP~P%[O(c(zO(m[O~O!Q(|O!j#xO(c(zO(m[O~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z$_Oa$pa'x$pa'u$pa!i$pa!W$pa!]$pa%h$pa!e$pa~Oj)bO~P!&iOh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Og(nP~P!+rO!O)gO!e)fO!]$]X$Y$]X$[$]X$^$]X$e$]X~O!e)fO!](yX$Y(yX$[(yX$^(yX$e(yX~O!O)gO~P!-{O!O)gO!](yX$Y(yX$[(yX$^(yX$e(yX~O!])iO$Y)mO$[)hO$^)hO$e)nO~O!Y)qO~P!(yO$[$hO$^$gO$e)uO~Ol$yX!O$yX#Q$yX'w$yX(w$yX(x$yX~OgkXg$yXlkX!ZkX#^kX~P!/qOv)wO(`)xO(a)zO~Ol*TO!O)|O'w)}O(w$}O(x%PO~Og){O~P!0uOg*UO~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q*WO!]*XO!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~O!Y*[O(R*VO!i(|P~P!1dO#i*^O~O!j*_O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R*aO(TTO(WUO(_$uO(w$}O(x%PO~O!Y*dO!W(}P~P!3cOp*pOq!nO!Q*fO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO(c!mO~O![*mO~P!5WO#Q$dOl(^X!O(^X'w(^X(w(^X(x(^X!Z(^X#^(^X~Og(^X#}(^X~P!6YOl*uO#^*tOg(]X!Z(]X~O!Z*vOg([X~Oj%cO(R&XOg([P~Oq*yO~O!j+OO~O(R(tO~On+TO!Q%gO!Y#iO!]%hO!z]O#g#lO#h#iO(R%fO!i(qP~O!e#vO#i+UO~O!Q%gO!Y+WO!Z([O!]%hO(R%fO!W(tP~Oq'YO!Q+YO!Y+XO(TTO(WUO(c(zO~O![(vP~P!9]O!Z+ZOa)RX'x)RX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa!ha!Z!ha'x!ha'u!ha!W!ha!i!hat!ha!]!ha%h!ha!e!ha~P!:TOR#zO!O#yO!Q#{O!j#xO(_VOP!pa[!pap!pa!Z!pa!n!pa#P!pa#l!pa#m!pa#n!pa#o!pa#p!pa#q!pa#r!pa#s!pa#t!pa#u!pa#w!pa#y!pa#z!pa(p!pa(w!pa(x!pa~Oa!pa'x!pa'u!pa!W!pa!i!pat!pa!]!pa%h!pa!e!pa~P!<kOR#zO!O#yO!Q#{O!j#xO(_VOP!ra[!rap!ra!Z!ra!n!ra#P!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#w!ra#y!ra#z!ra(p!ra(w!ra(x!ra~Oa!ra'x!ra'u!ra!W!ra!i!rat!ra!]!ra%h!ra!e!ra~P!?ROh%VOl+dO!]'^O%h+cO~O!e+fOa(ZX!](ZX'x(ZX!Z(ZX~Oa%mO!]XO'x%mO~Oh%VO!j%dO~Oh%VO!j%dO(R%fO~O!e#vO#i(vO~Ob+qO%i+rO(R+nO(TTO(WUO![)VP~O!Z+sO`)UX~O[+wO~O`+xO~O!]&OO(R%fO(S!lO`)UP~Oh%VO#^+}O~Oh%VOl,QO!]$|O~O!],SO~O!O,UO!]XO~O%m%uO~O!v,ZO~Oe,`O~Ob,aO(R#nO(TTO(WUO![)TP~Oe%|O~O%i!QO(R&XO~P=UO[,fO`,eO~OPYOQYOSfOdzOeyOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!guO!jZO!mYO!nYO!oYO!qvO!vxO!z]O$miO%g}O(TTO(WUO(_VO(m[O~O!]!eO!s!gO$V!kO(R!dO~P!FRO`,eOa%mO'x%mO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa,kOj!OO!swO%k!OO%l!OO%m!OO~P!HkO!j&mO~O&[,qO~O!],sO~O&m,uO&o,vOP&jaQ&jaS&jaY&jaa&jad&jae&jaj&jan&jap&jaq&jar&jax&jaz&ja|&ja!Q&ja!U&ja!V&ja!]&ja!g&ja!j&ja!m&ja!n&ja!o&ja!q&ja!s&ja!v&ja!z&ja$V&ja$m&ja%g&ja%i&ja%k&ja%l&ja%m&ja%p&ja%r&ja%u&ja%v&ja%x&ja&U&ja&[&ja&^&ja&`&ja&b&ja&e&ja&k&ja&q&ja&s&ja&u&ja&w&ja&y&ja'u&ja(R&ja(T&ja(W&ja(_&ja(m&ja![&ja&c&jab&ja&h&ja~O(R,{O~Oh!cX!Z!PX![!PX!e!PX!e!cX!j!cX#^!PX~O!Z!cX![!cX~P# qO!e-QO#^-POh(hX!Z#fX![#fX!e(hX!j(hX~O!Z(hX![(hX~P#!dOh%VO!e-SO!j%dO!Z!_X![!_X~Oq!nO!Q!oO(TTO(WUO(c!mO~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(TTO(WUO(_VO(m[O~O(R<rO~P##yO!Z-WO![(gX~O![-YO~O!e-QO#^-PO!Z#fX![#fX~O!Z-ZO![(vX~O![-]O~O!a-^O!b-^O(S!lO~P##hO![-aO~P'_Ol-dO!]'^O~O!W-iO~Oq!ya!`!ya!a!ya!b!ya#R!ya#S!ya#T!ya#U!ya#V!ya#Y!ya#Z!ya(S!ya(T!ya(W!ya(c!ya(m!ya~P!#eO!n-nO#^-lO~PCVO!a-pO!b-pO(S!lO~PCuOa%mO#^-lO'x%mO~Oa%mO!e#vO#^-lO'x%mO~Oa%mO!e#vO!n-nO#^-lO'x%mO(p'nO~O'}'vO(O'vO(P-uO~Ot-vO~O!W'Ua!Z'Ua~P!:TO!Y-zO!W'UX!Z'UX~P%[O!Z(TO!W(fa~O!W(fa~PGpO!Z([O!W(ta~O!Q%gO!Y.OO!]%hO(R%fO!W'[X!Z'[X~O#^.QO!Z(ra!i(raa(ra'x(ra~O!e#vO~P#,PO!Z(hO!i(qa~O!Q%gO!]%hO#h.UO(R%fO~On.ZO!Q%gO!Y.WO!]%hO!z]O#g.YO#h.WO(R%fO!Z'_X!i'_X~OR._O!j#xO~Oh%VOl.bO!]'^O%h.aO~Oa#ai!Z#ai'x#ai'u#ai!W#ai!i#ait#ai!]#ai%h#ai!e#ai~P!:TOl=|O!O)|O'w)}O(w$}O(x%PO~O#i#]aa#]a#^#]a'x#]a!Z#]a!i#]a!]#]a!W#]a~P#.{O#i(^XP(^XR(^X[(^Xa(^Xp(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X'x(^X(_(^X(p(^X!i(^X!W(^X'u(^Xt(^X!](^X%h(^X!e(^X~P!6YO!Z.oO!i(iX~P!:TO!i.rO~O!W.tO~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kia#kip#ki!Z#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#l#ki~P#2kO#l$OO~P#2kOP$[OR#zOp$aO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO[#kia#ki!Z#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#p#ki~P#5YO#p$QO~P#5YOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO(_VOa#ki!Z#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#u#ki~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO(_VO(x#}Oa#ki!Z#ki#y#ki#z#ki'x#ki(p#ki(w#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#w$UO~P#:_O#w#ki~P#:_O#u$SO~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO(_VO(w#|O(x#}Oa#ki!Z#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#y#ki~P#=TO#y$WO~P#=TOP]XR]X[]Xp]X!O]X!Q]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X!Z]X![]X~O#}]X~P#?rOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO#y<XO#z<YO(_VO(p$YO(w#|O(x#}O~O#}.vO~P#BPO#Q$dO#^<`O$P<`O#}(eX![(eX~P! dOa'ba!Z'ba'x'ba'u'ba!i'ba!W'bat'ba!]'ba%h'ba!e'ba~P!:TO[#kia#kip#ki!Z#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO(w#ki(x#ki~P#EROl=|O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P#ERO!Z.zOg(nX~P!0uOg.|O~Oa$Oi!Z$Oi'x$Oi'u$Oi!W$Oi!i$Oit$Oi!]$Oi%h$Oi!e$Oi~P!:TO$[.}O$^.}O~O$[/OO$^/OO~O!e)fO#^/PO!]$bX$Y$bX$[$bX$^$bX$e$bX~O!Y/QO~O!])iO$Y/SO$[)hO$^)hO$e/TO~O!Z<ZO![(dX~P#BPO![/UO~O!e)fO$e(yX~O$e/WO~Ot/XO~P!&iOv)wO(`)xO(a/[O~O!Q/_O~O(w$}Ol%`a!O%`a'w%`a(x%`a!Z%`a#^%`a~Og%`a#}%`a~P#LTO(x%POl%ba!O%ba'w%ba(w%ba!Z%ba#^%ba~Og%ba#}%ba~P#LvO!ZfX!efX!ifX!i$yX(pfX~P!/qO!Y/hO!Z([O(R/gO!W(tP!W(}P~P!1dOp*pO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO~Oq<oO!Q/iO!Y+XO![*mO(c<nO![(vP~P#NaO!i/jO~P#.{O!Z/kO!e#vO(p'nO!i(|X~O!i/pO~O!Q%gO!Y*[O!]%hO(R%fO!i(|P~O#i/rO~O!W$yX!Z$yX!e%QX~P!/qO!Z/sO!W(}X~P#.{O!e/uO~O!W/wO~OnkO(R/xO~P.iOh%VOp/}O!e#vO!j%dO(p'nO~O!e+fO~Oa%mO!Z0RO'x%mO~O![0TO~P!5WO!a0UO!b0UO(S!lO~P##hOq!nO!Q0VO(TTO(WUO(c!mO~O#Y0XO~Og%`a!Z%`a#^%`a#}%`a~P!0uOg%ba!Z%ba#^%ba#}%ba~P!0uOj%cO(R&XOg'kX!Z'kX~O!Z*vOg([a~Og0bO~OR0cO!O0cO!Q0dO#Q$dOl{a'w{a(w{a(x{a!Z{a#^{a~Og{a#}{a~P$&dO!O)|O'w)}Ol$ra(w$ra(x$ra!Z$ra#^$ra~Og$ra#}$ra~P$'`O!O)|O'w)}Ol$ta(w$ta(x$ta!Z$ta#^$ta~Og$ta#}$ta~P$(RO#i0gO~Og%Sa!Z%Sa#^%Sa#}%Sa~P!0uOl0iO#^0hOg(]a!Z(]a~O!e#vO~O#i0lO~O!Z+ZOa)Ra'x)Ra~OR#zO!O#yO!Q#{O!j#xO(_VOP!pi[!pip!pi!Z!pi!n!pi#P!pi#l!pi#m!pi#n!pi#o!pi#p!pi#q!pi#r!pi#s!pi#t!pi#u!pi#w!pi#y!pi#z!pi(p!pi(w!pi(x!pi~Oa!pi'x!pi'u!pi!W!pi!i!pit!pi!]!pi%h!pi!e!pi~P$*OOh%VOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~On0vO%[0wO(R0tO~P$,fO!e+fOa(Za!](Za'x(Za!Z(Za~O#i0|O~O[]X!ZfX![fX~O!Z0}O![)VX~O![1PO~O[1QO~Ob1SO(R+nO(TTO(WUO~O!]&OO(R%fO`'sX!Z'sX~O!Z+sO`)Ua~O!i1VO~P!:TO[1YO~O`1ZO~O#^1^O~Ol1aO!]$|O~O(c(zO![)SP~Oh%VOl1jO!]1gO%h1iO~O[1tO!Z1rO![)TX~O![1uO~O`1wOa%mO'x%mO~O(R#nO(TTO(WUO~O#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O#t1zO&Y1{Oa(eX~P$2PO#^$eO#t1zO&Y1{O~Oa1}O~P%[Oa2PO~O&c2SOP&aiQ&aiS&aiY&aia&aid&aie&aij&ain&aip&aiq&air&aix&aiz&ai|&ai!Q&ai!U&ai!V&ai!]&ai!g&ai!j&ai!m&ai!n&ai!o&ai!q&ai!s&ai!v&ai!z&ai$V&ai$m&ai%g&ai%i&ai%k&ai%l&ai%m&ai%p&ai%r&ai%u&ai%v&ai%x&ai&U&ai&[&ai&^&ai&`&ai&b&ai&e&ai&k&ai&q&ai&s&ai&u&ai&w&ai&y&ai'u&ai(R&ai(T&ai(W&ai(_&ai(m&ai![&aib&ai&h&ai~Ob2YO![2WO&h2XO~P`O!]XO!j2[O~O&o,vOP&jiQ&jiS&jiY&jia&jid&jie&jij&jin&jip&jiq&jir&jix&jiz&ji|&ji!Q&ji!U&ji!V&ji!]&ji!g&ji!j&ji!m&ji!n&ji!o&ji!q&ji!s&ji!v&ji!z&ji$V&ji$m&ji%g&ji%i&ji%k&ji%l&ji%m&ji%p&ji%r&ji%u&ji%v&ji%x&ji&U&ji&[&ji&^&ji&`&ji&b&ji&e&ji&k&ji&q&ji&s&ji&u&ji&w&ji&y&ji'u&ji(R&ji(T&ji(W&ji(_&ji(m&ji![&ji&c&jib&ji&h&ji~O!W2bO~O!Z!_a![!_a~P#BPOq!nO!Q!oO!Y2hO(c!mO!Z'VX!['VX~P@]O!Z-WO![(ga~O!Z']X![']X~P!9]O!Z-ZO![(va~O![2oO~P'_Oa%mO#^2xO'x%mO~Oa%mO!e#vO#^2xO'x%mO~Oa%mO!e#vO!n2|O#^2xO'x%mO(p'nO~Oa%mO'x%mO~P!:TO!Z$_Ot$pa~O!W'Ui!Z'Ui~P!:TO!Z(TO!W(fi~O!Z([O!W(ti~O!W(ui!Z(ui~P!:TO!Z(ri!i(ria(ri'x(ri~P!:TO#^3OO!Z(ri!i(ria(ri'x(ri~O!Z(hO!i(qi~O!Q%gO!]%hO!z]O#g3TO#h3SO(R%fO~O!Q%gO!]%hO#h3SO(R%fO~Ol3[O!]'^O%h3ZO~Oh%VOl3[O!]'^O%h3ZO~O#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`at%`a!]%`a%h%`a!e%`a~P#LTO#i%baP%baR%ba[%baa%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%bat%ba!]%ba%h%ba!e%ba~P#LvO#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!Z%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`a#^%`at%`a!]%`a%h%`a!e%`a~P#.{O#i%baP%baR%ba[%baa%bap%ba!Q%ba!Z%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%ba#^%bat%ba!]%ba%h%ba!e%ba~P#.{O#i{aP{a[{aa{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a'x{a(_{a(p{a!i{a!W{a'u{at{a!]{a%h{a!e{a~P$&dO#i$raP$raR$ra[$raa$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra'x$ra(_$ra(p$ra!i$ra!W$ra'u$rat$ra!]$ra%h$ra!e$ra~P$'`O#i$taP$taR$ta[$taa$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta'x$ta(_$ta(p$ta!i$ta!W$ta'u$tat$ta!]$ta%h$ta!e$ta~P$(RO#i%SaP%SaR%Sa[%Saa%Sap%Sa!Q%Sa!Z%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa'x%Sa(_%Sa(p%Sa!i%Sa!W%Sa'u%Sa#^%Sat%Sa!]%Sa%h%Sa!e%Sa~P#.{Oa#aq!Z#aq'x#aq'u#aq!W#aq!i#aqt#aq!]#aq%h#aq!e#aq~P!:TO!Y3dO!Z'WX!i'WX~P%[O!Z.oO!i(ia~O!Z.oO!i(ia~P!:TO!W3gO~O#}!la![!la~PKZO#}!ha!Z!ha![!ha~P#BPO#}!pa![!pa~P!<kO#}!ra![!ra~P!?ROg'ZX!Z'ZX~P!+rO!Z.zOg(na~OSfO!]3{O$c3|O~O![4QO~Ot4RO~P#.{Oa$lq!Z$lq'x$lq'u$lq!W$lq!i$lqt$lq!]$lq%h$lq!e$lq~P!:TO!W4TO~P!&iO!Q4UO~O!O)|O'w)}O(x%POl'ga(w'ga!Z'ga#^'ga~Og'ga#}'ga~P%+uO!O)|O'w)}Ol'ia(w'ia(x'ia!Z'ia#^'ia~Og'ia#}'ia~P%,hO(p$YO~P#.{O!WfX!W$yX!ZfX!Z$yX!e%QX#^fX~P!/qO(R<xO~P!1dO!Q%gO!Y4XO!]%hO(R%fO!Z'cX!i'cX~O!Z/kO!i(|a~O!Z/kO!e#vO!i(|a~O!Z/kO!e#vO(p'nO!i(|a~Og${i!Z${i#^${i#}${i~P!0uO!Y4aO!W'eX!Z'eX~P!3cO!Z/sO!W(}a~O!Z/sO!W(}a~P#.{OP]XR]X[]Xp]X!O]X!Q]X!W]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!e%XX#t%XX~P%0XO!e#vO#t4fO~Oh%VO!e#vO!j%dO~Oh%VOp4kO!j%dO(p'nO~Op4pO!e#vO(p'nO~Oq!nO!Q4qO(TTO(WUO(c!mO~O(w$}Ol%`i!O%`i'w%`i(x%`i!Z%`i#^%`i~Og%`i#}%`i~P%3xO(x%POl%bi!O%bi'w%bi(w%bi!Z%bi#^%bi~Og%bi#}%bi~P%4kOg(]i!Z(]i~P!0uO#^4wOg(]i!Z(]i~P!0uO!i4zO~Oa$nq!Z$nq'x$nq'u$nq!W$nq!i$nqt$nq!]$nq%h$nq!e$nq~P!:TO!W5QO~O!Z5RO!])OX~P#.{Oa]Xa$yX!]]X!]$yX%]]X'x]X'x$yX!Z]X!Z$yX~P!/qO%]5UOa%Za!]%Za'x%Za!Z%Za~OlmX!OmX'wmX(wmX(xmX~P%7nOn5VO(R#nO~Ob5]O%i5^O(R+nO(TTO(WUO!Z'rX!['rX~O!Z0}O![)Va~O[5bO~O`5cO~Oa%mO'x%mO~P#.{O!Z5kO#^5mO![)SX~O![5nO~Op5tOq!nO!Q*fO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!pO#U!pO#V!pO#Y5sO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O![5rO~P%:ROl5yO!]1gO%h5xO~Oh%VOl5yO!]1gO%h5xO~Ob6QO(R#nO(TTO(WUO!Z'qX!['qX~O!Z1rO![)Ta~O(TTO(WUO(c6SO~O`6WO~O#t6ZO&Y6[O~PMvO!i6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO![6dO&h2XO~P`O!e6fO~O!e6hOh(hi!Z(hi![(hi!e(hi!j(hip(hi(p(hi~O!Z#fi![#fi~P#BPO#^6iO!Z#fi![#fi~O!Z!_i![!_i~P#BPOa%mO#^6rO'x%mO~Oa%mO!e#vO#^6rO'x%mO~O!Z(rq!i(rqa(rq'x(rq~P!:TO!Z(hO!i(qq~O!Q%gO!]%hO#h6yO(R%fO~O!]'^O%h6|O~Ol7QO!]'^O%h6|O~O#i'gaP'gaR'ga['gaa'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga'x'ga(_'ga(p'ga!i'ga!W'ga'u'gat'ga!]'ga%h'ga!e'ga~P%+uO#i'iaP'iaR'ia['iaa'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia'x'ia(_'ia(p'ia!i'ia!W'ia'u'iat'ia!]'ia%h'ia!e'ia~P%,hO#i${iP${iR${i[${ia${ip${i!Q${i!Z${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i'x${i(_${i(p${i!i${i!W${i'u${i#^${it${i!]${i%h${i!e${i~P#.{O#i%`iP%`iR%`i[%`ia%`ip%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i'x%`i(_%`i(p%`i!i%`i!W%`i'u%`it%`i!]%`i%h%`i!e%`i~P%3xO#i%biP%biR%bi[%bia%bip%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi'x%bi(_%bi(p%bi!i%bi!W%bi'u%bit%bi!]%bi%h%bi!e%bi~P%4kO!Z'Wa!i'Wa~P!:TO!Z.oO!i(ii~O#}#ai!Z#ai![#ai~P#BPOP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kip#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#l#ki~P%MQO#l<PO~P%MQOP$[OR#zOp<]O!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO[#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#p#ki~P& YO#p<RO~P& YOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO(_VO#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#u#ki~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO(_VO(x#}O#y#ki#z#ki#}#ki(p#ki(w#ki!Z#ki![#ki~O#w<VO~P&%cO#w#ki~P&%cO#u<TO~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO(_VO(w#|O(x#}O#z#ki#}#ki(p#ki!Z#ki![#ki~O#y#ki~P&'rO#y<XO~P&'rOa#{y!Z#{y'x#{y'u#{y!W#{y!i#{yt#{y!]#{y%h#{y!e#{y~P!:TO[#kip#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki!Z#ki![#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO(w#ki(x#ki~P&*nOl=}O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P&*nO#Q$dOP(^XR(^X[(^Xl(^Xp(^X!O(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X#}(^X'w(^X(_(^X(p(^X(w(^X(x(^X!Z(^X![(^X~O#}$Oi!Z$Oi![$Oi~P#BPO#}!pi![!pi~P$*OOg'Za!Z'Za~P!0uO![7dO~O!Z'ba!['ba~P#BPO!W7eO~P#.{O!e#vO(p'nO!Z'ca!i'ca~O!Z/kO!i(|i~O!Z/kO!e#vO!i(|i~Og${q!Z${q#^${q#}${q~P!0uO!W'ea!Z'ea~P#.{O!e7lO~O!Z/sO!W(}i~P#.{O!Z/sO!W(}i~O!W7oO~Oh%VOp7tO!j%dO(p'nO~O!e#vO#t7vO~Op7yO!e#vO(p'nO~O!O)|O'w)}O(x%POl'ha(w'ha!Z'ha#^'ha~Og'ha#}'ha~P&3oO!O)|O'w)}Ol'ja(w'ja(x'ja!Z'ja#^'ja~Og'ja#}'ja~P&4bO!W7{O~Og$}q!Z$}q#^$}q#}$}q~P!0uOg(]q!Z(]q~P!0uO#^7|Og(]q!Z(]q~P!0uOa$ny!Z$ny'x$ny'u$ny!W$ny!i$nyt$ny!]$ny%h$ny!e$ny~P!:TO!e6hO~O!Z5RO!])Oa~O!]'^OP$SaR$Sa[$Sap$Sa!O$Sa!Q$Sa!Z$Sa!j$Sa!n$Sa#P$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#t$Sa#u$Sa#w$Sa#y$Sa#z$Sa(_$Sa(p$Sa(w$Sa(x$Sa~O%h6|O~P&7SO%]8QOa%Zi!]%Zi'x%Zi!Z%Zi~Oa#ay!Z#ay'x#ay'u#ay!W#ay!i#ayt#ay!]#ay%h#ay!e#ay~P!:TO[8SO~Ob8UO(R+nO(TTO(WUO~O!Z0}O![)Vi~O`8YO~O(c(zO!Z'nX!['nX~O!Z5kO![)Sa~O![8cO~P%:RO(m!sO~P$$oO#Y8dO~O!]1gO~O!]1gO%h8fO~Ol8iO!]1gO%h8fO~O[8nO!Z'qa!['qa~O!Z1rO![)Ti~O!i8rO~O!i8sO~O!i8vO~O!i8vO~P%[Oa8xO~O!e8yO~O!i8zO~O!Z(ui![(ui~P#BPOa%mO#^9SO'x%mO~O!Z(ry!i(rya(ry'x(ry~P!:TO!Z(hO!i(qy~O%h9VO~P&7SO!]'^O%h9VO~O#i${qP${qR${q[${qa${qp${q!Q${q!Z${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q'x${q(_${q(p${q!i${q!W${q'u${q#^${qt${q!]${q%h${q!e${q~P#.{O#i'haP'haR'ha['haa'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha'x'ha(_'ha(p'ha!i'ha!W'ha'u'hat'ha!]'ha%h'ha!e'ha~P&3oO#i'jaP'jaR'ja['jaa'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja'x'ja(_'ja(p'ja!i'ja!W'ja'u'jat'ja!]'ja%h'ja!e'ja~P&4bO#i$}qP$}qR$}q[$}qa$}qp$}q!Q$}q!Z$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q'x$}q(_$}q(p$}q!i$}q!W$}q'u$}q#^$}qt$}q!]$}q%h$}q!e$}q~P#.{O!Z'Wi!i'Wi~P!:TO#}#aq!Z#aq![#aq~P#BPO(w$}OP%`aR%`a[%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a#}%`a(_%`a(p%`a!Z%`a![%`a~Ol%`a!O%`a'w%`a(x%`a~P&HgO(x%POP%baR%ba[%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba#}%ba(_%ba(p%ba!Z%ba![%ba~Ol%ba!O%ba'w%ba(w%ba~P&JnOl=}O!O)|O'w)}O(x%PO~P&HgOl=}O!O)|O'w)}O(w$}O~P&JnOR0cO!O0cO!Q0dO#Q$dOP{a[{al{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a#}{a'w{a(_{a(p{a(w{a(x{a!Z{a![{a~O!O)|O'w)}OP$raR$ra[$ral$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra#}$ra(_$ra(p$ra(w$ra(x$ra!Z$ra![$ra~O!O)|O'w)}OP$taR$ta[$tal$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta#}$ta(_$ta(p$ta(w$ta(x$ta!Z$ta![$ta~Ol=}O!O)|O'w)}O(w$}O(x%PO~OP%SaR%Sa[%Sap%Sa!Q%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa#}%Sa(_%Sa(p%Sa!Z%Sa![%Sa~P'%sO#}$lq!Z$lq![$lq~P#BPO#}$nq!Z$nq![$nq~P#BPO![9dO~O#}9eO~P!0uO!e#vO!Z'ci!i'ci~O!e#vO(p'nO!Z'ci!i'ci~O!Z/kO!i(|q~O!W'ei!Z'ei~P#.{O!Z/sO!W(}q~Op9lO!e#vO(p'nO~O[9nO!W9mO~P#.{O!W9mO~O!e#vO#t9tO~Og(]y!Z(]y~P!0uO!Z'la!]'la~P#.{Oa%Zq!]%Zq'x%Zq!Z%Zq~P#.{O[9yO~O!Z0}O![)Vq~O#^9}O!Z'na!['na~O!Z5kO![)Si~P#BPO!Q:PO~O!]1gO%h:SO~O(TTO(WUO(c:XO~O!Z1rO![)Tq~O!i:[O~O!i:]O~O!i:^O~O!i:^O~P%[O#^:aO!Z#fy![#fy~O!Z#fy![#fy~P#BPO%h:fO~P&7SO!]'^O%h:fO~O#}#{y!Z#{y![#{y~P#BPOP${iR${i[${ip${i!Q${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i#}${i(_${i(p${i!Z${i![${i~P'%sO!O)|O'w)}O(x%POP'gaR'ga['gal'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga#}'ga(_'ga(p'ga(w'ga!Z'ga!['ga~O!O)|O'w)}OP'iaR'ia['ial'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia#}'ia(_'ia(p'ia(w'ia(x'ia!Z'ia!['ia~O(w$}OP%`iR%`i[%`il%`ip%`i!O%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i#}%`i'w%`i(_%`i(p%`i(x%`i!Z%`i![%`i~O(x%POP%biR%bi[%bil%bip%bi!O%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi#}%bi'w%bi(_%bi(p%bi(w%bi!Z%bi![%bi~O#}$ny!Z$ny![$ny~P#BPO#}#ay!Z#ay![#ay~P#BPO!e#vO!Z'cq!i'cq~O!Z/kO!i(|y~O!W'eq!Z'eq~P#.{Op:pO!e#vO(p'nO~O[:tO!W:sO~P#.{O!W:sO~Og(]!R!Z(]!R~P!0uOa%Zy!]%Zy'x%Zy!Z%Zy~P#.{O!Z0}O![)Vy~O!Z5kO![)Sq~O(R:zO~O!]1gO%h:}O~O!i;QO~O%h;VO~P&7SOP${qR${q[${qp${q!Q${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q#}${q(_${q(p${q!Z${q![${q~P'%sO!O)|O'w)}O(x%POP'haR'ha['hal'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha#}'ha(_'ha(p'ha(w'ha!Z'ha!['ha~O!O)|O'w)}OP'jaR'ja['jal'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja#}'ja(_'ja(p'ja(w'ja(x'ja!Z'ja!['ja~OP$}qR$}q[$}qp$}q!Q$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q#}$}q(_$}q(p$}q!Z$}q![$}q~P'%sOg%d!Z!Z%d!Z#^%d!Z#}%d!Z~P!0uO!W;ZO~P#.{Op;[O!e#vO(p'nO~O[;^O!W;ZO~P#.{O!Z'nq!['nq~P#BPO!Z#f!Z![#f!Z~P#BPO#i%d!ZP%d!ZR%d!Z[%d!Za%d!Zp%d!Z!Q%d!Z!Z%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z'x%d!Z(_%d!Z(p%d!Z!i%d!Z!W%d!Z'u%d!Z#^%d!Zt%d!Z!]%d!Z%h%d!Z!e%d!Z~P#.{Op;fO!e#vO(p'nO~O!W;gO~P#.{Op;nO!e#vO(p'nO~O!W;oO~P#.{OP%d!ZR%d!Z[%d!Zp%d!Z!Q%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z#}%d!Z(_%d!Z(p%d!Z!Z%d!Z![%d!Z~P'%sOp;rO!e#vO(p'nO~Ot(dX~P1qO!O%qO~P!(yO(S!lO~P!(yO!WfX!ZfX#^fX~P%0XOP]XR]X[]Xp]X!O]X!Q]X!Z]X!ZfX!j]X!n]X#P]X#Q]X#^]X#^fX#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!efX!i]X!ifX(pfX~P'JlOP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]XO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z<ZO![$pa~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<fO!Q${O!]$|O!g=wO!j$xO#h<lO$V%_O$s<hO$u<jO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Oj)bO~P( bOp!cX(p!cX~P# qOp(hX(p(hX~P#!dO![]X![fX~P'JlO!WfX!W$yX!ZfX!Z$yX#^fX~P!/qO#i<OO~O!e#vO#i<OO~O#^<`O~O#t<SO~O#^<pO!Z(uX![(uX~O#^<`O!Z(sX![(sX~O#i<qO~Og<sO~P!0uO#i<yO~O#i<zO~O!e#vO#i<{O~O!e#vO#i<qO~O#}<|O~P#BPO#i<}O~O#i=OO~O#i=TO~O#i=UO~O#i=VO~O#i=WO~O#}=XO~P!0uO#}=YO~P!0uO#Q#R#S#U#V#Y#g#h#s$m$s$u$x%[%]%g%h%i%p%r%u%v%x%z~'|T#m!V'z(S#nq#l#op!O'{$['{(R$^(c~",
  goto: "$8f)ZPPPPPP)[PP)_P)pP+Q/VPPPP6aPP6wPP<oP@cP@yP@yPPP@yPCRP@yP@yP@yPCVPC[PCyPHsPPPHwPPPPHwKzPPPLQLrPHwPHwPP! QHwPPPHwPHwP!#XHwP!&o!'t!'}P!(q!(u!(q!,SPPPPPPP!,s!'tPP!-T!.uP!2RHwHw!2W!5d!:Q!:Q!>PPPP!>XHwPPPPPPPPPP!AhP!BuPPHw!DWPHwPHwHwHwHwHwPHw!EjP!HtP!KzP!LO!LY!L^!L^P!HqP!Lb!LbP# hP# lHwPHw# r#$wCV@yP@yP@y@yP#&U@y@y#(h@y#+`@y#-l@y@y#.[#0p#0p#0u#1O#0p#1ZPP#0pP@y#1s@y#5r@y@y6aPPP#9wPPP#:b#:bP#:bP#:x#:bPP#;OP#:uP#:u#;c#:u#;}#<T#<W)_#<Z)_P#<b#<b#<bP)_P)_P)_P)_PP)_P#<h#<kP#<k)_P#<oP#<rP)_P)_P)_P)_P)_P)_)_PP#<x#=O#=Z#=a#=g#=m#=s#>R#>X#>c#>i#>s#>y#?Z#?a#@R#@e#@k#@q#AP#Af#CZ#Ci#Cp#E[#Ej#G[#Gj#Gp#Gv#G|#HW#H^#Hd#Hn#IQ#IWPPPPPPPPPPP#I^PPPPPPP#JR#MY#Nr#Ny$ RPPP$&mP$&v$)o$0Y$0]$0`$1_$1b$1i$1qP$1w$1zP$2h$2l$3d$4r$4w$5_PP$5d$5j$5n$5q$5u$5y$6u$7^$7u$7y$7|$8P$8V$8Y$8^$8bR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0u+fQ1S+rQ1y,fQ3W.bQ5V0wQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 378,
  context: QV,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 35, 37, 49, 51, 53, ""],
    ["group", -26, 9, 17, 19, 66, 206, 210, 214, 215, 217, 220, 223, 233, 235, 241, 243, 245, 247, 250, 256, 262, 264, 266, 268, 270, 272, 273, "Statement", -34, 13, 14, 30, 33, 34, 40, 49, 52, 53, 55, 60, 68, 70, 74, 78, 80, 82, 83, 108, 109, 118, 119, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 168, 170, "Expression", -23, 29, 31, 35, 39, 41, 43, 172, 174, 176, 177, 179, 180, 181, 183, 184, 185, 187, 188, 189, 200, 202, 204, 205, "Type", -3, 86, 101, 107, "ClassItem"],
    ["openedBy", 23, "<", 36, "InterpolationStart", 54, "[", 58, "{", 71, "(", 159, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 167, ">", 38, "InterpolationEnd", 48, "]", 59, "}", 72, ")", 164, "JSXEndTag"]
  ],
  propSources: [zV],
  skippedNodes: [0, 5, 6, 276],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Up(X!b'z0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(V#S$h&j'{0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Up(X!b'{0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!n),Q(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(T':f$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(X!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Up(X!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Up(X!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(X!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(X!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(UpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(UpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Up(X!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(m%1l(Up(X!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Up(X!b$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Up(X!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Up(X!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(x+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(W';W$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(UpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!j/.^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!i!Lf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Up(X!b(S%&f#o(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Up(X!b#l(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Up(X!bp+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Z+Jf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Up(X!b!O.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!Y!L^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Up(X!b#m(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(X!b!V7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!V7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!V7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!V7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!V7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(X!b!V7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(X!b!V7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(X!b!V7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(X!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(X!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Up!V7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Up!V7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Up!V7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Up!V7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(UpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(UpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Up(X!b!V7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Up(X!b!V7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Up(X!b!V7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Up(X!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Up(X!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Up(X!b'|0/l!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Up(X!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(X!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(X!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(UpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(UpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Up(X!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!e$b$h&j#})Lv(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#P-<U(Up(X!b$m7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#p(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#q(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#^*!Y$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#i(Cl$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#q(Ch$e#|$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#q(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(p(Ct$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!z$Ip$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!Q0,v$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!W#)l$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Up(X!b(_+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Up(X!b(R,2j$^#t(c$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Up(X!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!]#Hb(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(w+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_![(CdtBr$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!o7`$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Up(X!b'z0/l$[#t(R,2j(c$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Up(X!b'{0/l$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [TV, AV, RV, EV, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, MV, new uv("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOv~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!S~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(a~~", 141, 338), new uv("j~RQYZXz{^~^O(O~~aP!P!Qd~iO(P~~", 25, 321)],
  topRules: { Script: [0, 7], SingleExpression: [1, 274], SingleClassItem: [2, 275] },
  dialects: { jsx: 0, ts: 15091 },
  dynamicPrecedences: { 78: 1, 80: 1, 92: 1, 168: 1, 198: 1 },
  specialized: [{ term: 325, get: /* @__PURE__ */ y((n) => _V[n] || -1, "get") }, { term: 341, get: /* @__PURE__ */ y((n) => LV[n] || -1, "get") }, { term: 93, get: /* @__PURE__ */ y((n) => IV[n] || -1, "get") }],
  tokenPrec: 15116
}), YT = [
  /* @__PURE__ */ di("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ di("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ di("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ di("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ di("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ di(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ di("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ di(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ di(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ di('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ di('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], WV = /* @__PURE__ */ YT.concat([
  /* @__PURE__ */ di("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ di("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ di("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), q4 = /* @__PURE__ */ new d6(), GT = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function dc(n) {
  return (t, e) => {
    let i = t.node.getChild("VariableDefinition");
    return i && e(i, n), !0;
  };
}
h(dc, "ar$1");
y(dc, "defID");
const DV = ["FunctionDeclaration"], qV = {
  FunctionDeclaration: /* @__PURE__ */ dc("function"),
  ClassDeclaration: /* @__PURE__ */ dc("class"),
  ClassExpression: /* @__PURE__ */ y(() => !0, "ClassExpression"),
  EnumDeclaration: /* @__PURE__ */ dc("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ dc("type"),
  NamespaceDeclaration: /* @__PURE__ */ dc("namespace"),
  VariableDefinition(n, t) {
    n.matchContext(DV) || t(n, "variable");
  },
  TypeDefinition(n, t) {
    t(n, "type");
  },
  __proto__: null
};
function mS(n, t) {
  let e = q4.get(t);
  if (e)
    return e;
  let i = [], s = !0;
  function r(a, o) {
    let l = n.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return h(r, "s"), y(r, "def"), t.cursor(Yt.IncludeAnonymous).iterate((a) => {
    if (s)
      s = !1;
    else if (a.name) {
      let o = qV[a.name];
      if (o && o(a, r) || GT.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of mS(n, a.node))
        i.push(o);
      return !1;
    }
  }), q4.set(t, i), i;
}
h(mS, "om$1");
y(mS, "getScope");
const wv = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, wS = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function KT(n) {
  let t = ce(n.state).resolveInner(n.pos, -1);
  if (wS.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && wv.test(n.state.sliceDoc(t.from, t.to));
  if (!e && !n.explicit)
    return null;
  let i = [];
  for (let s = t; s; s = s.parent)
    GT.has(s.name) && (i = i.concat(mS(n.state.doc, s)));
  return {
    options: i,
    from: e ? t.from : n.pos,
    validFor: wv
  };
}
h(KT, "lm$1");
y(KT, "localCompletionSource");
function d1(n, t, e) {
  var i;
  let s = [];
  for (; ; ) {
    let r = t.firstChild, a;
    if ((r == null ? void 0 : r.name) == "VariableName")
      return s.push(n(r)), { path: s.reverse(), name: e };
    if ((r == null ? void 0 : r.name) == "MemberExpression" && ((i = a = r.lastChild) === null || i === void 0 ? void 0 : i.name) == "PropertyName")
      s.push(n(a)), t = r;
    else
      return null;
  }
}
h(d1, "zo$1");
y(d1, "pathFor");
function JT(n) {
  let t = /* @__PURE__ */ y((i) => n.state.doc.sliceString(i.from, i.to), "read"), e = ce(n.state).resolveInner(n.pos, -1);
  return e.name == "PropertyName" ? d1(t, e.parent, t(e)) : (e.name == "." || e.name == "?.") && e.parent.name == "MemberExpression" ? d1(t, e.parent, "") : wS.indexOf(e.name) > -1 ? null : e.name == "VariableName" || e.to - e.from < 20 && wv.test(t(e)) ? { path: [], name: t(e) } : e.name == "MemberExpression" ? d1(t, e, "") : n.explicit ? { path: [], name: "" } : null;
}
h(JT, "am$1");
y(JT, "completionPath");
function tA(n, t) {
  let e = [], i = /* @__PURE__ */ new Set();
  for (let s = 0; ; s++) {
    for (let a of (Object.getOwnPropertyNames || Object.keys)(n)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(a) || i.has(a))
        continue;
      i.add(a);
      let o;
      try {
        o = n[a];
      } catch {
        continue;
      }
      e.push({
        label: a,
        type: typeof o == "function" ? /^[A-Z]/.test(a) ? "class" : t ? "function" : "method" : t ? "variable" : "property",
        boost: -s
      });
    }
    let r = Object.getPrototypeOf(n);
    if (!r)
      return e;
    n = r;
  }
}
h(tA, "DS");
y(tA, "enumeratePropertyCompletions");
function VV(n) {
  let t = /* @__PURE__ */ new Map();
  return (e) => {
    let i = JT(e);
    if (!i)
      return null;
    let s = n;
    for (let a of i.path)
      if (s = s[a], !s)
        return null;
    let r = t.get(s);
    return r || t.set(s, r = tA(s, !i.path.length)), {
      from: e.pos - i.name.length,
      options: r,
      validFor: wv
    };
  };
}
h(VV, "BS");
y(VV, "scopeCompletionSource");
const On = /* @__PURE__ */ z5.define({
  name: "javascript",
  parser: /* @__PURE__ */ ZV.configure({
    props: [
      /* @__PURE__ */ Oy.add({
        IfStatement: /* @__PURE__ */ ew({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ew({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: zW,
        SwitchBody: /* @__PURE__ */ y((n) => {
          let t = n.textAfter, e = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return n.baseIndent + (e ? 0 : i ? 1 : 2) * n.unit;
        }, "SwitchBody"),
        Block: /* @__PURE__ */ N6({ closing: "}" }),
        ArrowFunction: /* @__PURE__ */ y((n) => n.baseIndent + n.unit, "ArrowFunction"),
        "TemplateString BlockComment": /* @__PURE__ */ y(() => null, "TemplateString BlockComment"),
        "Statement Property": /* @__PURE__ */ ew({ except: /^{/ }),
        JSXElement(n) {
          let t = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        JSXEscape(n) {
          let t = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ Jw.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Z5,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), eA = {
  test: /* @__PURE__ */ y((n) => /^JSX/.test(n.name), "test"),
  facet: /* @__PURE__ */ Kw({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, iA = /* @__PURE__ */ On.configure({ dialect: "ts" }, "typescript"), nA = /* @__PURE__ */ On.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ E5.add((n) => n.isTop ? [eA] : void 0)]
}), sA = /* @__PURE__ */ On.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ E5.add((n) => n.isTop ? [eA] : void 0)]
}, "typescript");
let rA = /* @__PURE__ */ y((n) => ({ label: n, type: "keyword" }), "kwCompletion");
const aA = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(rA), jV = /* @__PURE__ */ aA.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(rA));
function oA(n = {}) {
  let t = n.jsx ? n.typescript ? sA : nA : n.typescript ? iA : On, e = n.typescript ? WV.concat(jV) : YT.concat(aA);
  return new Hf(t, [
    On.data.of({
      autocomplete: fM(wS, F5(e))
    }),
    On.data.of({
      autocomplete: KT
    }),
    n.jsx ? UV : []
  ]);
}
h(oA, "um$1");
y(oA, "javascript");
function lA(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
h(lA, "NS");
y(lA, "findOpenTag");
function Dx(n, t, e = n.length) {
  for (let i = t == null ? void 0 : t.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return n.sliceString(i.from, Math.min(i.to, e));
  return "";
}
h(Dx, "gd$1");
y(Dx, "elementName$1");
const FV = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), UV = /* @__PURE__ */ kt.inputHandler.of((n, t, e, i, s) => {
  if ((FV ? n.composing : n.compositionStarted) || n.state.readOnly || t != e || i != ">" && i != "/" || !On.isActiveAt(n.state, t, -1))
    return !1;
  let r = s(), { state: a } = r, o = a.changeByRange((l) => {
    var c;
    let { head: d } = l, p = ce(a).resolveInner(d - 1, -1), f;
    if (p.name == "JSXStartTag" && (p = p.parent), !(a.doc.sliceString(d - 1, d) != i || p.name == "JSXAttributeValue" && p.to > d)) {
      if (i == ">" && p.name == "JSXFragmentTag")
        return { range: l, changes: { from: d, insert: "</>" } };
      if (i == "/" && p.name == "JSXStartCloseTag") {
        let m = p.parent, w = m.parent;
        if (w && m.from == d - 2 && ((f = Dx(a.doc, w.firstChild, d)) || ((c = w.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let b = `${f}>`;
          return { range: it.cursor(d + b.length, -1), changes: { from: d, insert: b } };
        }
      } else if (i == ">") {
        let m = lA(p);
        if (m && m.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(d, d + 2)) && (f = Dx(a.doc, m, d)))
          return { range: l, changes: { from: d, insert: `</${f}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    r,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
function BV(n, t) {
  return t || (t = {
    parserOptions: { ecmaVersion: 2019, sourceType: "module" },
    env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
    rules: {}
  }, n.getRules().forEach((e, i) => {
    e.meta.docs.recommended && (t.rules[i] = 2);
  })), (e) => {
    let { state: i } = e, s = [];
    for (let { from: r, to: a } of On.findRegions(i)) {
      let o = i.doc.lineAt(r), l = { line: o.number - 1, col: r - o.from, pos: r };
      for (let c of n.verify(i.sliceDoc(r, a), t))
        s.push(cA(c, i.doc, l));
    }
    return s;
  };
}
h(BV, "HS");
y(BV, "esLint");
function qx(n, t, e, i) {
  return e.line(n + i.line).from + t + (n == 1 ? i.col - 1 : -1);
}
h(qx, "yd$1");
y(qx, "mapPos");
function cA(n, t, e) {
  let i = qx(n.line, n.column, t, e), s = {
    from: i,
    to: n.endLine != null && n.endColumn != 1 ? qx(n.endLine, n.endColumn, t, e) : i,
    message: n.message,
    source: n.ruleId ? "eslint:" + n.ruleId : "eslint",
    severity: n.severity == 1 ? "warning" : "error"
  };
  if (n.fix) {
    let { range: r, text: a } = n.fix, o = r[0] + e.pos - i, l = r[1] + e.pos - i;
    s.actions = [{
      name: "fix",
      apply(c, d) {
        c.dispatch({ changes: { from: d + o, to: d + l, insert: a }, scrollIntoView: !0 });
      }
    }];
  }
  return s;
}
h(cA, "FS");
y(cA, "translateDiagnostic");
const Zy = ["_blank", "_self", "_top", "_parent"], Eb = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], zb = ["get", "post", "put", "delete"], _b = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ii = ["true", "false"], ut = {}, XV = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Zy,
      hreflang: null
    }
  },
  abbr: ut,
  address: ut,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ut,
  aside: ut,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ut,
  base: { attrs: { href: null, target: Zy } },
  bdi: ut,
  bdo: ut,
  blockquote: { attrs: { cite: null } },
  body: ut,
  br: ut,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: _b,
      formmethod: zb,
      formnovalidate: ["novalidate"],
      formtarget: Zy,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ut,
  center: ut,
  cite: ut,
  code: ut,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ut,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ut,
  div: ut,
  dl: ut,
  dt: ut,
  em: ut,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ut,
  figure: ut,
  footer: ut,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Eb,
      autocomplete: ["on", "off"],
      enctype: _b,
      method: zb,
      novalidate: ["novalidate"],
      target: Zy
    }
  },
  h1: ut,
  h2: ut,
  h3: ut,
  h4: ut,
  h5: ut,
  h6: ut,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ut,
  hgroup: ut,
  hr: ut,
  html: {
    attrs: { manifest: null }
  },
  i: ut,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: _b,
      formmethod: zb,
      formnovalidate: ["novalidate"],
      formtarget: Zy,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ut,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ut,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ut,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Eb,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ut,
  noscript: ut,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ut,
  param: { attrs: { name: null, value: null } },
  pre: ut,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ut,
  rt: ut,
  ruby: ut,
  samp: ut,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Eb
    }
  },
  section: ut,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ut,
  source: { attrs: { src: null, type: null, media: null } },
  span: ut,
  strong: ut,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ut,
  summary: ut,
  sup: ut,
  table: ut,
  tbody: ut,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ut,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ut,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ut,
  time: { attrs: { datetime: null } },
  title: ut,
  tr: ut,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ut,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ut
}, hA = {
  accesskey: null,
  class: null,
  contenteditable: Ii,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ii,
  autocorrect: Ii,
  autocapitalize: Ii,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ii,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ii,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ii,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ii,
  "aria-hidden": Ii,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ii,
  "aria-multiselectable": Ii,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ii,
  "aria-relevant": null,
  "aria-required": Ii,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, dA = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
for (let n of dA)
  hA[n] = null;
var jd;
const uA = (jd = class {
  constructor(t, e) {
    this.tags = Object.assign(Object.assign({}, XV), t), this.globalAttrs = Object.assign(Object.assign({}, hA), e), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}, h(jd, "xc"), jd);
y(uA, "Schema");
let $w = uA;
$w.default = /* @__PURE__ */ new $w();
function Wo(n, t, e = n.length) {
  if (!t)
    return "";
  let i = t.firstChild, s = i && i.getChild("TagName");
  return s ? n.sliceString(s.from, Math.min(s.to, e)) : "";
}
h(Wo, "Fi$1");
y(Wo, "elementName");
function Do(n, t = !1) {
  for (; n; n = n.parent)
    if (n.name == "Element")
      if (t)
        t = !1;
      else
        return n;
  return null;
}
h(Do, "Ki$1");
y(Do, "findParentElement");
function gS(n, t, e) {
  let i = e.tags[Wo(n, Do(t))];
  return (i == null ? void 0 : i.children) || e.allTags;
}
h(gS, "mm$1");
y(gS, "allowedChildren");
function S0(n, t) {
  let e = [];
  for (let i = Do(t); i && !i.type.isTop; i = Do(i.parent)) {
    let s = Wo(n, i);
    if (s && i.lastChild.name == "CloseTag")
      break;
    s && e.indexOf(s) < 0 && (t.name == "EndTag" || t.from >= i.firstChild.to) && e.push(s);
  }
  return e;
}
h(S0, "$h");
y(S0, "openTags");
const pA = /^[:\-\.\w\u00b7-\uffff]*$/;
function Vx(n, t, e, i, s) {
  let r = /\s*>/.test(n.sliceDoc(s, s + 5)) ? "" : ">", a = Do(e, !0);
  return {
    from: i,
    to: s,
    options: gS(n.doc, a, t).map((o) => ({ label: o, type: "type" })).concat(S0(n.doc, e).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + r,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
h(Vx, "bd$1");
y(Vx, "completeTag");
function jx(n, t, e, i) {
  let s = /\s*>/.test(n.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: e,
    to: i,
    options: S0(n.doc, t).map((r, a) => ({ label: r, apply: r + s, type: "type", boost: 99 - a })),
    validFor: pA
  };
}
h(jx, "Sd$1");
y(jx, "completeCloseTag");
function fA(n, t, e, i) {
  let s = [], r = 0;
  for (let a of gS(n.doc, e, t))
    s.push({ label: "<" + a, type: "type" });
  for (let a of S0(n.doc, e))
    s.push({ label: "</" + a + ">", type: "type", boost: 99 - r++ });
  return { from: i, to: i, options: s, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
h(fA, "JS");
y(fA, "completeStartTag");
function yA(n, t, e, i, s) {
  let r = Do(e), a = r ? t.tags[Wo(n.doc, r)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], l = a && a.globalAttrs === !1 ? o : o.length ? o.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: i,
    to: s,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: pA
  };
}
h(yA, "eQ");
y(yA, "completeAttrName");
function mA(n, t, e, i, s) {
  var r;
  let a = (r = e.parent) === null || r === void 0 ? void 0 : r.getChild("AttributeName"), o = [], l;
  if (a) {
    let c = n.sliceDoc(a.from, a.to), d = t.globalAttrs[c];
    if (!d) {
      let p = Do(e), f = p ? t.tags[Wo(n.doc, p)] : null;
      d = (f == null ? void 0 : f.attrs) && f.attrs[c];
    }
    if (d) {
      let p = n.sliceDoc(i, s).toLowerCase(), f = '"', m = '"';
      /^['"]/.test(p) ? (l = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", m = n.sliceDoc(s, s + 1) == p[0] ? "" : p[0], p = p.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let w of d)
        o.push({ label: w, apply: f + w + m, type: "constant" });
    }
  }
  return { from: i, to: s, options: o, validFor: l };
}
h(mA, "tQ");
y(mA, "completeAttrValue");
function vS(n, t) {
  let { state: e, pos: i } = t, s = ce(e).resolveInner(i, -1), r = s.resolve(i);
  for (let a = i, o; r == s && (o = s.childBefore(a)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    r = s = o, a = l.from;
  }
  return s.name == "TagName" ? s.parent && /CloseTag$/.test(s.parent.name) ? jx(e, s, s.from, i) : Vx(e, n, s, s.from, i) : s.name == "StartTag" ? Vx(e, n, s, i, i) : s.name == "StartCloseTag" || s.name == "IncompleteCloseTag" ? jx(e, s, i, i) : s.name == "OpenTag" || s.name == "SelfClosingTag" || s.name == "AttributeName" ? yA(e, n, s, s.name == "AttributeName" ? s.from : i, i) : s.name == "Is" || s.name == "AttributeValue" || s.name == "UnquotedAttributeValue" ? mA(e, n, s, s.name == "Is" ? i : s.from, i) : t.explicit && (r.name == "Element" || r.name == "Text" || r.name == "Document") ? fA(e, n, s, i) : null;
}
h(vS, "ym$1");
y(vS, "htmlCompletionFor");
function wA(n) {
  return vS($w.default, n);
}
h(wA, "bm$1");
y(wA, "htmlCompletionSource");
function gA(n) {
  let { extraTags: t, extraGlobalAttributes: e } = n, i = e || t ? new $w(t, e) : $w.default;
  return (s) => vS(i, s);
}
h(gA, "Sm$1");
y(gA, "htmlCompletionSourceWith");
const NV = /* @__PURE__ */ On.parser.configure({ top: "SingleExpression" }), vA = [
  {
    tag: "script",
    attrs: /* @__PURE__ */ y((n) => n.type == "text/typescript" || n.lang == "ts", "attrs"),
    parser: iA.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ y((n) => n.type == "text/babel" || n.type == "text/jsx", "attrs"),
    parser: nA.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ y((n) => n.type == "text/typescript-jsx", "attrs"),
    parser: sA.parser
  },
  {
    tag: "script",
    attrs(n) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(n.type);
    },
    parser: NV
  },
  {
    tag: "script",
    attrs(n) {
      return !n.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(n.type);
    },
    parser: On.parser
  },
  {
    tag: "style",
    attrs(n) {
      return (!n.lang || n.lang == "css") && (!n.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(n.type));
    },
    parser: mv.parser
  }
], bA = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ mv.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ dA.map((n) => ({ name: n, parser: On.parser }))), OA = /* @__PURE__ */ z5.define({
  name: "html",
  parser: /* @__PURE__ */ _q.configure({
    props: [
      /* @__PURE__ */ Oy.add({
        Element(n) {
          let t = /^(\s*)(<\/)?/.exec(n.textAfter);
          return n.node.to <= n.pos + t[0].length ? n.continue() : n.lineIndent(n.node.from) + (t[2] ? 0 : n.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        },
        Document(n) {
          if (n.pos + /\s*/.exec(n.textAfter)[0].length < n.node.to)
            return n.continue();
          let t = null, e;
          for (let i = n.node; ; ) {
            let s = i.lastChild;
            if (!s || s.name != "Element" || s.to != i.to)
              break;
            t = i = s;
          }
          return t && !((e = t.lastChild) && (e.name == "CloseTag" || e.name == "SelfClosingTag")) ? n.lineIndent(t.from) + n.unit : null;
        }
      }),
      /* @__PURE__ */ Jw.add({
        Element(n) {
          let t = n.firstChild, e = n.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: e.name == "CloseTag" ? e.from : n.to };
        }
      }),
      /* @__PURE__ */ J6.add({
        "OpenTag CloseTag": /* @__PURE__ */ y((n) => n.getChild("TagName"), "OpenTag CloseTag")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), u1 = /* @__PURE__ */ OA.configure({
  wrap: /* @__PURE__ */ pS(vA, bA)
});
function $A(n = {}) {
  let t = "", e;
  n.matchClosingTags === !1 && (t = "noMatch"), n.selfClosingTags === !0 && (t = (t ? t + " " : "") + "selfClosing"), (n.nestedLanguages && n.nestedLanguages.length || n.nestedAttributes && n.nestedAttributes.length) && (e = pS((n.nestedLanguages || []).concat(vA), (n.nestedAttributes || []).concat(bA)));
  let i = e ? OA.configure({ wrap: e, dialect: t }) : t ? u1.configure({ dialect: t }) : u1;
  return new Hf(i, [
    u1.data.of({ autocomplete: gA(n) }),
    n.autoCloseTags !== !1 ? HV : [],
    oA().support,
    NT().support
  ]);
}
h($A, "xm$1");
y($A, "html");
const V4 = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), HV = /* @__PURE__ */ kt.inputHandler.of((n, t, e, i, s) => {
  if (n.composing || n.state.readOnly || t != e || i != ">" && i != "/" || !u1.isActiveAt(n.state, t, -1))
    return !1;
  let r = s(), { state: a } = r, o = a.changeByRange((l) => {
    var c, d, p;
    let f = a.doc.sliceString(l.from - 1, l.to) == i, { head: m } = l, w = ce(a).resolveInner(m, -1), b;
    if (f && i == ">" && w.name == "EndTag") {
      let x = w.parent;
      if (((d = (c = x.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (b = Wo(a.doc, x.parent, m)) && !V4.has(b)) {
        let O = m + (a.doc.sliceString(m, m + 1) === ">" ? 1 : 0), P = `</${b}>`;
        return { range: l, changes: { from: m, to: O, insert: P } };
      }
    } else if (f && i == "/" && w.name == "IncompleteCloseTag") {
      let x = w.parent;
      if (w.from == m - 2 && ((p = x.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (b = Wo(a.doc, x, m)) && !V4.has(b)) {
        let O = m + (a.doc.sliceString(m, m + 1) === ">" ? 1 : 0), P = `${b}>`;
        return {
          range: it.cursor(m + P.length, -1),
          changes: { from: m, to: O, insert: P }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    r,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), xA = /* @__PURE__ */ Kw({ commentTokens: { block: { open: "<!--", close: "-->" } } }), kA = /* @__PURE__ */ new xt(), SA = /* @__PURE__ */ _D.configure({
  props: [
    /* @__PURE__ */ Jw.add((n) => !n.is("Block") || n.is("Document") || gv(n) != null || PA(n) ? void 0 : (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })),
    /* @__PURE__ */ kA.add(gv),
    /* @__PURE__ */ Oy.add({
      Document: /* @__PURE__ */ y(() => null, "Document")
    }),
    /* @__PURE__ */ br.add({
      Document: xA
    })
  ]
});
function gv(n) {
  let t = /^(?:ATX|Setext)Heading(\d)$/.exec(n.name);
  return t ? +t[1] : void 0;
}
h(gv, "Ba$1");
y(gv, "isHeading");
function PA(n) {
  return n.name == "OrderedList" || n.name == "BulletList";
}
h(PA, "nQ");
y(PA, "isList");
function CA(n, t) {
  let e = n;
  for (; ; ) {
    let i = e.nextSibling, s;
    if (!i || (s = gv(i.type)) != null && s <= t)
      break;
    e = i;
  }
  return e.to;
}
h(CA, "sQ");
y(CA, "findSectionEnd");
const YV = /* @__PURE__ */ _W.of((n, t, e) => {
  for (let i = ce(n).resolveInner(e, -1); i && !(i.from < t); i = i.parent) {
    let s = i.type.prop(kA);
    if (s == null)
      continue;
    let r = CA(i, s);
    if (r > e)
      return { from: e, to: r };
  }
  return null;
});
function P0(n) {
  return new Fi(xA, n, [YV], "markdown");
}
h(P0, "Th$1");
y(P0, "mkLang");
const GV = /* @__PURE__ */ P0(SA), KV = /* @__PURE__ */ SA.configure([jD, UD, FD, BD, {
  props: [
    /* @__PURE__ */ Jw.add({
      Table: /* @__PURE__ */ y((n, t) => ({ from: t.doc.lineAt(n.from).to, to: n.to }), "Table")
    })
  ]
}]), Fx = /* @__PURE__ */ P0(KV);
function QA(n, t) {
  return (e) => {
    if (e && n) {
      let i = null;
      if (e = /\S*/.exec(e)[0], typeof n == "function" ? i = n(e) : i = u4.matchLanguageName(n, e, !0), i instanceof u4)
        return i.support ? i.support.language.parser : av.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return t ? t.parser : null;
  };
}
h(QA, "aQ");
y(QA, "getCodeParser");
var Fd;
const MA = (Fd = class {
  constructor(t, e, i, s, r, a, o) {
    this.node = t, this.from = e, this.to = i, this.spaceBefore = s, this.spaceAfter = r, this.type = a, this.item = o;
  }
  blank(t, e = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (t != null) {
      for (; i.length < t; )
        i += " ";
      return i;
    } else {
      for (let s = this.to - this.from - i.length - this.spaceAfter.length; s > 0; s--)
        i += " ";
      return i + (e ? this.spaceAfter : "");
    }
  }
  marker(t, e) {
    let i = this.node.name == "OrderedList" ? String(+OS(this.item, t)[2] + e) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
}, h(Fd, "Pc"), Fd);
y(MA, "Context");
let Lb = MA;
function bS(n, t) {
  let e = [], i = [];
  for (let s = n; s; s = s.parent) {
    if (s.name == "FencedCode")
      return i;
    (s.name == "ListItem" || s.name == "Blockquote") && e.push(s);
  }
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s], a, o = t.lineAt(r.from), l = r.from - o.from;
    if (r.name == "Blockquote" && (a = /^ *>( ?)/.exec(o.text.slice(l))))
      i.push(new Lb(r, l, l + a[0].length, "", a[1], ">", null));
    else if (r.name == "ListItem" && r.parent.name == "OrderedList" && (a = /^( *)\d+([.)])( *)/.exec(o.text.slice(l)))) {
      let c = a[3], d = a[0].length;
      c.length >= 4 && (c = c.slice(0, c.length - 4), d -= 4), i.push(new Lb(r.parent, l, l + d, a[1], c, a[2], r));
    } else if (r.name == "ListItem" && r.parent.name == "BulletList" && (a = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(o.text.slice(l)))) {
      let c = a[4], d = a[0].length;
      c.length > 4 && (c = c.slice(0, c.length - 4), d -= 4);
      let p = a[2];
      a[3] && (p += a[3].replace(/[xX]/, " ")), i.push(new Lb(r.parent, l, l + d, a[1], c, p, r));
    }
  }
  return i;
}
h(bS, "Tm$1");
y(bS, "getContext");
function OS(n, t) {
  return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(n.from, n.from + 10));
}
h(OS, "Am$1");
y(OS, "itemNumber");
function p1(n, t, e, i = 0) {
  for (let s = -1, r = n; ; ) {
    if (r.name == "ListItem") {
      let o = OS(r, t), l = +o[2];
      if (s >= 0) {
        if (l != s + 1)
          return;
        e.push({ from: r.from + o[1].length, to: r.from + o[0].length, insert: String(s + 2 + i) });
      }
      s = l;
    }
    let a = r.nextSibling;
    if (!a)
      break;
    r = a;
  }
}
h(p1, "Fo$1");
y(p1, "renumberList");
function C0(n, t) {
  let e = /^[ \t]*/.exec(n)[0].length;
  if (!e || t.facet(m0) != "	")
    return n;
  let i = Br(n, 4, e), s = "";
  for (let r = i; r > 0; )
    r >= 4 ? (s += "	", r -= 4) : (s += " ", r--);
  return s + n.slice(e);
}
h(C0, "Ah$1");
y(C0, "normalizeIndent");
const JV = /* @__PURE__ */ y(({ state: n, dispatch: t }) => {
  let e = ce(n), { doc: i } = n, s = null, r = n.changeByRange((a) => {
    if (!a.empty || !Fx.isActiveAt(n, a.from, -1) && !Fx.isActiveAt(n, a.from, 1))
      return s = { range: a };
    let o = a.from, l = i.lineAt(o), c = bS(e.resolveInner(o, -1), i);
    for (; c.length && c[c.length - 1].from > o - l.from; )
      c.pop();
    if (!c.length)
      return s = { range: a };
    let d = c[c.length - 1];
    if (d.to - d.spaceAfter.length > o - l.from)
      return s = { range: a };
    let p = o >= d.to - d.spaceAfter.length && !/\S/.test(l.text.slice(d.to));
    if (d.item && p) {
      let x = d.node.firstChild, O = d.node.getChild("ListItem", "ListItem");
      if (x.to >= o || O && O.to < o || l.from > 0 && !/[^\s>]/.test(i.lineAt(l.from - 1).text)) {
        let P = c.length > 1 ? c[c.length - 2] : null, A, R = "";
        P && P.item ? (A = l.from + P.from, R = P.marker(i, 1)) : A = l.from + (P ? P.to : 0);
        let T = [{ from: A, to: o, insert: R }];
        return d.node.name == "OrderedList" && p1(d.item, i, T, -2), P && P.node.name == "OrderedList" && p1(P.item, i, T), { range: it.cursor(A + R.length), changes: T };
      } else {
        let P = Bx(c, n, l);
        return {
          range: it.cursor(o + P.length + 1),
          changes: { from: l.from, insert: P + n.lineBreak }
        };
      }
    }
    if (d.node.name == "Blockquote" && p && l.from) {
      let x = i.lineAt(l.from - 1), O = />\s*$/.exec(x.text);
      if (O && O.index == d.from) {
        let P = n.changes([
          { from: x.from + O.index, to: x.to },
          { from: l.from + d.from, to: l.to }
        ]);
        return { range: a.map(P), changes: P };
      }
    }
    let f = [];
    d.node.name == "OrderedList" && p1(d.item, i, f);
    let m = d.item && d.item.from < l.from, w = "";
    if (!m || /^[\s\d.)\-+*>]*/.exec(l.text)[0].length >= d.to)
      for (let x = 0, O = c.length - 1; x <= O; x++)
        w += x == O && !m ? c[x].marker(i, 1) : c[x].blank(x < O ? Br(l.text, 4, c[x + 1].from) - w.length : null);
    let b = o;
    for (; b > l.from && /\s/.test(l.text.charAt(b - l.from - 1)); )
      b--;
    return w = C0(w, n), TA(d.node, n.doc) && (w = Bx(c, n, l) + n.lineBreak + w), f.push({ from: b, to: o, insert: n.lineBreak + w }), { range: it.cursor(b + w.length + 1), changes: f };
  });
  return s ? !1 : (t(n.update(r, { scrollIntoView: !0, userEvent: "input" })), !0);
}, "insertNewlineContinueMarkup");
function Ux(n) {
  return n.name == "QuoteMark" || n.name == "ListMark";
}
h(Ux, "wd$1");
y(Ux, "isMark");
function TA(n, t) {
  if (n.name != "OrderedList" && n.name != "BulletList")
    return !1;
  let e = n.firstChild, i = n.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let s = t.lineAt(e.to), r = t.lineAt(i.from), a = /^[\s>]*$/.test(s.text);
  return s.number + (a ? 0 : 1) < r.number;
}
h(TA, "hQ");
y(TA, "nonTightList");
function Bx(n, t, e) {
  let i = "";
  for (let s = 0, r = n.length - 2; s <= r; s++)
    i += n[s].blank(s < r ? Br(e.text, 4, n[s + 1].from) - i.length : null, s < r);
  return C0(i, t);
}
h(Bx, "xd$1");
y(Bx, "blankLine");
function AA(n, t) {
  let e = n.resolveInner(t, -1), i = t;
  Ux(e) && (i = e.from, e = e.parent);
  for (let s; s = e.childBefore(i); )
    if (Ux(s))
      i = s.from;
    else if (s.name == "OrderedList" || s.name == "BulletList")
      e = s.lastChild, i = e.to;
    else
      break;
  return e;
}
h(AA, "fQ");
y(AA, "contextNodeForDelete");
const tj = /* @__PURE__ */ y(({ state: n, dispatch: t }) => {
  let e = ce(n), i = null, s = n.changeByRange((r) => {
    let a = r.from, { doc: o } = n;
    if (r.empty && Fx.isActiveAt(n, r.from)) {
      let l = o.lineAt(a), c = bS(AA(e, a), o);
      if (c.length) {
        let d = c[c.length - 1], p = d.to - d.spaceAfter.length + (d.spaceAfter ? 1 : 0);
        if (a - l.from > p && !/\S/.test(l.text.slice(p, a - l.from)))
          return {
            range: it.cursor(l.from + p),
            changes: { from: l.from + p, to: a }
          };
        if (a - l.from == p && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!d.item || l.from <= d.item.from || !/\S/.test(l.text.slice(0, d.to)))) {
          let f = l.from + d.from;
          if (d.item && d.node.from < d.item.from && /\S/.test(l.text.slice(d.from, d.to))) {
            let m = d.blank(Br(l.text, 4, d.to) - Br(l.text, 4, d.from));
            return f == l.from && (m = C0(m, n)), {
              range: it.cursor(f + m.length),
              changes: { from: f, to: l.from + d.to, insert: m }
            };
          }
          if (f < a)
            return { range: it.cursor(f), changes: { from: f, to: a } };
        }
      }
    }
    return i = { range: r };
  });
  return i ? !1 : (t(n.update(s, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, "deleteMarkupBackward"), ej = [
  { key: "Enter", run: JV },
  { key: "Backspace", run: tj }
], RA = /* @__PURE__ */ $A({ matchClosingTags: !1 });
function ij(n = {}) {
  let { codeLanguages: t, defaultCodeLanguage: e, addKeymap: i = !0, base: { parser: s } = GV, completeHTMLTags: r = !0, htmlTagLanguage: a = RA } = n;
  if (!(s instanceof JM))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let o = n.extensions ? [n.extensions] : [], l = [a.support], c;
  e instanceof Hf ? (l.push(e.support), c = e.language) : e && (c = e);
  let d = t || c ? QA(t, c) : void 0;
  o.push(dT({ codeParser: d, htmlParser: a.language.parser })), i && l.push(rl.high(d0.of(ej)));
  let p = P0(s.configure(o));
  return r && l.push(p.data.of({ autocomplete: EA })), new Hf(p, l);
}
h(ij, "Cm$1");
y(ij, "markdown");
function EA(n) {
  let { state: t, pos: e } = n, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(e - 25, e));
  if (!i)
    return null;
  let s = ce(t).resolveInner(e, -1);
  for (; s && !s.type.isTop; ) {
    if (s.name == "CodeBlock" || s.name == "FencedCode" || s.name == "ProcessingInstructionBlock" || s.name == "CommentBlock" || s.name == "Link" || s.name == "Image")
      return null;
    s = s.parent;
  }
  return {
    from: e - i[0].length,
    to: e,
    options: zA(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
h(EA, "cQ");
y(EA, "htmlTagCompletion");
let Ib = null;
function zA() {
  if (Ib)
    return Ib;
  let n = wA(new j5(ze.create({ extensions: RA }), 0, !0));
  return Ib = n ? n.options : [];
}
h(zA, "uQ");
y(zA, "htmlTagCompletions");
function nj(n) {
  return new Hf(qW.define(n));
}
h(nj, "w");
y(nj, "legacy");
function sj(n) {
  return import(
    /* webpackIgnore: true */
    /* @vite-ignore */
    new URL("./@codemirror/lang-sql/dist/index.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
  ).then((t) => t.sql({ dialect: t[n] }));
}
h(sj, "pt$1");
y(sj, "sql");
function rj(n) {
  const t = new Event("Weavy-SoftSubmit");
  return n.dom.dispatchEvent(t), !0;
}
h(rj, "Em$1");
y(rj, "softSubmit");
const j4 = new uW({
  regexp: /(\[(.+?)\])(\(@u(\d+)\))/g,
  decoration: /* @__PURE__ */ y((n) => Jt.replace({
    // NOTE: can't use backspace to go "up one row" when inclusive is false
    inclusive: !0,
    widget: new aj(n)
  }), "decoration")
});
var Ud;
const _A = (Ud = class extends by {
  constructor(t) {
    super(), this.match = t;
  }
  eq(t) {
    return t.match[1] === this.match[1];
  }
  toDOM() {
    ti();
    const t = document.createElement("span");
    return t.className = "wy-mention", t.innerHTML = typeof this.match[5] < "u" ? this.match[5] : this.match[2], t;
  }
  ignoreEvent() {
    return !1;
  }
}, h(Ud, "kc"), Ud);
y(_A, "MentionWidget");
let aj = _A;
Ds.fromClass(
  class {
    constructor(n) {
      this.mentions = j4.createDeco(n);
    }
    update(n) {
      this.mentions = j4.updateDeco(n, this.mentions);
    }
  },
  {
    decorations: /* @__PURE__ */ y((n) => n.mentions, "decorations"),
    provide: /* @__PURE__ */ y((n) => kt.atomicRanges.of((t) => {
      var e;
      return ((e = t.plugin(n)) == null ? void 0 : e.mentions) || Jt.none;
    }), "provide")
  }
);
function oj(n, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let s = n(t, e);
    return s ? (i(e.update(s)), !0) : !1;
  };
}
h(oj, "Zh$1");
y(oj, "command");
function $S(n, t) {
  let e = n.languageDataAt("commentTokens", t, 1);
  return e.length ? e[0] : {};
}
h($S, "Lh$1");
y($S, "getConfig");
const Wy = 50;
function LA(n, { open: t, close: e }, i, s) {
  let r = n.sliceDoc(i - Wy, i), a = n.sliceDoc(s, s + Wy), o = /\s*$/.exec(r)[0].length, l = /^\s*/.exec(a)[0].length, c = r.length - o;
  if (r.slice(c - t.length, c) == t && a.slice(l, l + e.length) == e)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: s + l, margin: l && 1 }
    };
  let d, p;
  s - i <= 2 * Wy ? d = p = n.sliceDoc(i, s) : (d = n.sliceDoc(i, i + Wy), p = n.sliceDoc(s - Wy, s));
  let f = /^\s*/.exec(d)[0].length, m = /\s*$/.exec(p)[0].length, w = p.length - m - e.length;
  return d.slice(f, f + t.length) == t && p.slice(w, w + e.length) == e ? {
    open: {
      pos: i + f + t.length,
      margin: /\s/.test(d.charAt(f + t.length)) ? 1 : 0
    },
    close: {
      pos: s - m - e.length,
      margin: /\s/.test(p.charAt(w - 1)) ? 1 : 0
    }
  } : null;
}
h(LA, "wQ");
y(LA, "findBlockComment");
function lj(n) {
  let t = [];
  for (let e of n.selection.ranges) {
    let i = n.doc.lineAt(e.from), s = e.to <= i.to ? i : n.doc.lineAt(e.to);
    s.from > i.from && s.from == e.to && (s = e.to == i.to + 1 ? i : n.doc.lineAt(e.to - 1));
    let r = t.length - 1;
    r >= 0 && t[r].to > i.from ? t[r].to = s.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: s.to });
  }
  return t;
}
h(lj, "xQ");
y(lj, "selectedLineRanges");
function cj(n, t, e = t.selection.ranges) {
  let i = e.map((r) => $S(t, r.from).block);
  if (!i.every((r) => r))
    return null;
  let s = e.map((r, a) => LA(t, i[a], r.from, r.to));
  if (n != 2 && !s.every((r) => r))
    return { changes: t.changes(e.map((r, a) => s[a] ? [] : [{ from: r.from, insert: i[a].open + " " }, { from: r.to, insert: " " + i[a].close }])) };
  if (n != 1 && s.some((r) => r)) {
    let r = [];
    for (let a = 0, o; a < s.length; a++)
      if (o = s[a]) {
        let l = i[a], { open: c, close: d } = o;
        r.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: d.pos - d.margin, to: d.pos + l.close.length });
      }
    return { changes: r };
  }
  return null;
}
h(cj, "Vm");
y(cj, "changeBlockComment");
function hj(n, t, e = t.selection.ranges) {
  let i = [], s = -1;
  for (let { from: r, to: a } of e) {
    let o = i.length, l = 1e9, c = $S(t, r).line;
    if (c) {
      for (let d = r; d <= a; ) {
        let p = t.doc.lineAt(d);
        if (p.from > s && (r == a || a > p.from)) {
          s = p.from;
          let f = /^\s*/.exec(p.text)[0].length, m = f == p.length, w = p.text.slice(f, f + c.length) == c ? f : -1;
          f < p.text.length && f < l && (l = f), i.push({ line: p, comment: w, token: c, indent: f, empty: m, single: !1 });
        }
        d = p.to + 1;
      }
      if (l < 1e9)
        for (let d = o; d < i.length; d++)
          i[d].indent < i[d].line.text.length && (i[d].indent = l);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (n != 2 && i.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: o, token: l, indent: c, empty: d, single: p } of i)
      (p || !d) && r.push({ from: o.from + c, insert: l + " " });
    let a = t.changes(r);
    return { changes: a, selection: t.selection.map(a, 1) };
  } else if (n != 1 && i.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: a, comment: o, token: l } of i)
      if (o >= 0) {
        let c = a.from + o, d = c + l.length;
        a.text[d - a.from] == " " && d++, r.push({ from: c, to: d });
      }
    return { changes: r };
  }
  return null;
}
h(hj, "PQ");
y(hj, "changeLineComment");
const Xx = /* @__PURE__ */ Ys.define(), dj = /* @__PURE__ */ Ys.define(), uj = /* @__PURE__ */ gt.define(), IA = /* @__PURE__ */ gt.define({
  combine(n) {
    return Yk(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: /* @__PURE__ */ y((t, e) => e, "joinToEvent")
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: /* @__PURE__ */ y((t, e) => (i, s) => t(i, s) || e(i, s), "joinToEvent")
    });
  }
}), ZA = /* @__PURE__ */ Hs.define({
  create() {
    return iw.empty;
  },
  update(n, t) {
    let e = t.state.facet(IA), i = t.annotation(Xx);
    if (i) {
      let l = Qs.fromTransaction(t, i.selection), c = i.side, d = c == 0 ? n.undone : n.done;
      return l ? d = xw(d, d.length, e.minDepth, l) : d = SS(d, t.startState.selection), new iw(c == 0 ? i.rest : d, c == 0 ? d : i.rest);
    }
    let s = t.annotation(dj);
    if ((s == "full" || s == "before") && (n = n.isolate()), t.annotation(wi.addToHistory) === !1)
      return t.changes.empty ? n : n.addMapping(t.changes.desc);
    let r = Qs.fromTransaction(t), a = t.annotation(wi.time), o = t.annotation(wi.userEvent);
    return r ? n = n.addChanges(r, a, o, e, t) : t.selection && (n = n.addSelection(t.startState.selection, a, o, e.newGroupDelay)), (s == "full" || s == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((t) => t.toJSON()), undone: n.undone.map((t) => t.toJSON()) };
  },
  fromJSON(n) {
    return new iw(n.done.map(Qs.fromJSON), n.undone.map(Qs.fromJSON));
  }
});
function pj(n = {}) {
  return [
    ZA,
    IA.of(n),
    kt.domEventHandlers({
      beforeinput(t, e) {
        let i = t.inputType == "historyUndo" ? fj : t.inputType == "historyRedo" ? yj : null;
        return i ? (t.preventDefault(), i(e)) : !1;
      }
    })
  ];
}
h(pj, "$Q");
y(pj, "history");
function xS(n, t) {
  return function({ state: e, dispatch: i }) {
    if (!t && e.readOnly)
      return !1;
    let s = e.field(ZA, !1);
    if (!s)
      return !1;
    let r = s.pop(n, e, t);
    return r ? (i(r), !0) : !1;
  };
}
h(xS, "So$1");
y(xS, "cmd");
const fj = /* @__PURE__ */ xS(0, !1), yj = /* @__PURE__ */ xS(1, !1);
var ts;
const WA = (ts = class {
  constructor(t, e, i, s, r) {
    this.changes = t, this.effects = e, this.mapped = i, this.startSelection = s, this.selectionsAfter = r;
  }
  setSelAfter(t) {
    return new ts(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, e, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (e = this.mapped) === null || e === void 0 ? void 0 : e.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(t) {
    return new ts(t.changes && xn.fromJSON(t.changes), [], t.mapped && zc.fromJSON(t.mapped), t.startSelection && it.fromJSON(t.startSelection), t.selectionsAfter.map(it.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, e) {
    let i = en;
    for (let s of t.startState.facet(uj)) {
      let r = s(t);
      r.length && (i = i.concat(r));
    }
    return !i.length && t.changes.empty ? null : new ts(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, en);
  }
  static selection(t) {
    return new ts(void 0, en, void 0, void 0, t);
  }
}, h(ts, "Nt"), ts);
y(WA, "HistEvent");
let Qs = WA;
function xw(n, t, e, i) {
  let s = t + 1 > e + 20 ? t - e - 1 : 0, r = n.slice(s, t);
  return r.push(i), r;
}
h(xw, "Vs$1");
y(xw, "updateBranch");
function DA(n, t) {
  let e = [], i = !1;
  return n.iterChangedRanges((s, r) => e.push(s, r)), t.iterChangedRanges((s, r, a, o) => {
    for (let l = 0; l < e.length; ) {
      let c = e[l++], d = e[l++];
      o >= c && a <= d && (i = !0);
    }
  }), i;
}
h(DA, "AQ");
y(DA, "isAdjacent");
function qA(n, t) {
  return n.ranges.length == t.ranges.length && n.ranges.filter((e, i) => e.empty != t.ranges[i].empty).length === 0;
}
h(qA, "ZQ");
y(qA, "eqSelectionShape");
function kS(n, t) {
  return n.length ? t.length ? n.concat(t) : n : t;
}
h(kS, "Ym$1");
y(kS, "conc");
const en = [], mj = 200;
function SS(n, t) {
  if (n.length) {
    let e = n[n.length - 1], i = e.selectionsAfter.slice(Math.max(0, e.selectionsAfter.length - mj));
    return i.length && i[i.length - 1].eq(t) ? n : (i.push(t), xw(n, n.length - 1, 1e9, e.setSelAfter(i)));
  } else
    return [Qs.selection([t])];
}
h(SS, "Im$1");
y(SS, "addSelection");
function VA(n) {
  let t = n[n.length - 1], e = n.slice();
  return e[n.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), e;
}
h(VA, "MQ");
y(VA, "popSelection");
function f1(n, t) {
  if (!n.length)
    return n;
  let e = n.length, i = en;
  for (; e; ) {
    let s = jA(n[e - 1], t, i);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let r = n.slice(0, e);
      return r[e - 1] = s, r;
    } else
      t = s.mapped, e--, i = s.selectionsAfter;
  }
  return i.length ? [Qs.selection(i)] : en;
}
h(f1, "Jo$1");
y(f1, "addMappingToBranch");
function jA(n, t, e) {
  let i = kS(n.selectionsAfter.length ? n.selectionsAfter.map((o) => o.map(t)) : en, e);
  if (!n.changes)
    return Qs.selection(i);
  let s = n.changes.map(t), r = t.mapDesc(n.changes, !0), a = n.mapped ? n.mapped.composeDesc(r) : r;
  return new Qs(s, Bt.mapEffects(n.effects, t), a, n.startSelection.map(r), i);
}
h(jA, "_Q");
y(jA, "mapEvent");
const wj = /^(input\.type|delete)($|\.)/;
var es;
const FA = (es = class {
  constructor(t, e, i = 0, s = void 0) {
    this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new es(this.done, this.undone) : this;
  }
  addChanges(t, e, i, s, r) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && t.changes && (!i || wj.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < s.newGroupDelay && s.joinToEvent(r, DA(o.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = xw(a, a.length - 1, s.minDepth, new Qs(t.changes.compose(o.changes), kS(Bt.mapEffects(t.effects, o.changes), o.effects), o.mapped, o.startSelection, en)) : a = xw(a, a.length, s.minDepth, t), new es(a, en, e, i);
  }
  addSelection(t, e, i, s) {
    let r = this.done.length ? this.done[this.done.length - 1].selectionsAfter : en;
    return r.length > 0 && e - this.prevTime < s && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && qA(r[r.length - 1], t) ? this : new es(SS(this.done, t), this.undone, e, i);
  }
  addMapping(t) {
    return new es(f1(this.done, t), f1(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, e, i) {
    let s = t == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let r = s[s.length - 1], a = r.selectionsAfter[0] || e.selection;
    if (i && r.selectionsAfter.length)
      return e.update({
        selection: r.selectionsAfter[r.selectionsAfter.length - 1],
        annotations: Xx.of({ side: t, rest: VA(s), selection: a }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (r.changes) {
      let o = s.length == 1 ? en : s.slice(0, s.length - 1);
      return r.mapped && (o = f1(o, r.mapped)), e.update({
        changes: r.changes,
        selection: r.startSelection,
        effects: r.effects,
        annotations: Xx.of({ side: t, rest: o, selection: a }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}, h(es, "Gt"), es);
y(FA, "HistoryState");
let iw = FA;
iw.empty = /* @__PURE__ */ new iw(en, en);
function eg(n, t) {
  return it.create(n.ranges.map(t), n.mainIndex);
}
h(eg, "tr$1");
y(eg, "updateSel");
function ig(n, t) {
  return n.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
h(ig, "st$2");
y(ig, "setSel");
function Q0({ state: n, dispatch: t }, e) {
  let i = eg(n.selection, e);
  return i.eq(n.selection, !0) ? !1 : (t(ig(n, i)), !0);
}
h(Q0, "De$2");
y(Q0, "moveSel");
function ng(n, t) {
  return it.cursor(t ? n.to : n.from);
}
h(ng, "Qo$1");
y(ng, "rangeEnd");
function gj(n, t) {
  return Q0(n, (e) => e.empty ? n.moveByChar(e, t) : ng(e, t));
}
h(gj, "jm");
y(gj, "cursorByChar");
function vj(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Pe.LTR;
}
h(vj, "he$2");
y(vj, "ltrAtCursor");
function bj(n, t) {
  return Q0(n, (e) => e.empty ? n.moveByGroup(e, t) : ng(e, t));
}
h(bj, "Bm");
y(bj, "cursorByGroup");
function UA(n, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(t.from, t.to))) || t.firstChild;
}
h(UA, "WQ");
y(UA, "interestingNode");
function Oj(n, t, e) {
  let i = ce(n).resolveInner(t.head), s = e ? xt.closedBy : xt.openedBy;
  for (let l = t.head; ; ) {
    let c = e ? i.childAfter(l) : i.childBefore(l);
    if (!c)
      break;
    UA(n, c, s) ? i = c : l = e ? c.to : c.from;
  }
  let r = i.type.prop(s), a, o;
  return r && (a = e ? Va(n, i.from, 1) : Va(n, i.to, -1)) && a.matched ? o = e ? a.end.to : a.end.from : o = e ? i.to : i.from, it.cursor(o, e ? -1 : 1);
}
h(Oj, "wo$1");
y(Oj, "moveBySyntax");
function $j(n, t) {
  return Q0(n, (e) => {
    if (!e.empty)
      return ng(e, t);
    let i = n.moveVertically(e, t);
    return i.head != e.head ? i : n.moveToLineBoundary(e, t);
  });
}
h($j, "zm$1");
y($j, "cursorByLine");
function PS(n) {
  let t = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, e = 0, i = 0, s;
  if (t) {
    for (let r of n.state.facet(kt.scrollMargins)) {
      let a = r(n);
      a != null && a.top && (e = Math.max(a == null ? void 0 : a.top, e)), a != null && a.bottom && (i = Math.max(a == null ? void 0 : a.bottom, i));
    }
    s = n.scrollDOM.clientHeight - e - i;
  } else
    s = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: e,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(n.defaultLineHeight, s - 5)
  };
}
h(PS, "Hm$1");
y(PS, "pageInfo");
function xj(n, t) {
  let e = PS(n), { state: i } = n, s = eg(i.selection, (a) => a.empty ? n.moveVertically(a, t, e.height) : ng(a, t));
  if (s.eq(i.selection))
    return !1;
  let r;
  if (e.selfScroll) {
    let a = n.coordsAtPos(i.selection.main.head), o = n.scrollDOM.getBoundingClientRect(), l = o.top + e.marginTop, c = o.bottom - e.marginBottom;
    a && a.top > l && a.bottom < c && (r = kt.scrollIntoView(s.main.head, { y: "start", yMargin: a.top - l }));
  }
  return n.dispatch(ig(i, s), { effects: r }), !0;
}
h(xj, "Fm$1");
y(xj, "cursorByPage");
function kj(n, t, e) {
  let i = n.lineBlockAt(t.head), s = n.moveToLineBoundary(t, e);
  if (s.head == t.head && s.head != (e ? i.to : i.from) && (s = n.moveToLineBoundary(t, e, !1)), !e && s.head == i.from && i.length) {
    let r = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    r && t.head != i.from + r && (s = it.cursor(i.from + r));
  }
  return s;
}
h(kj, "_t$1");
y(kj, "moveByLineBoundary");
function Sj(n, t, e) {
  let i = !1, s = eg(n.selection, (r) => {
    let a = Va(n, r.head, -1) || Va(n, r.head, 1) || r.head > 0 && Va(n, r.head - 1, 1) || r.head < n.doc.length && Va(n, r.head + 1, -1);
    if (!a || !a.end)
      return r;
    i = !0;
    let o = a.start.from == r.head ? a.end.to : a.end.from;
    return it.cursor(o);
  });
  return i ? (t(ig(n, s)), !0) : !1;
}
h(Sj, "NQ");
y(Sj, "toMatchingBracket");
function sg(n, t) {
  let e = eg(n.state.selection, (i) => {
    let s = t(i);
    return it.range(i.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return e.eq(n.state.selection) ? !1 : (n.dispatch(ig(n.state, e)), !0);
}
h(sg, "Ue$2");
y(sg, "extendSel");
function Pj(n, t) {
  return sg(n, (e) => n.moveByChar(e, t));
}
h(Pj, "Km");
y(Pj, "selectByChar");
function Cj(n, t) {
  return sg(n, (e) => n.moveByGroup(e, t));
}
h(Cj, "tg$1");
y(Cj, "selectByGroup");
function Qj(n, t) {
  return sg(n, (e) => n.moveVertically(e, t));
}
h(Qj, "ig$1");
y(Qj, "selectByLine");
function Mj(n, t) {
  return sg(n, (e) => n.moveVertically(e, t, PS(n).height));
}
h(Mj, "sg$1");
y(Mj, "selectByPage");
function Tj(n, t) {
  if (n.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = n, s = i.changeByRange((r) => {
    let { from: a, to: o } = r;
    if (a == o) {
      let l = t(r);
      l < a ? (e = "delete.backward", l = gm(n, l, !1)) : l > a && (e = "delete.forward", l = gm(n, l, !0)), a = Math.min(a, l), o = Math.max(o, l);
    } else
      a = gm(n, a, !1), o = gm(n, o, !0);
    return a == o ? { range: r } : { changes: { from: a, to: o }, range: it.cursor(a, a < r.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (n.dispatch(i.update(s, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? kt.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
h(Tj, "Sn$1");
y(Tj, "deleteBy");
function gm(n, t, e) {
  if (n instanceof kt)
    for (let i of n.state.facet(kt.atomicRanges).map((s) => s(n)))
      i.between(t, t, (s, r) => {
        s < t && r > t && (t = e ? r : s);
      });
  return t;
}
h(gm, "In$1");
y(gm, "skipAtomic");
function CS(n) {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let s = n.doc.lineAt(i.from), r = n.doc.lineAt(i.to);
    if (!i.empty && i.to == r.from && (r = n.doc.lineAt(i.to - 1)), e >= s.number) {
      let a = t[t.length - 1];
      a.to = r.to, a.ranges.push(i);
    } else
      t.push({ from: s.from, to: r.to, ranges: [i] });
    e = r.number + 1;
  }
  return t;
}
h(CS, "xo$1");
y(CS, "selectedLineBlocks");
function Aj(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [], s = [];
  for (let r of CS(n)) {
    if (e ? r.to == n.doc.length : r.from == 0)
      continue;
    let a = n.doc.lineAt(e ? r.to + 1 : r.from - 1), o = a.length + 1;
    if (e) {
      i.push({ from: r.to, to: a.to }, { from: r.from, insert: a.text + n.lineBreak });
      for (let l of r.ranges)
        s.push(it.range(Math.min(n.doc.length, l.anchor + o), Math.min(n.doc.length, l.head + o)));
    } else {
      i.push({ from: a.from, to: r.from }, { from: r.to, insert: n.lineBreak + a.text });
      for (let l of r.ranges)
        s.push(it.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (t(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: it.create(s, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
h(Aj, "fg$1");
y(Aj, "moveLine");
function Rj(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let s of CS(n))
    e ? i.push({ from: s.from, insert: n.doc.slice(s.from, s.to) + n.lineBreak }) : i.push({ from: s.to, insert: n.lineBreak + n.doc.slice(s.from, s.to) });
  return t(n.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
h(Rj, "cg$1");
y(Rj, "copyLine");
function BA(n, t) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = ce(n).resolveInner(t), i = e.childBefore(t), s = e.childAfter(t), r;
  return i && s && i.to <= t && s.from >= t && (r = i.type.prop(xt.closedBy)) && r.indexOf(s.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(s.from).from && !/\S/.test(n.sliceDoc(i.to, s.from)) ? { from: i.to, to: s.from } : null;
}
h(BA, "Qw$1");
y(BA, "isBetweenBrackets");
function Ej(n) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((s) => {
      let { from: r, to: a } = s, o = t.doc.lineAt(r), l = !n && r == a && BA(t, r);
      n && (r = a = (a <= o.to ? o : t.doc.lineAt(a)).to);
      let c = new _5(t, { simulateBreak: r, simulateDoubleBreak: !!l }), d = W6(c, r);
      for (d == null && (d = Br(/^\s*/.exec(t.doc.lineAt(r).text)[0], t.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      l ? { from: r, to: a } = l : r > o.from && r < o.from + 100 && !/\S/.test(o.text.slice(0, r)) && (r = o.from);
      let p = ["", yx(t, d)];
      return l && p.push(yx(t, c.lineIndent(o.from, -1))), {
        changes: { from: r, to: a, insert: Zt.of(p) },
        range: it.cursor(r + 1 + p[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
h(Ej, "ug$1");
y(Ej, "newlineAndIndent");
function zj(n, t) {
  let e = -1;
  return n.changeByRange((i) => {
    let s = [];
    for (let a = i.from; a <= i.to; ) {
      let o = n.doc.lineAt(a);
      o.number > e && (i.empty || i.to > o.from) && (t(o, s, i), e = o.number), a = o.to + 1;
    }
    let r = n.changes(s);
    return {
      changes: s,
      range: it.range(r.mapPos(i.anchor, 1), r.mapPos(i.head, 1))
    };
  });
}
h(zj, "Mh$1");
y(zj, "changeBySelectedLine");
Y6.define([
  { tag: M.meta, class: "code" },
  { tag: M.link, class: "wy-link" },
  { tag: M.heading, textDecoration: "underline", fontWeight: "bold" },
  { tag: M.emphasis, fontStyle: "italic" },
  { tag: M.strong, fontWeight: "bold" },
  { tag: M.strikethrough, textDecoration: "line-through" },
  { tag: M.keyword, class: "code token keyword" },
  { tag: [M.atom, M.bool], class: "code token builtin" },
  { tag: [M.url, M.contentSeparator, M.labelName], class: "code token prolog" },
  { tag: M.literal, class: "code token char" },
  { tag: M.inserted, class: "code token inserted" },
  { tag: M.deleted, class: "code token deleted" },
  { tag: M.string, class: "code token string" },
  { tag: [M.regexp, M.escape, M.special(M.string)], class: "code token regex" },
  { tag: M.definition(M.variableName), class: "code token constant" },
  { tag: M.local(M.variableName), class: "code token variable" },
  { tag: [M.typeName, M.namespace], class: "code token keyword" },
  { tag: M.className, class: "code token class-name" },
  { tag: [M.special(M.variableName), M.macroName], class: "code token function" },
  { tag: M.propertyName, class: "code token property" },
  { tag: M.comment, class: "code token comment" },
  { tag: M.invalid, color: "#f00", class: "code token" }
]);
function _j(n) {
  QS(n, "start");
  var t = {}, e = n.languageData || {}, i = !1;
  for (var s in n) if (s != e && n.hasOwnProperty(s))
    for (var r = t[s] = [], a = n[s], o = 0; o < a.length; o++) {
      var l = a[o];
      r.push(new HA(l, n)), (l.indent || l.dedent) && (i = !0);
    }
  return {
    name: e.name,
    startState: /* @__PURE__ */ y(function() {
      return { state: "start", pending: null, indent: i ? [] : null };
    }, "startState"),
    copyState: /* @__PURE__ */ y(function(c) {
      var d = { state: c.state, pending: c.pending, indent: c.indent && c.indent.slice(0) };
      return c.stack && (d.stack = c.stack.slice(0)), d;
    }, "copyState"),
    token: YA(t),
    indent: GA(t, e),
    mergeTokens: e.mergeTokens,
    languageData: e
  };
}
h(_j, "Bw$1");
y(_j, "simpleMode");
function QS(n, t) {
  if (!n.hasOwnProperty(t))
    throw new Error("Undefined state " + t + " in simple mode");
}
h(QS, "dg$1");
y(QS, "ensureState");
function XA(n, t) {
  if (!n) return /(?:)/;
  var e = "";
  return n instanceof RegExp ? (n.ignoreCase && (e = "i"), n = n.source) : n = String(n), new RegExp("^(?:" + n + ")", e);
}
h(XA, "Zw$1");
y(XA, "toRegex");
function NA(n) {
  if (!n) return null;
  if (n.apply) return n;
  if (typeof n == "string") return n.replace(/\./g, " ");
  for (var t = [], e = 0; e < n.length; e++)
    t.push(n[e] && n[e].replace(/\./g, " "));
  return t;
}
h(NA, "Lw$1");
y(NA, "asToken");
function HA(n, t) {
  (n.next || n.push) && QS(t, n.next || n.push), this.regex = XA(n.regex), this.token = NA(n.token), this.data = n;
}
h(HA, "Mw$1");
y(HA, "Rule");
function YA(n) {
  return function(t, e) {
    if (e.pending) {
      var i = e.pending.shift();
      return e.pending.length == 0 && (e.pending = null), t.pos += i.text.length, i.token;
    }
    for (var s = n[e.state], r = 0; r < s.length; r++) {
      var a = s[r], o = (!a.data.sol || t.sol()) && t.match(a.regex);
      if (o) {
        a.data.next ? e.state = a.data.next : a.data.push ? ((e.stack || (e.stack = [])).push(e.state), e.state = a.data.push) : a.data.pop && e.stack && e.stack.length && (e.state = e.stack.pop()), a.data.indent && e.indent.push(t.indentation() + t.indentUnit), a.data.dedent && e.indent.pop();
        var l = a.token;
        if (l && l.apply && (l = l(o)), o.length > 2 && a.token && typeof a.token != "string") {
          e.pending = [];
          for (var c = 2; c < o.length; c++)
            o[c] && e.pending.push({ text: o[c], token: a.token[c - 1] });
          return t.backUp(o[0].length - (o[1] ? o[1].length : 0)), l[0];
        } else return l && l.join ? l[0] : l;
      }
    }
    return t.next(), null;
  };
}
h(YA, "_w$1");
y(YA, "tokenFunction");
function GA(n, t) {
  return function(e, i) {
    if (e.indent == null || t.dontIndentStates && t.dontIndentStates.indexOf(e.state) > -1)
      return null;
    var s = e.indent.length - 1, r = n[e.state];
    t: for (; ; ) {
      for (var a = 0; a < r.length; a++) {
        var o = r[a];
        if (o.data.dedent && o.data.dedentIfLineStart !== !1) {
          var l = o.regex.exec(i);
          if (l && l[0]) {
            s--, (o.next || o.push) && (r = n[o.next || o.push]), i = i.slice(l[0].length);
            continue t;
          }
        }
      }
      break;
    }
    return s < 0 ? 0 : e.indent[s];
  };
}
h(GA, "Cw$1");
y(GA, "indentFunction");
var Lj = Object.defineProperty, pt = /* @__PURE__ */ h((n, t) => Lj(n, "name", { value: t, configurable: !0 }), "o$2");
const Nx = "lit-localize-status", Ij = /* @__PURE__ */ pt((n, ...t) => ({
  strTag: !0,
  strings: n,
  values: t
}), "_str"), at = Ij, Zj = /* @__PURE__ */ pt((n) => typeof n != "string" && "strTag" in n, "isStrTagged"), KA = /* @__PURE__ */ pt((n, t, e) => {
  let i = n[0];
  for (let s = 1; s < n.length; s++)
    i += t[e ? e[s - 1] : s - 1], i += n[s];
  return i;
}, "joinStringsAndValues"), JA = /* @__PURE__ */ pt((n) => Zj(n) ? KA(n.strings, n.values) : n, "defaultMsg");
let C = JA, F4 = !1;
function tR(n) {
  if (F4)
    throw new Error("lit-localize can only be configured once");
  C = n, F4 = !0;
}
h(tR, "Ot$1");
pt(tR, "_installMsgImplementation");
var Bd;
const eR = (Bd = class {
  constructor(t) {
    this.__litLocalizeEventHandler = (e) => {
      e.detail.status === "ready" && this.host.requestUpdate();
    }, this.host = t;
  }
  hostConnected() {
    window.addEventListener(Nx, this.__litLocalizeEventHandler);
  }
  hostDisconnected() {
    window.removeEventListener(Nx, this.__litLocalizeEventHandler);
  }
}, h(Bd, "Fe"), Bd);
pt(eR, "LocalizeController");
let Wj = eR;
const Dj = /* @__PURE__ */ pt((n) => n.addController(new Wj(n)), "_updateWhenLocaleChanges"), qj = Dj, Ot = /* @__PURE__ */ pt(() => (n, t) => (n.addInitializer(qj), n), "localized");
var Xd;
const iR = (Xd = class {
  constructor() {
    this.settled = !1, this.promise = new Promise((t, e) => {
      this._resolve = t, this._reject = e;
    });
  }
  resolve(t) {
    this.settled = !0, this._resolve(t);
  }
  reject(t) {
    this.settled = !0, this._reject(t);
  }
}, h(Xd, "Ge"), Xd);
pt(iR, "Deferred");
let nR = iR;
const Os = [];
for (let n = 0; n < 256; n++)
  Os[n] = (n >> 4 & 15).toString(16) + (n & 15).toString(16);
function sR(n) {
  let t = 0, e = 8997, i = 0, s = 33826, r = 0, a = 40164, o = 0, l = 52210;
  for (let c = 0; c < n.length; c++)
    e ^= n.charCodeAt(c), t = e * 435, i = s * 435, r = a * 435, o = l * 435, r += e << 8, o += s << 8, i += t >>> 16, e = t & 65535, r += i >>> 16, s = i & 65535, l = o + (r >>> 16) & 65535, a = r & 65535;
  return Os[l >> 8] + Os[l & 255] + Os[a >> 8] + Os[a & 255] + Os[s >> 8] + Os[s & 255] + Os[e >> 8] + Os[e & 255];
}
h(sR, "It$1");
pt(sR, "fnv1a64");
const Vj = "", jj = "h", Fj = "s";
function rR(n, t) {
  return (t ? jj : Fj) + sR(typeof n == "string" ? n : n.join(Vj));
}
h(rR, "Wt$1");
pt(rR, "generateMsgId");
const U4 = /* @__PURE__ */ new WeakMap(), B4 = /* @__PURE__ */ new Map();
function aR(n, t, e) {
  if (n) {
    const i = (e == null ? void 0 : e.id) ?? oR(t), s = n[i];
    if (s) {
      if (typeof s == "string")
        return s;
      if ("strTag" in s)
        return KA(
          s.strings,
          // Cast `template` because its type wasn't automatically narrowed (but
          // we know it must be the same type as `localized`).
          t.values,
          s.values
        );
      {
        let r = U4.get(s);
        return r === void 0 && (r = s.values, U4.set(s, r)), {
          ...s,
          values: r.map((a) => t.values[a])
        };
      }
    }
  }
  return JA(t);
}
h(aR, "Vt");
pt(aR, "runtimeMsg");
function oR(n) {
  const t = typeof n == "string" ? n : n.strings;
  let e = B4.get(t);
  return e === void 0 && (e = rR(t, typeof n != "string" && !("strTag" in n)), B4.set(t, e)), e;
}
h(oR, "zt");
pt(oR, "generateId");
function y1(n) {
  window.dispatchEvent(new CustomEvent(Nx, { detail: n }));
}
h(y1, "Ae$1");
pt(y1, "dispatchStatusEvent");
let vv = "", Zb, lR, bv, Hx, cR, Ia = new nR();
Ia.resolve();
let Lg = 0;
const Uj = /* @__PURE__ */ pt((n) => (tR((t, e) => aR(cR, t, e)), vv = lR = n.sourceLocale, bv = new Set(n.targetLocales), bv.add(n.sourceLocale), Hx = n.loadLocale, { getLocale: Bj, setLocale: Xj }), "configureLocalization"), Bj = /* @__PURE__ */ pt(() => vv, "getLocale"), Xj = /* @__PURE__ */ pt((n) => {
  if (n === (Zb ?? vv))
    return Ia.promise;
  if (!bv || !Hx)
    throw new Error("Internal error");
  if (!bv.has(n))
    throw new Error("Invalid locale code");
  Lg++;
  const t = Lg;
  return Zb = n, Ia.settled && (Ia = new nR()), y1({ status: "loading", loadingLocale: n }), (n === lR ? (
    // We could switch to the source locale synchronously, but we prefer to
    // queue it on a microtask so that switching locales is consistently
    // asynchronous.
    Promise.resolve({ templates: void 0 })
  ) : Hx(n)).then((e) => {
    Lg === t && (vv = n, Zb = void 0, cR = e.templates, y1({ status: "ready", readyLocale: n }), Ia.resolve());
  }, (e) => {
    Lg === t && (y1({
      status: "error",
      errorLocale: n,
      errorMessage: e.toString()
    }), Ia.reject(e));
  }), Ia.promise;
}, "setLocale");
var Wb, Nd;
const Nj = (Wb = (Nd = class {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(t) {
    this.ariaAtomic = "", this.ariaAutoComplete = "", this.ariaBrailleLabel = "", this.ariaBrailleRoleDescription = "", this.ariaBusy = "", this.ariaChecked = "", this.ariaColCount = "", this.ariaColIndex = "", this.ariaColSpan = "", this.ariaCurrent = "", this.ariaDescription = "", this.ariaDisabled = "", this.ariaExpanded = "", this.ariaHasPopup = "", this.ariaHidden = "", this.ariaInvalid = "", this.ariaKeyShortcuts = "", this.ariaLabel = "", this.ariaLevel = "", this.ariaLive = "", this.ariaModal = "", this.ariaMultiLine = "", this.ariaMultiSelectable = "", this.ariaOrientation = "", this.ariaPlaceholder = "", this.ariaPosInSet = "", this.ariaPressed = "", this.ariaReadOnly = "", this.ariaRequired = "", this.ariaRoleDescription = "", this.ariaRowCount = "", this.ariaRowIndex = "", this.ariaRowSpan = "", this.ariaSelected = "", this.ariaSetSize = "", this.ariaSort = "", this.ariaValueMax = "", this.ariaValueMin = "", this.ariaValueNow = "", this.ariaValueText = "", this.role = "", this.form = null, this.labels = [], this.states = /* @__PURE__ */ new Set(), this.validationMessage = "", this.validity = {}, this.willValidate = !0, this.__host = t;
  }
  checkValidity() {
    return console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true."), !0;
  }
  reportValidity() {
    return !0;
  }
  setFormValue() {
  }
  setValidity() {
  }
}, h(Nd, "I"), Nd), pt(Wb, "ElementInternals"), Wb);
var Vn = /* @__PURE__ */ h(function(n, t, e, i, s) {
  if (typeof t == "function" ? n !== t || !0 : !t.has(n)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(n, e), e;
}, "y$1"), Xe = /* @__PURE__ */ h(function(n, t, e, i) {
  if (typeof t == "function" ? n !== t || !0 : !t.has(n)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(n) : i ? i.value : t.get(n);
}, "$"), Kl, Ig, Zg, Dy, Db, qy, Wg, xa, Vy, sr, Dg, X4;
const N4 = /* @__PURE__ */ pt((n) => typeof n == "boolean" ? n : (n == null ? void 0 : n.capture) ?? !1, "isCaptureEventListener"), Ov = 0, Yx = 1, $v = 2, Gx = 3;
var qb, Hd;
const Hj = (qb = (Hd = class {
  constructor() {
    this.__eventListeners = /* @__PURE__ */ new Map(), this.__captureEventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(t, e, i) {
    var s;
    if (e == null)
      return;
    const r = N4(i) ? this.__captureEventListeners : this.__eventListeners;
    let a = r.get(t);
    if (a === void 0)
      a = /* @__PURE__ */ new Map(), r.set(t, a);
    else if (a.has(e))
      return;
    const o = typeof i == "object" && i ? i : {};
    (s = o.signal) == null || s.addEventListener("abort", () => this.removeEventListener(t, e, i)), a.set(e, o ?? {});
  }
  removeEventListener(t, e, i) {
    if (e == null)
      return;
    const s = N4(i) ? this.__captureEventListeners : this.__eventListeners, r = s.get(t);
    r !== void 0 && (r.delete(e), r.size || s.delete(t));
  }
  dispatchEvent(t) {
    const e = [this];
    let i = this.__eventTargetParent;
    if (t.composed)
      for (; i; )
        e.push(i), i = i.__eventTargetParent;
    else
      for (; i && i !== this.__host; )
        e.push(i), i = i.__eventTargetParent;
    let s = !1, r = !1, a = Ov, o = null, l = null, c = null;
    const d = t.stopPropagation, p = t.stopImmediatePropagation;
    Object.defineProperties(t, {
      target: {
        get() {
          return o ?? l;
        },
        ...Ft
      },
      srcElement: {
        get() {
          return t.target;
        },
        ...Ft
      },
      currentTarget: {
        get() {
          return c;
        },
        ...Ft
      },
      eventPhase: {
        get() {
          return a;
        },
        ...Ft
      },
      composedPath: {
        value: /* @__PURE__ */ pt(() => e, "value"),
        ...Ft
      },
      stopPropagation: {
        value: /* @__PURE__ */ pt(() => {
          s = !0, d.call(t);
        }, "value"),
        ...Ft
      },
      stopImmediatePropagation: {
        value: /* @__PURE__ */ pt(() => {
          r = !0, p.call(t);
        }, "value"),
        ...Ft
      }
    });
    const f = /* @__PURE__ */ pt((O, P, A) => {
      typeof O == "function" ? O(t) : typeof (O == null ? void 0 : O.handleEvent) == "function" && O.handleEvent(t), P.once && A.delete(O);
    }, "invokeEventListener"), m = /* @__PURE__ */ pt(() => (c = null, a = Ov, !t.defaultPrevented), "finishDispatch"), w = e.slice().reverse();
    o = !this.__host || !t.composed ? this : null;
    const b = /* @__PURE__ */ pt((O) => {
      for (l = this; l.__host && O.includes(l.__host); )
        l = l.__host;
    }, "retarget");
    for (const O of w) {
      !o && (!l || l === O.__host) && b(w.slice(w.indexOf(O))), c = O, a = O === t.target ? $v : Yx;
      const P = O.__captureEventListeners.get(t.type);
      if (P) {
        for (const [A, R] of P)
          if (f(A, R, P), r)
            return m();
      }
      if (s)
        return m();
    }
    const x = t.bubbles ? e : [this];
    l = null;
    for (const O of x) {
      !o && (!l || O === l.__host) && b(x.slice(0, x.indexOf(O) + 1)), c = O, a = O === t.target ? $v : Gx;
      const P = O.__eventListeners.get(t.type);
      if (P) {
        for (const [A, R] of P)
          if (f(A, R, P), r)
            return m();
      }
      if (s)
        return m();
    }
    return m();
  }
}, h(Hd, "j"), Hd), pt(qb, "EventTarget"), qb), Yj = Hj, Ft = { __proto__: null };
Ft.enumerable = !0;
Object.freeze(Ft);
var Vb, Yd;
const MS = (sr = (Vb = (Yd = class {
  constructor(t, e = {}) {
    if (Kl.set(this, !1), Ig.set(this, !1), Zg.set(this, !1), Dy.set(this, !1), Db.set(this, Date.now()), qy.set(this, !1), Wg.set(this, void 0), xa.set(this, void 0), Vy.set(this, void 0), this.NONE = Ov, this.CAPTURING_PHASE = Yx, this.AT_TARGET = $v, this.BUBBLING_PHASE = Gx, arguments.length === 0)
      throw new Error("The type argument must be specified");
    if (typeof e != "object" || !e)
      throw new Error('The "options" argument must be an object');
    const { bubbles: i, cancelable: s, composed: r } = e;
    Vn(this, Kl, !!s), Vn(this, Ig, !!i), Vn(this, Zg, !!r), Vn(this, Wg, `${t}`), Vn(this, xa, null), Vn(this, Vy, !1);
  }
  initEvent(t, e, i) {
    throw new Error("Method not implemented.");
  }
  stopImmediatePropagation() {
    this.stopPropagation();
  }
  preventDefault() {
    Vn(this, Dy, !0);
  }
  get target() {
    return Xe(this, xa, "f");
  }
  get currentTarget() {
    return Xe(this, xa, "f");
  }
  get srcElement() {
    return Xe(this, xa, "f");
  }
  get type() {
    return Xe(this, Wg, "f");
  }
  get cancelable() {
    return Xe(this, Kl, "f");
  }
  get defaultPrevented() {
    return Xe(this, Kl, "f") && Xe(this, Dy, "f");
  }
  get timeStamp() {
    return Xe(this, Db, "f");
  }
  composedPath() {
    return Xe(this, Vy, "f") ? [Xe(this, xa, "f")] : [];
  }
  get returnValue() {
    return !Xe(this, Kl, "f") || !Xe(this, Dy, "f");
  }
  get bubbles() {
    return Xe(this, Ig, "f");
  }
  get composed() {
    return Xe(this, Zg, "f");
  }
  get eventPhase() {
    return Xe(this, Vy, "f") ? sr.AT_TARGET : sr.NONE;
  }
  get cancelBubble() {
    return Xe(this, qy, "f");
  }
  set cancelBubble(t) {
    t && Vn(this, qy, !0);
  }
  stopPropagation() {
    Vn(this, qy, !0);
  }
  get isTrusted() {
    return !1;
  }
}, h(Yd, "D"), Yd), pt(Vb, "Event"), Vb), Kl = /* @__PURE__ */ new WeakMap(), Ig = /* @__PURE__ */ new WeakMap(), Zg = /* @__PURE__ */ new WeakMap(), Dy = /* @__PURE__ */ new WeakMap(), Db = /* @__PURE__ */ new WeakMap(), qy = /* @__PURE__ */ new WeakMap(), Wg = /* @__PURE__ */ new WeakMap(), xa = /* @__PURE__ */ new WeakMap(), Vy = /* @__PURE__ */ new WeakMap(), sr.NONE = Ov, sr.CAPTURING_PHASE = Yx, sr.AT_TARGET = $v, sr.BUBBLING_PHASE = Gx, sr);
Object.defineProperties(MS.prototype, {
  initEvent: Ft,
  stopImmediatePropagation: Ft,
  preventDefault: Ft,
  target: Ft,
  currentTarget: Ft,
  srcElement: Ft,
  type: Ft,
  cancelable: Ft,
  defaultPrevented: Ft,
  timeStamp: Ft,
  composedPath: Ft,
  returnValue: Ft,
  bubbles: Ft,
  composed: Ft,
  eventPhase: Ft,
  cancelBubble: Ft,
  stopPropagation: Ft,
  isTrusted: Ft
});
var jb, Gd;
const hR = (X4 = (jb = (Gd = class extends MS {
  constructor(t, e = {}) {
    super(t, e), Dg.set(this, void 0), Vn(this, Dg, (e == null ? void 0 : e.detail) ?? null);
  }
  initCustomEvent(t, e, i, s) {
    throw new Error("Method not implemented.");
  }
  get detail() {
    return Xe(this, Dg, "f");
  }
}, h(Gd, "B"), Gd), pt(jb, "CustomEvent"), jb), Dg = /* @__PURE__ */ new WeakMap(), X4);
Object.defineProperties(hR.prototype, {
  detail: Ft
});
const Gj = MS, Kj = hR;
globalThis.Event ?? (globalThis.Event = Gj);
globalThis.CustomEvent ?? (globalThis.CustomEvent = Kj);
const H4 = /* @__PURE__ */ new WeakMap(), jy = /* @__PURE__ */ pt((n) => {
  let t = H4.get(n);
  return t === void 0 && H4.set(n, t = /* @__PURE__ */ new Map()), t;
}, "attributesForElement");
var Fb, Kd;
const Jj = (Fb = (Kd = class extends Yj {
  constructor() {
    super(...arguments), this.__shadowRootMode = null, this.__shadowRoot = null, this.__internals = null;
  }
  get attributes() {
    return Array.from(jy(this)).map(([t, e]) => ({
      name: t,
      value: e
    }));
  }
  get shadowRoot() {
    return this.__shadowRootMode === "closed" ? null : this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    var t;
    return (t = this.localName) == null ? void 0 : t.toUpperCase();
  }
  setAttribute(t, e) {
    jy(this).set(t, String(e));
  }
  removeAttribute(t) {
    jy(this).delete(t);
  }
  toggleAttribute(t, e) {
    if (this.hasAttribute(t)) {
      if (e === void 0 || !e)
        return this.removeAttribute(t), !1;
    } else
      return e === void 0 || e ? (this.setAttribute(t, ""), !0) : !1;
    return !0;
  }
  hasAttribute(t) {
    return jy(this).has(t);
  }
  attachShadow(t) {
    const e = { host: this };
    return this.__shadowRootMode = t.mode, t && t.mode === "open" && (this.__shadowRoot = e), e;
  }
  attachInternals() {
    if (this.__internals !== null)
      throw new Error("Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.");
    const t = new Nj(this);
    return this.__internals = t, t;
  }
  getAttribute(t) {
    return jy(this).get(t) ?? null;
  }
}, h(Kd, "W$1"), Kd), pt(Fb, "Element"), Fb);
var Ub, Jd;
const tF = (Ub = (Jd = class extends Jj {
}, h(Jd, "V"), Jd), pt(Ub, "HTMLElement"), Ub), dR = tF;
globalThis.litServerRoot ?? (globalThis.litServerRoot = Object.defineProperty(new dR(), "localName", {
  // Patch localName (and tagName) to return a unique name.
  get() {
    return "lit-server-root";
  }
}));
var Bb, tu;
const eF = (Bb = (tu = class {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map();
  }
  define(t, e) {
    if (this.__definitions.has(t))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${t}" has already been used with this registry`);
    e.__localName = t, this.__definitions.set(t, {
      ctor: e,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: e.observedAttributes ?? []
    });
  }
  get(t) {
    const e = this.__definitions.get(t);
    return e == null ? void 0 : e.ctor;
  }
}, h(tu, "z"), tu), pt(Bb, "CustomElementRegistry"), Bb), iF = eF, nF = new iF(), nw = globalThis, M0 = nw.ShadowRoot && (nw.ShadyCSS === void 0 || nw.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, TS = Symbol(), Y4 = /* @__PURE__ */ new WeakMap();
var Xb, eu;
let uR = (Xb = (eu = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== TS) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (M0 && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = Y4.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && Y4.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}, h(eu, "F"), eu), pt(Xb, "n"), Xb);
const pR = /* @__PURE__ */ pt((n) => new uR(typeof n == "string" ? n : n + "", void 0, TS), "r$2"), Mt = /* @__PURE__ */ pt((n, ...t) => {
  const e = n.length === 1 ? n[0] : t.reduce((i, s, r) => i + ((a) => {
    if (a._$cssResult$ === !0) return a.cssText;
    if (typeof a == "number") return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + n[r + 1], n[0]);
  return new uR(e, n, TS);
}, "i$2"), fR = /* @__PURE__ */ pt((n, t) => {
  if (M0) n.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of t) {
    const i = document.createElement("style"), s = nw.litNonce;
    s !== void 0 && i.setAttribute("nonce", s), i.textContent = e.cssText, n.appendChild(i);
  }
}, "S$1"), G4 = M0 || nw.CSSStyleSheet === void 0 ? (n) => n : (n) => n instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return pR(e);
})(n) : n, { is: sF, defineProperty: rF, getOwnPropertyDescriptor: aF, getOwnPropertyNames: oF, getOwnPropertySymbols: lF, getPrototypeOf: cF } = Object, Kr = globalThis;
Kr.customElements ?? (Kr.customElements = nF);
const K4 = Kr.trustedTypes, hF = K4 ? K4.emptyScript : "", J4 = Kr.reactiveElementPolyfillSupport, sw = /* @__PURE__ */ pt((n, t) => n, "f$1"), xv = { toAttribute(n, t) {
  switch (t) {
    case Boolean:
      n = n ? hF : null;
      break;
    case Object:
    case Array:
      n = n == null ? n : JSON.stringify(n);
  }
  return n;
}, fromAttribute(n, t) {
  let e = n;
  switch (t) {
    case Boolean:
      e = n !== null;
      break;
    case Number:
      e = n === null ? null : Number(n);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(n);
      } catch {
        e = null;
      }
  }
  return e;
} }, AS = /* @__PURE__ */ pt((n, t) => !sF(n, t), "m$1"), t3 = { attribute: !0, type: String, converter: xv, reflect: !1, useDefault: !1, hasChanged: AS };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Kr.litPropertyMetadata ?? (Kr.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Nb, iu;
let uc = (Nb = (iu = class extends (globalThis.HTMLElement ?? dR) {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = t3) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), s = this.getPropertyDescriptor(t, i, e);
      s !== void 0 && rF(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: s, set: r } = aF(this.prototype, t) ?? { get() {
      return this[e];
    }, set(a) {
      this[e] = a;
    } };
    return { get: s, set(a) {
      const o = s == null ? void 0 : s.call(this);
      r == null || r.call(this, a), this.requestUpdate(t, o, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? t3;
  }
  static _$Ei() {
    if (this.hasOwnProperty(sw("elementProperties"))) return;
    const t = cF(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(sw("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(sw("properties"))) {
      const e = this.properties, i = [...oF(e), ...lF(e)];
      for (const s of i) this.createProperty(s, e[s]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, s] of e) this.elementProperties.set(i, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const s = this._$Eu(e, i);
      s !== void 0 && this._$Eh.set(s, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const s of i) e.unshift(G4(s));
    } else t !== void 0 && e.push(G4(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return fR(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) == null ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) == null ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    var i;
    const s = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, s);
    if (r !== void 0 && s.reflect === !0) {
      const a = (((i = s.converter) == null ? void 0 : i.toAttribute) !== void 0 ? s.converter : xv).toAttribute(e, s.type);
      this._$Em = t, a == null ? this.removeAttribute(r) : this.setAttribute(r, a), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var i, s;
    const r = this.constructor, a = r._$Eh.get(t);
    if (a !== void 0 && this._$Em !== a) {
      const o = r.getPropertyOptions(a), l = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((i = o.converter) == null ? void 0 : i.fromAttribute) !== void 0 ? o.converter : xv;
      this._$Em = a, this[a] = l.fromAttribute(e, o.type) ?? ((s = this._$Ej) == null ? void 0 : s.get(a)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    var s;
    if (t !== void 0) {
      const r = this.constructor, a = this[t];
      if (i ?? (i = r.getPropertyOptions(t)), !((i.hasChanged ?? AS)(a, e) || i.useDefault && i.reflect && a === ((s = this._$Ej) == null ? void 0 : s.get(t)) && !this.hasAttribute(r._$Eu(t, i)))) return;
      this.C(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: s, wrapped: r }, a) {
    i && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t) && (this._$Ej.set(t, a ?? e ?? this[t]), r !== !0 || a !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), s === !0 && this._$Em !== t && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, a] of this._$Ep) this[r] = a;
        this._$Ep = void 0;
      }
      const s = this.constructor.elementProperties;
      if (s.size > 0) for (const [r, a] of s) {
        const { wrapped: o } = a, l = this[r];
        o !== !0 || this._$AL.has(r) || l === void 0 || this.C(r, void 0, a, l);
      }
    }
    let e = !1;
    const i = this._$AL;
    try {
      e = this.shouldUpdate(i), e ? (this.willUpdate(i), (t = this._$EO) == null || t.forEach((s) => {
        var r;
        return (r = s.hostUpdate) == null ? void 0 : r.call(s);
      }), this.update(i)) : this._$EM();
    } catch (s) {
      throw e = !1, this._$EM(), s;
    }
    e && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((i) => {
      var s;
      return (s = i.hostUpdated) == null ? void 0 : s.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}, h(iu, "G$1"), iu), pt(Nb, "g"), Nb);
uc.elementStyles = [], uc.shadowRootOptions = { mode: "open" }, uc[sw("elementProperties")] = /* @__PURE__ */ new Map(), uc[sw("finalized")] = /* @__PURE__ */ new Map(), J4 == null || J4({ ReactiveElement: uc }), (Kr.reactiveElementVersions ?? (Kr.reactiveElementVersions = [])).push("2.1.0");
const kw = globalThis, kv = kw.trustedTypes, e3 = kv ? kv.createPolicy("lit-html", { createHTML: /* @__PURE__ */ pt((n) => n, "createHTML") }) : void 0, yR = "$lit$", gr = `lit$${Math.random().toFixed(9).slice(2)}$`, mR = "?" + gr, dF = `<${mR}>`, qo = kw.document === void 0 ? { createTreeWalker: /* @__PURE__ */ pt(() => ({}), "createTreeWalker") } : document, Sw = /* @__PURE__ */ pt(() => qo.createComment(""), "l"), Pw = /* @__PURE__ */ pt((n) => n === null || typeof n != "object" && typeof n != "function", "c"), RS = Array.isArray, uF = /* @__PURE__ */ pt((n) => RS(n) || typeof (n == null ? void 0 : n[Symbol.iterator]) == "function", "u"), Hb = `[ 	
\f\r]`, Fy = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, i3 = /-->/g, n3 = />/g, ka = RegExp(`>|${Hb}(?:([^\\s"'>=/]+)(${Hb}*=${Hb}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), s3 = /'/g, r3 = /"/g, wR = /^(?:script|style|textarea|title)$/i, gR = /* @__PURE__ */ pt((n) => (t, ...e) => ({ _$litType$: n, strings: t, values: e }), "y"), v = gR(1), a3 = gR(2), Pn = Symbol.for("lit-noChange"), Q = Symbol.for("lit-nothing"), o3 = /* @__PURE__ */ new WeakMap(), Fa = qo.createTreeWalker(qo, 129);
function ES(n, t) {
  if (!RS(n) || !n.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return e3 !== void 0 ? e3.createHTML(t) : t;
}
h(ES, "Rt");
pt(ES, "P");
const pF = /* @__PURE__ */ pt((n, t) => {
  const e = n.length - 1, i = [];
  let s, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = Fy;
  for (let o = 0; o < e; o++) {
    const l = n[o];
    let c, d, p = -1, f = 0;
    for (; f < l.length && (a.lastIndex = f, d = a.exec(l), d !== null); ) f = a.lastIndex, a === Fy ? d[1] === "!--" ? a = i3 : d[1] !== void 0 ? a = n3 : d[2] !== void 0 ? (wR.test(d[2]) && (s = RegExp("</" + d[2], "g")), a = ka) : d[3] !== void 0 && (a = ka) : a === ka ? d[0] === ">" ? (a = s ?? Fy, p = -1) : d[1] === void 0 ? p = -2 : (p = a.lastIndex - d[2].length, c = d[1], a = d[3] === void 0 ? ka : d[3] === '"' ? r3 : s3) : a === r3 || a === s3 ? a = ka : a === i3 || a === n3 ? a = Fy : (a = ka, s = void 0);
    const m = a === ka && n[o + 1].startsWith("/>") ? " " : "";
    r += a === Fy ? l + dF : p >= 0 ? (i.push(c), l.slice(0, p) + yR + l.slice(p) + gr + m) : l + gr + (p === -2 ? o : m);
  }
  return [ES(n, r + (n[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
}, "V");
var Mo;
const vR = (Mo = class {
  constructor({ strings: t, _$litType$: e }, i) {
    let s;
    this.parts = [];
    let r = 0, a = 0;
    const o = t.length - 1, l = this.parts, [c, d] = pF(t, e);
    if (this.el = Mo.createElement(c, i), Fa.currentNode = this.el.content, e === 2 || e === 3) {
      const p = this.el.content.firstChild;
      p.replaceWith(...p.childNodes);
    }
    for (; (s = Fa.nextNode()) !== null && l.length < o; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes()) for (const p of s.getAttributeNames()) if (p.endsWith(yR)) {
          const f = d[a++], m = s.getAttribute(p).split(gr), w = /([.?@])?(.*)/.exec(f);
          l.push({ type: 1, index: r, name: w[2], strings: m, ctor: w[1] === "." ? yF : w[1] === "?" ? mF : w[1] === "@" ? wF : A0 }), s.removeAttribute(p);
        } else p.startsWith(gr) && (l.push({ type: 6, index: r }), s.removeAttribute(p));
        if (wR.test(s.tagName)) {
          const p = s.textContent.split(gr), f = p.length - 1;
          if (f > 0) {
            s.textContent = kv ? kv.emptyScript : "";
            for (let m = 0; m < f; m++) s.append(p[m], Sw()), Fa.nextNode(), l.push({ type: 2, index: ++r });
            s.append(p[f], Sw());
          }
        }
      } else if (s.nodeType === 8) if (s.data === mR) l.push({ type: 2, index: r });
      else {
        let p = -1;
        for (; (p = s.data.indexOf(gr, p + 1)) !== -1; ) l.push({ type: 7, index: r }), p += gr.length - 1;
      }
      r++;
    }
  }
  static createElement(t, e) {
    const i = qo.createElement("template");
    return i.innerHTML = t, i;
  }
}, h(Mo, "_e"), Mo);
pt(vR, "N");
let Kx = vR;
function Vo(n, t, e = n, i) {
  var s, r;
  if (t === Pn) return t;
  let a = i !== void 0 ? (s = e._$Co) == null ? void 0 : s[i] : e._$Cl;
  const o = Pw(t) ? void 0 : t._$litDirective$;
  return (a == null ? void 0 : a.constructor) !== o && ((r = a == null ? void 0 : a._$AO) == null || r.call(a, !1), o === void 0 ? a = void 0 : (a = new o(n), a._$AT(n, e, i)), i !== void 0 ? (e._$Co ?? (e._$Co = []))[i] = a : e._$Cl = a), a !== void 0 && (t = Vo(n, a._$AS(n, t.values), a, i)), t;
}
h(Vo, "K");
pt(Vo, "S");
var nu;
const bR = (nu = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, s = ((t == null ? void 0 : t.creationScope) ?? qo).importNode(e, !0);
    Fa.currentNode = s;
    let r = Fa.nextNode(), a = 0, o = 0, l = i[0];
    for (; l !== void 0; ) {
      if (a === l.index) {
        let c;
        l.type === 2 ? c = new T0(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new gF(r, this, t)), this._$AV.push(c), l = i[++o];
      }
      a !== (l == null ? void 0 : l.index) && (r = Fa.nextNode(), a++);
    }
    return Fa.currentNode = qo, s;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, h(nu, "qe"), nu);
pt(bR, "M");
let fF = bR;
var To;
const OR = (To = class {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, i, s) {
    this.type = 2, this._$AH = Q, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Vo(this, t, e), Pw(t) ? t === Q || t == null || t === "" ? (this._$AH !== Q && this._$AR(), this._$AH = Q) : t !== this._$AH && t !== Pn && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : uF(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== Q && Pw(this._$AH) ? this._$AA.nextSibling.data = t : this.T(qo.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var e;
    const { values: i, _$litType$: s } = t, r = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Kx.createElement(ES(s.h, s.h[0]), this.options)), s);
    if (((e = this._$AH) == null ? void 0 : e._$AD) === r) this._$AH.p(i);
    else {
      const a = new fF(r, this), o = a.u(this.options);
      a.p(i), this.T(o), this._$AH = a;
    }
  }
  _$AC(t) {
    let e = o3.get(t.strings);
    return e === void 0 && o3.set(t.strings, e = new Kx(t)), e;
  }
  k(t) {
    RS(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, s = 0;
    for (const r of t) s === e.length ? e.push(i = new To(this.O(Sw()), this.O(Sw()), this, this.options)) : i = e[s], i._$AI(r), s++;
    s < e.length && (this._$AR(i && i._$AB.nextSibling, s), e.length = s);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const s = t.nextSibling;
      t.remove(), t = s;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
}, h(To, "ve"), To);
pt(OR, "k");
let T0 = OR;
var su;
const $R = (su = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, s, r) {
    this.type = 1, this._$AH = Q, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Q;
  }
  _$AI(t, e = this, i, s) {
    const r = this.strings;
    let a = !1;
    if (r === void 0) t = Vo(this, t, e, 0), a = !Pw(t) || t !== this._$AH && t !== Pn, a && (this._$AH = t);
    else {
      const o = t;
      let l, c;
      for (t = r[0], l = 0; l < r.length - 1; l++) c = Vo(this, o[i + l], e, l), c === Pn && (c = this._$AH[l]), a || (a = !Pw(c) || c !== this._$AH[l]), c === Q ? t = Q : t !== Q && (t += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    a && !s && this.j(t);
  }
  j(t) {
    t === Q ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, h(su, "Ke"), su);
pt($R, "R");
let A0 = $R;
var ru;
const xR = (ru = class extends A0 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === Q ? void 0 : t;
  }
}, h(ru, "Ze"), ru);
pt(xR, "H");
let yF = xR;
var au;
const kR = (au = class extends A0 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== Q);
  }
}, h(au, "Je"), au);
pt(kR, "I");
let mF = kR;
var ou;
const SR = (ou = class extends A0 {
  constructor(t, e, i, s, r) {
    super(t, e, i, s, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Vo(this, t, e, 0) ?? Q) === Pn) return;
    const i = this._$AH, s = t === Q && i !== Q || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, r = t !== Q && (i === Q || s);
    s && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, h(ou, "Xe"), ou);
pt(SR, "L");
let wF = SR;
var lu;
const PR = (lu = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Vo(this, t);
  }
}, h(lu, "Qe"), lu);
pt(PR, "z");
let gF = PR;
const vF = { I: T0 }, l3 = kw.litHtmlPolyfillSupport;
l3 == null || l3(Kx, T0), (kw.litHtmlVersions ?? (kw.litHtmlVersions = [])).push("3.3.0");
const bF = /* @__PURE__ */ pt((n, t, e) => {
  const i = (e == null ? void 0 : e.renderBefore) ?? t;
  let s = i._$litPart$;
  if (s === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    i._$litPart$ = s = new T0(t.insertBefore(Sw(), r), r, void 0, e ?? {});
  }
  return s._$AI(n), s;
}, "j"), Cw = globalThis;
var cu;
const CR = (cu = class extends uc {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = bF(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return Pn;
  }
}, h(cu, "Ye"), cu);
pt(CR, "i");
let ft = CR;
var c3;
ft._$litElement$ = !0, ft.finalized = !0, (c3 = Cw.litElementHydrateSupport) == null || c3.call(Cw, { LitElement: ft });
const h3 = Cw.litElementPolyfillSupport;
h3 == null || h3({ LitElement: ft });
(Cw.litElementVersions ?? (Cw.litElementVersions = [])).push("4.2.0");
v`<strong>${0}</strong> redigerade <em>${1}</em>`, v`<strong>${0}</strong> nämnde dig i ett inlägg`, v`<strong>${0}</strong> kommenterade på <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på <em>${2}</em>`, v`<strong>${0}</strong> svarade på ett inlägg`, v`<strong>${0}</strong> redigerade ett inlägg`, v`<strong>${0}</strong> nämnde dig i ett meddelande`, v`<strong>${0}</strong> nämnde dig i en kommentar`, v`<strong>${0}</strong> och <strong>${1}</strong> röstade i din omröstning`, v`<strong>${0}</strong> reagerade med ${1} på ditt inlägg`, v`<strong>${0}</strong> reagerade med ${1} på din kommentar`, v`Nytt meddelande från <strong>${0}</strong>`, v`<strong>${0}</strong> svarade på ditt inlägg`, v`<strong>${0}</strong> röstade i din omröstning`, v`<strong>${0}</strong> publicerade ett inlägg i <strong>${1}</strong>`, v`<strong>${0}</strong> gillade ditt meddelande`, v`<strong>${0}</strong>, <strong>${1}</strong> och <strong>${2}</strong> röstade i din omröstning`, v`<strong>${0}</strong> lade till <em>${1}</em> till <strong>${2}</strong>`, v`<strong>${0}</strong> skickade ett meddelande i <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på ditt meddelande`, v`<strong>${0}</strong> gillade <em>${1}</em>`, v`<strong>${0}</strong> gillade ditt inlägg`, v`<strong>${0}</strong> gillade din kommentar`, v`<strong>${0}</strong> och ${1} andra röstade i din omröstning`, v`<strong>${0}</strong> kommenterade på <em>${1}</em>`, at`${0} svarade på ditt inlägg`, at`${0} röstade i din omröstning`, at`Öppna i ${0}?`, at`${0} skriver${1}`, at`${0} och ${1} röstade i din omröstning`, at`${0} kommenterade på ${1}`, at`${0} gillade ${1}`, at`${0} skickade ett meddelande i ${1}`, at`${0} redigerade ett inlägg`, at`Röster på ${0}`, at`${0} kommentarer`, at`Sedd av ${0} vid ${1}`, at`${0} och ${1} andra röstade i din omröstning`, at`Nytt meddelande från ${0}`, at`${0} reagerade med ${1} på ditt inlägg`, at`${0} nämnde dig i ett inlägg`, at`${0} nämnde dig i en kommentar`, at`${0} publicerade ett inlägg i ${1}`, at`${0} gillade ditt inlägg`, at`${0} nämnde dig i ett meddelande`, at`${0} reagerade med ${1} på din kommentar`, at` Öppna i ${0}
        `, at`${0} svarade på ett inlägg`, at`${0} lade till ${1} till ${2}`, at`${0} redigerade ${1}`, at`${0} gillade ditt meddelande`, at`${0}, ${1} och ${2} röstade i din omröstning`, at`${0} reagerade med ${1} på ${2}`, at`${0} reagerade med ${1} på ditt meddelande`, at`${0} gillade din kommentar`, at`${0} skriver${1}`;
var OF = Object.defineProperty, QR = /* @__PURE__ */ h((n) => {
  throw TypeError(n);
}, "Xp"), u = /* @__PURE__ */ h((n, t) => OF(n, "name", { value: t, configurable: !0 }), "o$1"), zS = /* @__PURE__ */ h((n, t, e) => t.has(n) || QR("Cannot " + e), "Ch"), k = /* @__PURE__ */ h((n, t, e) => (zS(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "f"), F = /* @__PURE__ */ h((n, t, e) => t.has(n) ? QR("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "T"), L = /* @__PURE__ */ h((n, t, e, i) => (zS(n, t, "write to private field"), t.set(n, e), e), "A"), mt = /* @__PURE__ */ h((n, t, e) => (zS(n, t, "access private method"), e), "it"), Jx = /* @__PURE__ */ h((n, t, e, i) => ({
  set _(s) {
    L(n, t, s);
  },
  get _() {
    return k(n, t, i);
  }
}), "kl");
function Qw(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
h(Qw, "Tl");
u(Qw, "isObject");
function jo(n) {
  if (Qw(n) === !1) return !1;
  const t = n.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(Qw(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
h(jo, "Lo");
u(jo, "isPlainObject$1");
function Sv(n) {
  return typeof n.toJSON == "function";
}
h(Sv, "Vh");
u(Sv, "hasToJSON");
function MR(n) {
  return typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n === null || jo(n) || Array.isArray(n);
}
h(MR, "Zm");
u(MR, "isJSONSerializable");
function rw(n, t, e = !1) {
  n = n || {}, t = t || {};
  const i = {};
  for (const s in n)
    Object.prototype.hasOwnProperty.call(n, s) && (i[s] = n[s]);
  for (const s in t)
    Object.prototype.hasOwnProperty.call(t, s) && (e && i[s] && jo(i[s]) && jo(t[s]) ? i[s] = rw(i[s], t[s], e) : i[s] = t[s]);
  return i;
}
h(rw, "Sl");
u(rw, "assign");
function TR(n) {
  return n && (Array.isArray(n) ? n : [n]) || [];
}
h(TR, "Ym");
u(TR, "asArray");
async function AR(n, t) {
  for (const e of n)
    if (await t(e))
      return e;
}
h(AR, "Xm");
u(AR, "findAsyncSequential");
function Vc(n, t, e = !1, i = !1) {
  if (!i && (!jo(n) || !jo(t)) || i && (!Qw(n) || !Qw(t)))
    return !1;
  const s = Object.getOwnPropertyNames(n), r = Object.getOwnPropertyNames(t);
  if (!e && s.length !== r.length)
    return !1;
  for (let a = 0; a < s.length; a++) {
    const o = s[a], l = n[o], c = t[o];
    if (l !== c && !Vc(l, c, e))
      return !1;
  }
  return !0;
}
h(Vc, "yc");
u(Vc, "eqObjects");
function _S(n) {
  return Object.entries(n);
}
h(_S, "pw");
u(_S, "objectAsIterable");
function R0(n) {
  return n.charAt(0).toUpperCase() + n.substring(1).toLowerCase();
}
h(R0, "Hu");
u(R0, "toUpperCaseFirst");
const $F = '\\s,.:;"', xF = new RegExp(`^|[${$F}]|$`, "g"), kF = ".!?", SF = new RegExp(`^|(?<=[${kF}])|$`);
function LS(n) {
  return n.length > 0 ? n.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : n;
}
h(LS, "yw");
u(LS, "toKebabCase");
function RR(n, t = 2) {
  if (!n)
    return null;
  let e = "";
  const i = n.split(xF).filter((s) => s);
  return i.length == 1 ? e = i[0] : i.forEach((s) => {
    e += s.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
h(RR, "sv");
u(RR, "getInitials");
function IS(n) {
  let t;
  const e = n.split(SF).filter((i) => i);
  return e.length ? t = e[0] : t = n, t;
}
h(IS, "ww");
u(IS, "getTitleFromText");
function ZS(n, t = 256) {
  return n.length > t && (n = n.substring(0, t - 1) + "…"), n;
}
h(ZS, "fw");
u(ZS, "truncateText");
const PF = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function ER() {
  const n = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ u(function(e, i) {
    if (Sv(i) && (i = i.toJSON()), !(i !== null && typeof i == "object"))
      return i;
    if (n.has(i))
      return "[Circular]";
    let s;
    if (n.add(i), jo(i)) {
      const r = {};
      Object.keys(i).forEach((a) => {
        r[a] = t(a, i[a]);
      }), s = r;
    } else Array.isArray(i) && (s = i.map((r, a) => t(a, r)));
    return n.delete(i), s;
  }, "replacer");
  return t;
}
h(ER, "nv");
u(ER, "getCircularReferenceReplacer");
function Kf() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
h(Kf, "bc");
u(Kf, "S4");
function zR(n) {
  if (n && n.ok && n.body) {
    const t = n.body.getReader();
    return new ReadableStream({
      start(e) {
        const i = /* @__PURE__ */ u(() => t.read().then(({ done: s, value: r }) => {
          if (s) {
            e.close();
            return;
          }
          return e.enqueue(r), i();
        }), "pump");
        return i();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
h(zR, "av");
u(zR, "getTextStreamFromResponse");
function WS(n) {
  let t;
  try {
    if (t = window[n], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", n);
  }
  return t;
}
h(WS, "mw");
u(WS, "getStorage");
var hu;
const _R = (hu = class extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
}, h(hu, "xp"), hu);
u(_R, "DestroyError");
let Se = _R;
var Yb, du, $y = (Yb = (du = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, h(du, "Kr"), du), u(Yb, "Subscribable"), Yb), Jf = typeof window > "u" || "Deno" in globalThis;
function fi() {
}
h(fi, "Oe");
u(fi, "noop$1");
function LR(n, t) {
  return typeof n == "function" ? n(t) : n;
}
h(LR, "ov");
u(LR, "functionalUpdate");
function Pv(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
h(Pv, "Bh");
u(Pv, "isValidTimeout");
function DS(n, t) {
  return Math.max(n + (t || 0) - Date.now(), 0);
}
h(DS, "vw");
u(DS, "timeUntilStale");
function Ws(n, t) {
  return typeof n == "function" ? n(t) : n;
}
h(Ws, "xs");
u(Ws, "resolveStaleTime");
function Ki(n, t) {
  return typeof n == "function" ? n(t) : n;
}
h(Ki, "ai");
u(Ki, "resolveEnabled");
function tk(n, t) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: s,
    predicate: r,
    queryKey: a,
    stale: o
  } = n;
  if (a) {
    if (i) {
      if (t.queryHash !== E0(a, t.options))
        return !1;
    } else if (!ty(t.queryKey, a))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof o == "boolean" && t.isStale() !== o || s && s !== t.state.fetchStatus || r && !r(t));
}
h(tk, "ey");
u(tk, "matchQuery");
function ek(n, t) {
  const { exact: e, status: i, predicate: s, mutationKey: r } = n;
  if (r) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (Jr(t.options.mutationKey) !== Jr(r))
        return !1;
    } else if (!ty(t.options.mutationKey, r))
      return !1;
  }
  return !(i && t.state.status !== i || s && !s(t));
}
h(ek, "iy");
u(ek, "matchMutation");
function E0(n, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Jr)(n);
}
h(E0, "Vu");
u(E0, "hashQueryKeyByOptions");
function Jr(n) {
  return JSON.stringify(
    n,
    (t, e) => Cv(e) ? Object.keys(e).sort().reduce((i, s) => (i[s] = e[s], i), {}) : e
  );
}
h(Jr, "ar");
u(Jr, "hashKey");
function ty(n, t) {
  return n === t ? !0 : typeof n != typeof t ? !1 : n && t && typeof n == "object" && typeof t == "object" ? Object.keys(t).every((e) => ty(n[e], t[e])) : !1;
}
h(ty, "xc");
u(ty, "partialMatchKey");
function xy(n, t) {
  if (n === t)
    return n;
  const e = ik(n) && ik(t);
  if (e || Cv(n) && Cv(t)) {
    const i = e ? n : Object.keys(n), s = i.length, r = e ? t : Object.keys(t), a = r.length, o = e ? [] : {}, l = new Set(i);
    let c = 0;
    for (let d = 0; d < a; d++) {
      const p = e ? d : r[d];
      (!e && l.has(p) || e) && n[p] === void 0 && t[p] === void 0 ? (o[p] = void 0, c++) : (o[p] = xy(n[p], t[p]), o[p] === n[p] && n[p] !== void 0 && c++);
    }
    return s === a && c === s ? n : o;
  }
  return t;
}
h(xy, "cl");
u(xy, "replaceEqualDeep");
function Mw(n, t) {
  if (!t || Object.keys(n).length !== Object.keys(t).length)
    return !1;
  for (const e in n)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
h(Mw, "Fl");
u(Mw, "shallowEqualObjects");
function ik(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
h(ik, "sy");
u(ik, "isPlainArray");
function Cv(n) {
  if (!nk(n))
    return !1;
  const t = n.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!nk(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(n) !== Object.prototype);
}
h(Cv, "Uh");
u(Cv, "isPlainObject");
function nk(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
h(nk, "ry");
u(nk, "hasObjectPrototype");
function IR(n) {
  return new Promise((t) => {
    setTimeout(t, n);
  });
}
h(IR, "cv");
u(IR, "sleep");
function Qv(n, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(n, t) : e.structuralSharing !== !1 ? xy(n, t) : t;
}
h(Qv, "qh");
u(Qv, "replaceData");
function ZR(n, t, e = 0) {
  const i = [...n, t];
  return e && i.length > e ? i.slice(1) : i;
}
h(ZR, "lv");
u(ZR, "addToEnd");
function WR(n, t, e = 0) {
  const i = [t, ...n];
  return e && i.length > e ? i.slice(0, -1) : i;
}
h(WR, "dv");
u(WR, "addToStart");
var qS = Symbol();
function VS(n, t) {
  return !n.queryFn && t != null && t.initialPromise ? () => t.initialPromise : !n.queryFn || n.queryFn === qS ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`)) : n.queryFn;
}
h(VS, "gw");
u(VS, "ensureQueryFn");
var Jl, Sa, Uy, Gb, uu, CF = (Gb = (uu = class extends $y {
  constructor() {
    super(), F(this, Jl), F(this, Sa), F(this, Uy), L(this, Uy, (t) => {
      if (!Jf && window.addEventListener) {
        const e = /* @__PURE__ */ u(() => t(), "listener");
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    });
  }
  onSubscribe() {
    k(this, Sa) || this.setEventListener(k(this, Uy));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = k(this, Sa)) == null || t.call(this), L(this, Sa, void 0));
  }
  setEventListener(t) {
    var e;
    L(this, Uy, t), (e = k(this, Sa)) == null || e.call(this), L(this, Sa, t((i) => {
      typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
    }));
  }
  setFocused(t) {
    k(this, Jl) !== t && (L(this, Jl, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    var t;
    return typeof k(this, Jl) == "boolean" ? k(this, Jl) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden";
  }
}, h(uu, "Zr"), uu), Jl = /* @__PURE__ */ new WeakMap(), Sa = /* @__PURE__ */ new WeakMap(), Uy = /* @__PURE__ */ new WeakMap(), u(Gb, "FocusManager"), Gb), jS = new CF(), By, Pa, Xy, Kb, pu, QF = (Kb = (pu = class extends $y {
  constructor() {
    super(), F(this, By, !0), F(this, Pa), F(this, Xy), L(this, Xy, (t) => {
      if (!Jf && window.addEventListener) {
        const e = /* @__PURE__ */ u(() => t(!0), "onlineListener"), i = /* @__PURE__ */ u(() => t(!1), "offlineListener");
        return window.addEventListener("online", e, !1), window.addEventListener("offline", i, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", i);
        };
      }
    });
  }
  onSubscribe() {
    k(this, Pa) || this.setEventListener(k(this, Xy));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = k(this, Pa)) == null || t.call(this), L(this, Pa, void 0));
  }
  setEventListener(t) {
    var e;
    L(this, Xy, t), (e = k(this, Pa)) == null || e.call(this), L(this, Pa, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    k(this, By) !== t && (L(this, By, t), this.listeners.forEach((e) => {
      e(t);
    }));
  }
  isOnline() {
    return k(this, By);
  }
}, h(pu, "Jr"), pu), By = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), Xy = /* @__PURE__ */ new WeakMap(), u(Kb, "OnlineManager"), Kb), Mv = new QF();
function Tv() {
  let n, t;
  const e = new Promise((s, r) => {
    n = s, t = r;
  });
  e.status = "pending", e.catch(() => {
  });
  function i(s) {
    Object.assign(e, s), delete e.resolve, delete e.reject;
  }
  return h(i, "i"), u(i, "finalize"), e.resolve = (s) => {
    i({
      status: "fulfilled",
      value: s
    }), n(s);
  }, e.reject = (s) => {
    i({
      status: "rejected",
      reason: s
    }), t(s);
  }, e;
}
h(Tv, "Nh");
u(Tv, "pendingThenable");
function DR(n) {
  var t;
  let e;
  if ((t = n.then((i) => (e = i, i), fi)) == null || t.catch(fi), e !== void 0)
    return { data: e };
}
h(DR, "pv");
u(DR, "tryResolveSync");
function qR(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
h(qR, "yv");
u(qR, "defaultRetryDelay");
function FS(n) {
  return (n ?? "online") === "online" ? Mv.isOnline() : !0;
}
h(FS, "bw");
u(FS, "canFetch");
var Jb, fu, VR = (Jb = (fu = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
}, h(fu, "tn"), fu), u(Jb, "CancelledError"), Jb);
function m1(n) {
  return n instanceof VR;
}
h(m1, "kh");
u(m1, "isCancelledError");
function US(n) {
  let t = !1, e = 0, i = !1, s;
  const r = Tv(), a = /* @__PURE__ */ u((b) => {
    var x;
    i || (f(new VR(b)), (x = n.abort) == null || x.call(n));
  }, "cancel"), o = /* @__PURE__ */ u(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ u(() => {
    t = !1;
  }, "continueRetry"), c = /* @__PURE__ */ u(() => jS.isFocused() && (n.networkMode === "always" || Mv.isOnline()) && n.canRun(), "canContinue"), d = /* @__PURE__ */ u(() => FS(n.networkMode) && n.canRun(), "canStart"), p = /* @__PURE__ */ u((b) => {
    var x;
    i || (i = !0, (x = n.onSuccess) == null || x.call(n, b), s == null || s(), r.resolve(b));
  }, "resolve"), f = /* @__PURE__ */ u((b) => {
    var x;
    i || (i = !0, (x = n.onError) == null || x.call(n, b), s == null || s(), r.reject(b));
  }, "reject"), m = /* @__PURE__ */ u(() => new Promise((b) => {
    var x;
    s = /* @__PURE__ */ u((O) => {
      (i || c()) && b(O);
    }, "continueFn"), (x = n.onPause) == null || x.call(n);
  }).then(() => {
    var b;
    s = void 0, i || (b = n.onContinue) == null || b.call(n);
  }), "pause"), w = /* @__PURE__ */ u(() => {
    if (i)
      return;
    let b;
    const x = e === 0 ? n.initialPromise : void 0;
    try {
      b = x ?? n.fn();
    } catch (O) {
      b = Promise.reject(O);
    }
    Promise.resolve(b).then(p).catch((O) => {
      var P;
      if (i)
        return;
      const A = n.retry ?? (Jf ? 0 : 3), R = n.retryDelay ?? qR, T = typeof R == "function" ? R(e, O) : R, I = A === !0 || typeof A == "number" && e < A || typeof A == "function" && A(e, O);
      if (t || !I) {
        f(O);
        return;
      }
      e++, (P = n.onFail) == null || P.call(n, e, O), IR(T).then(() => c() ? void 0 : m()).then(() => {
        t ? f(O) : w();
      });
    });
  }, "run");
  return {
    promise: r,
    cancel: a,
    continue: /* @__PURE__ */ u(() => (s == null || s(), r), "continue"),
    cancelRetry: o,
    continueRetry: l,
    canStart: d,
    start: /* @__PURE__ */ u(() => (d() ? w() : m().then(w), r), "start")
  };
}
h(US, "$w");
u(US, "createRetryer");
var MF = /* @__PURE__ */ u((n) => setTimeout(n, 0), "defaultScheduler");
function jR() {
  let n = [], t = 0, e = /* @__PURE__ */ u((o) => {
    o();
  }, "notifyFn"), i = /* @__PURE__ */ u((o) => {
    o();
  }, "batchNotifyFn"), s = MF;
  const r = /* @__PURE__ */ u((o) => {
    t ? n.push(o) : s(() => {
      e(o);
    });
  }, "schedule"), a = /* @__PURE__ */ u(() => {
    const o = n;
    n = [], o.length && s(() => {
      i(() => {
        o.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ u((o) => {
      let l;
      t++;
      try {
        l = o();
      } finally {
        t--, t || a();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ u((o) => (...l) => {
      r(() => {
        o(...l);
      });
    }, "batchCalls"),
    schedule: r,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ u((o) => {
      e = o;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ u((o) => {
      i = o;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ u((o) => {
      s = o;
    }, "setScheduler")
  };
}
h(jR, "fv");
u(jR, "createNotifyManager");
var Je = jR(), tc, tO, yu, FR = (tO = (yu = class {
  constructor() {
    F(this, tc);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Pv(this.gcTime) && L(this, tc, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (Jf ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    k(this, tc) && (clearTimeout(k(this, tc)), L(this, tc, void 0));
  }
}, h(yu, "en"), yu), tc = /* @__PURE__ */ new WeakMap(), u(tO, "Removable"), tO), Ny, ec, fn, ic, ci, qg, nc, Zn, ws, eO, mu, TF = (eO = (mu = class extends FR {
  constructor(t) {
    super(), F(this, Zn), F(this, Ny), F(this, ec), F(this, fn), F(this, ic), F(this, ci), F(this, qg), F(this, nc), L(this, nc, !1), L(this, qg, t.defaultOptions), this.setOptions(t.options), this.observers = [], L(this, ic, t.client), L(this, fn, k(this, ic).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, L(this, Ny, UR(this.options)), this.state = t.state ?? k(this, Ny), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var t;
    return (t = k(this, ci)) == null ? void 0 : t.promise;
  }
  setOptions(t) {
    this.options = { ...k(this, qg), ...t }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && k(this, fn).remove(this);
  }
  setData(t, e) {
    const i = Qv(this.state.data, t, this.options);
    return mt(this, Zn, ws).call(this, {
      data: i,
      type: "success",
      dataUpdatedAt: e == null ? void 0 : e.updatedAt,
      manual: e == null ? void 0 : e.manual
    }), i;
  }
  setState(t, e) {
    mt(this, Zn, ws).call(this, { type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    var e, i;
    const s = (e = k(this, ci)) == null ? void 0 : e.promise;
    return (i = k(this, ci)) == null || i.cancel(t), s ? s.then(fi).catch(fi) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(k(this, Ny));
  }
  isActive() {
    return this.observers.some(
      (t) => Ki(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === qS || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => Ws(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !DS(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var t;
    const e = this.observers.find((i) => i.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (t = k(this, ci)) == null || t.continue();
  }
  onOnline() {
    var t;
    const e = this.observers.find((i) => i.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (t = k(this, ci)) == null || t.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), k(this, fn).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (k(this, ci) && (k(this, nc) ? k(this, ci).cancel({ revert: !0 }) : k(this, ci).cancelRetry()), this.scheduleGc()), k(this, fn).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || mt(this, Zn, ws).call(this, { type: "invalidate" });
  }
  fetch(t, e) {
    var i, s, r;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && e != null && e.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (k(this, ci))
        return k(this, ci).continueRetry(), k(this, ci).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const p = this.observers.find((f) => f.options.queryFn);
      p && this.setOptions(p.options);
    }
    const a = new AbortController(), o = /* @__PURE__ */ u((p) => {
      Object.defineProperty(p, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ u(() => (L(this, nc, !0), a.signal), "get")
      });
    }, "addSignalProperty"), l = /* @__PURE__ */ u(() => {
      const p = VS(this.options, e), f = (/* @__PURE__ */ u(() => {
        const m = {
          client: k(this, ic),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return o(m), m;
      }, "createQueryFnContext"))();
      return L(this, nc, !1), this.options.persister ? this.options.persister(
        p,
        f,
        this
      ) : p(f);
    }, "fetchFn"), c = (/* @__PURE__ */ u(() => {
      const p = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: k(this, ic),
        state: this.state,
        fetchFn: l
      };
      return o(p), p;
    }, "createFetchContext"))();
    (i = this.options.behavior) == null || i.onFetch(c, this), L(this, ec, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((s = c.fetchOptions) == null ? void 0 : s.meta)) && mt(this, Zn, ws).call(this, { type: "fetch", meta: (r = c.fetchOptions) == null ? void 0 : r.meta });
    const d = /* @__PURE__ */ u((p) => {
      var f, m, w, b;
      m1(p) && p.silent || mt(this, Zn, ws).call(this, {
        type: "error",
        error: p
      }), m1(p) || ((m = (f = k(this, fn).config).onError) == null || m.call(
        f,
        p,
        this
      ), (b = (w = k(this, fn).config).onSettled) == null || b.call(
        w,
        this.state.data,
        p,
        this
      )), this.scheduleGc();
    }, "onError");
    return L(this, ci, US({
      initialPromise: e == null ? void 0 : e.initialPromise,
      fn: c.fetchFn,
      abort: a.abort.bind(a),
      onSuccess: /* @__PURE__ */ u((p) => {
        var f, m, w, b;
        if (p === void 0) {
          d(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(p);
        } catch (x) {
          d(x);
          return;
        }
        (m = (f = k(this, fn).config).onSuccess) == null || m.call(f, p, this), (b = (w = k(this, fn).config).onSettled) == null || b.call(
          w,
          p,
          this.state.error,
          this
        ), this.scheduleGc();
      }, "onSuccess"),
      onError: d,
      onFail: /* @__PURE__ */ u((p, f) => {
        mt(this, Zn, ws).call(this, { type: "failed", failureCount: p, error: f });
      }, "onFail"),
      onPause: /* @__PURE__ */ u(() => {
        mt(this, Zn, ws).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ u(() => {
        mt(this, Zn, ws).call(this, { type: "continue" });
      }, "onContinue"),
      retry: c.options.retry,
      retryDelay: c.options.retryDelay,
      networkMode: c.options.networkMode,
      canRun: /* @__PURE__ */ u(() => !0, "canRun")
    })), k(this, ci).start();
  }
}, h(mu, "rn"), mu), Ny = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap(), fn = /* @__PURE__ */ new WeakMap(), ic = /* @__PURE__ */ new WeakMap(), ci = /* @__PURE__ */ new WeakMap(), qg = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakMap(), Zn = /* @__PURE__ */ new WeakSet(), ws = /* @__PURE__ */ u(function(n) {
  const t = /* @__PURE__ */ u((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          fetchFailureCount: n.failureCount,
          fetchFailureReason: n.error
        };
      case "pause":
        return {
          ...e,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...e,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...e,
          ...BS(e.data, this.options),
          fetchMeta: n.meta ?? null
        };
      case "success":
        return L(this, ec, void 0), {
          ...e,
          data: n.data,
          dataUpdateCount: e.dataUpdateCount + 1,
          dataUpdatedAt: n.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!n.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const i = n.error;
        return m1(i) && i.revert && k(this, ec) ? { ...k(this, ec), fetchStatus: "idle" } : {
          ...e,
          error: i,
          errorUpdateCount: e.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: e.fetchFailureCount + 1,
          fetchFailureReason: i,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...e,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...e,
          ...n.state
        };
    }
  }, "reducer");
  this.state = t(this.state), Je.batch(() => {
    this.observers.forEach((e) => {
      e.onQueryUpdate();
    }), k(this, fn).notify({ query: this, type: "updated", action: n });
  });
}, "#dispatch"), u(eO, "Query"), eO);
function BS(n, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: FS(t.networkMode) ? "fetching" : "paused",
    ...n === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
h(BS, "kw");
u(BS, "fetchState");
function UR(n) {
  const t = typeof n.initialData == "function" ? n.initialData() : n.initialData, e = t !== void 0, i = e ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
h(UR, "vv");
u(UR, "getDefaultState$1");
var gs, iO, wu, AF = (iO = (wu = class extends $y {
  constructor(t = {}) {
    super(), F(this, gs), this.config = t, L(this, gs, /* @__PURE__ */ new Map());
  }
  build(t, e, i) {
    const s = e.queryKey, r = e.queryHash ?? E0(s, e);
    let a = this.get(r);
    return a || (a = new TF({
      client: t,
      queryKey: s,
      queryHash: r,
      options: t.defaultQueryOptions(e),
      state: i,
      defaultOptions: t.getQueryDefaults(s)
    }), this.add(a)), a;
  }
  add(t) {
    k(this, gs).has(t.queryHash) || (k(this, gs).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = k(this, gs).get(t.queryHash);
    e && (t.destroy(), e === t && k(this, gs).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    Je.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return k(this, gs).get(t);
  }
  getAll() {
    return [...k(this, gs).values()];
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => tk(e, i)
    );
  }
  findAll(t = {}) {
    const e = this.getAll();
    return Object.keys(t).length > 0 ? e.filter((i) => tk(t, i)) : e;
  }
  notify(t) {
    Je.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  onFocus() {
    Je.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    Je.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, h(wu, "nn"), wu), gs = /* @__PURE__ */ new WeakMap(), u(iO, "QueryCache"), iO), vs, $i, sc, bs, rr, nO, gu, RF = (nO = (gu = class extends FR {
  constructor(t) {
    super(), F(this, bs), F(this, vs), F(this, $i), F(this, sc), this.mutationId = t.mutationId, L(this, $i, t.mutationCache), L(this, vs, []), this.state = t.state || XS(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    k(this, vs).includes(t) || (k(this, vs).push(t), this.clearGcTimeout(), k(this, $i).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    L(this, vs, k(this, vs).filter((e) => e !== t)), this.scheduleGc(), k(this, $i).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    k(this, vs).length || (this.state.status === "pending" ? this.scheduleGc() : k(this, $i).remove(this));
  }
  continue() {
    var t;
    return ((t = k(this, sc)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var e, i, s, r, a, o, l, c, d, p, f, m, w, b, x, O, P, A, R, T;
    const I = /* @__PURE__ */ u(() => {
      mt(this, bs, rr).call(this, { type: "continue" });
    }, "onContinue");
    L(this, sc, US({
      fn: /* @__PURE__ */ u(() => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ u((V, Y) => {
        mt(this, bs, rr).call(this, { type: "failed", failureCount: V, error: Y });
      }, "onFail"),
      onPause: /* @__PURE__ */ u(() => {
        mt(this, bs, rr).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: I,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ u(() => k(this, $i).canRun(this), "canRun")
    }));
    const Z = this.state.status === "pending", W = !k(this, sc).canStart();
    try {
      if (Z)
        I();
      else {
        mt(this, bs, rr).call(this, { type: "pending", variables: t, isPaused: W }), await ((i = (e = k(this, $i).config).onMutate) == null ? void 0 : i.call(
          e,
          t,
          this
        ));
        const Y = await ((r = (s = this.options).onMutate) == null ? void 0 : r.call(s, t));
        Y !== this.state.context && mt(this, bs, rr).call(this, {
          type: "pending",
          context: Y,
          variables: t,
          isPaused: W
        });
      }
      const V = await k(this, sc).start();
      return await ((o = (a = k(this, $i).config).onSuccess) == null ? void 0 : o.call(
        a,
        V,
        t,
        this.state.context,
        this
      )), await ((c = (l = this.options).onSuccess) == null ? void 0 : c.call(l, V, t, this.state.context)), await ((p = (d = k(this, $i).config).onSettled) == null ? void 0 : p.call(
        d,
        V,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((m = (f = this.options).onSettled) == null ? void 0 : m.call(f, V, null, t, this.state.context)), mt(this, bs, rr).call(this, { type: "success", data: V }), V;
    } catch (V) {
      try {
        throw await ((b = (w = k(this, $i).config).onError) == null ? void 0 : b.call(
          w,
          V,
          t,
          this.state.context,
          this
        )), await ((O = (x = this.options).onError) == null ? void 0 : O.call(
          x,
          V,
          t,
          this.state.context
        )), await ((A = (P = k(this, $i).config).onSettled) == null ? void 0 : A.call(
          P,
          void 0,
          V,
          this.state.variables,
          this.state.context,
          this
        )), await ((T = (R = this.options).onSettled) == null ? void 0 : T.call(
          R,
          void 0,
          V,
          t,
          this.state.context
        )), V;
      } finally {
        mt(this, bs, rr).call(this, { type: "error", error: V });
      }
    } finally {
      k(this, $i).runNext(this);
    }
  }
}, h(gu, "an"), gu), vs = /* @__PURE__ */ new WeakMap(), $i = /* @__PURE__ */ new WeakMap(), sc = /* @__PURE__ */ new WeakMap(), bs = /* @__PURE__ */ new WeakSet(), rr = /* @__PURE__ */ u(function(n) {
  const t = /* @__PURE__ */ u((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          failureCount: n.failureCount,
          failureReason: n.error
        };
      case "pause":
        return {
          ...e,
          isPaused: !0
        };
      case "continue":
        return {
          ...e,
          isPaused: !1
        };
      case "pending":
        return {
          ...e,
          context: n.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: n.isPaused,
          status: "pending",
          variables: n.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...e,
          data: n.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...e,
          data: void 0,
          error: n.error,
          failureCount: e.failureCount + 1,
          failureReason: n.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = t(this.state), Je.batch(() => {
    k(this, vs).forEach((e) => {
      e.onMutationUpdate(n);
    }), k(this, $i).notify({
      mutation: this,
      type: "updated",
      action: n
    });
  });
}, "#dispatch"), u(nO, "Mutation"), nO);
function XS() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
h(XS, "_w");
u(XS, "getDefaultState");
var ar, Wn, Vg, sO, vu, EF = (sO = (vu = class extends $y {
  constructor(t = {}) {
    super(), F(this, ar), F(this, Wn), F(this, Vg), this.config = t, L(this, ar, /* @__PURE__ */ new Set()), L(this, Wn, /* @__PURE__ */ new Map()), L(this, Vg, 0);
  }
  build(t, e, i) {
    const s = new RF({
      mutationCache: this,
      mutationId: ++Jx(this, Vg)._,
      options: t.defaultMutationOptions(e),
      state: i
    });
    return this.add(s), s;
  }
  add(t) {
    k(this, ar).add(t);
    const e = vm(t);
    if (typeof e == "string") {
      const i = k(this, Wn).get(e);
      i ? i.push(t) : k(this, Wn).set(e, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if (k(this, ar).delete(t)) {
      const e = vm(t);
      if (typeof e == "string") {
        const i = k(this, Wn).get(e);
        if (i)
          if (i.length > 1) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1);
          } else i[0] === t && k(this, Wn).delete(e);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const e = vm(t);
    if (typeof e == "string") {
      const i = k(this, Wn).get(e), s = i == null ? void 0 : i.find(
        (r) => r.state.status === "pending"
      );
      return !s || s === t;
    } else
      return !0;
  }
  runNext(t) {
    var e;
    const i = vm(t);
    if (typeof i == "string") {
      const s = (e = k(this, Wn).get(i)) == null ? void 0 : e.find((r) => r !== t && r.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    Je.batch(() => {
      k(this, ar).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), k(this, ar).clear(), k(this, Wn).clear();
    });
  }
  getAll() {
    return Array.from(k(this, ar));
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => ek(e, i)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((e) => ek(t, e));
  }
  notify(t) {
    Je.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((e) => e.state.isPaused);
    return Je.batch(
      () => Promise.all(
        t.map((e) => e.continue().catch(fi))
      )
    );
  }
}, h(vu, "on"), vu), ar = /* @__PURE__ */ new WeakMap(), Wn = /* @__PURE__ */ new WeakMap(), Vg = /* @__PURE__ */ new WeakMap(), u(sO, "MutationCache"), sO);
function vm(n) {
  var t;
  return (t = n.options.scope) == null ? void 0 : t.id;
}
h(vm, "_l");
u(vm, "scopeFor");
function Tw(n) {
  return {
    onFetch: /* @__PURE__ */ u((t, e) => {
      var i, s, r, a, o;
      const l = t.options, c = (r = (s = (i = t.fetchOptions) == null ? void 0 : i.meta) == null ? void 0 : s.fetchMore) == null ? void 0 : r.direction, d = ((a = t.state.data) == null ? void 0 : a.pages) || [], p = ((o = t.state.data) == null ? void 0 : o.pageParams) || [];
      let f = { pages: [], pageParams: [] }, m = 0;
      const w = /* @__PURE__ */ u(async () => {
        let b = !1;
        const x = /* @__PURE__ */ u((A) => {
          Object.defineProperty(A, "signal", {
            enumerable: !0,
            get: /* @__PURE__ */ u(() => (t.signal.aborted ? b = !0 : t.signal.addEventListener("abort", () => {
              b = !0;
            }), t.signal), "get")
          });
        }, "addSignalProperty"), O = VS(t.options, t.fetchOptions), P = /* @__PURE__ */ u(async (A, R, T) => {
          if (b)
            return Promise.reject();
          if (R == null && A.pages.length)
            return Promise.resolve(A);
          const I = (/* @__PURE__ */ u(() => {
            const Y = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: R,
              direction: T ? "backward" : "forward",
              meta: t.options.meta
            };
            return x(Y), Y;
          }, "createQueryFnContext"))(), Z = await O(I), { maxPages: W } = t.options, V = T ? WR : ZR;
          return {
            pages: V(A.pages, Z, W),
            pageParams: V(A.pageParams, R, W)
          };
        }, "fetchPage");
        if (c && d.length) {
          const A = c === "backward", R = A ? NS : Av, T = {
            pages: d,
            pageParams: p
          }, I = R(l, T);
          f = await P(T, I, A);
        } else {
          const A = n ?? d.length;
          do {
            const R = m === 0 ? p[0] ?? l.initialPageParam : Av(l, f);
            if (m > 0 && R == null)
              break;
            f = await P(f, R), m++;
          } while (m < A);
        }
        return f;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => {
        var b, x;
        return (x = (b = t.options).persister) == null ? void 0 : x.call(
          b,
          w,
          {
            client: t.client,
            queryKey: t.queryKey,
            meta: t.options.meta,
            signal: t.signal
          },
          e
        );
      } : t.fetchFn = w;
    }, "onFetch")
  };
}
h(Tw, "Hl");
u(Tw, "infiniteQueryBehavior");
function Av(n, { pages: t, pageParams: e }) {
  const i = t.length - 1;
  return t.length > 0 ? n.getNextPageParam(
    t[i],
    t,
    e[i],
    e
  ) : void 0;
}
h(Av, "jh");
u(Av, "getNextPageParam");
function NS(n, { pages: t, pageParams: e }) {
  var i;
  return t.length > 0 ? (i = n.getPreviousPageParam) == null ? void 0 : i.call(n, t[0], t, e[0], e) : void 0;
}
h(NS, "zw");
u(NS, "getPreviousPageParam");
function BR(n, t) {
  return t ? Av(n, t) != null : !1;
}
h(BR, "$v");
u(BR, "hasNextPage");
function XR(n, t) {
  return !t || !n.getPreviousPageParam ? !1 : NS(n, t) != null;
}
h(XR, "Cv");
u(XR, "hasPreviousPage");
var ye, Ca, Qa, Hy, Yy, Ma, Gy, Ky, rO, bu, zF = (rO = (bu = class {
  constructor(t = {}) {
    F(this, ye), F(this, Ca), F(this, Qa), F(this, Hy), F(this, Yy), F(this, Ma), F(this, Gy), F(this, Ky), L(this, ye, t.queryCache || new AF()), L(this, Ca, t.mutationCache || new EF()), L(this, Qa, t.defaultOptions || {}), L(this, Hy, /* @__PURE__ */ new Map()), L(this, Yy, /* @__PURE__ */ new Map()), L(this, Ma, 0);
  }
  mount() {
    Jx(this, Ma)._++, k(this, Ma) === 1 && (L(this, Gy, jS.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), k(this, ye).onFocus());
    })), L(this, Ky, Mv.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), k(this, ye).onOnline());
    })));
  }
  unmount() {
    var t, e;
    Jx(this, Ma)._--, k(this, Ma) === 0 && ((t = k(this, Gy)) == null || t.call(this), L(this, Gy, void 0), (e = k(this, Ky)) == null || e.call(this), L(this, Ky, void 0));
  }
  isFetching(t) {
    return k(this, ye).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return k(this, Ca).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    var e;
    const i = this.defaultQueryOptions({ queryKey: t });
    return (e = k(this, ye).get(i.queryHash)) == null ? void 0 : e.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), i = k(this, ye).build(this, e), s = i.state.data;
    return s === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && i.isStaleByTime(Ws(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(s));
  }
  getQueriesData(t) {
    return k(this, ye).findAll(t).map(({ queryKey: e, state: i }) => {
      const s = i.data;
      return [e, s];
    });
  }
  setQueryData(t, e, i) {
    const s = this.defaultQueryOptions({ queryKey: t }), r = k(this, ye).get(
      s.queryHash
    ), a = r == null ? void 0 : r.state.data, o = LR(e, a);
    if (o !== void 0)
      return k(this, ye).build(this, s).setData(o, { ...i, manual: !0 });
  }
  setQueriesData(t, e, i) {
    return Je.batch(
      () => k(this, ye).findAll(t).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, e, i)
      ])
    );
  }
  getQueryState(t) {
    var e;
    const i = this.defaultQueryOptions({ queryKey: t });
    return (e = k(this, ye).get(
      i.queryHash
    )) == null ? void 0 : e.state;
  }
  removeQueries(t) {
    const e = k(this, ye);
    Je.batch(() => {
      e.findAll(t).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(t, e) {
    const i = k(this, ye);
    return Je.batch(() => (i.findAll(t).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const i = { revert: !0, ...e }, s = Je.batch(
      () => k(this, ye).findAll(t).map((r) => r.cancel(i))
    );
    return Promise.all(s).then(fi).catch(fi);
  }
  invalidateQueries(t, e = {}) {
    return Je.batch(() => (k(this, ye).findAll(t).forEach((i) => {
      i.invalidate();
    }), (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, s = Je.batch(
      () => k(this, ye).findAll(t).filter((r) => !r.isDisabled() && !r.isStatic()).map((r) => {
        let a = r.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(fi)), r.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(s).then(fi);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const i = k(this, ye).build(this, e);
    return i.isStaleByTime(
      Ws(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(fi).catch(fi);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Tw(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(fi).catch(fi);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Tw(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Mv.isOnline() ? k(this, Ca).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return k(this, ye);
  }
  getMutationCache() {
    return k(this, Ca);
  }
  getDefaultOptions() {
    return k(this, Qa);
  }
  setDefaultOptions(t) {
    L(this, Qa, t);
  }
  setQueryDefaults(t, e) {
    k(this, Hy).set(Jr(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...k(this, Hy).values()], i = {};
    return e.forEach((s) => {
      ty(t, s.queryKey) && Object.assign(i, s.defaultOptions);
    }), i;
  }
  setMutationDefaults(t, e) {
    k(this, Yy).set(Jr(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...k(this, Yy).values()], i = {};
    return e.forEach((s) => {
      ty(t, s.mutationKey) && Object.assign(i, s.defaultOptions);
    }), i;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...k(this, Qa).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = E0(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === qS && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...k(this, Qa).mutations,
      ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    k(this, ye).clear(), k(this, Ca).clear();
  }
}, h(bu, "un"), bu), ye = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), Hy = /* @__PURE__ */ new WeakMap(), Yy = /* @__PURE__ */ new WeakMap(), Ma = /* @__PURE__ */ new WeakMap(), Gy = /* @__PURE__ */ new WeakMap(), Ky = /* @__PURE__ */ new WeakMap(), u(rO, "QueryClient"), rO), Zi, zt, jg, xi, rc, Jy, Ta, Aa, Fg, tm, em, ac, oc, Ra, im, me, nm, aO, oO, lO, cO, hO, dO, uO, d3, pO, Ou, NR = (pO = (Ou = class extends $y {
  constructor(t, e) {
    super(), F(this, me), F(this, Zi), F(this, zt), F(this, jg), F(this, xi), F(this, rc), F(this, Jy), F(this, Ta), F(this, Aa), F(this, Fg), F(this, tm), F(this, em), F(this, ac), F(this, oc), F(this, Ra), F(this, im, /* @__PURE__ */ new Set()), this.options = e, L(this, Zi, t), L(this, Aa, null), L(this, Ta, Tv()), this.options.experimental_prefetchInRender || k(this, Ta).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(e);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (k(this, zt).addObserver(this), sk(k(this, zt), this.options) ? mt(this, me, nm).call(this) : this.updateResult(), mt(this, me, cO).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Rv(
      k(this, zt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Rv(
      k(this, zt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), mt(this, me, hO).call(this), mt(this, me, dO).call(this), k(this, zt).removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, i = k(this, zt);
    if (this.options = k(this, Zi).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Ki(this.options.enabled, k(this, zt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    mt(this, me, uO).call(this), k(this, zt).setOptions(this.options), e._defaulted && !Mw(this.options, e) && k(this, Zi).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: k(this, zt),
      observer: this
    });
    const s = this.hasListeners();
    s && rk(
      k(this, zt),
      i,
      this.options,
      e
    ) && mt(this, me, nm).call(this), this.updateResult(), s && (k(this, zt) !== i || Ki(this.options.enabled, k(this, zt)) !== Ki(e.enabled, k(this, zt)) || Ws(this.options.staleTime, k(this, zt)) !== Ws(e.staleTime, k(this, zt))) && mt(this, me, aO).call(this);
    const r = mt(this, me, oO).call(this);
    s && (k(this, zt) !== i || Ki(this.options.enabled, k(this, zt)) !== Ki(e.enabled, k(this, zt)) || r !== k(this, Ra)) && mt(this, me, lO).call(this, r);
  }
  getOptimisticResult(t) {
    const e = k(this, Zi).getQueryCache().build(k(this, Zi), t), i = this.createResult(e, t);
    return YR(this, i) && (L(this, xi, i), L(this, Jy, this.options), L(this, rc, k(this, zt).state)), i;
  }
  getCurrentResult() {
    return k(this, xi);
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: /* @__PURE__ */ u((i, s) => (this.trackProp(s), e == null || e(s), Reflect.get(i, s)), "get")
    });
  }
  trackProp(t) {
    k(this, im).add(t);
  }
  getCurrentQuery() {
    return k(this, zt);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = k(this, Zi).defaultQueryOptions(t), i = k(this, Zi).getQueryCache().build(k(this, Zi), e);
    return i.fetch().then(() => this.createResult(i, e));
  }
  fetch(t) {
    return mt(this, me, nm).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), k(this, xi)));
  }
  createResult(t, e) {
    var i;
    const s = k(this, zt), r = this.options, a = k(this, xi), o = k(this, rc), l = k(this, Jy), c = t !== s ? t.state : k(this, jg), { state: d } = t;
    let p = { ...d }, f = !1, m;
    if (e._optimisticResults) {
      const W = this.hasListeners(), V = !W && sk(t, e), Y = W && rk(t, s, e, r);
      (V || Y) && (p = {
        ...p,
        ...BS(d.data, t.options)
      }), e._optimisticResults === "isRestoring" && (p.fetchStatus = "idle");
    }
    let { error: w, errorUpdatedAt: b, status: x } = p;
    m = p.data;
    let O = !1;
    if (e.placeholderData !== void 0 && m === void 0 && x === "pending") {
      let W;
      a != null && a.isPlaceholderData && e.placeholderData === (l == null ? void 0 : l.placeholderData) ? (W = a.data, O = !0) : W = typeof e.placeholderData == "function" ? e.placeholderData(
        (i = k(this, em)) == null ? void 0 : i.state.data,
        k(this, em)
      ) : e.placeholderData, W !== void 0 && (x = "success", m = Qv(
        a == null ? void 0 : a.data,
        W,
        e
      ), f = !0);
    }
    if (e.select && m !== void 0 && !O)
      if (a && m === (o == null ? void 0 : o.data) && e.select === k(this, Fg))
        m = k(this, tm);
      else
        try {
          L(this, Fg, e.select), m = e.select(m), m = Qv(a == null ? void 0 : a.data, m, e), L(this, tm, m), L(this, Aa, null);
        } catch (W) {
          L(this, Aa, W);
        }
    k(this, Aa) && (w = k(this, Aa), m = k(this, tm), b = Date.now(), x = "error");
    const P = p.fetchStatus === "fetching", A = x === "pending", R = x === "error", T = A && P, I = m !== void 0, Z = {
      status: x,
      fetchStatus: p.fetchStatus,
      isPending: A,
      isSuccess: x === "success",
      isError: R,
      isInitialLoading: T,
      isLoading: T,
      data: m,
      dataUpdatedAt: p.dataUpdatedAt,
      error: w,
      errorUpdatedAt: b,
      failureCount: p.fetchFailureCount,
      failureReason: p.fetchFailureReason,
      errorUpdateCount: p.errorUpdateCount,
      isFetched: p.dataUpdateCount > 0 || p.errorUpdateCount > 0,
      isFetchedAfterMount: p.dataUpdateCount > c.dataUpdateCount || p.errorUpdateCount > c.errorUpdateCount,
      isFetching: P,
      isRefetching: P && !A,
      isLoadingError: R && !I,
      isPaused: p.fetchStatus === "paused",
      isPlaceholderData: f,
      isRefetchError: R && I,
      isStale: z0(t, e),
      refetch: this.refetch,
      promise: k(this, Ta)
    };
    if (this.options.experimental_prefetchInRender) {
      const W = /* @__PURE__ */ u((G) => {
        Z.status === "error" ? G.reject(Z.error) : Z.data !== void 0 && G.resolve(Z.data);
      }, "finalizeThenableIfPossible"), V = /* @__PURE__ */ u(() => {
        const G = L(this, Ta, Z.promise = Tv());
        W(G);
      }, "recreateThenable"), Y = k(this, Ta);
      switch (Y.status) {
        case "pending":
          t.queryHash === s.queryHash && W(Y);
          break;
        case "fulfilled":
          (Z.status === "error" || Z.data !== Y.value) && V();
          break;
        case "rejected":
          (Z.status !== "error" || Z.error !== Y.reason) && V();
          break;
      }
    }
    return Z;
  }
  updateResult() {
    const t = k(this, xi), e = this.createResult(k(this, zt), this.options);
    if (L(this, rc, k(this, zt).state), L(this, Jy, this.options), k(this, rc).data !== void 0 && L(this, em, k(this, zt)), Mw(e, t))
      return;
    L(this, xi, e);
    const i = /* @__PURE__ */ u(() => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: s } = this.options, r = typeof s == "function" ? s() : s;
      if (r === "all" || !r && !k(this, im).size)
        return !0;
      const a = new Set(
        r ?? k(this, im)
      );
      return this.options.throwOnError && a.add("error"), Object.keys(k(this, xi)).some((o) => {
        const l = o;
        return k(this, xi)[l] !== t[l] && a.has(l);
      });
    }, "shouldNotifyListeners");
    mt(this, me, d3).call(this, { listeners: i() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && mt(this, me, cO).call(this);
  }
}, h(Ou, "mn"), Ou), Zi = /* @__PURE__ */ new WeakMap(), zt = /* @__PURE__ */ new WeakMap(), jg = /* @__PURE__ */ new WeakMap(), xi = /* @__PURE__ */ new WeakMap(), rc = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new WeakMap(), Ta = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Fg = /* @__PURE__ */ new WeakMap(), tm = /* @__PURE__ */ new WeakMap(), em = /* @__PURE__ */ new WeakMap(), ac = /* @__PURE__ */ new WeakMap(), oc = /* @__PURE__ */ new WeakMap(), Ra = /* @__PURE__ */ new WeakMap(), im = /* @__PURE__ */ new WeakMap(), me = /* @__PURE__ */ new WeakSet(), nm = /* @__PURE__ */ u(function(n) {
  mt(this, me, uO).call(this);
  let t = k(this, zt).fetch(
    this.options,
    n
  );
  return n != null && n.throwOnError || (t = t.catch(fi)), t;
}, "#executeFetch"), aO = /* @__PURE__ */ u(function() {
  mt(this, me, hO).call(this);
  const n = Ws(
    this.options.staleTime,
    k(this, zt)
  );
  if (Jf || k(this, xi).isStale || !Pv(n))
    return;
  const t = DS(k(this, xi).dataUpdatedAt, n) + 1;
  L(this, ac, setTimeout(() => {
    k(this, xi).isStale || this.updateResult();
  }, t));
}, "#updateStaleTimeout"), oO = /* @__PURE__ */ u(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(k(this, zt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), lO = /* @__PURE__ */ u(function(n) {
  mt(this, me, dO).call(this), L(this, Ra, n), !(Jf || Ki(this.options.enabled, k(this, zt)) === !1 || !Pv(k(this, Ra)) || k(this, Ra) === 0) && L(this, oc, setInterval(() => {
    (this.options.refetchIntervalInBackground || jS.isFocused()) && mt(this, me, nm).call(this);
  }, k(this, Ra)));
}, "#updateRefetchInterval"), cO = /* @__PURE__ */ u(function() {
  mt(this, me, aO).call(this), mt(this, me, lO).call(this, mt(this, me, oO).call(this));
}, "#updateTimers"), hO = /* @__PURE__ */ u(function() {
  k(this, ac) && (clearTimeout(k(this, ac)), L(this, ac, void 0));
}, "#clearStaleTimeout"), dO = /* @__PURE__ */ u(function() {
  k(this, oc) && (clearInterval(k(this, oc)), L(this, oc, void 0));
}, "#clearRefetchInterval"), uO = /* @__PURE__ */ u(function() {
  const n = k(this, Zi).getQueryCache().build(k(this, Zi), this.options);
  if (n === k(this, zt))
    return;
  const t = k(this, zt);
  L(this, zt, n), L(this, jg, n.state), this.hasListeners() && (t == null || t.removeObserver(this), n.addObserver(this));
}, "#updateQuery"), d3 = /* @__PURE__ */ u(function(n) {
  Je.batch(() => {
    n.listeners && this.listeners.forEach((t) => {
      t(k(this, xi));
    }), k(this, Zi).getQueryCache().notify({
      query: k(this, zt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), u(pO, "QueryObserver"), pO);
function HR(n, t) {
  return Ki(t.enabled, n) !== !1 && n.state.data === void 0 && !(n.state.status === "error" && t.retryOnMount === !1);
}
h(HR, "_v");
u(HR, "shouldLoadOnMount");
function sk(n, t) {
  return HR(n, t) || n.state.data !== void 0 && Rv(n, t, t.refetchOnMount);
}
h(sk, "ny");
u(sk, "shouldFetchOnMount");
function Rv(n, t, e) {
  if (Ki(t.enabled, n) !== !1 && Ws(t.staleTime, n) !== "static") {
    const i = typeof e == "function" ? e(n) : e;
    return i === "always" || i !== !1 && z0(n, t);
  }
  return !1;
}
h(Rv, "Jh");
u(Rv, "shouldFetchOn");
function rk(n, t, e, i) {
  return (n !== t || Ki(i.enabled, n) === !1) && (!e.suspense || n.state.status !== "error") && z0(n, e);
}
h(rk, "ay");
u(rk, "shouldFetchOptionally");
function z0(n, t) {
  return Ki(t.enabled, n) !== !1 && n.isStaleByTime(Ws(t.staleTime, n));
}
h(z0, "qu");
u(z0, "isStale");
function YR(n, t) {
  return !Mw(n.getCurrentResult(), t);
}
h(YR, "zv");
u(YR, "shouldAssignObserverCurrentProperties");
var fO, $u, _F = (fO = ($u = class extends NR {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Tw()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Tw(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    var i, s;
    const { state: r } = t, a = super.createResult(t, e), { isFetching: o, isRefetching: l, isError: c, isRefetchError: d } = a, p = (s = (i = r.fetchMeta) == null ? void 0 : i.fetchMore) == null ? void 0 : s.direction, f = c && p === "forward", m = o && p === "forward", w = c && p === "backward", b = o && p === "backward";
    return {
      ...a,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: BR(e, r.data),
      hasPreviousPage: XR(e, r.data),
      isFetchNextPageError: f,
      isFetchingNextPage: m,
      isFetchPreviousPageError: w,
      isFetchingPreviousPage: b,
      isRefetchError: d && !f && !w,
      isRefetching: l && !m && !b
    };
  }
}, h($u, "vn"), $u), u(fO, "InfiniteQueryObserver"), fO), Ea, za, Wi, or, _a, Ug, yO, mO, xu, Vt = (mO = (xu = class extends $y {
  constructor(t, e) {
    super(), F(this, _a), F(this, Ea), F(this, za), F(this, Wi), F(this, or), L(this, Ea, t), this.setOptions(e), this.bindMethods(), mt(this, _a, Ug).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    var e;
    const i = this.options;
    this.options = k(this, Ea).defaultMutationOptions(t), Mw(this.options, i) || k(this, Ea).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: k(this, Wi),
      observer: this
    }), i != null && i.mutationKey && this.options.mutationKey && Jr(i.mutationKey) !== Jr(this.options.mutationKey) ? this.reset() : ((e = k(this, Wi)) == null ? void 0 : e.state.status) === "pending" && k(this, Wi).setOptions(this.options);
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || (t = k(this, Wi)) == null || t.removeObserver(this);
  }
  onMutationUpdate(t) {
    mt(this, _a, Ug).call(this), mt(this, _a, yO).call(this, t);
  }
  getCurrentResult() {
    return k(this, za);
  }
  reset() {
    var t;
    (t = k(this, Wi)) == null || t.removeObserver(this), L(this, Wi, void 0), mt(this, _a, Ug).call(this), mt(this, _a, yO).call(this);
  }
  mutate(t, e) {
    var i;
    return L(this, or, e), (i = k(this, Wi)) == null || i.removeObserver(this), L(this, Wi, k(this, Ea).getMutationCache().build(k(this, Ea), this.options)), k(this, Wi).addObserver(this), k(this, Wi).execute(t);
  }
}, h(xu, "gn"), xu), Ea = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap(), or = /* @__PURE__ */ new WeakMap(), _a = /* @__PURE__ */ new WeakSet(), Ug = /* @__PURE__ */ u(function() {
  var n;
  const t = ((n = k(this, Wi)) == null ? void 0 : n.state) ?? XS();
  L(this, za, {
    ...t,
    isPending: t.status === "pending",
    isSuccess: t.status === "success",
    isError: t.status === "error",
    isIdle: t.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), yO = /* @__PURE__ */ u(function(n) {
  Je.batch(() => {
    var t, e, i, s, r, a, o, l;
    if (k(this, or) && this.hasListeners()) {
      const c = k(this, za).variables, d = k(this, za).context;
      (n == null ? void 0 : n.type) === "success" ? ((e = (t = k(this, or)).onSuccess) == null || e.call(t, n.data, c, d), (s = (i = k(this, or)).onSettled) == null || s.call(i, n.data, null, c, d)) : (n == null ? void 0 : n.type) === "error" && ((a = (r = k(this, or)).onError) == null || a.call(r, n.error, c, d), (l = (o = k(this, or)).onSettled) == null || l.call(
        o,
        void 0,
        n.error,
        c,
        d
      ));
    }
    this.listeners.forEach((c) => {
      c(k(this, za));
    });
  });
}, "#notify"), u(mO, "MutationObserver"), mO);
function HS(n) {
  return n;
}
h(HS, "Sw");
u(HS, "defaultTransformerFn");
function GR(n) {
  return {
    mutationKey: n.options.mutationKey,
    state: n.state,
    ...n.options.scope && { scope: n.options.scope },
    ...n.meta && { meta: n.meta }
  };
}
h(GR, "Pv");
u(GR, "dehydrateMutation");
function KR(n, t, e) {
  var i;
  return {
    dehydratedAt: Date.now(),
    state: {
      ...n.state,
      ...n.state.data !== void 0 && {
        data: t(n.state.data)
      }
    },
    queryKey: n.queryKey,
    queryHash: n.queryHash,
    ...n.state.status === "pending" && {
      promise: (i = n.promise) == null ? void 0 : i.then(t).catch((s) => e(s) ? Promise.reject(new Error("redacted")) : Promise.reject(s))
    },
    ...n.meta && { meta: n.meta }
  };
}
h(KR, "Sv");
u(KR, "dehydrateQuery");
function JR(n) {
  return n.state.isPaused;
}
h(JR, "Av");
u(JR, "defaultShouldDehydrateMutation");
function tE(n) {
  return n.state.status === "success";
}
h(tE, "Ev");
u(tE, "defaultShouldDehydrateQuery");
function eE(n) {
  return !0;
}
h(eE, "Rv");
u(eE, "defaultShouldRedactErrors");
function iE(n, t = {}) {
  var e, i, s, r;
  const a = t.shouldDehydrateMutation ?? ((e = n.getDefaultOptions().dehydrate) == null ? void 0 : e.shouldDehydrateMutation) ?? JR, o = n.getMutationCache().getAll().flatMap(
    (f) => a(f) ? [GR(f)] : []
  ), l = t.shouldDehydrateQuery ?? ((i = n.getDefaultOptions().dehydrate) == null ? void 0 : i.shouldDehydrateQuery) ?? tE, c = t.shouldRedactErrors ?? ((s = n.getDefaultOptions().dehydrate) == null ? void 0 : s.shouldRedactErrors) ?? eE, d = t.serializeData ?? ((r = n.getDefaultOptions().dehydrate) == null ? void 0 : r.serializeData) ?? HS, p = n.getQueryCache().getAll().flatMap(
    (f) => l(f) ? [KR(f, d, c)] : []
  );
  return { mutations: o, queries: p };
}
h(iE, "Ov");
u(iE, "dehydrate");
function nE(n, t, e) {
  var i;
  if (typeof t != "object" || t === null)
    return;
  const s = n.getMutationCache(), r = n.getQueryCache(), a = ((i = n.getDefaultOptions().hydrate) == null ? void 0 : i.deserializeData) ?? HS, o = t.mutations || [], l = t.queries || [];
  o.forEach(({ state: c, ...d }) => {
    var p, f;
    s.build(
      n,
      {
        ...(p = n.getDefaultOptions().hydrate) == null ? void 0 : p.mutations,
        ...(f = e == null ? void 0 : e.defaultOptions) == null ? void 0 : f.mutations,
        ...d
      },
      c
    );
  }), l.forEach(
    ({ queryKey: c, state: d, queryHash: p, meta: f, promise: m, dehydratedAt: w }) => {
      var b, x;
      const O = m ? DR(m) : void 0, P = d.data === void 0 ? O == null ? void 0 : O.data : d.data, A = P === void 0 ? P : a(P);
      let R = r.get(p);
      const T = (R == null ? void 0 : R.state.status) === "pending", I = (R == null ? void 0 : R.state.fetchStatus) === "fetching";
      if (R) {
        const Z = O && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        w !== void 0 && w > R.state.dataUpdatedAt;
        if (d.dataUpdatedAt > R.state.dataUpdatedAt || Z) {
          const { fetchStatus: W, ...V } = d;
          R.setState({
            ...V,
            data: A
          });
        }
      } else
        R = r.build(
          n,
          {
            ...(b = n.getDefaultOptions().hydrate) == null ? void 0 : b.queries,
            ...(x = e == null ? void 0 : e.defaultOptions) == null ? void 0 : x.queries,
            queryKey: c,
            queryHash: p,
            meta: f
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...d,
            data: A,
            fetchStatus: "idle",
            status: A !== void 0 ? "success" : d.status
          }
        );
      m && !T && !I && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (w === void 0 || w > R.state.dataUpdatedAt) && R.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(m).then(a)
      });
    }
  );
}
h(nE, "Lv");
u(nE, "hydrate");
var Pt = /* @__PURE__ */ ((n) => (n.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", n.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(Pt || {}), vn = /* @__PURE__ */ ((n) => (n.Chat = "chat", n.Comments = "comments", n.Files = "files", n.Posts = "posts", n.ChatRoom = "chat_room", n.PrivateChat = "private_chat", n.AgentChat = "agent_chat", n))(vn || {}), sE = /* @__PURE__ */ ((n) => (n["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", n["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", n["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", n["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", n["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", n["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(sE || {}), rE = /* @__PURE__ */ ((n) => (n.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(rE || {}), aE = /* @__PURE__ */ ((n) => (n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(aE || {}), oE = /* @__PURE__ */ ((n) => (n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(oE || {}), nn = /* @__PURE__ */ ((n) => (n.Unknown = "unknown", n))(nn || {}), yr = /* @__PURE__ */ ((n) => (n.None = "none", n.Read = "read", n.Write = "write", n.Admin = "admin", n))(yr || {}), Fo = /* @__PURE__ */ ((n) => (n.List = "list", n.Read = "read", n.Create = "create", n.Update = "update", n.Delete = "delete", n.Admin = "admin", n))(Fo || {}), oi = /* @__PURE__ */ ((n) => (n.App = "app", n.File = "file", n.Message = "message", n.User = "user", n.Comment = "comment", n.Post = "post", n))(oi || {});
function ol(n, t, e, i, s, r = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ u(async () => {
      const a = await n.fetch(e || "/api/" + t.join("/"), { method: r, body: s });
      if (a.ok)
        return await a.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...i
  };
}
h(ol, "tc");
u(ol, "getApiOptions");
async function Ev(n, t, e, i, s, r = "GET", a = !1) {
  const o = n.queryClient, l = ol(n, t, e, i, s, r);
  return a ? (l.staleTime = 1, await o.fetchQuery(l)) : await o.ensureQueryData(l);
}
h(Ev, "eu");
u(Ev, "getApi");
function lE(n, t, e = nn.Unknown, i) {
  return e === nn.Unknown || typeof t == "number" ? Ev(n, ["apps", t]) : Ev(n, ["apps", t], void 0, void 0, JSON.stringify({ type: e, ...i }), "PUT");
}
h(lE, "Iv");
u(lE, "getApp");
function cE(n, t, e = nn.Unknown, i, s) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ u(async () => {
      const r = [];
      e === nn.Unknown || typeof t == "number" ? r.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ) : r.push(
        // Get, update or create app using app uid
        n.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, members: i, ...s }) })
      );
      const a = (await Promise.allSettled(r)).findLast(
        (l) => {
          var c;
          return l.status === "fulfilled" && ((c = l.value) == null ? void 0 : c.ok);
        }
      ), o = (a == null ? void 0 : a.status) === "fulfilled" && a.value;
      if (o)
        return await o.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
h(cE, "Tv");
u(cE, "getOrCreateAppOptions");
function hE(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ name: t, members: e, type: i, uid: s }) => await (await n.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: t,
        members: e,
        type: i,
        uid: s
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ u(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(hE, "Fv");
u(hE, "getCreateAppMutationOptions");
function YS(n) {
  return new Vt(n.queryClient, hE(n));
}
h(YS, "Lw");
u(YS, "getCreateAppMutation");
function GS(n, t) {
  const e = n.queryClient, i = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ u(async ({ subscribe: s }) => {
      if (t.id >= 1) {
        const r = await n.fetch(`/api/apps/${t.id}/${s ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!r.ok)
          throw await r.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => {
      let r;
      return e.setQueryData(i, (a) => (r = a.is_subscribed, { ...a, is_subscribed: s.subscribe })), {
        previousSubscribe: r,
        subscribe: s.subscribe
      };
    }, "onMutate"),
    onError(s, r, a) {
      a && a.previousSubscribe !== void 0 && e.setQueryData(i, (o) => ({ ...o, is_subscribed: a == null ? void 0 : a.previousSubscribe }));
    }
  };
}
h(GS, "Iw");
u(GS, "getAppSubscribeMutationOptions");
function dE(n, t = [Pt.ChatRoom, Pt.PrivateChat], e, i = {}) {
  const s = new URLSearchParams({
    count_only: "true",
    unread: "true"
  });
  e && s.append("member", e), t == null || t.forEach((a) => s.append("type", a));
  const r = `/api/apps?${s.toString()}`;
  return ol(n, ["apps", "badge", t], r, i);
}
h(dE, "Dv");
u(dE, "getBadgeOptions$1");
function uE(n, t = {}, e, i, s, r, a) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, i, r, a],
    queryFn: /* @__PURE__ */ u(async (o) => {
      var l;
      const c = new URLSearchParams();
      i && c.append("member", i), o.pageParam && typeof o.pageParam == "number" && c.append("skip", (l = o.pageParam) == null ? void 0 : l.toString()), e == null || e.forEach((m) => c.append("type", m)), c.append("order_by", r);
      const d = s == null ? void 0 : s();
      d && c.append("q", d), c.append("uid", "false");
      const p = `/api/apps?${c.toString()}`, f = await (await n.fetch(p)).json();
      return f.data = f.data || [], f;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((o) => {
      if (o.end && (o == null ? void 0 : o.end) < (o == null ? void 0 : o.count))
        return o.end;
    }, "getNextPageParam")
  };
}
h(uE, "Hv");
u(uE, "getAppListOptions");
const LF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
      const r = this;
      this.api = {
        apps: {
          async getApp(a) {
            return await lE(r, a);
          }
        }
      };
    }
  }, h(e, "t"), e), u(t, "WeavyApi"), t;
}, "WeavyApiMixin"), IF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenTokenFactory = new Promise((r) => {
        this._resolveTokenFactory = r;
      }), this._whenUrlAndTokenFactory = new Promise((r) => {
        this._resolveUrlAndTokenFactory = r;
      }), this._whenTokenIsValid = new Promise((r) => {
        this._resolveTokenIsValid = r;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (r = !1) => {
        var a, o;
        const l = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay !== 1 / 0 && l.push(new Promise((d) => setTimeout(d, this.tokenFactoryRetryDelay))), await Promise.race(l);
        const c = await ((a = this.tokenFactory) == null ? void 0 : a.call(this, r)) ?? "";
        if (this._validateToken(c)) {
          if (r && c === this._token && this.tokenFactoryRetryDelay !== 1 / 0)
            return await new Promise((d) => setTimeout(d, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((d) => {
          this._resolveTokenFactory = d;
        }), !r)
          return await this._validTokenFromFactory(!1);
        if (!c)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return (o = this._resolveTokenFactory) == null || o.call(this, !0), this.whenUrl().then(this._resolveUrlAndTokenFactory), c;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        var r;
        this.url && this.tokenFactory && ((r = this._resolveUrlAndTokenFactory) == null || r.call(this, !0));
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(s) {
      if (this.isDestroyed)
        throw new Se();
      this._tokenFactory && this._tokenFactory !== s && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = s ?? void 0, this._tokenFactory && queueMicrotask(() => {
        var r;
        (r = this._resolveTokenFactory) == null || r.call(this, !0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(s) {
      if (this.isDestroyed)
        throw new Se();
      try {
        if (typeof s == "string")
          s && (this._tokenUrl = new URL(s, window.location.toString()));
        else if (s instanceof URL)
          this._tokenUrl = s;
        else if (s == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (r) {
        throw new Error("Invalid url", r);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (r) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const a = new URL(this.tokenUrl);
        r ? a.searchParams.set("refresh", "true") : a.searchParams.delete("refresh");
        const o = await fetch(a);
        if (o.ok) {
          const l = await o.json();
          if (l.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return l.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(s) {
      var r;
      if (!s)
        return !1;
      if (typeof s != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof s}.`);
      if (typeof s == "string" && !s.startsWith("wyu_"))
        throw s.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return (r = this._resolveTokenIsValid) == null || r.call(this, s), !0;
    }
    async getToken(s = !1) {
      if (this.isDestroyed)
        throw new Se();
      if (this._token && !s)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((r, a) => {
        this._validTokenFromFactory(s).then(r).catch(a), this.tokenFactoryTimeout !== 1 / 0 && setTimeout(() => a(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => a(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => a(new Error("Network changed.")), { once: !0 });
      });
      try {
        const r = await this._tokenPromise;
        return this._tokenPromise = null, this._token = r, this._token;
      } catch (r) {
        throw this._tokenPromise = null, r;
      }
    }
  }, h(e, "t"), e), u(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var Bg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pE(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
h(pE, "Uv");
u(pE, "getDefaultExportFromCjs");
function w1(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
h(w1, "_h");
u(w1, "commonjsRequire");
var u3 = { exports: {} }, p3;
function fE() {
  return p3 || (p3 = 1, function(n, t) {
    var e;
    e = /* @__PURE__ */ u(() => (() => {
      var gl, vl, bl, Ol, $l, xl, kl, Sl, Pl, Cl, Ql, Ml, fs, Tl, Al, Rl, El, zl, ys, _l, Ll, Il, Zl, ba, Wl, Dl, ql, Vl, jl, Fl, Ul, Bl, Oa, Xl, Nl, Hl;
      var i = { d: /* @__PURE__ */ u((B, g) => {
        for (var S in g) i.o(g, S) && !i.o(B, S) && Object.defineProperty(B, S, { enumerable: !0, get: g[S] });
      }, "d") };
      i.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), i.o = (B, g) => Object.prototype.hasOwnProperty.call(B, g), i.r = (B) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(B, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(B, "t", { value: !0 });
      };
      var s, r = {};
      i.r(r), i.d(r, { AbortError: /* @__PURE__ */ u(() => p, "AbortError"), DefaultHttpClient: /* @__PURE__ */ u(() => lC, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ u(() => V, "HttpClient"), HttpError: /* @__PURE__ */ u(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ u(() => Z, "HttpResponse"), HttpTransportType: /* @__PURE__ */ u(() => xe, "HttpTransportType"), HubConnection: /* @__PURE__ */ u(() => mC, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ u(() => vZ, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ u(() => Gt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ u(() => TC, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ u(() => s, "LogLevel"), MessageType: /* @__PURE__ */ u(() => St, "MessageType"), NullLogger: /* @__PURE__ */ u(() => G, "NullLogger"), Subject: /* @__PURE__ */ u(() => uC, "Subject"), TimeoutError: /* @__PURE__ */ u(() => c, "TimeoutError"), TransferFormat: /* @__PURE__ */ u(() => Be, "TransferFormat"), VERSION: /* @__PURE__ */ u(() => X, "VERSION") });
      const a = (gl = class extends Error {
        constructor(g, S) {
          const E = new.target.prototype;
          super(`${g}: Status code '${S}'`), this.statusCode = S, this.__proto__ = E;
        }
      }, h(gl, "jd"), gl);
      u(a, "i");
      let o = a;
      const l = (vl = class extends Error {
        constructor(g = "A timeout occurred.") {
          const S = new.target.prototype;
          super(g), this.__proto__ = S;
        }
      }, h(vl, "Wd"), vl);
      u(l, "n");
      let c = l;
      const d = (bl = class extends Error {
        constructor(g = "An abort occurred.") {
          const S = new.target.prototype;
          super(g), this.__proto__ = S;
        }
      }, h(bl, "Qd"), bl);
      u(d, "r");
      let p = d;
      const f = (Ol = class extends Error {
        constructor(g, S) {
          const E = new.target.prototype;
          super(g), this.transport = S, this.errorType = "UnsupportedTransportError", this.__proto__ = E;
        }
      }, h(Ol, "Kd"), Ol);
      u(f, "o");
      let m = f;
      const w = ($l = class extends Error {
        constructor(g, S) {
          const E = new.target.prototype;
          super(g), this.transport = S, this.errorType = "DisabledTransportError", this.__proto__ = E;
        }
      }, h($l, "Gd"), $l);
      u(w, "h");
      let b = w;
      const x = (xl = class extends Error {
        constructor(g, S) {
          const E = new.target.prototype;
          super(g), this.transport = S, this.errorType = "FailedToStartTransportError", this.__proto__ = E;
        }
      }, h(xl, "Zd"), xl);
      u(x, "c");
      let O = x;
      const P = (kl = class extends Error {
        constructor(g) {
          const S = new.target.prototype;
          super(g), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = S;
        }
      }, h(kl, "Yd"), kl);
      u(P, "a");
      let A = P;
      const R = (Sl = class extends Error {
        constructor(g, S) {
          const E = new.target.prototype;
          super(g), this.innerErrors = S, this.__proto__ = E;
        }
      }, h(Sl, "Xd"), Sl);
      u(R, "l");
      let T = R;
      const I = (Pl = class {
        constructor(g, S, E) {
          this.statusCode = g, this.statusText = S, this.content = E;
        }
      }, h(Pl, "Jd"), Pl);
      u(I, "u");
      let Z = I;
      const W = (Cl = class {
        get(g, S) {
          return this.send({ ...S, method: "GET", url: g });
        }
        post(g, S) {
          return this.send({ ...S, method: "POST", url: g });
        }
        delete(g, S) {
          return this.send({ ...S, method: "DELETE", url: g });
        }
        getCookieString(g) {
          return "";
        }
      }, h(Cl, "th"), Cl);
      u(W, "d");
      let V = W;
      (function(B) {
        B[B.Trace = 0] = "Trace", B[B.Debug = 1] = "Debug", B[B.Information = 2] = "Information", B[B.Warning = 3] = "Warning", B[B.Error = 4] = "Error", B[B.Critical = 5] = "Critical", B[B.None = 6] = "None";
      })(s || (s = {}));
      const Y = (Ql = class {
        constructor() {
        }
        log(g, S) {
        }
      }, h(Ql, "eh"), Ql);
      u(Y, "f");
      let G = Y;
      G.instance = new G();
      const X = "8.0.7", st = (Ml = class {
        static isRequired(g, S) {
          if (g == null) throw new Error(`The '${S}' argument is required.`);
        }
        static isNotEmpty(g, S) {
          if (!g || g.match(/^\s*$/)) throw new Error(`The '${S}' argument should not be empty.`);
        }
        static isIn(g, S, E) {
          if (!(g in S)) throw new Error(`Unknown ${E} value: ${g}.`);
        }
      }, h(Ml, "ih"), Ml);
      u(st, "w");
      let tt = st;
      const Qt = (fs = class {
        static get isBrowser() {
          return !fs.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !fs.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !fs.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      }, h(fs, "Sr"), fs);
      u(Qt, "g");
      let vt = Qt;
      function It(B, g) {
        let S = "";
        return Wt(B) ? (S = `Binary data of length ${B.byteLength}`, g && (S += `. Content: '${function(E) {
          const z = new Uint8Array(E);
          let D = "";
          return z.forEach((j) => {
            D += `0x${j < 16 ? "0" : ""}${j.toString(16)} `;
          }), D.substr(0, D.length - 1);
        }(B)}'`)) : typeof B == "string" && (S = `String data of length ${B.length}`, g && (S += `. Content: '${B}'`)), S;
      }
      h(It, "q"), u(It, "m");
      function Wt(B) {
        return B && typeof ArrayBuffer < "u" && (B instanceof ArrayBuffer || B.constructor && B.constructor.name === "ArrayBuffer");
      }
      h(Wt, "R"), u(Wt, "y");
      async function Dt(B, g, S, E, z, D) {
        const j = {}, [ct, ht] = fe();
        j[ct] = ht, B.log(s.Trace, `(${g} transport) sending data. ${It(z, D.logMessageContent)}.`);
        const Tt = Wt(z) ? "arraybuffer" : "text", Ht = await S.post(E, { content: z, headers: { ...j, ...D.headers }, responseType: Tt, timeout: D.timeout, withCredentials: D.withCredentials });
        B.log(s.Trace, `(${g} transport) request complete. Response status: ${Ht.statusCode}.`);
      }
      h(Dt, "D"), u(Dt, "b");
      const bi = (Tl = class {
        constructor(g, S) {
          this.i = g, this.h = S;
        }
        dispose() {
          const g = this.i.observers.indexOf(this.h);
          g > -1 && this.i.observers.splice(g, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch((S) => {
          });
        }
      }, h(Tl, "sh"), Tl);
      u(bi, "v");
      let Ee = bi;
      const le = (Al = class {
        constructor(g) {
          this.l = g, this.out = console;
        }
        log(g, S) {
          if (g >= this.l) {
            const E = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${s[g]}: ${S}`;
            switch (g) {
              case s.Critical:
              case s.Error:
                this.out.error(E);
                break;
              case s.Warning:
                this.out.warn(E);
                break;
              case s.Information:
                this.out.info(E);
                break;
              default:
                this.out.log(E);
            }
          }
        }
      }, h(Al, "rh"), Al);
      u(le, "E");
      let ee = le;
      function fe() {
        let B = "X-SignalR-User-Agent";
        return vt.isNode && (B = "User-Agent"), [B, Oi(X, _i(), vt.isNode ? "NodeJS" : "Browser", Hi())];
      }
      h(fe, "F"), u(fe, "$");
      function Oi(B, g, S, E) {
        let z = "Microsoft SignalR/";
        const D = B.split(".");
        return z += `${D[0]}.${D[1]}`, z += ` (${B}; `, z += g && g !== "" ? `${g}; ` : "Unknown OS; ", z += `${S}`, z += E ? `; ${E}` : "; Unknown Runtime Version", z += ")", z;
      }
      h(Oi, "N"), u(Oi, "C");
      function _i() {
        if (!vt.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      h(_i, "tt"), u(_i, "S");
      function Hi() {
        if (vt.isNode) return process.versions.node;
      }
      h(Hi, "pt"), u(Hi, "k");
      function Nt(B) {
        return B.stack ? B.stack : B.message ? B.message : `${B}`;
      }
      h(Nt, "X"), u(Nt, "P");
      const pn = (Rl = class extends V {
        constructor(g) {
          if (super(), this.u = g, typeof fetch > "u" || vt.isNode) {
            const S = w1;
            this.p = new (S("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = S("node-fetch") : this.m = fetch, this.m = S("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind(function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (i.g !== void 0) return i.g;
            throw new Error("could not find global");
          }());
          if (typeof AbortController > "u") {
            const S = w1;
            this.v = S("abort-controller");
          } else this.v = AbortController;
        }
        async send(g) {
          if (g.abortSignal && g.abortSignal.aborted) throw new p();
          if (!g.method) throw new Error("No method defined.");
          if (!g.url) throw new Error("No url defined.");
          const S = new this.v();
          let E;
          g.abortSignal && (g.abortSignal.onabort = () => {
            S.abort(), E = new p();
          });
          let z, D = null;
          if (g.timeout) {
            const ht = g.timeout;
            D = setTimeout(() => {
              S.abort(), this.u.log(s.Warning, "Timeout from HTTP request."), E = new c();
            }, ht);
          }
          g.content === "" && (g.content = void 0), g.content && (g.headers = g.headers || {}, Wt(g.content) ? g.headers["Content-Type"] = "application/octet-stream" : g.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            z = await this.m(g.url, { body: g.content, cache: "no-cache", credentials: g.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...g.headers }, method: g.method, mode: "cors", redirect: "follow", signal: S.signal });
          } catch (ht) {
            throw E || (this.u.log(s.Warning, `Error from HTTP request. ${ht}.`), ht);
          } finally {
            D && clearTimeout(D), g.abortSignal && (g.abortSignal.onabort = null);
          }
          if (!z.ok) {
            const ht = await wl(z, "text");
            throw new o(ht || z.statusText, z.status);
          }
          const j = wl(z, g.responseType), ct = await j;
          return new Z(z.status, z.statusText, ct);
        }
        getCookieString(g) {
          let S = "";
          return vt.isNode && this.p && this.p.getCookies(g, (E, z) => S = z.join("; ")), S;
        }
      }, h(Rl, "nh"), Rl);
      u(pn, "T");
      let ga = pn;
      function wl(B, g) {
        let S;
        switch (g) {
          case "arraybuffer":
            S = B.arrayBuffer();
            break;
          case "text":
          default:
            S = B.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${g} is not supported.`);
        }
        return S;
      }
      h(wl, "Vt"), u(wl, "I");
      const aC = (El = class extends V {
        constructor(g) {
          super(), this.u = g;
        }
        send(g) {
          return g.abortSignal && g.abortSignal.aborted ? Promise.reject(new p()) : g.method ? g.url ? new Promise((S, E) => {
            const z = new XMLHttpRequest();
            z.open(g.method, g.url, !0), z.withCredentials = g.withCredentials === void 0 || g.withCredentials, z.setRequestHeader("X-Requested-With", "XMLHttpRequest"), g.content === "" && (g.content = void 0), g.content && (Wt(g.content) ? z.setRequestHeader("Content-Type", "application/octet-stream") : z.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const D = g.headers;
            D && Object.keys(D).forEach((j) => {
              z.setRequestHeader(j, D[j]);
            }), g.responseType && (z.responseType = g.responseType), g.abortSignal && (g.abortSignal.onabort = () => {
              z.abort(), E(new p());
            }), g.timeout && (z.timeout = g.timeout), z.onload = () => {
              g.abortSignal && (g.abortSignal.onabort = null), z.status >= 200 && z.status < 300 ? S(new Z(z.status, z.statusText, z.response || z.responseText)) : E(new o(z.response || z.responseText || z.statusText, z.status));
            }, z.onerror = () => {
              this.u.log(s.Warning, `Error from HTTP request. ${z.status}: ${z.statusText}.`), E(new o(z.statusText, z.status));
            }, z.ontimeout = () => {
              this.u.log(s.Warning, "Timeout from HTTP request."), E(new c());
            }, z.send(g.content);
          }) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      }, h(El, "ah"), El);
      u(aC, "_");
      let oZ = aC;
      const oC = (zl = class extends V {
        constructor(g) {
          if (super(), typeof fetch < "u" || vt.isNode) this.$ = new ga(g);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new oZ(g);
          }
        }
        send(g) {
          return g.abortSignal && g.abortSignal.aborted ? Promise.reject(new p()) : g.method ? g.url ? this.$.send(g) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(g) {
          return this.$.getCookieString(g);
        }
      }, h(zl, "oh"), zl);
      u(oC, "H");
      let lC = oC;
      const cC = (ys = class {
        static write(g) {
          return `${g}${ys.RecordSeparator}`;
        }
        static parse(g) {
          if (g[g.length - 1] !== ys.RecordSeparator) throw new Error("Message is incomplete.");
          const S = g.split(ys.RecordSeparator);
          return S.pop(), S;
        }
      }, h(ys, "Ar"), ys);
      u(cC, "D");
      let ps = cC;
      ps.RecordSeparatorCode = 30, ps.RecordSeparator = String.fromCharCode(ps.RecordSeparatorCode);
      const hC = (_l = class {
        writeHandshakeRequest(g) {
          return ps.write(JSON.stringify(g));
        }
        parseHandshakeResponse(g) {
          let S, E;
          if (Wt(g)) {
            const j = new Uint8Array(g), ct = j.indexOf(ps.RecordSeparatorCode);
            if (ct === -1) throw new Error("Message is incomplete.");
            const ht = ct + 1;
            S = String.fromCharCode.apply(null, Array.prototype.slice.call(j.slice(0, ht))), E = j.byteLength > ht ? j.slice(ht).buffer : null;
          } else {
            const j = g, ct = j.indexOf(ps.RecordSeparator);
            if (ct === -1) throw new Error("Message is incomplete.");
            const ht = ct + 1;
            S = j.substring(0, ht), E = j.length > ht ? j.substring(ht) : null;
          }
          const z = ps.parse(S), D = JSON.parse(z[0]);
          if (D.type) throw new Error("Expected a handshake response from the server.");
          return [E, D];
        }
      }, h(_l, "ch"), _l);
      u(hC, "R");
      let lZ = hC;
      var St, Gt;
      (function(B) {
        B[B.Invocation = 1] = "Invocation", B[B.StreamItem = 2] = "StreamItem", B[B.Completion = 3] = "Completion", B[B.StreamInvocation = 4] = "StreamInvocation", B[B.CancelInvocation = 5] = "CancelInvocation", B[B.Ping = 6] = "Ping", B[B.Close = 7] = "Close", B[B.Ack = 8] = "Ack", B[B.Sequence = 9] = "Sequence";
      })(St || (St = {}));
      const dC = (Ll = class {
        constructor() {
          this.observers = [];
        }
        next(g) {
          for (const S of this.observers) S.next(g);
        }
        error(g) {
          for (const S of this.observers) S.error && S.error(g);
        }
        complete() {
          for (const g of this.observers) g.complete && g.complete();
        }
        subscribe(g) {
          return this.observers.push(g), new Ee(this, g);
        }
      }, h(Ll, "lh"), Ll);
      u(dC, "U");
      let uC = dC;
      const pC = (Il = class {
        constructor(g, S, E) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = g, this.R = S, this.C = E;
        }
        async A(g) {
          const S = this.D.writeMessage(g);
          let E = Promise.resolve();
          if (this.U(g)) {
            this.k++;
            let z = /* @__PURE__ */ u(() => {
            }, "t"), D = /* @__PURE__ */ u(() => {
            }, "i");
            Wt(S) ? this._ += S.byteLength : this._ += S.length, this._ >= this.C && (E = new Promise((j, ct) => {
              z = j, D = ct;
            })), this.S.push(new hZ(S, this.k, z, D));
          }
          try {
            this.H || await this.R.send(S);
          } catch {
            this.L();
          }
          await E;
        }
        N(g) {
          let S = -1;
          for (let E = 0; E < this.S.length; E++) {
            const z = this.S[E];
            if (z.q <= g.sequenceId) S = E, Wt(z.M) ? this._ -= z.M.byteLength : this._ -= z.M.length, z.j();
            else {
              if (!(this._ < this.C)) break;
              z.j();
            }
          }
          S !== -1 && (this.S = this.S.slice(S + 1));
        }
        W(g) {
          if (this.P) return g.type === St.Sequence && (this.P = !1, !0);
          if (!this.U(g)) return !0;
          const S = this.T;
          return this.T++, S <= this.I ? (S === this.I && this.O(), !1) : (this.I = S, this.O(), !0);
        }
        F(g) {
          g.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = g.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const g = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: St.Sequence, sequenceId: g }));
          const S = this.S;
          for (const E of S) await this.R.send(E.M);
          this.H = !1;
        }
        X(g) {
          g != null || (g = new Error("Unable to reconnect to server."));
          for (const S of this.S) S.J(g);
        }
        U(g) {
          switch (g.type) {
            case St.Invocation:
            case St.StreamItem:
            case St.Completion:
            case St.StreamInvocation:
            case St.CancelInvocation:
              return !0;
            case St.Close:
            case St.Sequence:
            case St.Ping:
            case St.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout(async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: St.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }, 1e3));
        }
      }, h(Il, "dh"), Il);
      u(pC, "L");
      let cZ = pC;
      const fC = (Zl = class {
        constructor(g, S, E, z) {
          this.M = g, this.q = S, this.j = E, this.J = z;
        }
      }, h(Zl, "hh"), Zl);
      u(fC, "N");
      let hZ = fC;
      (function(B) {
        B.Disconnected = "Disconnected", B.Connecting = "Connecting", B.Connected = "Connected", B.Disconnecting = "Disconnecting", B.Reconnecting = "Reconnecting";
      })(Gt || (Gt = {}));
      const yC = (ba = class {
        static create(g, S, E, z, D, j, ct) {
          return new ba(g, S, E, z, D, j, ct);
        }
        constructor(g, S, E, z, D, j, ct) {
          this.K = 0, this.G = () => {
            this.u.log(s.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, tt.isRequired(g, "connection"), tt.isRequired(S, "logger"), tt.isRequired(E, "protocol"), this.serverTimeoutInMilliseconds = D ?? 3e4, this.keepAliveIntervalInMilliseconds = j ?? 15e3, this.Y = ct ?? 1e5, this.u = S, this.D = E, this.connection = g, this.Z = z, this.tt = new lZ(), this.connection.onreceive = (ht) => this.et(ht), this.connection.onclose = (ht) => this.st(ht), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = Gt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: St.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(g) {
          if (this.ut !== Gt.Disconnected && this.ut !== Gt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!g) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = g;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== Gt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = Gt.Connecting, this.u.log(s.Debug, "Starting HubConnection.");
          try {
            await this.yt(), vt.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = Gt.Connected, this.dt = !0, this.u.log(s.Debug, "HubConnection connected successfully.");
          } catch (g) {
            return this.ut = Gt.Disconnected, this.u.log(s.Debug, `HubConnection failed to start successfully because of error '${g}'.`), Promise.reject(g);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const g = new Promise((S, E) => {
            this.vt = S, this.Et = E;
          });
          await this.connection.start(this.D.transferFormat);
          try {
            let S = this.D.version;
            this.connection.features.reconnect || (S = 1);
            const E = { protocol: this.D.name, version: S };
            if (this.u.log(s.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(E)), this.u.log(s.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await g, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new cZ(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (S) {
            throw this.u.log(s.Debug, `Hub handshake failed with error '${S}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(S), S;
          }
        }
        async stop() {
          const g = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await g;
          } catch {
          }
        }
        _t(g) {
          if (this.ut === Gt.Disconnected) return this.u.log(s.Debug, `Call to HubConnection.stop(${g}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === Gt.Disconnecting) return this.u.log(s.Debug, `Call to HttpConnection.stop(${g}) ignored because the connection is already in the disconnecting state.`), this.It;
          const S = this.ut;
          return this.ut = Gt.Disconnecting, this.u.log(s.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(s.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (S === Gt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = g || new p("The connection was stopped before the hub handshake could complete."), this.connection.stop(g));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(g, ...S) {
          const [E, z] = this.Ut(S), D = this.Lt(g, S, z);
          let j;
          const ct = new uC();
          return ct.cancelCallback = () => {
            const ht = this.Nt(D.invocationId);
            return delete this.it[D.invocationId], j.then(() => this.xt(ht));
          }, this.it[D.invocationId] = (ht, Tt) => {
            Tt ? ct.error(Tt) : ht && (ht.type === St.Completion ? ht.error ? ct.error(new Error(ht.error)) : ct.complete() : ct.next(ht.item));
          }, j = this.xt(D).catch((ht) => {
            ct.error(ht), delete this.it[D.invocationId];
          }), this.qt(E, j), ct;
        }
        $t(g) {
          return this.kt(), this.connection.send(g);
        }
        xt(g) {
          return this.Pt ? this.Pt.A(g) : this.$t(this.D.writeMessage(g));
        }
        send(g, ...S) {
          const [E, z] = this.Ut(S), D = this.xt(this.Mt(g, S, !0, z));
          return this.qt(E, D), D;
        }
        invoke(g, ...S) {
          const [E, z] = this.Ut(S), D = this.Mt(g, S, !1, z);
          return new Promise((j, ct) => {
            this.it[D.invocationId] = (Tt, Ht) => {
              Ht ? ct(Ht) : Tt && (Tt.type === St.Completion ? Tt.error ? ct(new Error(Tt.error)) : j(Tt.result) : ct(new Error(`Unexpected message type: ${Tt.type}`)));
            };
            const ht = this.xt(D).catch((Tt) => {
              ct(Tt), delete this.it[D.invocationId];
            });
            this.qt(E, ht);
          });
        }
        on(g, S) {
          g && S && (g = g.toLowerCase(), this.nt[g] || (this.nt[g] = []), this.nt[g].indexOf(S) === -1 && this.nt[g].push(S));
        }
        off(g, S) {
          if (!g) return;
          g = g.toLowerCase();
          const E = this.nt[g];
          if (E) if (S) {
            const z = E.indexOf(S);
            z !== -1 && (E.splice(z, 1), E.length === 0 && delete this.nt[g]);
          } else delete this.nt[g];
        }
        onclose(g) {
          g && this.rt.push(g);
        }
        onreconnecting(g) {
          g && this.ot.push(g);
        }
        onreconnected(g) {
          g && this.ht.push(g);
        }
        et(g) {
          if (this.Ct(), this.lt || (g = this.jt(g), this.lt = !0), g) {
            const S = this.D.parseMessages(g, this.u);
            for (const E of S) if (!this.Pt || this.Pt.W(E)) switch (E.type) {
              case St.Invocation:
                this.Wt(E).catch((z) => {
                  this.u.log(s.Error, `Invoke client method threw error: ${Nt(z)}`);
                });
                break;
              case St.StreamItem:
              case St.Completion: {
                const z = this.it[E.invocationId];
                if (z) {
                  E.type === St.Completion && delete this.it[E.invocationId];
                  try {
                    z(E);
                  } catch (D) {
                    this.u.log(s.Error, `Stream callback threw error: ${Nt(D)}`);
                  }
                }
                break;
              }
              case St.Ping:
                break;
              case St.Close: {
                this.u.log(s.Information, "Close message received from server.");
                const z = E.error ? new Error("Server returned an error on close: " + E.error) : void 0;
                E.allowReconnect === !0 ? this.connection.stop(z) : this.It = this._t(z);
                break;
              }
              case St.Ack:
                this.Pt && this.Pt.N(E);
                break;
              case St.Sequence:
                this.Pt && this.Pt.F(E);
                break;
              default:
                this.u.log(s.Warning, `Invalid message type: ${E.type}.`);
            }
          }
          this.St();
        }
        jt(g) {
          let S, E;
          try {
            [E, S] = this.tt.parseHandshakeResponse(g);
          } catch (z) {
            const D = "Error parsing handshake response: " + z;
            this.u.log(s.Error, D);
            const j = new Error(D);
            throw this.Et(j), j;
          }
          if (S.error) {
            const z = "Server returned handshake error: " + S.error;
            this.u.log(s.Error, z);
            const D = new Error(z);
            throw this.Et(D), D;
          }
          return this.u.log(s.Debug, "Server handshake complete."), this.vt(), E;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let g = this.K - (/* @__PURE__ */ new Date()).getTime();
            g < 0 && (g = 0), this.Ft = setTimeout(async () => {
              if (this.ut === Gt.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }, g);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(g) {
          const S = g.target.toLowerCase(), E = this.nt[S];
          if (!E) return this.u.log(s.Warning, `No client method with the name '${S}' found.`), void (g.invocationId && (this.u.log(s.Warning, `No result given for '${S}' method and invocation ID '${g.invocationId}'.`), await this.xt(this.Bt(g.invocationId, "Client didn't provide a result.", null))));
          const z = E.slice(), D = !!g.invocationId;
          let j, ct, ht;
          for (const Tt of z) try {
            const Ht = j;
            j = await Tt.apply(this, g.arguments), D && j && Ht && (this.u.log(s.Error, `Multiple results provided for '${S}'. Sending error to server.`), ht = this.Bt(g.invocationId, "Client provided multiple results.", null)), ct = void 0;
          } catch (Ht) {
            ct = Ht, this.u.log(s.Error, `A callback for the method '${S}' threw error '${Ht}'.`);
          }
          ht ? await this.xt(ht) : D ? (ct ? ht = this.Bt(g.invocationId, `${ct}`, null) : j !== void 0 ? ht = this.Bt(g.invocationId, null, j) : (this.u.log(s.Warning, `No result given for '${S}' method and invocation ID '${g.invocationId}'.`), ht = this.Bt(g.invocationId, "Client didn't provide a result.", null)), await this.xt(ht)) : j && this.u.log(s.Error, `Result given for '${S}' method but server is not expecting a result.`);
        }
        st(g) {
          this.u.log(s.Debug, `HubConnection.connectionClosed(${g}) called while in state ${this.ut}.`), this.bt = this.bt || g || new p("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(g || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === Gt.Disconnecting ? this.Dt(g) : this.ut === Gt.Connected && this.Z ? this.Jt(g) : this.ut === Gt.Connected && this.Dt(g);
        }
        Dt(g) {
          if (this.dt) {
            this.ut = Gt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(g ?? new Error("Connection closed.")), this.Pt = void 0), vt.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach((S) => S.apply(this, [g]));
            } catch (S) {
              this.u.log(s.Error, `An onclose callback called with error '${g}' threw error '${S}'.`);
            }
          }
        }
        async Jt(g) {
          const S = Date.now();
          let E = 0, z = g !== void 0 ? g : new Error("Attempting to reconnect due to a unknown error."), D = this.zt(E++, 0, z);
          if (D === null) return this.u.log(s.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(g);
          if (this.ut = Gt.Reconnecting, g ? this.u.log(s.Information, `Connection reconnecting because of error '${g}'.`) : this.u.log(s.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach((j) => j.apply(this, [g]));
            } catch (j) {
              this.u.log(s.Error, `An onreconnecting callback called with error '${g}' threw error '${j}'.`);
            }
            if (this.ut !== Gt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; D !== null; ) {
            if (this.u.log(s.Information, `Reconnect attempt number ${E} will start in ${D} ms.`), await new Promise((j) => {
              this.Ht = setTimeout(j, D);
            }), this.Ht = void 0, this.ut !== Gt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = Gt.Connected, this.u.log(s.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach((j) => j.apply(this, [this.connection.connectionId]));
              } catch (j) {
                this.u.log(s.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${j}'.`);
              }
              return;
            } catch (j) {
              if (this.u.log(s.Information, `Reconnect attempt failed because of error '${j}'.`), this.ut !== Gt.Reconnecting) return this.u.log(s.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === Gt.Disconnecting && this.Dt());
              z = j instanceof Error ? j : new Error(j.toString()), D = this.zt(E++, Date.now() - S, z);
            }
          }
          this.u.log(s.Information, `Reconnect retries have been exhausted after ${Date.now() - S} ms and ${E} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(g, S, E) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: S, previousRetryCount: g, retryReason: E });
          } catch (z) {
            return this.u.log(s.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${g}, ${S}) threw error '${z}'.`), null;
          }
        }
        Xt(g) {
          const S = this.it;
          this.it = {}, Object.keys(S).forEach((E) => {
            const z = S[E];
            try {
              z(null, g);
            } catch (D) {
              this.u.log(s.Error, `Stream 'error' callback called with '${g}' threw error: ${Nt(D)}`);
            }
          });
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(g, S, E, z) {
          if (E) return z.length !== 0 ? { arguments: S, streamIds: z, target: g, type: St.Invocation } : { arguments: S, target: g, type: St.Invocation };
          {
            const D = this.ct;
            return this.ct++, z.length !== 0 ? { arguments: S, invocationId: D.toString(), streamIds: z, target: g, type: St.Invocation } : { arguments: S, invocationId: D.toString(), target: g, type: St.Invocation };
          }
        }
        qt(g, S) {
          if (g.length !== 0) {
            S || (S = Promise.resolve());
            for (const E in g) g[E].subscribe({ complete: /* @__PURE__ */ u(() => {
              S = S.then(() => this.xt(this.Bt(E)));
            }, "complete"), error: /* @__PURE__ */ u((z) => {
              let D;
              D = z instanceof Error ? z.message : z && z.toString ? z.toString() : "Unknown error", S = S.then(() => this.xt(this.Bt(E, D)));
            }, "error"), next: /* @__PURE__ */ u((z) => {
              S = S.then(() => this.xt(this.Vt(E, z)));
            }, "next") });
          }
        }
        Ut(g) {
          const S = [], E = [];
          for (let z = 0; z < g.length; z++) {
            const D = g[z];
            if (this.Kt(D)) {
              const j = this.ct;
              this.ct++, S[j] = D, E.push(j.toString()), g.splice(z, 1);
            }
          }
          return [S, E];
        }
        Kt(g) {
          return g && g.subscribe && typeof g.subscribe == "function";
        }
        Lt(g, S, E) {
          const z = this.ct;
          return this.ct++, E.length !== 0 ? { arguments: S, invocationId: z.toString(), streamIds: E, target: g, type: St.StreamInvocation } : { arguments: S, invocationId: z.toString(), target: g, type: St.StreamInvocation };
        }
        Nt(g) {
          return { invocationId: g, type: St.CancelInvocation };
        }
        Vt(g, S) {
          return { invocationId: g, item: S, type: St.StreamItem };
        }
        Bt(g, S, E) {
          return S ? { error: S, invocationId: g, type: St.Completion } : { invocationId: g, result: E, type: St.Completion };
        }
        At() {
          return { type: St.Close };
        }
      }, h(ba, "$l"), ba);
      u(yC, "q");
      let mC = yC;
      const dZ = [0, 2e3, 1e4, 3e4, null], wC = (Wl = class {
        constructor(g) {
          this.Gt = g !== void 0 ? [...g, null] : dZ;
        }
        nextRetryDelayInMilliseconds(g) {
          return this.Gt[g.previousRetryCount];
        }
      }, h(Wl, "uh"), Wl);
      u(wC, "j");
      let gC = wC;
      const vC = (Dl = class {
      }, h(Dl, "ph"), Dl);
      u(vC, "W");
      let va = vC;
      va.Authorization = "Authorization", va.Cookie = "Cookie";
      const bC = (ql = class extends V {
        constructor(g, S) {
          super(), this.Qt = g, this.Yt = S;
        }
        async send(g) {
          let S = !0;
          this.Yt && (!this.Zt || g.url && g.url.indexOf("/negotiate?") > 0) && (S = !1, this.Zt = await this.Yt()), this.te(g);
          const E = await this.Qt.send(g);
          return S && E.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(g), await this.Qt.send(g)) : E;
        }
        te(g) {
          g.headers || (g.headers = {}), this.Zt ? g.headers[va.Authorization] = `Bearer ${this.Zt}` : this.Yt && g.headers[va.Authorization] && delete g.headers[va.Authorization];
        }
        getCookieString(g) {
          return this.Qt.getCookieString(g);
        }
      }, h(ql, "yh"), ql);
      u(bC, "O");
      let uZ = bC;
      var xe, Be;
      (function(B) {
        B[B.None = 0] = "None", B[B.WebSockets = 1] = "WebSockets", B[B.ServerSentEvents = 2] = "ServerSentEvents", B[B.LongPolling = 4] = "LongPolling";
      })(xe || (xe = {})), function(B) {
        B[B.Text = 1] = "Text", B[B.Binary = 2] = "Binary";
      }(Be || (Be = {}));
      const OC = (Vl = class {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      }, h(Vl, "wh"), Vl);
      u(OC, "X");
      let pZ = OC;
      const $C = (jl = class {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(g, S, E) {
          this.$ = g, this.u = S, this.se = new pZ(), this.ie = E, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(g, S) {
          if (tt.isRequired(g, "url"), tt.isRequired(S, "transferFormat"), tt.isIn(S, Be, "transferFormat"), this.re = g, this.u.log(s.Trace, "(LongPolling transport) Connecting."), S === Be.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [E, z] = fe(), D = { [E]: z, ...this.ie.headers }, j = { abortSignal: this.se.signal, headers: D, timeout: 1e5, withCredentials: this.ie.withCredentials };
          S === Be.Binary && (j.responseType = "arraybuffer");
          const ct = `${g}&_=${Date.now()}`;
          this.u.log(s.Trace, `(LongPolling transport) polling: ${ct}.`);
          const ht = await this.$.get(ct, j);
          ht.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${ht.statusCode}.`), this.oe = new o(ht.statusText || "", ht.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, j);
        }
        async ce(g, S) {
          try {
            for (; this.ne; ) try {
              const E = `${g}&_=${Date.now()}`;
              this.u.log(s.Trace, `(LongPolling transport) polling: ${E}.`);
              const z = await this.$.get(E, S);
              z.statusCode === 204 ? (this.u.log(s.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : z.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${z.statusCode}.`), this.oe = new o(z.statusText || "", z.statusCode), this.ne = !1) : z.content ? (this.u.log(s.Trace, `(LongPolling transport) data received. ${It(z.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(z.content)) : this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (E) {
              this.ne ? E instanceof c ? this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = E, this.ne = !1) : this.u.log(s.Trace, `(LongPolling transport) Poll errored after shutdown: ${E.message}`);
            }
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(g) {
          return this.ne ? Dt(this.u, "LongPolling", this.$, this.re, g, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(s.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(s.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const g = {}, [S, E] = fe();
            g[S] = E;
            const z = { headers: { ...g, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let D;
            try {
              await this.$.delete(this.re, z);
            } catch (j) {
              D = j;
            }
            D ? D instanceof o && (D.statusCode === 404 ? this.u.log(s.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(s.Trace, `(LongPolling transport) Error sending a DELETE request: ${D}`)) : this.u.log(s.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let g = "(LongPolling transport) Firing onclose event.";
            this.oe && (g += " Error: " + this.oe), this.u.log(s.Trace, g), this.onclose(this.oe);
          }
        }
      }, h(jl, "fh"), jl);
      u($C, "J");
      let xC = $C;
      const kC = (Fl = class {
        constructor(g, S, E, z) {
          this.$ = g, this.Zt = S, this.u = E, this.ie = z, this.onreceive = null, this.onclose = null;
        }
        async connect(g, S) {
          return tt.isRequired(g, "url"), tt.isRequired(S, "transferFormat"), tt.isIn(S, Be, "transferFormat"), this.u.log(s.Trace, "(SSE transport) Connecting."), this.re = g, this.Zt && (g += (g.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise((E, z) => {
            let D, j = !1;
            if (S === Be.Text) {
              if (vt.isBrowser || vt.isWebWorker) D = new this.ie.EventSource(g, { withCredentials: this.ie.withCredentials });
              else {
                const ct = this.$.getCookieString(g), ht = {};
                ht.Cookie = ct;
                const [Tt, Ht] = fe();
                ht[Tt] = Ht, D = new this.ie.EventSource(g, { withCredentials: this.ie.withCredentials, headers: { ...ht, ...this.ie.headers } });
              }
              try {
                D.onmessage = (ct) => {
                  if (this.onreceive) try {
                    this.u.log(s.Trace, `(SSE transport) data received. ${It(ct.data, this.ie.logMessageContent)}.`), this.onreceive(ct.data);
                  } catch (ht) {
                    return void this.le(ht);
                  }
                }, D.onerror = (ct) => {
                  j ? this.le() : z(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, D.onopen = () => {
                  this.u.log(s.Information, `SSE connected to ${this.re}`), this.ue = D, j = !0, E();
                };
              } catch (ct) {
                return void z(ct);
              }
            } else z(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          });
        }
        async send(g) {
          return this.ue ? Dt(this.u, "SSE", this.$, this.re, g, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(g) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(g));
        }
      }, h(Fl, "mh"), Fl);
      u(kC, "z");
      let fZ = kC;
      const SC = (Ul = class {
        constructor(g, S, E, z, D, j) {
          this.u = E, this.Yt = S, this.de = z, this.fe = D, this.$ = g, this.onreceive = null, this.onclose = null, this.pe = j;
        }
        async connect(g, S) {
          let E;
          return tt.isRequired(g, "url"), tt.isRequired(S, "transferFormat"), tt.isIn(S, Be, "transferFormat"), this.u.log(s.Trace, "(WebSockets transport) Connecting."), this.Yt && (E = await this.Yt()), new Promise((z, D) => {
            let j;
            g = g.replace(/^http/, "ws");
            const ct = this.$.getCookieString(g);
            let ht = !1;
            if (vt.isNode || vt.isReactNative) {
              const Tt = {}, [Ht, Yl] = fe();
              Tt[Ht] = Yl, E && (Tt[va.Authorization] = `Bearer ${E}`), ct && (Tt[va.Cookie] = ct), j = new this.fe(g, void 0, { headers: { ...Tt, ...this.pe } });
            } else E && (g += (g.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(E)}`);
            j || (j = new this.fe(g)), S === Be.Binary && (j.binaryType = "arraybuffer"), j.onopen = (Tt) => {
              this.u.log(s.Information, `WebSocket connected to ${g}.`), this.we = j, ht = !0, z();
            }, j.onerror = (Tt) => {
              let Ht = null;
              Ht = typeof ErrorEvent < "u" && Tt instanceof ErrorEvent ? Tt.error : "There was an error with the transport", this.u.log(s.Information, `(WebSockets transport) ${Ht}.`);
            }, j.onmessage = (Tt) => {
              if (this.u.log(s.Trace, `(WebSockets transport) data received. ${It(Tt.data, this.de)}.`), this.onreceive) try {
                this.onreceive(Tt.data);
              } catch (Ht) {
                return void this.le(Ht);
              }
            }, j.onclose = (Tt) => {
              if (ht) this.le(Tt);
              else {
                let Ht = null;
                Ht = typeof ErrorEvent < "u" && Tt instanceof ErrorEvent ? Tt.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", D(new Error(Ht));
              }
            };
          });
        }
        send(g) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(s.Trace, `(WebSockets transport) sending data. ${It(g, this.de)}.`), this.we.send(g), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(g) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(s.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(g) || g.wasClean !== !1 && g.code === 1e3 ? g instanceof Error ? this.onclose(g) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${g.code} (${g.reason || "no reason given"}).`)));
        }
        ge(g) {
          return g && typeof g.wasClean == "boolean" && typeof g.code == "number";
        }
      }, h(Ul, "vh"), Ul);
      u(SC, "V");
      let yZ = SC;
      const PC = (Bl = class {
        constructor(g, S = {}) {
          var E;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, tt.isRequired(g, "url"), this.u = (E = S.logger) === void 0 ? new ee(s.Information) : E === null ? G.instance : E.log !== void 0 ? E : new ee(E), this.baseUrl = this.be(g), (S = S || {}).logMessageContent = S.logMessageContent !== void 0 && S.logMessageContent, typeof S.withCredentials != "boolean" && S.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          S.withCredentials = S.withCredentials === void 0 || S.withCredentials, S.timeout = S.timeout === void 0 ? 1e5 : S.timeout;
          let z = null, D = null;
          if (vt.isNode) {
            const j = w1;
            z = j("ws"), D = j("eventsource");
          }
          vt.isNode || typeof WebSocket > "u" || S.WebSocket ? vt.isNode && !S.WebSocket && z && (S.WebSocket = z) : S.WebSocket = WebSocket, vt.isNode || typeof EventSource > "u" || S.EventSource ? vt.isNode && !S.EventSource && D !== void 0 && (S.EventSource = D) : S.EventSource = EventSource, this.$ = new uZ(S.httpClient || new lC(this.u), S.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = S, this.onreceive = null, this.onclose = null;
        }
        async start(g) {
          if (g = g || Be.Binary, tt.isIn(g, Be, "transferFormat"), this.u.log(s.Debug, `Starting connection with transfer format '${Be[g]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(g), await this.ve, this.ut === "Disconnecting") {
            const S = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(s.Error, S), await this.It, Promise.reject(new p(S));
          }
          if (this.ut !== "Connected") {
            const S = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(s.Error, S), Promise.reject(new p(S));
          }
          this.dt = !0;
        }
        send(g) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new wZ(this.transport)), this.Ee.send(g));
        }
        async stop(g) {
          return this.ut === "Disconnected" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${g}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${g}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise((S) => {
            this.me = S;
          }), await this._t(g), void await this.It);
        }
        async _t(g) {
          this.$e = g;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (S) {
              this.u.log(s.Error, `HttpConnection.transport.stop() threw error '${S}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(s.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(g) {
          let S = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== xe.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(xe.WebSockets), await this.ke(S, g);
            } else {
              let E = null, z = 0;
              do {
                if (E = await this.Pe(S), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new p("The connection was stopped during negotiation.");
                if (E.error) throw new Error(E.error);
                if (E.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (E.url && (S = E.url), E.accessToken) {
                  const D = E.accessToken;
                  this.Yt = () => D, this.$.Zt = D, this.$.Yt = void 0;
                }
                z++;
              } while (E.url && z < 100);
              if (z === 100 && E.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(S, this.ie.transport, E, g);
            }
            this.transport instanceof xC && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(s.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (E) {
            return this.u.log(s.Error, "Failed to start the connection: " + E), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(E);
          }
        }
        async Pe(g) {
          const S = {}, [E, z] = fe();
          S[E] = z;
          const D = this.Ie(g);
          this.u.log(s.Debug, `Sending negotiation request: ${D}.`);
          try {
            const j = await this.$.post(D, { content: "", headers: { ...S, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (j.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${j.statusCode}'`));
            const ct = JSON.parse(j.content);
            return (!ct.negotiateVersion || ct.negotiateVersion < 1) && (ct.connectionToken = ct.connectionId), ct.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new A("Client didn't negotiate Stateful Reconnect but the server did.")) : ct;
          } catch (j) {
            let ct = "Failed to complete negotiation with the server: " + j;
            return j instanceof o && j.statusCode === 404 && (ct += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(s.Error, ct), Promise.reject(new A(ct));
          }
        }
        He(g, S) {
          return S ? g + (g.indexOf("?") === -1 ? "?" : "&") + `id=${S}` : g;
        }
        async Te(g, S, E, z) {
          let D = this.He(g, E.connectionToken);
          if (this.De(S)) return this.u.log(s.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = S, await this.ke(D, z), void (this.connectionId = E.connectionId);
          const j = [], ct = E.availableTransports || [];
          let ht = E;
          for (const Tt of ct) {
            const Ht = this.Re(Tt, S, z, (ht == null ? void 0 : ht.useStatefulReconnect) === !0);
            if (Ht instanceof Error) j.push(`${Tt.transport} failed:`), j.push(Ht);
            else if (this.De(Ht)) {
              if (this.transport = Ht, !ht) {
                try {
                  ht = await this.Pe(g);
                } catch (Yl) {
                  return Promise.reject(Yl);
                }
                D = this.He(g, ht.connectionToken);
              }
              try {
                return await this.ke(D, z), void (this.connectionId = ht.connectionId);
              } catch (Yl) {
                if (this.u.log(s.Error, `Failed to start the transport '${Tt.transport}': ${Yl}`), ht = void 0, j.push(new O(`${Tt.transport} failed: ${Yl}`, xe[Tt.transport])), this.ut !== "Connecting") {
                  const RC = "Failed to select transport before stop() was called.";
                  return this.u.log(s.Debug, RC), Promise.reject(new p(RC));
                }
              }
            }
          }
          return j.length > 0 ? Promise.reject(new T(`Unable to connect to the server with any of the available transports. ${j.join(" ")}`, j)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(g) {
          switch (g) {
            case xe.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new yZ(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case xe.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new fZ(this.$, this.$.Zt, this.u, this.ie);
            case xe.LongPolling:
              return new xC(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${g}.`);
          }
        }
        ke(g, S) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (E) => {
            let z = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(g, S), await this.features.resend();
              } catch {
                z = !0;
              }
              z && this.Ce(E);
            } else this.Ce(E);
          } : this.transport.onclose = (E) => this.Ce(E), this.transport.connect(g, S);
        }
        Re(g, S, E, z) {
          const D = xe[g.transport];
          if (D == null) return this.u.log(s.Debug, `Skipping transport '${g.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${g.transport}' because it is not supported by this client.`);
          if (!function(j, ct) {
            return !j || (ct & j) != 0;
          }(S, D)) return this.u.log(s.Debug, `Skipping transport '${xe[D]}' because it was disabled by the client.`), new b(`'${xe[D]}' is disabled by the client.`, D);
          if (!(g.transferFormats.map((j) => Be[j]).indexOf(E) >= 0)) return this.u.log(s.Debug, `Skipping transport '${xe[D]}' because it does not support the requested transfer format '${Be[E]}'.`), new Error(`'${xe[D]}' does not support ${Be[E]}.`);
          if (D === xe.WebSockets && !this.ie.WebSocket || D === xe.ServerSentEvents && !this.ie.EventSource) return this.u.log(s.Debug, `Skipping transport '${xe[D]}' because it is not supported in your environment.'`), new m(`'${xe[D]}' is not supported in your environment.`, D);
          this.u.log(s.Debug, `Selecting transport '${xe[D]}'.`);
          try {
            return this.features.reconnect = D === xe.WebSockets ? z : void 0, this.Se(D);
          } catch (j) {
            return j;
          }
        }
        De(g) {
          return g && typeof g == "object" && "connect" in g;
        }
        Ce(g) {
          if (this.u.log(s.Debug, `HttpConnection.stopConnection(${g}) called while in state ${this.ut}.`), this.transport = void 0, g = this.$e || g, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(s.Warning, `Call to HttpConnection.stopConnection(${g}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${g}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), g ? this.u.log(s.Error, `Connection disconnected with error '${g}'.`) : this.u.log(s.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch((S) => {
              this.u.log(s.Error, `TransportSendQueue.stop() threw error '${S}'.`);
            }), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(g);
              } catch (S) {
                this.u.log(s.Error, `HttpConnection.onclose(${g}) threw error '${S}'.`);
              }
            }
          } else this.u.log(s.Debug, `Call to HttpConnection.stopConnection(${g}) was ignored because the connection is already in the disconnected state.`);
        }
        be(g) {
          if (g.lastIndexOf("https://", 0) === 0 || g.lastIndexOf("http://", 0) === 0) return g;
          if (!vt.isBrowser) throw new Error(`Cannot resolve '${g}'.`);
          const S = window.document.createElement("a");
          return S.href = g, this.u.log(s.Information, `Normalizing '${g}' to '${S.href}'.`), S.href;
        }
        Ie(g) {
          const S = new URL(g);
          S.pathname.endsWith("/") ? S.pathname += "negotiate" : S.pathname += "/negotiate";
          const E = new URLSearchParams(S.searchParams);
          return E.has("negotiateVersion") || E.append("negotiateVersion", this.ye.toString()), E.has("useStatefulReconnect") ? E.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && E.append("useStatefulReconnect", "true"), S.search = E.toString(), S.toString();
        }
      }, h(Bl, "gh"), Bl);
      u(PC, "K");
      let mZ = PC;
      const CC = (Oa = class {
        constructor(g) {
          this.xe = g, this.Ae = [], this.Ue = !0, this.Le = new xg(), this.Ne = new xg(), this.qe = this.Me();
        }
        send(g) {
          return this.je(g), this.Ne || (this.Ne = new xg()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(g) {
          if (this.Ae.length && typeof this.Ae[0] != typeof g) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof g}`);
          this.Ae.push(g), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new xg();
            const g = this.Ne;
            this.Ne = void 0;
            const S = typeof this.Ae[0] == "string" ? this.Ae.join("") : Oa.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(S), g.resolve();
            } catch (E) {
              g.reject(E);
            }
          }
        }
        static We(g) {
          const S = g.map((D) => D.byteLength).reduce((D, j) => D + j), E = new Uint8Array(S);
          let z = 0;
          for (const D of g) E.set(new Uint8Array(D), z), z += D.byteLength;
          return E.buffer;
        }
      }, h(Oa, "Cl"), Oa);
      u(CC, "G");
      let wZ = CC;
      const QC = (Xl = class {
        constructor() {
          this.promise = new Promise((g, S) => [this.j, this.Oe] = [g, S]);
        }
        resolve() {
          this.j();
        }
        reject(g) {
          this.Oe(g);
        }
      }, h(Xl, "bh"), Xl);
      u(QC, "Q");
      let xg = QC;
      const MC = (Nl = class {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = Be.Text;
        }
        parseMessages(g, S) {
          if (typeof g != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!g) return [];
          S === null && (S = G.instance);
          const E = ps.parse(g), z = [];
          for (const D of E) {
            const j = JSON.parse(D);
            if (typeof j.type != "number") throw new Error("Invalid payload.");
            switch (j.type) {
              case St.Invocation:
                this.U(j);
                break;
              case St.StreamItem:
                this.Fe(j);
                break;
              case St.Completion:
                this.Be(j);
                break;
              case St.Ping:
              case St.Close:
                break;
              case St.Ack:
                this.Xe(j);
                break;
              case St.Sequence:
                this.Je(j);
                break;
              default:
                S.log(s.Information, "Unknown message type '" + j.type + "' ignored.");
                continue;
            }
            z.push(j);
          }
          return z;
        }
        writeMessage(g) {
          return ps.write(JSON.stringify(g));
        }
        U(g) {
          this.ze(g.target, "Invalid payload for Invocation message."), g.invocationId !== void 0 && this.ze(g.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(g) {
          if (this.ze(g.invocationId, "Invalid payload for StreamItem message."), g.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(g) {
          if (g.result && g.error) throw new Error("Invalid payload for Completion message.");
          !g.result && g.error && this.ze(g.error, "Invalid payload for Completion message."), this.ze(g.invocationId, "Invalid payload for Completion message.");
        }
        Xe(g) {
          if (typeof g.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(g) {
          if (typeof g.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(g, S) {
          if (typeof g != "string" || g === "") throw new Error(S);
        }
      }, h(Nl, "xh"), Nl);
      u(MC, "Y");
      let TC = MC;
      const gZ = { trace: s.Trace, debug: s.Debug, info: s.Information, information: s.Information, warn: s.Warning, warning: s.Warning, error: s.Error, critical: s.Critical, none: s.None }, AC = (Hl = class {
        configureLogging(g) {
          if (tt.isRequired(g, "logging"), g.log !== void 0) this.logger = g;
          else if (typeof g == "string") {
            const S = function(E) {
              const z = gZ[E.toLowerCase()];
              if (z !== void 0) return z;
              throw new Error(`Unknown log level: ${E}`);
            }(g);
            this.logger = new ee(S);
          } else this.logger = new ee(g);
          return this;
        }
        withUrl(g, S) {
          return tt.isRequired(g, "url"), tt.isNotEmpty(g, "url"), this.url = g, this.httpConnectionOptions = typeof S == "object" ? { ...this.httpConnectionOptions, ...S } : { ...this.httpConnectionOptions, transport: S }, this;
        }
        withHubProtocol(g) {
          return tt.isRequired(g, "protocol"), this.protocol = g, this;
        }
        withAutomaticReconnect(g) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return g ? Array.isArray(g) ? this.reconnectPolicy = new gC(g) : this.reconnectPolicy = g : this.reconnectPolicy = new gC(), this;
        }
        withServerTimeout(g) {
          return tt.isRequired(g, "milliseconds"), this.Ve = g, this;
        }
        withKeepAliveInterval(g) {
          return tt.isRequired(g, "milliseconds"), this.Ke = g, this;
        }
        withStatefulReconnect(g) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = g == null ? void 0 : g.bufferSize, this;
        }
        build() {
          const g = this.httpConnectionOptions || {};
          if (g.logger === void 0 && (g.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const S = new mZ(this.url, g);
          return mC.create(S, this.logger || G.instance, this.protocol || new TC(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      }, h(Hl, "$h"), Hl);
      u(AC, "tt");
      let vZ = AC;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ u(function(B, g) {
        return new Uint8Array(Array.prototype.slice.call(this, B, g));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), r;
    })(), "e"), n.exports = e();
  }(u3)), u3.exports;
}
h(fE, "qv");
u(fE, "requireSignalr_min");
var f3 = /* @__PURE__ */ fE();
const ZF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenConnectionRequested = new Promise((r) => {
        this._resolveConnectionRequested = r;
      }), this._whenConnectionCreated = new Promise((r) => {
        this._resolveConnectionCreated = r;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((r, a) => {
        this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = a;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      var s;
      if (this.isDestroyed)
        throw new Se();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const r = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== r.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          r.toString()
        ), await this.disconnect(), this._connection.baseUrl = r.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const r = new URL("/hubs/rtm", this.url);
        this._connection = new f3.HubConnectionBuilder().configureLogging(f3.LogLevel.None).withUrl(r.toString(), {
          accessTokenFactory: /* @__PURE__ */ u(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const a = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, a;
              } else
                return await this.getToken();
            } catch (a) {
              throw console.error(a), a;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ u((a) => !this.isDestroyed && window.navigator.onLine && (document == null ? void 0 : document.visibilityState) !== "hidden" && a.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][a.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((a, o) => {
            this._whenConnectionStartedResolve = a, this._whenConnectionStartedReject = o;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((a) => {
          var o;
          console.info(this.weavyId, `SignalR reconnected ${a}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let l = 0; l < this._connectionEventListeners.length; l++)
            (o = this._connection) == null || o.invoke("Subscribe", this._connectionEventListeners[l].name);
        }), (s = this._resolveConnectionCreated) == null || s.call(this, this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      var s;
      if (this.isDestroyed)
        throw new Se();
      let r;
      this._connection ? r = this._connection : r = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([r.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", (s = this._whenConnectionStartedResolve) == null || s.call(this, r), console.info(this.weavyId, `SignalR connected ${r.connectionId}`);
      } catch (a) {
        if (a instanceof Se)
          return console.warn(this.weavyId, "SignalR connection aborted."), r;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && a.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((o) => {
          setTimeout(o, 5e3), window.addEventListener("visibilitychange", o, { once: !0 }), window.addEventListener("offline", o, { once: !0 }), window.addEventListener("online", o, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((o) => {
          window.addEventListener("online", o, { once: !0 });
        })), window.navigator.onLine && (document == null ? void 0 : document.visibilityState) !== "hidden" && await new Promise((o) => setTimeout(o, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return r;
    }
    async subscribe(s, r, a) {
      var o, l;
      if (this.isDestroyed)
        throw new Se();
      (o = this._resolveConnectionRequested) == null || o.call(this, !0);
      const c = s ? s + ":" + r : r;
      try {
        if (this._connectionEventListeners || await new Promise((d) => queueMicrotask(() => d(!0))), this._connectionEventListeners.some((d) => d.name === c && d.callback === a))
          throw new Error("Duplicate subscribe: " + c);
        if (this._connectionEventListeners.push({ name: c, callback: a }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(c, a), await this._connection.invoke("Subscribe", c) === !1)
          throw new Error("Could not subscribe to " + c);
        return !0;
      } catch (d) {
        d instanceof Se || console.error(this.weavyId, "Error in Subscribe:", d);
        const p = this._connectionEventListeners.findIndex((f) => f.name === c && f.callback === a);
        return p !== -1 && (this._connectionEventListeners.splice(p, 1), (l = this._connection) == null || l.off(c, a)), !1;
      }
    }
    async unsubscribe(s, r, a) {
      var o;
      if (this.isDestroyed)
        throw new Se();
      try {
        const l = s ? s + ":" + r : r, c = this._connectionEventListeners.findIndex((d) => d.name === l && d.callback === a);
        if (c !== -1) {
          if (this._connectionEventListeners.splice(c, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          (o = this._connection) == null || o.off(l, a), this._connectionEventListeners.some((d) => d.name === l) || await this._connection.invoke("Unsubscribe", l);
        }
      } catch (l) {
        l instanceof Se || console.error(this.weavyId, "Error in Unsubscribe:", l);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Se()));
    }
  }, h(e, "t"), e), u(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var zv = /* @__PURE__ */ ((n) => (n.JSON = "application/json;charset=utf-8", n.FormData = "multipart/form-data;charset=utf-8", n.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", n.Text = "text/plain;charset=utf-8", n.Auto = "", n))(zv || {});
const WF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // FETCH
    async fetchOptions(s = {}, r = !0) {
      if (this.isDestroyed)
        throw new Se();
      const a = {
        headers: {
          "X-Weavy-Source": `${Ce.sourceName}@${Ce.version}`,
          "Content-Type": zv.JSON
        },
        method: "GET"
      }, o = rw(rw(PF, a, !0), s, !0);
      return r ? rw(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(s, r, a = !0) {
      if (this.isDestroyed)
        throw new Se();
      const o = await this.fetchOptions(r);
      this.networkStateIsPending = !0;
      const l = await fetch(new URL(s, this.url), o);
      if (l.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (l.status === 401 || l.status === 403) {
        if (a)
          return await this.getToken(!0), await this.fetch(s, r, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return l;
    }
    async upload(s, r, a, o = zv.JSON, l, c = !0) {
      if (this.isDestroyed)
        throw new Se();
      const d = await this.getToken();
      return await new Promise((p, f) => {
        const m = new XMLHttpRequest();
        m.open(r, new URL(s, this.url), !0), m.setRequestHeader("Authorization", "Bearer " + d), m.setRequestHeader("X-Weavy-Source", `${Ce.sourceName}@${Ce.version}`), o && m.setRequestHeader("Content-Type", o), l && m.upload.addEventListener("progress", (w) => {
          l(w.loaded / w.total * 100 || 100);
        }), m.onload = (w) => {
          c && (m.status === 401 || m.status === 401) ? this.getToken(!0).then(() => this.upload(s, r, a, o, l, !1)).then(p).catch(f) : p(new Response(m.response, { status: m.status, statusText: m.statusText }));
        }, m.onerror = f, m.send(a);
      });
    }
    // DEPRECATED
    async get(s) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${s}") instead.`), this.fetch(s);
    }
    // DEPRECATED
    async post(s, r, a, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${s}", { method: "${r}"}) instead.`
      );
      const l = o ? { "Content-Type": o } : void 0;
      return this.fetch(s, { method: r, body: a, headers: l });
    }
  }, h(e, "t"), e), u(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), yE = "en", DF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((s) => s.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return yE;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(s) {
      if (this.isDestroyed)
        throw new Se();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (s) {
        if (!Array.isArray(s))
          throw new TypeError("Provided locales have invalid format.");
        s.forEach((r) => {
          if (!Array.isArray(r) || r.length !== 2 || typeof r[0] != "string")
            throw new TypeError("Invalid locale provided: " + r[0]);
          this._locales.set(...r);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(s) {
      if (this.isDestroyed)
        throw new Se();
      !this._locale && !s || (s || (s = t.sourceLocale), this._locale = s, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${s}'.`
        ));
      }));
    }
    async loadLocale(s) {
      var r;
      if (this.isDestroyed)
        throw new Se();
      if ((r = this._locales) != null && r.has(s)) {
        const a = this._locales.get(s);
        return console.info(
          this.weavyId,
          typeof a == "function" ? "loading locale" : "preloaded locale",
          s
        ), await (typeof a == "function" ? a() : a);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      var s;
      if (this.isDestroyed)
        throw new Se();
      if ((s = this._locales) != null && s.size && !this.localization) {
        const r = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", r);
        const { getLocale: a, setLocale: o } = Uj({
          sourceLocale: t.sourceLocale,
          targetLocales: r,
          loadLocale: /* @__PURE__ */ u((l) => this.loadLocale(l), "loadLocale")
        });
        this._localization = {
          getLocale: a,
          setLocale: o
        };
      }
    }
  }, h(e, "t"), e), u(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), qF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      });
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(s) {
      this._networkState = s, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(s) {
      this._serverState = s, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(s) {
      this._connectionState = s, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(s) {
      this._networkStateIsPending = s, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? this._connectionState === "connected" || this._serverState === "ok" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    triggerNetworkChange() {
      const s = this.network;
      this._networkEvents.forEach((r) => {
        r(s);
      });
    }
    addNetworkListener(s) {
      this._networkEvents.add(s);
    }
    removeNetworkListener(s) {
      this._networkEvents.delete(s);
    }
  }, h(e, "t"), e), u(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
function g1() {
}
h(g1, "Mh");
u(g1, "noop");
function mE({
  storage: n,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: i = JSON.stringify,
  deserialize: s = JSON.parse,
  retry: r
}) {
  if (n) {
    const a = /* @__PURE__ */ u((o) => {
      try {
        n.setItem(t, i(o));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: wE((o) => {
        let l = o, c = a(l), d = 0;
        for (; c && l; )
          d++, l = r == null ? void 0 : r({
            persistedClient: l,
            error: c,
            errorCount: d
          }), l && (c = a(l));
      }, e),
      restoreClient: /* @__PURE__ */ u(() => {
        const o = n.getItem(t);
        if (o)
          return s(o);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ u(() => {
        n.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: g1,
    restoreClient: g1,
    removeClient: g1
  };
}
h(mE, "Kv");
u(mE, "createSyncStoragePersister");
function wE(n, t = 100) {
  let e = null, i;
  return function(...s) {
    i = s, e === null && (e = setTimeout(() => {
      n(...i), e = null;
    }, t));
  };
}
h(wE, "Gv");
u(wE, "throttle$1");
var VF = ["added", "removed", "updated"];
function ak(n) {
  return VF.includes(n);
}
h(ak, "ly");
u(ak, "isCacheEventType");
async function gE({
  queryClient: n,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: i = "",
  hydrateOptions: s
}) {
  try {
    const r = await t.restoreClient();
    if (r)
      if (r.timestamp) {
        const a = Date.now() - r.timestamp > e, o = r.buster !== i;
        if (a || o)
          return t.removeClient();
        nE(n, r.clientState, s);
      } else
        return t.removeClient();
  } catch (r) {
    throw await t.removeClient(), r;
  }
}
h(gE, "Yv");
u(gE, "persistQueryClientRestore");
async function ok({
  queryClient: n,
  persister: t,
  buster: e = "",
  dehydrateOptions: i
}) {
  const s = {
    buster: e,
    timestamp: Date.now(),
    clientState: iE(n, i)
  };
  await t.persistClient(s);
}
h(ok, "dy");
u(ok, "persistQueryClientSave");
function vE(n) {
  const t = n.queryClient.getQueryCache().subscribe((i) => {
    ak(i.type) && ok(n);
  }), e = n.queryClient.getMutationCache().subscribe((i) => {
    ak(i.type) && ok(n);
  });
  return () => {
    t(), e();
  };
}
h(vE, "Xv");
u(vE, "persistQueryClientSubscribe");
const jF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._queryClient = new zF({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Se();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = mE({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const s = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ u((r) => {
              var a, o;
              const l = ((o = (a = r.state.context) == null ? void 0 : a.status) == null ? void 0 : o.state) === "pending";
              return !!(r.state.context && !l || r.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await gE(s), this._unsubscribeQueryClient = vE(s);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = t9(this.host, (s) => {
        this.isDestroyed || (s ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      var s;
      await super.reset(), await this._queryClient.cancelQueries(), await ((s = this._sessionStoragePersister) == null ? void 0 : s.removeClient()), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      var s, r;
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await ((s = this._sessionStoragePersister) == null ? void 0 : s.removeClient()), (r = this._unsubscribeQueryClient) == null || r.call(this), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      var s;
      super.destroy(), (s = this._hostIsConnectedObserver) == null || s.disconnect(), this.disconnectQueryClient();
    }
  }, h(e, "t"), e), u(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), FF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._notificationEvents = Ce.defaults.notificationEvents ?? !1, this.dispatchRealtimeEvent = (r) => {
        ti();
        const a = this.host !== document.documentElement ? { composed: !0 } : { bubbles: !0 };
        switch (r.action) {
          case "notification_created":
          case "notification_updated":
          case "notification_deleted":
          case "notifications_marked": {
            const o = new CustomEvent("wy-notifications", {
              ...a,
              detail: r
            });
            this.host.dispatchEvent(o);
          }
        }
      };
    }
    get notificationEvents() {
      return this._notificationEvents;
    }
    set notificationEvents(s) {
      this.realtimeUnsubscribe(), this._notificationEvents = s ?? !1, this.realtimeSubscribe();
    }
    realtimeSubscribe() {
      const s = this;
      this.notificationEvents && (s.subscribe(null, "notification_created", this.dispatchRealtimeEvent), s.subscribe(null, "notification_updated", this.dispatchRealtimeEvent), s.subscribe(null, "notifications_marked", this.dispatchRealtimeEvent));
    }
    realtimeUnsubscribe() {
      const s = this;
      this.notificationEvents && (s.unsubscribe(null, "notification_created", this.dispatchRealtimeEvent), s.unsubscribe(null, "notification_updated", this.dispatchRealtimeEvent), s.unsubscribe(null, "notifications_marked", this.dispatchRealtimeEvent));
    }
    destroy() {
      this.realtimeUnsubscribe(), super.destroy();
    }
  }, h(e, "t"), e), u(t, "WeavyRealtime"), t;
}, "WeavyRealtimeMixin"), UF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
    }
    set notifications(s) {
      this._notifications = s, this.updateContext();
    }
    get notifications() {
      return this._notifications ?? Ce.defaults.notifications;
    }
    set notificationsBadge(s) {
      this._notificationsBadge = s, this.updateContext();
    }
    get notificationsBadge() {
      return this._notificationsBadge ?? Ce.defaults.notificationsBadge;
    }
    set reactions(s) {
      this._reactions = s, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? Ce.defaults.reactions;
    }
  }, h(e, "t"), e), u(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function hi(n) {
  return n < 0 ? -1 : n === 0 ? 0 : 1;
}
h(hi, "Se");
u(hi, "signum");
function jc(n, t, e) {
  return (1 - e) * n + e * t;
}
h(jc, "wc");
u(jc, "lerp");
function bE(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
h(bE, "i1");
u(bE, "clampInt");
function Aw(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
h(Aw, "Bl");
u(Aw, "clampDouble");
function _0(n) {
  return n = n % 360, n < 0 && (n = n + 360), n;
}
h(_0, "Nu");
u(_0, "sanitizeDegreesDouble");
function OE(n, t) {
  return _0(t - n) <= 180 ? 1 : -1;
}
h(OE, "s1");
u(OE, "rotationDirection");
function $E(n, t) {
  return 180 - Math.abs(Math.abs(n - t) - 180);
}
h($E, "r1");
u($E, "differenceDegrees");
function _v(n, t) {
  const e = n[0] * t[0][0] + n[1] * t[0][1] + n[2] * t[0][2], i = n[0] * t[1][0] + n[1] * t[1][1] + n[2] * t[1][2], s = n[0] * t[2][0] + n[1] * t[2][1] + n[2] * t[2][2];
  return [e, i, s];
}
h(_v, "iu");
u(_v, "matrixMultiply");
const BF = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], XF = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], NF = [95.047, 100, 108.883];
function L0(n, t, e) {
  return (255 << 24 | (n & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
h(L0, "ju");
u(L0, "argbFromRgb");
function lk(n) {
  const t = kr(n[0]), e = kr(n[1]), i = kr(n[2]);
  return L0(t, e, i);
}
h(lk, "hy");
u(lk, "argbFromLinrgb");
function KS(n) {
  return n >> 16 & 255;
}
h(KS, "Fw");
u(KS, "redFromArgb");
function JS(n) {
  return n >> 8 & 255;
}
h(JS, "Dw");
u(JS, "greenFromArgb");
function tP(n) {
  return n & 255;
}
h(tP, "Hw");
u(tP, "blueFromArgb");
function xE(n, t, e) {
  const i = XF, s = i[0][0] * n + i[0][1] * t + i[0][2] * e, r = i[1][0] * n + i[1][1] * t + i[1][2] * e, a = i[2][0] * n + i[2][1] * t + i[2][2] * e, o = kr(s), l = kr(r), c = kr(a);
  return L0(o, l, c);
}
h(xE, "c1");
u(xE, "argbFromXyz");
function kE(n) {
  const t = Xa(KS(n)), e = Xa(JS(n)), i = Xa(tP(n));
  return _v([t, e, i], BF);
}
h(kE, "l1");
u(kE, "xyzFromArgb");
function SE(n) {
  const t = Ms(n), e = kr(t);
  return L0(e, e, e);
}
h(SE, "d1");
u(SE, "argbFromLstar");
function Lv(n) {
  const t = kE(n)[1];
  return 116 * eP(t / 100) - 16;
}
h(Lv, "su");
u(Lv, "lstarFromArgb");
function Ms(n) {
  return 100 * CE((n + 16) / 116);
}
h(Ms, "gs");
u(Ms, "yFromLstar");
function Iv(n) {
  return eP(n / 100) * 116 - 16;
}
h(Iv, "ru");
u(Iv, "lstarFromY");
function Xa(n) {
  const t = n / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
h(Xa, "Wr");
u(Xa, "linearized");
function kr(n) {
  const t = n / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, bE(0, 255, Math.round(e * 255));
}
h(kr, "rr");
u(kr, "delinearized");
function PE() {
  return NF;
}
h(PE, "h1");
u(PE, "whitePointD65");
function eP(n) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return n > t ? Math.pow(n, 1 / 3) : (e * n + 16) / 116;
}
h(eP, "Vw");
u(eP, "labF");
function CE(n) {
  const t = 0.008856451679035631, e = 24389 / 27, i = n * n * n;
  return i > t ? i : (116 * n - 16) / e;
}
h(CE, "u1");
u(CE, "labInvf");
var Ao;
const QE = (Ao = class {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = PE(), e = 200 / Math.PI * Ms(50) / 100, i = 50, s = 2, r = !1) {
    const a = t, o = a[0] * 0.401288 + a[1] * 0.650173 + a[2] * -0.051461, l = a[0] * -0.250268 + a[1] * 1.204414 + a[2] * 0.045854, c = a[0] * -2079e-6 + a[1] * 0.048952 + a[2] * 0.953127, d = 0.8 + s / 10, p = d >= 0.9 ? jc(0.59, 0.69, (d - 0.9) * 10) : jc(0.525, 0.59, (d - 0.8) * 10);
    let f = r ? 1 : d * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    f = f > 1 ? 1 : f < 0 ? 0 : f;
    const m = d, w = [
      f * (100 / o) + 1 - f,
      f * (100 / l) + 1 - f,
      f * (100 / c) + 1 - f
    ], b = 1 / (5 * e + 1), x = b * b * b * b, O = 1 - x, P = x * e + 0.1 * O * O * Math.cbrt(5 * e), A = Ms(i) / t[1], R = 1.48 + Math.sqrt(A), T = 0.725 / Math.pow(A, 0.2), I = T, Z = [
      Math.pow(P * w[0] * o / 100, 0.42),
      Math.pow(P * w[1] * l / 100, 0.42),
      Math.pow(P * w[2] * c / 100, 0.42)
    ], W = [
      400 * Z[0] / (Z[0] + 27.13),
      400 * Z[1] / (Z[1] + 27.13),
      400 * Z[2] / (Z[2] + 27.13)
    ], V = (2 * W[0] + W[1] + 0.05 * W[2]) * T;
    return new Ao(A, V, T, I, p, m, w, P, Math.pow(P, 0.25), R);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, i, s, r, a, o, l, c, d) {
    this.n = t, this.aw = e, this.nbb = i, this.ncb = s, this.c = r, this.nc = a, this.rgbD = o, this.fl = l, this.fLRoot = c, this.z = d;
  }
}, h(Ao, "ud"), Ao);
u(QE, "ViewingConditions");
let Ts = QE;
Ts.DEFAULT = Ts.make();
var Vi;
const ME = (Vi = class {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, i, s, r, a, o, l, c) {
    this.hue = t, this.chroma = e, this.j = i, this.q = s, this.m = r, this.s = a, this.jstar = o, this.astar = l, this.bstar = c;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, i = this.astar - t.astar, s = this.bstar - t.bstar, r = Math.sqrt(e * e + i * i + s * s);
    return 1.41 * Math.pow(r, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return Vi.fromIntInViewingConditions(t, Ts.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const i = (t & 16711680) >> 16, s = (t & 65280) >> 8, r = t & 255, a = Xa(i), o = Xa(s), l = Xa(r), c = 0.41233895 * a + 0.35762064 * o + 0.18051042 * l, d = 0.2126 * a + 0.7152 * o + 0.0722 * l, p = 0.01932141 * a + 0.11916382 * o + 0.95034478 * l, f = 0.401288 * c + 0.650173 * d - 0.051461 * p, m = -0.250268 * c + 1.204414 * d + 0.045854 * p, w = -2079e-6 * c + 0.048952 * d + 0.953127 * p, b = e.rgbD[0] * f, x = e.rgbD[1] * m, O = e.rgbD[2] * w, P = Math.pow(e.fl * Math.abs(b) / 100, 0.42), A = Math.pow(e.fl * Math.abs(x) / 100, 0.42), R = Math.pow(e.fl * Math.abs(O) / 100, 0.42), T = hi(b) * 400 * P / (P + 27.13), I = hi(x) * 400 * A / (A + 27.13), Z = hi(O) * 400 * R / (R + 27.13), W = (11 * T + -12 * I + Z) / 11, V = (T + I - 2 * Z) / 9, Y = (20 * T + 20 * I + 21 * Z) / 20, G = (40 * T + 20 * I + Z) / 20, X = Math.atan2(V, W) * 180 / Math.PI, st = X < 0 ? X + 360 : X >= 360 ? X - 360 : X, tt = st * Math.PI / 180, Qt = G * e.nbb, vt = 100 * Math.pow(Qt / e.aw, e.c * e.z), It = 4 / e.c * Math.sqrt(vt / 100) * (e.aw + 4) * e.fLRoot, Wt = st < 20.14 ? st + 360 : st, Dt = 0.25 * (Math.cos(Wt * Math.PI / 180 + 2) + 3.8), bi = 5e4 / 13 * Dt * e.nc * e.ncb * Math.sqrt(W * W + V * V) / (Y + 0.305), Ee = Math.pow(bi, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), le = Ee * Math.sqrt(vt / 100), ee = le * e.fLRoot, fe = 50 * Math.sqrt(Ee * e.c / (e.aw + 4)), Oi = (1 + 100 * 7e-3) * vt / (1 + 7e-3 * vt), _i = 1 / 0.0228 * Math.log(1 + 0.0228 * ee), Hi = _i * Math.cos(tt), Nt = _i * Math.sin(tt);
    return new Vi(st, le, vt, It, ee, fe, Oi, Hi, Nt);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, i) {
    return Vi.fromJchInViewingConditions(t, e, i, Ts.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, i, s) {
    const r = 4 / s.c * Math.sqrt(t / 100) * (s.aw + 4) * s.fLRoot, a = e * s.fLRoot, o = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(o * s.c / (s.aw + 4)), c = i * Math.PI / 180, d = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), p = 1 / 0.0228 * Math.log(1 + 0.0228 * a), f = p * Math.cos(c), m = p * Math.sin(c);
    return new Vi(i, e, t, r, a, l, d, f, m);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, i) {
    return Vi.fromUcsInViewingConditions(t, e, i, Ts.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, i, s) {
    const r = e, a = i, o = Math.sqrt(r * r + a * a), l = (Math.exp(o * 0.0228) - 1) / 0.0228 / s.fLRoot;
    let c = Math.atan2(a, r) * (180 / Math.PI);
    c < 0 && (c += 360);
    const d = t / (1 - (t - 100) * 7e-3);
    return Vi.fromJchInViewingConditions(d, l, c, s);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(Ts.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, r = 0.25 * (Math.cos(s + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = r * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, c = Math.sin(s), d = Math.cos(s), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * d + 108 * i * c), f = p * d, m = p * c, w = (460 * l + 451 * f + 288 * m) / 1403, b = (460 * l - 891 * f - 261 * m) / 1403, x = (460 * l - 220 * f - 6300 * m) / 1403, O = Math.max(0, 27.13 * Math.abs(w) / (400 - Math.abs(w))), P = hi(w) * (100 / t.fl) * Math.pow(O, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), R = hi(b) * (100 / t.fl) * Math.pow(A, 1 / 0.42), T = Math.max(0, 27.13 * Math.abs(x) / (400 - Math.abs(x))), I = hi(x) * (100 / t.fl) * Math.pow(T, 1 / 0.42), Z = P / t.rgbD[0], W = R / t.rgbD[1], V = I / t.rgbD[2], Y = 1.86206786 * Z - 1.01125463 * W + 0.14918677 * V, G = 0.38752654 * Z + 0.62144744 * W - 897398e-8 * V, X = -0.0158415 * Z - 0.03412294 * W + 1.04996444 * V;
    return xE(Y, G, X);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, i, s) {
    const r = 0.401288 * t + 0.650173 * e - 0.051461 * i, a = -0.250268 * t + 1.204414 * e + 0.045854 * i, o = -2079e-6 * t + 0.048952 * e + 0.953127 * i, l = s.rgbD[0] * r, c = s.rgbD[1] * a, d = s.rgbD[2] * o, p = Math.pow(s.fl * Math.abs(l) / 100, 0.42), f = Math.pow(s.fl * Math.abs(c) / 100, 0.42), m = Math.pow(s.fl * Math.abs(d) / 100, 0.42), w = hi(l) * 400 * p / (p + 27.13), b = hi(c) * 400 * f / (f + 27.13), x = hi(d) * 400 * m / (m + 27.13), O = (11 * w + -12 * b + x) / 11, P = (w + b - 2 * x) / 9, A = (20 * w + 20 * b + 21 * x) / 20, R = (40 * w + 20 * b + x) / 20, T = Math.atan2(P, O) * 180 / Math.PI, I = T < 0 ? T + 360 : T >= 360 ? T - 360 : T, Z = I * Math.PI / 180, W = R * s.nbb, V = 100 * Math.pow(W / s.aw, s.c * s.z), Y = 4 / s.c * Math.sqrt(V / 100) * (s.aw + 4) * s.fLRoot, G = I < 20.14 ? I + 360 : I, X = 1 / 4 * (Math.cos(G * Math.PI / 180 + 2) + 3.8), st = 5e4 / 13 * X * s.nc * s.ncb * Math.sqrt(O * O + P * P) / (A + 0.305), tt = Math.pow(st, 0.9) * Math.pow(1.64 - Math.pow(0.29, s.n), 0.73), Qt = tt * Math.sqrt(V / 100), vt = Qt * s.fLRoot, It = 50 * Math.sqrt(tt * s.c / (s.aw + 4)), Wt = (1 + 100 * 7e-3) * V / (1 + 7e-3 * V), Dt = Math.log(1 + 0.0228 * vt) / 0.0228, bi = Dt * Math.cos(Z), Ee = Dt * Math.sin(Z);
    return new Vi(I, Qt, V, Y, vt, It, Wt, bi, Ee);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, r = 0.25 * (Math.cos(s + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = r * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, c = Math.sin(s), d = Math.cos(s), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * d + 108 * i * c), f = p * d, m = p * c, w = (460 * l + 451 * f + 288 * m) / 1403, b = (460 * l - 891 * f - 261 * m) / 1403, x = (460 * l - 220 * f - 6300 * m) / 1403, O = Math.max(0, 27.13 * Math.abs(w) / (400 - Math.abs(w))), P = hi(w) * (100 / t.fl) * Math.pow(O, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), R = hi(b) * (100 / t.fl) * Math.pow(A, 1 / 0.42), T = Math.max(0, 27.13 * Math.abs(x) / (400 - Math.abs(x))), I = hi(x) * (100 / t.fl) * Math.pow(T, 1 / 0.42), Z = P / t.rgbD[0], W = R / t.rgbD[1], V = I / t.rgbD[2], Y = 1.86206786 * Z - 1.01125463 * W + 0.14918677 * V, G = 0.38752654 * Z + 0.62144744 * W - 897398e-8 * V, X = -0.0158415 * Z - 0.03412294 * W + 1.04996444 * V;
    return [Y, G, X];
  }
}, h(Vi, "mi"), Vi);
u(ME, "Cam16");
let Xn = ME;
var bt;
const TE = (bt = class {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let i = 0;
    return e <= 31308e-7 ? i = e * 12.92 : i = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, i * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return hi(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = _v(t, bt.SCALED_DISCOUNT_FROM_LINRGB), i = bt.chromaticAdaptation(e[0]), s = bt.chromaticAdaptation(e[1]), r = bt.chromaticAdaptation(e[2]), a = (11 * i + -12 * s + r) / 11, o = (i + s - 2 * r) / 9;
    return Math.atan2(o, a);
  }
  static areInCyclicOrder(t, e, i) {
    const s = bt.sanitizeRadians(e - t), r = bt.sanitizeRadians(i - t);
    return s < r;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, i) {
    return (e - t) / (i - t);
  }
  static lerpPoint(t, e, i) {
    return [
      t[0] + (i[0] - t[0]) * e,
      t[1] + (i[1] - t[1]) * e,
      t[2] + (i[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, i, s) {
    const r = bt.intercept(t[s], e, i[s]);
    return bt.lerpPoint(t, r, i);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const i = bt.Y_FROM_LINRGB[0], s = bt.Y_FROM_LINRGB[1], r = bt.Y_FROM_LINRGB[2], a = e % 4 <= 1 ? 0 : 100, o = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = a, c = o, d = (t - l * s - c * r) / i;
      return bt.isBounded(d) ? [d, l, c] : [-1, -1, -1];
    } else if (e < 8) {
      const l = a, c = o, d = (t - c * i - l * r) / s;
      return bt.isBounded(d) ? [c, d, l] : [-1, -1, -1];
    } else {
      const l = a, c = o, d = (t - l * i - c * s) / r;
      return bt.isBounded(d) ? [l, c, d] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let i = [-1, -1, -1], s = i, r = 0, a = 0, o = !1, l = !0;
    for (let c = 0; c < 12; c++) {
      const d = bt.nthVertex(t, c);
      if (d[0] < 0)
        continue;
      const p = bt.hueOf(d);
      if (!o) {
        i = d, s = d, r = p, a = p, o = !0;
        continue;
      }
      (l || bt.areInCyclicOrder(r, p, a)) && (l = !1, bt.areInCyclicOrder(r, e, p) ? (s = d, a = p) : (i = d, r = p));
    }
    return [i, s];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const i = bt.bisectToSegment(t, e);
    let s = i[0], r = bt.hueOf(s), a = i[1];
    for (let o = 0; o < 3; o++)
      if (s[o] !== a[o]) {
        let l = -1, c = 255;
        s[o] < a[o] ? (l = bt.criticalPlaneBelow(bt.trueDelinearized(s[o])), c = bt.criticalPlaneAbove(bt.trueDelinearized(a[o]))) : (l = bt.criticalPlaneAbove(bt.trueDelinearized(s[o])), c = bt.criticalPlaneBelow(bt.trueDelinearized(a[o])));
        for (let d = 0; d < 8 && !(Math.abs(c - l) <= 1); d++) {
          const p = Math.floor((l + c) / 2), f = bt.CRITICAL_PLANES[p], m = bt.setCoordinate(s, f, a, o), w = bt.hueOf(m);
          bt.areInCyclicOrder(r, e, w) ? (a = m, c = p) : (s = m, r = w, l = p);
        }
      }
    return bt.midpoint(s, a);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), i = Math.max(0, 27.13 * e / (400 - e));
    return hi(t) * Math.pow(i, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, i) {
    let s = Math.sqrt(i) * 11;
    const r = Ts.DEFAULT, a = 1 / Math.pow(1.64 - Math.pow(0.29, r.n), 0.73), o = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * r.nc * r.ncb, l = Math.sin(t), c = Math.cos(t);
    for (let d = 0; d < 5; d++) {
      const p = s / 100, f = e === 0 || s === 0 ? 0 : e / Math.sqrt(p), m = Math.pow(f * a, 1 / 0.9), w = r.aw * Math.pow(p, 1 / r.c / r.z) / r.nbb, b = 23 * (w + 0.305) * m / (23 * o + 11 * m * c + 108 * m * l), x = b * c, O = b * l, P = (460 * w + 451 * x + 288 * O) / 1403, A = (460 * w - 891 * x - 261 * O) / 1403, R = (460 * w - 220 * x - 6300 * O) / 1403, T = bt.inverseChromaticAdaptation(P), I = bt.inverseChromaticAdaptation(A), Z = bt.inverseChromaticAdaptation(R), W = _v([T, I, Z], bt.LINRGB_FROM_SCALED_DISCOUNT);
      if (W[0] < 0 || W[1] < 0 || W[2] < 0)
        return 0;
      const V = bt.Y_FROM_LINRGB[0], Y = bt.Y_FROM_LINRGB[1], G = bt.Y_FROM_LINRGB[2], X = V * W[0] + Y * W[1] + G * W[2];
      if (X <= 0)
        return 0;
      if (d === 4 || Math.abs(X - i) < 2e-3)
        return W[0] > 100.01 || W[1] > 100.01 || W[2] > 100.01 ? 0 : lk(W);
      s = s - (X - i) * s / (2 * X);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, i) {
    if (e < 1e-4 || i < 1e-4 || i > 99.9999)
      return SE(i);
    t = _0(t);
    const s = t / 180 * Math.PI, r = Ms(i), a = bt.findResultByJ(s, e, r);
    if (a !== 0)
      return a;
    const o = bt.bisectToLimit(r, s);
    return lk(o);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, i) {
    return Xn.fromInt(bt.solveToInt(t, e, i));
  }
}, h(bt, "ot"), bt);
u(TE, "HctSolver");
let Or = TE;
Or.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
Or.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
Or.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
Or.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
var Zs;
const AE = (Zs = class {
  static from(t, e, i) {
    return new Zs(Or.solveToInt(t, e, i));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new Zs(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(Or.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(Or.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(Or.solveToInt(this.internalHue, this.internalChroma, t));
  }
  constructor(t) {
    this.argb = t;
    const e = Xn.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = Lv(t), this.argb = t;
  }
  setInternalState(t) {
    const e = Xn.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = Lv(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const e = Xn.fromInt(this.toInt()).xyzInViewingConditions(t), i = Xn.fromXyzInViewingConditions(e[0], e[1], e[2], Ts.make());
    return Zs.from(i.hue, i.chroma, Iv(e[1]));
  }
}, h(Zs, "jr"), Zs);
u(AE, "Hct");
let Pi = AE;
var Ro;
const RE = (Ro = class {
  /**
   * Blend the design color's HCT hue towards the key color's HCT
   * hue, in a way that leaves the original color recognizable and
   * recognizably shifted towards the key color.
   *
   * @param designColor ARGB representation of an arbitrary color.
   * @param sourceColor ARGB representation of the main theme color.
   * @return The design color with a hue shifted towards the
   * system's color, a slightly warmer/cooler variant of the design
   * color's hue.
   */
  static harmonize(t, e) {
    const i = Pi.fromInt(t), s = Pi.fromInt(e), r = $E(i.hue, s.hue), a = Math.min(r * 0.5, 15), o = _0(i.hue + a * OE(i.hue, s.hue));
    return Pi.from(o, i.chroma, i.tone).toInt();
  }
  /**
   * Blends hue from one color into another. The chroma and tone of
   * the original color are maintained.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, with a hue blended towards to. Chroma and tone
   * are constant.
   */
  static hctHue(t, e, i) {
    const s = Ro.cam16Ucs(t, e, i), r = Xn.fromInt(s), a = Xn.fromInt(t);
    return Pi.from(r.hue, a.chroma, Lv(t)).toInt();
  }
  /**
   * Blend in CAM16-UCS space.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, blended towards to. Hue, chroma, and tone will
   * change.
   */
  static cam16Ucs(t, e, i) {
    const s = Xn.fromInt(t), r = Xn.fromInt(e), a = s.jstar, o = s.astar, l = s.bstar, c = r.jstar, d = r.astar, p = r.bstar, f = a + (c - a) * i, m = o + (d - o) * i, w = l + (p - l) * i;
    return Xn.fromUcs(f, m, w).toInt();
  }
}, h(Ro, "pd"), Ro);
u(RE, "Blend");
let Dn = RE;
var mn;
const EE = (mn = class {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = Aw(0, 100, t), e = Aw(0, 100, e), mn.ratioOfYs(Ms(t), Ms(e));
  }
  static ratioOfYs(t, e) {
    const i = t > e ? t : e, s = i === e ? t : e;
    return (i + 5) / (s + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Ms(t), s = e * (i + 5) - 5, r = mn.ratioOfYs(s, i), a = Math.abs(r - e);
    if (r < e && a > 0.04)
      return -1;
    const o = Iv(s) + 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Ms(t), s = (i + 5) / e - 5, r = mn.ratioOfYs(i, s), a = Math.abs(r - e);
    if (r < e && a > 0.04)
      return -1;
    const o = Iv(s) - 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const i = mn.lighter(t, e);
    return i < 0 ? 100 : i;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const i = mn.darker(t, e);
    return i < 0 ? 0 : i;
  }
}, h(mn, "as"), mn);
u(EE, "Contrast");
let Yi = EE;
var Eo;
const zE = (Eo = class {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, i = Math.round(t.chroma) > 16, s = Math.round(t.tone) < 65;
    return e && i && s;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return Eo.isDisliked(t) ? Pi.from(t.hue, t.chroma, 70) : t;
  }
}, h(Eo, "yd"), Eo);
u(zE, "DislikeAnalyzer");
let HF = zE;
var qe;
const _E = (qe = class {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(t) {
    return new qe(t.name ?? "", t.palette, t.tone, t.isBackground ?? !1, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(t, e, i, s, r, a, o, l) {
    if (this.name = t, this.palette = e, this.tone = i, this.isBackground = s, this.background = r, this.secondBackground = a, this.contrastCurve = o, this.toneDeltaPair = l, this.hctCache = /* @__PURE__ */ new Map(), !r && a)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!r && o)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (r && !o)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const i = this.getTone(t), s = this.palette(t).getHct(i);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, s), s;
  }
  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(t) {
    const e = t.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const i = this.toneDeltaPair(t), s = i.roleA, r = i.roleB, a = i.delta, o = i.polarity, l = i.stayTogether, c = this.background(t).getTone(t), d = o === "nearer" || o === "lighter" && !t.isDark || o === "darker" && t.isDark, p = d ? s : r, f = d ? r : s, m = this.name === p.name, w = t.isDark ? 1 : -1, b = p.contrastCurve.getContrast(t.contrastLevel), x = f.contrastCurve.getContrast(t.contrastLevel), O = p.tone(t);
      let P = Yi.ratioOfTones(c, O) >= b ? O : qe.foregroundTone(c, b);
      const A = f.tone(t);
      let R = Yi.ratioOfTones(c, A) >= x ? A : qe.foregroundTone(c, x);
      return e && (P = qe.foregroundTone(c, b), R = qe.foregroundTone(c, x)), (R - P) * w >= a || (R = Aw(0, 100, P + a * w), (R - P) * w >= a || (P = Aw(0, 100, R - a * w))), 50 <= P && P < 60 ? w > 0 ? (P = 60, R = Math.max(R, P + a * w)) : (P = 49, R = Math.min(R, P + a * w)) : 50 <= R && R < 60 && (l ? w > 0 ? (P = 60, R = Math.max(R, P + a * w)) : (P = 49, R = Math.min(R, P + a * w)) : w > 0 ? R = 60 : R = 49), m ? P : R;
    } else {
      let i = this.tone(t);
      if (this.background == null)
        return i;
      const s = this.background(t).getTone(t), r = this.contrastCurve.getContrast(t.contrastLevel);
      if (Yi.ratioOfTones(s, i) >= r || (i = qe.foregroundTone(s, r)), e && (i = qe.foregroundTone(s, r)), this.isBackground && 50 <= i && i < 60 && (Yi.ratioOfTones(49, s) >= r ? i = 49 : i = 60), this.secondBackground) {
        const [a, o] = [this.background, this.secondBackground], [l, c] = [a(t).getTone(t), o(t).getTone(t)], [d, p] = [Math.max(l, c), Math.min(l, c)];
        if (Yi.ratioOfTones(d, i) >= r && Yi.ratioOfTones(p, i) >= r)
          return i;
        const f = Yi.lighter(d, r), m = Yi.darker(p, r), w = [];
        return f !== -1 && w.push(f), m !== -1 && w.push(m), qe.tonePrefersLightForeground(l) || qe.tonePrefersLightForeground(c) ? f < 0 ? 100 : f : w.length === 1 ? w[0] : m < 0 ? 0 : m;
      }
      return i;
    }
  }
  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const i = Yi.lighterUnsafe(t, e), s = Yi.darkerUnsafe(t, e), r = Yi.ratioOfTones(i, t), a = Yi.ratioOfTones(s, t);
    if (qe.tonePrefersLightForeground(t)) {
      const o = Math.abs(r - a) < 0.1 && r < e && a < e;
      return r >= e || r >= a || o ? i : s;
    } else
      return a >= e || a >= r ? s : i;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return qe.tonePrefersLightForeground(t) && !qe.toneAllowsLightForeground(t) ? 49 : t;
  }
}, h(qe, "ke"), qe);
u(_E, "DynamicColor");
let dt = _E;
var Rw;
(function(n) {
  n[n.MONOCHROME = 0] = "MONOCHROME", n[n.NEUTRAL = 1] = "NEUTRAL", n[n.TONAL_SPOT = 2] = "TONAL_SPOT", n[n.VIBRANT = 3] = "VIBRANT", n[n.EXPRESSIVE = 4] = "EXPRESSIVE", n[n.FIDELITY = 5] = "FIDELITY", n[n.CONTENT = 6] = "CONTENT", n[n.RAINBOW = 7] = "RAINBOW", n[n.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(Rw || (Rw = {}));
var ku;
const LE = (ku = class {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Contrast requirement for contrast level -1.0
   * @param normal Contrast requirement for contrast level 0.0
   * @param medium Contrast requirement for contrast level 0.5
   * @param high Contrast requirement for contrast level 1.0
   */
  constructor(t, e, i, s) {
    this.low = t, this.normal = e, this.medium = i, this.high = s;
  }
  /**
   * Returns the contrast ratio at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal);
   * -1.0 is the lowest; 1.0 is the highest.
   * @return The contrast ratio, a number between 1.0 and 21.0.
   */
  getContrast(t) {
    return t <= -1 ? this.low : t < 0 ? jc(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? jc(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? jc(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
}, h(ku, "$p"), ku);
u(LE, "ContrastCurve");
let Et = LE;
var Su;
const IE = (Su = class {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, i, s, r) {
    this.roleA = t, this.roleB = e, this.delta = i, this.polarity = s, this.stayTogether = r;
  }
}, h(Su, "Cp"), Su);
u(IE, "ToneDeltaPair");
let Ri = IE;
function ll(n) {
  return n.variant === Rw.FIDELITY || n.variant === Rw.CONTENT;
}
h(ll, "ec");
u(ll, "isFidelity");
function pe(n) {
  return n.variant === Rw.MONOCHROME;
}
h(pe, "jt");
u(pe, "isMonochrome");
function ZE(n, t, e, i) {
  let s = e, r = Pi.from(n, t, e);
  if (r.chroma < t) {
    let a = r.chroma;
    for (; r.chroma < t; ) {
      s += i ? -1 : 1;
      const o = Pi.from(n, t, s);
      if (a > o.chroma || Math.abs(o.chroma - t) < 0.4)
        break;
      const l = Math.abs(o.chroma - t), c = Math.abs(r.chroma - t);
      l < c && (r = o), a = Math.max(a, o.chroma);
    }
  }
  return s;
}
h(ZE, "p1");
u(ZE, "findDesiredChromaByTone");
function WE(n) {
  return Ts.make(
    /*whitePoint=*/
    void 0,
    /*adaptingLuminance=*/
    void 0,
    /*backgroundLstar=*/
    n.isDark ? 30 : 80,
    /*surround=*/
    void 0,
    /*discountingIlluminant=*/
    void 0
  );
}
h(WE, "y1");
u(WE, "viewingConditionsForAlbers");
function I0(n, t) {
  const e = n.inViewingConditions(WE(t));
  return dt.tonePrefersLightForeground(n.tone) && !dt.toneAllowsLightForeground(e.tone) ? dt.enableLightForeground(n.tone) : dt.enableLightForeground(e.tone);
}
h(I0, "Wu");
u(I0, "performAlbers");
var Ur;
const DE = (Ur = class {
  static highestSurface(t) {
    return t.isDark ? Ur.surfaceBright : Ur.surfaceDim;
  }
}, h(Ur, "gc"), Ur);
u(DE, "MaterialDynamicColors");
let q = DE;
q.contentAccentToneDelta = 15;
q.primaryPaletteKeyColor = dt.fromPalette({
  name: "primary_palette_key_color",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.primaryPalette.keyColor.tone, "tone")
});
q.secondaryPaletteKeyColor = dt.fromPalette({
  name: "secondary_palette_key_color",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.secondaryPalette.keyColor.tone, "tone")
});
q.tertiaryPaletteKeyColor = dt.fromPalette({
  name: "tertiary_palette_key_color",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.tertiaryPalette.keyColor.tone, "tone")
});
q.neutralPaletteKeyColor = dt.fromPalette({
  name: "neutral_palette_key_color",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.neutralPalette.keyColor.tone, "tone")
});
q.neutralVariantPaletteKeyColor = dt.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: /* @__PURE__ */ u((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.neutralVariantPalette.keyColor.tone, "tone")
});
q.background = dt.fromPalette({
  name: "background",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
q.onBackground = dt.fromPalette({
  name: "on_background",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.background, "background"),
  contrastCurve: new Et(3, 3, 4.5, 7)
});
q.surface = dt.fromPalette({
  name: "surface",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
q.surfaceDim = dt.fromPalette({
  name: "surface_dim",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 6 : 87, "tone"),
  isBackground: !0
});
q.surfaceBright = dt.fromPalette({
  name: "surface_bright",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 24 : 98, "tone"),
  isBackground: !0
});
q.surfaceContainerLowest = dt.fromPalette({
  name: "surface_container_lowest",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 4 : 100, "tone"),
  isBackground: !0
});
q.surfaceContainerLow = dt.fromPalette({
  name: "surface_container_low",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 10 : 96, "tone"),
  isBackground: !0
});
q.surfaceContainer = dt.fromPalette({
  name: "surface_container",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 12 : 94, "tone"),
  isBackground: !0
});
q.surfaceContainerHigh = dt.fromPalette({
  name: "surface_container_high",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 17 : 92, "tone"),
  isBackground: !0
});
q.surfaceContainerHighest = dt.fromPalette({
  name: "surface_container_highest",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 22 : 90, "tone"),
  isBackground: !0
});
q.onSurface = dt.fromPalette({
  name: "on_surface",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.surfaceVariant = dt.fromPalette({
  name: "surface_variant",
  palette: /* @__PURE__ */ u((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0
});
q.onSurfaceVariant = dt.fromPalette({
  name: "on_surface_variant",
  palette: /* @__PURE__ */ u((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 80 : 30, "tone"),
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
q.inverseSurface = dt.fromPalette({
  name: "inverse_surface",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 90 : 20, "tone")
});
q.inverseOnSurface = dt.fromPalette({
  name: "inverse_on_surface",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 20 : 95, "tone"),
  background: /* @__PURE__ */ u((n) => q.inverseSurface, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.outline = dt.fromPalette({
  name: "outline",
  palette: /* @__PURE__ */ u((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 60 : 50, "tone"),
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1.5, 3, 4.5, 7)
});
q.outlineVariant = dt.fromPalette({
  name: "outline_variant",
  palette: /* @__PURE__ */ u((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 30 : 80, "tone"),
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7)
});
q.shadow = dt.fromPalette({
  name: "shadow",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => 0, "tone")
});
q.scrim = dt.fromPalette({
  name: "scrim",
  palette: /* @__PURE__ */ u((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => 0, "tone")
});
q.surfaceTint = dt.fromPalette({
  name: "surface_tint",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0
});
q.primary = dt.fromPalette({
  name: "primary",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? n.isDark ? 100 : 0 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.primaryContainer, q.primary, 15, "nearer", !1), "toneDeltaPair")
});
q.onPrimary = dt.fromPalette({
  name: "on_primary",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ u((n) => q.primary, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.primaryContainer = dt.fromPalette({
  name: "primary_container",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => ll(n) ? I0(n.sourceColorHct, n) : pe(n) ? n.isDark ? 85 : 25 : n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.primaryContainer, q.primary, 15, "nearer", !1), "toneDeltaPair")
});
q.onPrimaryContainer = dt.fromPalette({
  name: "on_primary_container",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => ll(n) ? dt.foregroundTone(q.primaryContainer.tone(n), 4.5) : pe(n) ? n.isDark ? 0 : 100 : n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.primaryContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.inversePrimary = dt.fromPalette({
  name: "inverse_primary",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 40 : 80, "tone"),
  background: /* @__PURE__ */ u((n) => q.inverseSurface, "background"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
q.secondary = dt.fromPalette({
  name: "secondary",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.secondaryContainer, q.secondary, 15, "nearer", !1), "toneDeltaPair")
});
q.onSecondary = dt.fromPalette({
  name: "on_secondary",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? n.isDark ? 10 : 100 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ u((n) => q.secondary, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.secondaryContainer = dt.fromPalette({
  name: "secondary_container",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => {
    const t = n.isDark ? 30 : 90;
    if (pe(n))
      return n.isDark ? 30 : 85;
    if (!ll(n))
      return t;
    let e = ZE(n.secondaryPalette.hue, n.secondaryPalette.chroma, t, !n.isDark);
    return e = I0(n.secondaryPalette.getHct(e), n), e;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.secondaryContainer, q.secondary, 15, "nearer", !1), "toneDeltaPair")
});
q.onSecondaryContainer = dt.fromPalette({
  name: "on_secondary_container",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => ll(n) ? dt.foregroundTone(q.secondaryContainer.tone(n), 4.5) : n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.secondaryContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.tertiary = dt.fromPalette({
  name: "tertiary",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? n.isDark ? 90 : 25 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.tertiaryContainer, q.tertiary, 15, "nearer", !1), "toneDeltaPair")
});
q.onTertiary = dt.fromPalette({
  name: "on_tertiary",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ u((n) => q.tertiary, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.tertiaryContainer = dt.fromPalette({
  name: "tertiary_container",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => {
    if (pe(n))
      return n.isDark ? 60 : 49;
    if (!ll(n))
      return n.isDark ? 30 : 90;
    const t = I0(n.tertiaryPalette.getHct(n.sourceColorHct.tone), n), e = n.tertiaryPalette.getHct(t);
    return HF.fixIfDisliked(e).tone;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.tertiaryContainer, q.tertiary, 15, "nearer", !1), "toneDeltaPair")
});
q.onTertiaryContainer = dt.fromPalette({
  name: "on_tertiary_container",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? n.isDark ? 0 : 100 : ll(n) ? dt.foregroundTone(q.tertiaryContainer.tone(n), 4.5) : n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.tertiaryContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.error = dt.fromPalette({
  name: "error",
  palette: /* @__PURE__ */ u((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.errorContainer, q.error, 15, "nearer", !1), "toneDeltaPair")
});
q.onError = dt.fromPalette({
  name: "on_error",
  palette: /* @__PURE__ */ u((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ u((n) => q.error, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.errorContainer = dt.fromPalette({
  name: "error_container",
  palette: /* @__PURE__ */ u((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.errorContainer, q.error, 15, "nearer", !1), "toneDeltaPair")
});
q.onErrorContainer = dt.fromPalette({
  name: "on_error_container",
  palette: /* @__PURE__ */ u((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.errorContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.primaryFixed = dt.fromPalette({
  name: "primary_fixed",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.primaryFixed, q.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
q.primaryFixedDim = dt.fromPalette({
  name: "primary_fixed_dim",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.primaryFixed, q.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
q.onPrimaryFixed = dt.fromPalette({
  name: "on_primary_fixed",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ u((n) => q.primaryFixed, "secondBackground"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.onPrimaryFixedVariant = dt.fromPalette({
  name: "on_primary_fixed_variant",
  palette: /* @__PURE__ */ u((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ u((n) => q.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ u((n) => q.primaryFixed, "secondBackground"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
q.secondaryFixed = dt.fromPalette({
  name: "secondary_fixed",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 80 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.secondaryFixed, q.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
q.secondaryFixedDim = dt.fromPalette({
  name: "secondary_fixed_dim",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 70 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.secondaryFixed, q.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
q.onSecondaryFixed = dt.fromPalette({
  name: "on_secondary_fixed",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ u((n) => q.secondaryFixed, "secondBackground"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.onSecondaryFixedVariant = dt.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: /* @__PURE__ */ u((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 25 : 30, "tone"),
  background: /* @__PURE__ */ u((n) => q.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ u((n) => q.secondaryFixed, "secondBackground"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
q.tertiaryFixed = dt.fromPalette({
  name: "tertiary_fixed",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.tertiaryFixed, q.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
q.tertiaryFixedDim = dt.fromPalette({
  name: "tertiary_fixed_dim",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ u((n) => q.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ u((n) => new Ri(q.tertiaryFixed, q.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
q.onTertiaryFixed = dt.fromPalette({
  name: "on_tertiary_fixed",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ u((n) => q.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ u((n) => q.tertiaryFixed, "secondBackground"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
q.onTertiaryFixedVariant = dt.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: /* @__PURE__ */ u((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ u((n) => pe(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ u((n) => q.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ u((n) => q.tertiaryFixed, "secondBackground"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
var is;
const qE = (is = class {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = Pi.fromInt(t);
    return is.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new is(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    return new is(t, e, is.createKeyColor(t, e));
  }
  constructor(t, e, i) {
    this.hue = t, this.chroma = e, this.keyColor = i, this.cache = /* @__PURE__ */ new Map();
  }
  static createKeyColor(t, e) {
    let i = Pi.from(t, e, 50), s = Math.abs(i.chroma - e);
    for (let r = 1; r < 50; r += 1) {
      if (Math.round(e) === Math.round(i.chroma))
        return i;
      const a = Pi.from(t, e, 50 + r), o = Math.abs(a.chroma - e);
      o < s && (s = o, i = a);
      const l = Pi.from(t, e, 50 - r), c = Math.abs(l.chroma - e);
      c < s && (s = c, i = l);
    }
    return i;
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (e = Pi.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return Pi.fromInt(this.tone(t));
  }
}, h(is, "Us"), is);
u(qE, "TonalPalette");
let ie = qE;
function ck(n) {
  const t = KS(n), e = JS(n), i = tP(n), s = [t.toString(16), e.toString(16), i.toString(16)];
  for (const [r, a] of s.entries())
    a.length === 1 && (s[r] = "0" + a);
  return "#" + s.join("");
}
h(ck, "uy");
u(ck, "hexFromArgb");
function VE(n) {
  n = n.replace("#", "");
  const t = n.length === 3, e = n.length === 6, i = n.length === 8;
  if (!t && !e && !i)
    throw new Error("unexpected hex " + n);
  let s = 0, r = 0, a = 0;
  return t ? (s = jn(n.slice(0, 1).repeat(2)), r = jn(n.slice(1, 2).repeat(2)), a = jn(n.slice(2, 3).repeat(2))) : e ? (s = jn(n.slice(0, 2)), r = jn(n.slice(2, 4)), a = jn(n.slice(4, 6))) : i && (s = jn(n.slice(2, 4)), r = jn(n.slice(4, 6)), a = jn(n.slice(6, 8))), (255 << 24 | (s & 255) << 16 | (r & 255) << 8 | a & 255) >>> 0;
}
h(VE, "w1");
u(VE, "argbFromHex");
function jn(n) {
  return parseInt(n, 16);
}
h(jn, "Ti");
u(jn, "parseIntHex");
function jE(n, t = !1) {
  var e;
  const i = (e = n.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)) == null ? void 0 : e.slice(1).map((l, c) => c === 3 ? Math.round(parseFloat(l) * 255) : parseFloat(l));
  if (!i)
    throw new Error("Could not parse rgba color.");
  const [s, r, a, o] = i;
  return ((t ? 255 : o & 255) << 24 | (s & 255) << 16 | (r & 255) << 8 | a & 255) >>> 0;
}
h(jE, "f1");
u(jE, "argbFromRgba");
function FE(n) {
  ti();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${n} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
h(FE, "m1");
u(FE, "getComputedColor");
function Zv(n) {
  return getComputedStyle(n).getPropertyValue("--wy-theme-color") || void 0;
}
h(Zv, "au");
u(Zv, "getCSSThemeColor");
function UE(n, t) {
  let e = Zv(n);
  const i = new MutationObserver(() => {
    const a = Zv(n);
    a !== e && (e = a, t(a));
  }), s = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let r = n;
  for (; r && r !== document; )
    i.observe(r, s), r = r.parentNode;
  return () => i.disconnect();
}
h(UE, "v1");
u(UE, "observeCSSThemeColor");
function Wv() {
  var n;
  return ti(), ((n = Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((t) => {
    var e;
    const i = t.getAttribute("media");
    return !i || ((e = window.matchMedia(i)) == null ? void 0 : e.matches);
  }).pop()) == null ? void 0 : n.getAttribute("content")) || void 0;
}
h(Wv, "ou");
u(Wv, "getMetaThemeColor");
function BE(n) {
  ti();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = Wv();
  const i = /* @__PURE__ */ u(() => {
    const o = Wv();
    o !== e && (e = o, n(o));
  }, "checkChangedColor"), s = new MutationObserver(i), r = {
    attributes: !0,
    attributeFilter: ["content"]
  }, a = [];
  return t.forEach((o) => {
    s.observe(o, r);
    const l = o.getAttribute("media");
    if (l) {
      const c = window.matchMedia(l);
      c.addEventListener("change", i), a.push(c);
    }
  }), () => {
    s.disconnect(), a.forEach((o) => o.removeEventListener("change", i));
  };
}
h(BE, "g1");
u(BE, "observeMetaThemeColor");
const sm = [], YF = 16;
function XE(n, t = !1) {
  var e;
  if (sm.some((T) => T.seedColor === n)) {
    const T = (e = sm.find((I) => I.seedColor === n)) == null ? void 0 : e.colors;
    if (T)
      return T;
  }
  const i = [];
  t && i.push(`--wy-theme-color:${n};`);
  let s = n;
  !n.startsWith("#") && !n.startsWith("rgb") && (s = FE(n));
  const r = n.startsWith("#") ? VE(s) : jE(s), a = Pi.fromInt(r), o = a.hue, l = a.chroma, c = Math.max(48, l), d = Math.min(c, 84), p = 360 / 16, f = 27.4, m = -8, w = (o + 360 - f - m + p / 2) % p + f + m - p / 2, b = {
    primary: ie.fromHueAndChroma(o, c),
    secondary: ie.fromHueAndChroma(o, c / 3),
    tertiary: ie.fromHueAndChroma(o + 60, c / 2),
    neutral: ie.fromHueAndChroma(o, Math.min(l / 12, 4)),
    "neutral-variant": ie.fromHueAndChroma(o, Math.min(l / 6, 8)),
    error: ie.fromHueAndChroma(w, 84),
    warning: ie.fromHueAndChroma(w + 4 * p, d),
    // Same as yellow
    red: ie.fromHueAndChroma(w, d),
    "deep-orange": ie.fromHueAndChroma(w + 1 * p, d),
    orange: ie.fromHueAndChroma(w + 2 * p, d),
    amber: ie.fromHueAndChroma(w + 3 * p, d),
    yellow: ie.fromHueAndChroma(w + 4 * p, d),
    lime: ie.fromHueAndChroma(w + 5 * p, d),
    "light-green": ie.fromHueAndChroma(w + 6 * p, d),
    green: ie.fromHueAndChroma(w + 7 * p, d),
    teal: ie.fromHueAndChroma(w + 8 * p, d),
    cyan: ie.fromHueAndChroma(w + 9 * p, d),
    "light-blue": ie.fromHueAndChroma(w + 10 * p, d),
    blue: ie.fromHueAndChroma(w + 11 * p, d),
    indigo: ie.fromHueAndChroma(w + 12 * p, d),
    "deep-purple": ie.fromHueAndChroma(w + 13 * p, d),
    purple: ie.fromHueAndChroma(w + 14 * p, d),
    pink: ie.fromHueAndChroma(w + 15 * p, d),
    gray: ie.fromHueAndChroma(o, 4)
  }, x = {
    //"100": 100,
    99: 99,
    95: 95,
    90: 90,
    80: 80,
    70: 70,
    60: 60,
    50: 50,
    40: 40,
    30: 30,
    20: 20,
    10: 10
    //"0": 0
  }, O = {
    primary: x,
    secondary: x,
    tertiary: x,
    neutral: x,
    "neutral-variant": x,
    error: x,
    warning: x,
    blue: { light: 70, dark: 80 },
    indigo: { light: 60, dark: 60 },
    purple: { light: 60, dark: 70 },
    pink: { light: 60, dark: 70 },
    red: { light: 60, dark: 60 },
    orange: { light: 70, dark: 70 },
    yellow: { light: 70, dark: 80 },
    green: { light: 60, dark: 60 },
    teal: { light: 60, dark: 60 },
    cyan: { light: 50, dark: 60 },
    gray: { light: 50, dark: 60 }
  };
  for (const T in O) {
    const I = O[T];
    for (const Z in I) {
      const W = ck(b[T].tone(I[Z]));
      i.push(`--wy-${T}-${Z}:${W};`);
    }
  }
  const P = {
    light: b.primary.tone(40),
    dark: b.primary.tone(80)
  }, A = {
    light: b.neutral.tone(99),
    dark: b.neutral.tone(10)
  }, R = {
    "surface-1": {
      light: Dn.cam16Ucs(A.light, P.light, 0.05),
      dark: Dn.cam16Ucs(A.dark, P.dark, 0.05)
    },
    "surface-2": {
      light: Dn.cam16Ucs(A.light, P.light, 0.08),
      dark: Dn.cam16Ucs(A.dark, P.dark, 0.08)
    },
    "surface-3": {
      light: Dn.cam16Ucs(A.light, P.light, 0.11),
      dark: Dn.cam16Ucs(A.dark, P.dark, 0.11)
    },
    "surface-4": {
      light: Dn.cam16Ucs(A.light, P.light, 0.12),
      dark: Dn.cam16Ucs(A.dark, P.dark, 0.12)
    },
    "surface-5": {
      light: Dn.cam16Ucs(A.light, P.light, 0.14),
      dark: Dn.cam16Ucs(A.dark, P.dark, 0.14)
    }
  };
  for (const T in R) {
    const I = R[T];
    for (const Z in I) {
      const W = ck(I[Z]);
      i.push(`--wy-${T}-${Z}:${W};`);
    }
  }
  return sm.unshift({ seedColor: n, colors: i }), sm.length = Math.min(sm.length, YF), i;
}
h(XE, "x1");
u(XE, "generateThemeColors");
const GF = /* @__PURE__ */ u((n) => {
  if (ti(), M0)
    document.adoptedStyleSheets = n.map(
      (t) => t instanceof CSSStyleSheet ? t : t.styleSheet
    );
  else
    for (const t of n) {
      const e = document.createElement("style"), i = global.litNonce;
      i !== void 0 && e.setAttribute("nonce", i), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), Xi = Mt`.wy-light :where(wy-chat),.wy-light :where(wy-comments),.wy-light :where(wy-component),.wy-light :where(wy-copilot),.wy-light :where(wy-files),.wy-light :where(wy-messenger),.wy-light :where(wy-notification-toasts),.wy-light :where(wy-notifications),.wy-light :where(wy-posts),:host(.wy-light),:host .wy-light,::slotted(.wy-light){color-scheme:light;--wy-primary: var(--wy-primary-40, #006399);--wy-on-primary: var(--wy-white, #ffffff);--wy-primary-container: var(--wy-primary-90, #cde5ff);--wy-on-primary-container: var(--wy-primary-10, #001d32);--wy-secondary: var(--wy-secondary-40, #3b6a1c);--wy-on-secondary: var(--wy-white, #ffffff);--wy-secondary-container: var(--wy-secondary-90, #bbf294);--wy-on-secondary-container: var(--wy-secondary-10, #0a2100);--wy-tertiary: var(--wy-tertiary-40, #3b6a1c);--wy-on-tertiary: var(--wy-white, #ffffff);--wy-tertiary-container: var(--wy-tertiary-90, #bbf294);--wy-on-tertiary-container: var(--wy-tertiary-10, #0a2100);--wy-error: var(--wy-error-40, #ba1824);--wy-on-error: var(--wy-white, #ffffff);--wy-error-container: var(--wy-error-90, #ffdad7);--wy-on-error-container: var(--wy-error-10, #410004);--wy-warning: var(--wy-warning-70, #afb140);--wy-on-warning: var(--wy-black, #000000);--wy-warning-container: var(--wy-warning-90, #e7e971);--wy-on-warning-container: var(--wy-warning-10, #1c1d00);--wy-background: var(--wy-neutral-99, #fcfcff);--wy-on-background: var(--wy-neutral-10, #1a1c1e);--wy-surface: var(--wy-neutral-99, #fcfcff);--wy-on-surface: var(--wy-neutral-10, #1a1c1e);--wy-surface-variant: var(--wy-neutral-variant-90, #dee3eb);--wy-on-surface-variant: var(--wy-neutral-variant-30, #42474e);--wy-outline: var(--wy-neutral-variant-50, #72777e);--wy-outline-variant: var(--wy-neutral-variant-80, #c2c7ce);--wy-inverse-surface: var(--wy-neutral-20, #2f3033);--wy-on-inverse-surface: var(--wy-neutral-95, #f0f0f4);--wy-inverse-primary: var(--wy-primary-80, #95ccff);--wy-surface-1: var(--wy-surface-1-light, #f1f2f7);--wy-surface-2: var(--wy-surface-2-light, #eaedf3);--wy-surface-3: var(--wy-surface-3-light, #e3e7ee);--wy-surface-4: var(--wy-surface-4-light, #e1e6ed);--wy-surface-5: var(--wy-surface-5-light, #dce2ea);--wy-highlight: var(--wy-primary-95, #e8f2ff);--wy-on-highlight: var(--wy-primary-10, #001d32);--wy-link: var(--wy-primary-40, #006399);--wy-presence-active: var(--wy-green-light, #00a38b);--wy-blue: var(--wy-blue-light, #89a9fc);--wy-indigo: var(--wy-indigo-light, #9185de);--wy-purple: var(--wy-purple-light, #c675b7);--wy-pink: var(--wy-pink-light, #d57194);--wy-red: var(--wy-red-light, #db726c);--wy-orange: var(--wy-orange-light, #e89a3a);--wy-yellow: var(--wy-yellow-light, #afb140);--wy-green: var(--wy-green-light, #00a38b);--wy-teal: var(--wy-teal-light, #00a0a8);--wy-cyan: var(--wy-cyan-light, #0082a1);--wy-gray: var(--wy-gray-light, #76777a);--wy-code-text: var(--wy-code-text-light, #3b3b3b);--wy-code-variable: var(--wy-code-variable-light, #001080);--wy-code-operator: var(--wy-code-operator-light, #000000);--wy-code-prolog: var(--wy-code-prolog-light, #000080);--wy-code-comment: var(--wy-code-comment-light, #008000);--wy-code-builtin: var(--wy-code-builtin-light, #0070C1);--wy-code-number: var(--wy-code-number-light, #098658);--wy-code-inserted: var(--wy-code-inserted-light, #098658);--wy-code-constant: var(--wy-code-constant-light, #811F3F);--wy-code-hexcode: var(--wy-code-hexcode-light, #811F3F);--wy-code-regex: var(--wy-code-regex-light, #811F3F);--wy-code-char: var(--wy-code-char-light, #811F3F);--wy-code-tag: var(--wy-code-tag-light, #800000);--wy-code-attr-name: var(--wy-code-attr-name-light, #E50000);--wy-code-selector: var(--wy-code-selector-light, #E50000);--wy-code-property: var(--wy-code-property-light, #E50000);--wy-code-deleted: var(--wy-code-deleted-light, #A31515);--wy-code-string: var(--wy-code-string-light, #A31515);--wy-code-changed: var(--wy-code-changed-light, #0451A5);--wy-code-punctuation: var(--wy-code-punctuation-light, #000000);--wy-code-function: var(--wy-code-function-light, #0000FF);--wy-code-keyword: var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name: var(--wy-code-class-name-light, #267F99)}.wy-dark:not(.wy-light) :where(wy-chat),.wy-dark:not(.wy-light) :where(wy-comments),.wy-dark:not(.wy-light) :where(wy-component),.wy-dark:not(.wy-light) :where(wy-copilot),.wy-dark:not(.wy-light) :where(wy-files),.wy-dark:not(.wy-light) :where(wy-messenger),.wy-dark:not(.wy-light) :where(wy-notification-toasts),.wy-dark:not(.wy-light) :where(wy-notifications),.wy-dark:not(.wy-light) :where(wy-posts),:host(.wy-dark:not(.wy-light)),:host .wy-dark:not(.wy-light),::slotted(.wy-dark:not(.wy-light)){color-scheme:dark;--wy-primary: var(--wy-primary-80, #95ccff);--wy-on-primary: var(--wy-primary-20, #003352);--wy-primary-container: var(--wy-primary-30, #004a75);--wy-on-primary-container: var(--wy-primary-90, #cde5ff);--wy-secondary: var(--wy-secondary-80, #a0d57b);--wy-on-secondary: var(--wy-secondary-20, #163800);--wy-secondary-container: var(--wy-secondary-30, #245103);--wy-on-secondary-container: var(--wy-secondary-90, #bbf294);--wy-tertiary: var(--wy-tertiary-80, #a0d57b);--wy-on-tertiary: var(--wy-tertiary-20, #163800);--wy-tertiary-container: var(--wy-tertiary-30, #245103);--wy-on-tertiary-container: var(--wy-tertiary-90, #bbf294);--wy-error: var(--wy-error-80, #ffb3ae);--wy-on-error: var(--wy-error-20, #68000b);--wy-error-container: var(--wy-error-30, #930014);--wy-on-error-container: var(--wy-error-90, #ffdad7);--wy-warning: var(--wy-warning-90, #e7e971);--wy-on-warning: var(--wy-warning-30, #484a00);--wy-warning-container: var(--wy-warning-50, #7a7c05);--wy-on-warning-container: var(--wy-warning-95, #f5f77d);--wy-background: var(--wy-neutral-10, #1a1c1e);--wy-on-background: var(--wy-neutral-90, #e2e2e5);--wy-surface: var(--wy-neutral-10, #1a1c1e);--wy-on-surface: var(--wy-neutral-90, #e2e2e5);--wy-surface-variant: var(--wy-neutral-variant-30, #42474e);--wy-on-surface-variant: var(--wy-neutral-variant-80, #c2c7ce);--wy-outline: var(--wy-neutral-variant-60, #8c9198);--wy-outline-variant: var(--wy-neutral-variant-30, #42474e);--wy-inverse-surface: var(--wy-neutral-90, #e2e2e5);--wy-on-inverse-surface: var(--wy-neutral-20, #2f3033);--wy-inverse-primary: var(--wy-primary-40, #006399);--wy-surface-1: var(--wy-surface-1-dark, #212427);--wy-surface-2: var(--wy-surface-2-dark, #25292d);--wy-surface-3: var(--wy-surface-3-dark, #292e33);--wy-surface-4: var(--wy-surface-4-dark, #2b3035);--wy-surface-5: var(--wy-surface-5-dark, #2d3338);--wy-highlight: var(--wy-primary-20, #003352);--wy-on-highlight: var(--wy-primary-90, #cde5ff);--wy-link: var(--wy-primary-80, #95ccff);--wy-presence-active: var(--wy-green-dark, #00a38b);--wy-blue: var(--wy-blue-dark, #b1c5ff);--wy-indigo: var(--wy-indigo-dark, #9185de);--wy-purple: var(--wy-purple-dark, #e38fd3);--wy-pink: var(--wy-pink-dark, #f48bae);--wy-red: var(--wy-red-dark, #db726c);--wy-orange: var(--wy-orange-dark, #e89a3a);--wy-yellow: var(--wy-yellow-dark, #cacc58);--wy-green: var(--wy-green-dark, #00a38b);--wy-teal: var(--wy-teal-dark, #00a0a8);--wy-cyan: var(--wy-cyan-dark, #009dc3);--wy-gray: var(--wy-gray-dark, #909194);--wy-code-text: var(--wy-code-text-dark, #cccccc);--wy-code-variable: var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator: var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog: var(--wy-code-prolog-dark, #569CD6);--wy-code-comment: var(--wy-code-comment-dark, #6a9955);--wy-code-builtin: var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number: var(--wy-code-number-dark, #b5cea8);--wy-code-inserted: var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant: var(--wy-code-constant-dark, #646695);--wy-code-hexcode: var(--wy-code-hexcode-dark, #646695);--wy-code-regex: var(--wy-code-regex-dark, #d16969);--wy-code-char: var(--wy-code-char-dark, #d16969);--wy-code-tag: var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name: var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector: var(--wy-code-selector-dark, #9cdcfe);--wy-code-property: var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted: var(--wy-code-deleted-dark, #ce9178);--wy-code-string: var(--wy-code-string-dark, #ce9178);--wy-code-changed: var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation: var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function: var(--wy-code-function-dark, #569cd6);--wy-code-keyword: var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name: var(--wy-code-class-name-dark, #4ec9b0)}`, KF = Mt`@property --wy-component-color{syntax: \"<color>\"; inherits: true; initial-value: currentColor;}@property --wy-component-background-color{syntax: \"<color>\"; inherits: true; initial-value: transparent;}`, JF = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), GF([KF, Xi]);
    }
  }, h(e, "t"), e), u(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), tU = /* @__PURE__ */ u((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this.version = Ce.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     * @param {string} [version] - Optional version to check against the environment version.
     */
    async checkVersion(s = this.version) {
      var r, a;
      await this.whenUrl(), this.networkStateIsPending = !0;
      let o;
      try {
        if (o = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !o.ok)
          throw new Error("Could not verify environment version.");
        this.networkStateIsPending = !1, this.serverState = "ok";
      } catch (c) {
        this.networkStateIsPending = !1, this.serverState = "unreachable", console.warn("Could not check version: " + c.toString());
        return;
      }
      const l = await o.text();
      if (l.startsWith("v") && (!s || !l || s !== l))
        try {
          const c = s.split(".").slice(0, 2), d = l.split(".").slice(0, 2);
          if (c[0] !== d[0])
            throw new Error();
          c[1] !== d[1] && console.warn(
            `Version inconsistency: ${Ce.sourceName}@${this.version} ≠ ${(r = this.url) == null ? void 0 : r.hostname}@${l}`
          );
        } catch {
          throw new Error(
            `Version mismatch! ${Ce.sourceName}@${this.version} ≠ ${(a = this.url) == null ? void 0 : a.hostname}@${l}`
          );
        }
    }
  }, h(e, "t"), e), u(t, "WeavyVersion"), t;
}, "WeavyVersionMixin");
var wO, Pu;
let NE = (wO = (Pu = class extends Event {
  constructor(t, e, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = s ?? !1;
  }
}, h(Pu, "bn"), Pu), u(wO, "s"), wO);
var gO, Cu;
let qs = (gO = (Cu = class {
  constructor(t, e, i, s) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (r, a) => {
      this.unsubscribe && (this.unsubscribe !== a && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = r, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(r, a)), this.unsubscribe = a;
    }, this.host = t, e.context !== void 0) {
      const r = e;
      this.context = r.context, this.callback = r.callback, this.subscribe = r.subscribe ?? !1;
    } else this.context = e, this.callback = i, this.subscribe = s ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new NE(this.context, this.host, this.t, this.subscribe));
  }
}, h(Cu, "xn"), Cu), u(gO, "s"), gO);
var vO, Qu;
let eU = (vO = (Qu = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const i = e || !Object.is(t, this.o);
    this.o = t, i && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: i }] of this.subscriptions) e(this.o, i);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, i) {
    if (!i) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ u(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: s } = this.subscriptions.get(t);
    t(this.value, s);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, h(Qu, "$n"), Qu), u(vO, "s"), vO);
var bO, Mu;
let iU = (bO = (Mu = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, h(Mu, "Cn"), Mu), u(bO, "e"), bO);
var OO, Tu;
let hk = (OO = (Tu = class extends eU {
  constructor(t, e, i) {
    var s, r;
    super(e.context !== void 0 ? e.initialValue : i), this.onContextRequest = (a) => {
      if (a.context !== this.context) return;
      const o = a.contextTarget ?? a.composedPath()[0];
      o !== this.host && (a.stopPropagation(), this.addCallback(a.callback, o, a.subscribe));
    }, this.onProviderRequest = (a) => {
      if (a.context !== this.context || (a.contextTarget ?? a.composedPath()[0]) === this.host) return;
      const o = /* @__PURE__ */ new Set();
      for (const [l, { consumerHost: c }] of this.subscriptions) o.has(l) || (o.add(l), c.dispatchEvent(new NE(this.context, c, l, !0)));
      a.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), (r = (s = this.host).addController) == null || r.call(s, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new iU(this.context, this.host));
  }
}, h(Tu, "kn"), Tu), u(OO, "i"), OO);
function Gs({ context: n }) {
  return (t, e) => {
    const i = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(s) {
      return i.get(this).setValue(s), t.set.call(this, s);
    }, init(s) {
      return i.set(this, new hk(this, { context: n, initialValue: s })), s;
    } };
    {
      t.constructor.addInitializer((a) => {
        i.set(a, new hk(a, { context: n }));
      });
      const s = Object.getOwnPropertyDescriptor(t, e);
      let r;
      if (s === void 0) {
        const a = /* @__PURE__ */ new WeakMap();
        r = { get() {
          return a.get(this);
        }, set(o) {
          i.get(this).setValue(o), a.set(this, o);
        }, configurable: !0, enumerable: !0 };
      } else {
        const a = s.set;
        r = { ...s, set(o) {
          i.get(this).setValue(o), a == null || a.call(this, o);
        } };
      }
      return void Object.defineProperty(t, e, r);
    }
  };
}
h(Gs, "Os");
u(Gs, "e$5");
function ve({ context: n, subscribe: t }) {
  return (e, i) => {
    typeof i == "object" ? i.addInitializer(function() {
      new qs(this, { context: n, callback: /* @__PURE__ */ u((s) => {
        e.set.call(this, s);
      }, "callback"), subscribe: t });
    }) : e.constructor.addInitializer((s) => {
      new qs(s, { context: n, callback: /* @__PURE__ */ u((r) => {
        s[i] = r;
      }, "callback"), subscribe: t });
    });
  };
}
h(ve, "ee");
u(ve, "c$2");
var Au;
const HE = (Au = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = s ?? !1;
  }
}, h(Au, "kp"), Au);
u(HE, "ContextRequestEvent");
let nU = HE;
var Ru;
const YE = (Ru = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, h(Ru, "_p"), Ru);
u(YE, "ContextProviderEvent");
let sU = YE;
var Eu;
const GE = (Eu = class extends hk {
  constructor(t, e, i) {
    e.context !== void 0 ? super(t, e) : super(t, e, i), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof ft || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new sU(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
}, h(Eu, "zp"), Eu);
u(GE, "WyContextProvider");
let KE = GE;
const _e = Symbol.for("weavy-client");
function JE(n, t) {
  return ti(), new KE(n, { context: _e, initialValue: t });
}
h(JE, "P1");
u(JE, "createWeavyContextProvider");
const Di = a0() ? JE(document.documentElement) : void 0, rU = /* @__PURE__ */ u((n) => {
  var i;
  var t, e;
  return e = (i = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), F(this, t), this.host !== document.documentElement ? (Di == null || Di.detachListeners(), L(this, t, new KE(this.host, {
        context: _e,
        initialValue: this
      }))) : Di == null || Di.setValue(this);
    }
    updateContext() {
      var r;
      this.host !== document.documentElement ? (r = k(this, t)) == null || r.updateObservers() : Di == null || Di.updateObservers();
    }
    destroy() {
      var r;
      super.destroy(), this.host !== document.documentElement ? (r = k(this, t)) == null || r.detachListeners() : (Di == null ? void 0 : Di.value) === this && (Di == null || Di.setValue(void 0));
    }
  }, h(i, "e"), i), t = /* @__PURE__ */ new WeakMap(), u(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var v1, b1, cr, bm, He;
const Om = (He = class {
  // CONSTRUCTOR
  constructor(t) {
    F(this, v1), F(this, b1), F(this, cr), F(this, bm), this.weavySid = Kf(), this.weavyId = `${He.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = He.defaults.cloudFilePickerUrl, this.disableEnvironmentImports = He.defaults.disableEnvironmentImports, this.gcTime = He.defaults.gcTime, this.scrollBehavior = He.defaults.scrollBehavior, this.staleTime = He.defaults.staleTime, this.tokenFactoryRetryDelay = He.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = He.defaults.tokenFactoryTimeout, L(this, b1, new Promise((i) => {
      L(this, v1, i);
    })), L(this, bm, !1), console.info(`${He.sourceName}@${He.version} #${this.weavySid}`), ti(), this.host = document.documentElement;
    const e = {};
    for (const i in t) {
      const s = i;
      t[s] !== void 0 && Object.assign(e, { [s]: t[s] });
    }
    e != null && e.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await k(this, b1);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return k(this, cr);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Se();
    try {
      if (typeof t == "string")
        t && L(this, cr, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        L(this, cr, t || void 0);
      else if (t == null)
        L(this, cr, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), k(this, cr) && ((e = k(this, v1)) == null || e.call(this, k(this, cr)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${He.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return k(this, bm);
  }
  destroy() {
    L(this, bm, !0), console.info(this.weavyId, "was destroyed");
  }
}, h(He, "he"), He);
v1 = /* @__PURE__ */ new WeakMap(), b1 = /* @__PURE__ */ new WeakMap(), cr = /* @__PURE__ */ new WeakMap(), bm = /* @__PURE__ */ new WeakMap(), u(Om, "WeavyClient"), Om.version = "29.1.0", Om.sourceName = "@weavy/uikit-web", Om.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: yE,
  notificationEvents: !1,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  notifications: "button-list",
  notificationsBadge: "count",
  reactions: "😍 😎 😉 😜 👍"
};
let Ce = Om;
var zu;
const tz = (zu = class extends rU(
  LF(
    FF(
      DF(
        ZF(
          qF(
            IF(
              jF(tU(WF(JF(UF(Ce)))))
            )
          )
        )
      )
    )
  )
) {
}, h(zu, "Mp"), zu);
u(tz, "Weavy");
let ke = tz;
var _u;
const ez = (_u = class {
  constructor(t, e, i, s, r) {
    var a, o;
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (l, c) => {
      this.unsubscribe && (this.unsubscribe !== c && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = l, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(l, c)), this.unsubscribe = c;
    }, this.host = t, e.context !== void 0) {
      const l = e;
      this.context = l.context, this.callback = l.callback, this.subscribe = l.subscribe ?? !1, this.ref = l.ref ?? t;
    } else
      this.context = e, this.callback = i, this.subscribe = s ?? !1, this.ref = r ?? t;
    (o = (a = this.host).addController) == null || o.call(a, this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new nU(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
}, h(_u, "Pp"), _u);
u(ez, "ContextConsumer");
let aU = ez;
var Lu;
const iz = (Lu = class {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, i) {
    this.whenRef = new Promise((s) => this.resolveRef = s), t.addController(this), this.host = t, this.ref = i, this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    var e;
    this._ref = t, t && ((e = this.resolveRef) == null || e.call(this, t));
  }
  async setContext(t) {
    this.whenContext = new Promise((i) => this.resolveContext = i);
    const e = await this.whenRef;
    this.context = new aU(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ u((i, s) => {
        var r;
        (r = this.resolveContext) == null || r.call(this, i), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await Wk(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    var t, e;
    (t = this.context) != null && t.value && ((e = this.resolveContext) == null || e.call(this, this.context.value));
  }
}, h(Lu, "Sp"), Lu);
u(iz, "ContextController");
let oU = iz;
const lU = { attribute: !0, type: String, converter: xv, reflect: !1, hasChanged: AS }, cU = /* @__PURE__ */ u((n = lU, t, e) => {
  const { kind: i, metadata: s } = e;
  let r = globalThis.litPropertyMetadata.get(s);
  if (r === void 0 && globalThis.litPropertyMetadata.set(s, r = /* @__PURE__ */ new Map()), i === "setter" && ((n = Object.create(n)).wrapped = !0), r.set(e.name, n), i === "accessor") {
    const { name: a } = e;
    return { set(o) {
      const l = t.get.call(this);
      t.set.call(this, o), this.requestUpdate(a, l, n);
    }, init(o) {
      return o !== void 0 && this.C(a, void 0, n, o), o;
    } };
  }
  if (i === "setter") {
    const { name: a } = e;
    return function(o) {
      const l = this[a];
      t.call(this, o), this.requestUpdate(a, l, n);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$3");
function $(n) {
  return (t, e) => typeof e == "object" ? cU(n, t, e) : ((i, s, r) => {
    const a = s.hasOwnProperty(r);
    return s.constructor.createProperty(r, i), a ? Object.getOwnPropertyDescriptor(s, r) : void 0;
  })(n, t, e);
}
h($, "y");
u($, "n$3");
function U(n) {
  return $({ ...n, state: !0, attribute: !1 });
}
h(U, "H");
u(U, "r$2");
const hU = /* @__PURE__ */ u((n, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(n, t, e), e), "e$4");
function iP(n) {
  return (t, e) => {
    const { slot: i, selector: s } = n ?? {}, r = "slot" + (i ? `[name=${i}]` : ":not([name])");
    return hU(t, e, { get() {
      var a;
      const o = (a = this.renderRoot) == null ? void 0 : a.querySelector(r), l = (o == null ? void 0 : o.assignedElements(n)) ?? [];
      return s === void 0 ? l : l.filter((c) => c.matches(s));
    } });
  };
}
h(iP, "Uw");
u(iP, "o$6");
var O1, Iu;
const nz = (Iu = class {
  // PROPERTY INIT
  constructor(t) {
    F(this, O1), this.notifications = Ce.defaults.notifications, this.notificationsBadge = Ce.defaults.notificationsBadge, this.reactions = Ce.defaults.reactions, L(this, O1, t), Object.keys(this).forEach((e) => {
      e in t && Object.assign(this, { [e]: t[e] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return k(this, O1);
  }
}, h(Iu, "Ap"), Iu);
O1 = /* @__PURE__ */ new WeakMap(), u(nz, "WeavyComponentSettings");
let y3 = nz;
const sz = Symbol.for("weavy-component-settings");
var Zu;
const rz = (Zu = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await sl(this.host), this.context = new qs(this.host, {
      context: _e,
      subscribe: !0,
      callback: /* @__PURE__ */ u((t) => {
        var e, i;
        t && ((e = this.resolveContext) == null || e.call(this, t), this.queryClient = t.queryClient, (i = this.resolveQueryClient) == null || i.call(this, t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    var i;
    (i = this.observerUnsubscribe) == null || i.call(this);
    const s = await this.whenQueryClient;
    if (!s)
      throw new Error("No QueryClient provided");
    const r = new NR(s, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    var e;
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const s = xy(this.result, this.observer.getCurrentResult());
          s !== this._result && (this._result = s, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let i;
      t ? i = this.observer.fetchOptimistic(this.observer.options) : i = (e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)) == null ? void 0 : e.promise, i == null || i.catch(() => {
      }).finally(() => {
        var s;
        (s = this.observer) == null || s.updateResult();
      });
    }
  }
  untrackQuery() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this);
  }
}, h(Zu, "Ep"), Zu);
u(rz, "QueryController");
let Cn = rz;
const nP = Symbol.for("weavy-app"), Z0 = Symbol.for("weavy-user");
var _ = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.agents = "agents", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(_ || {});
const W0 = Symbol.for("weavy-features");
var Za, pc, $s, zo;
const az = (zo = class {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    F(this, Za), F(this, pc), F(this, $s), L(this, Za, Object.keys(t)), L(this, pc, Object.entries(t).reduce(
      (i, [s, r]) => (r && i.push(s), i),
      []
    )), L(this, $s, e ?? k(this, pc));
  }
  features() {
    return k(this, Za);
  }
  supportedFeature(...t) {
    return t.every((e) => k(this, Za).includes(e));
  }
  allowedFeatures() {
    return k(this, $s);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? k(this, $s).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? k(this, $s).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return L(this, $s, typeof t == "string" ? sP(t, k(this, Za)) : k(this, pc)), k(this, $s);
  }
  immutable() {
    const t = D0(k(this, Za), k(this, pc));
    return new zo(t, k(this, $s));
  }
}, h(zo, "wd"), zo);
Za = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap(), $s = /* @__PURE__ */ new WeakMap(), u(az, "ComponentFeatures");
let $n = az;
function sP(n, t) {
  return n.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
h(sP, "Nw");
u(sP, "featureListFromString");
function D0(n, t) {
  return t ?? (t = n), Object.fromEntries(
    n.map((e) => [e, t.includes(e)])
  );
}
h(D0, "Ku");
u(D0, "featureConfigFromList");
const dk = Object.values(_), oz = Symbol.for("weavy-link"), Ne = [];
for (let n = 0; n < 256; ++n)
  Ne.push((n + 256).toString(16).slice(1));
function lz(n, t = 0) {
  return (Ne[n[t + 0]] + Ne[n[t + 1]] + Ne[n[t + 2]] + Ne[n[t + 3]] + "-" + Ne[n[t + 4]] + Ne[n[t + 5]] + "-" + Ne[n[t + 6]] + Ne[n[t + 7]] + "-" + Ne[n[t + 8]] + Ne[n[t + 9]] + "-" + Ne[n[t + 10]] + Ne[n[t + 11]] + Ne[n[t + 12]] + Ne[n[t + 13]] + Ne[n[t + 14]] + Ne[n[t + 15]]).toLowerCase();
}
h(lz, "O1");
u(lz, "unsafeStringify");
let $O;
const dU = new Uint8Array(16);
function cz() {
  if (!$O) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    $O = crypto.getRandomValues.bind(crypto);
  }
  return $O(dU);
}
h(cz, "I1");
u(cz, "rng");
const uU = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), m3 = { randomUUID: uU };
function Fc(n, t, e) {
  var i;
  if (m3.randomUUID && !n)
    return m3.randomUUID();
  n = n || {};
  const s = n.random ?? ((i = n.rng) == null ? void 0 : i.call(n)) ?? cz();
  if (s.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return s[6] = s[6] & 15 | 64, s[8] = s[8] & 63 | 128, lz(s);
}
h(Fc, "fc");
u(Fc, "v4");
function hz(n) {
  let t;
  if (n instanceof URL)
    t = { type: "url", item: n };
  else if (n instanceof File)
    t = { type: "file", item: n };
  else if (n instanceof Blob)
    t = {
      type: "file",
      item: new File([n], `${Fc()}`, { type: n.type })
    };
  else if (typeof n == "string")
    t = {
      type: "file",
      item: new File([n], `${Fc()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (MR(n) || Sv(n))
    try {
      const e = Sv(n) ? n.toJSON() : JSON.stringify(n, ER(), 2);
      t = {
        type: "file",
        item: new File([e], `${Fc()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
h(hz, "F1");
u(hz, "getContextDataRef");
const ky = /* @__PURE__ */ u((n, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let i = n, s = 0;
  for (; s < e.length - 1 && i >= 1024; )
    i = 100 * i / 1024 / 100, s++;
  return i.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[s];
}, "fileSizeAsString");
function Ei(n) {
  return n.lastIndexOf(".") === -1 ? "." : (n.substring(n.lastIndexOf("."), n.length) || n).toLowerCase();
}
h(Ei, "Qe");
u(Ei, "getExtension");
function rP(n) {
  switch (n) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
h(rP, "Ww");
u(rP, "isAudio");
function dz(n) {
  switch (n) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
h(dz, "D1");
u(dz, "isImage");
function uz(n) {
  switch (Ei(n)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
h(uz, "H1");
u(uz, "isWebImage");
function aP(n) {
  switch (n) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
h(aP, "Qw");
u(aP, "isVideo");
function pz(n) {
  switch (n) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
h(pz, "V1");
u(pz, "isMarkdown");
function oP(n) {
  switch (n) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
h(oP, "Kw");
u(oP, "isMarkup");
function q0(n) {
  if (oP(n))
    return !0;
  switch (n) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
h(q0, "Gu");
u(q0, "isCode");
function lP(n) {
  if (q0(n) || pz(n))
    return !0;
  switch (n) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
h(lP, "Gw");
u(lP, "isText");
function An(n) {
  const t = Ei(n);
  if (t === "") return { icon: "file" };
  if (rP(t))
    return { icon: "file-music", color: "indigo" };
  if (dz(t))
    return { icon: "file-image", color: "cyan" };
  if (aP(t))
    return { icon: "file-video", color: "pink" };
  if (oP(t))
    return { icon: "file-xml", color: "purple" };
  if (q0(t))
    return { icon: "file-code", color: "purple" };
  if (lP(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
h(An, "Ei");
u(An, "getIcon");
function fz(n) {
  const t = Ei(n);
  return t === "" ? "none" : uz(t) ? "image" : q0(t) ? "code" : lP(t) ? "text" : rP(t) ? "audio" : aP(t) ? "video" : "none";
}
h(fz, "B1");
u(fz, "getWebPreviewFormat");
function Ks(n) {
  switch (n) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
h(Ks, "Ls");
u(Ks, "getProvider");
function Sy(n) {
  let t = "file";
  switch (Ei(n)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
h(Sy, "ll");
u(Sy, "getKind");
function V0(n) {
  const t = n.target, e = t == null ? void 0 : t.value.lastIndexOf(".");
  e === -1 ? t == null || t.select() : e !== void 0 && (t == null || t.setSelectionRange(0, e));
}
h(V0, "Zu");
u(V0, "handleSelectFilename");
async function Dv(n, t = "SHA-256") {
  return await new Promise((e) => {
    if (n) {
      const i = new FileReader();
      i.readAsArrayBuffer(n), i.onloadend = async () => {
        const s = await crypto.subtle.digest(t, i.result);
        let r = "";
        s && (r = Array.from(new Uint8Array(s)).map((a) => a.toString(16).padStart(2, "0")).join("")), e(r);
      };
    } else
      e("");
  });
}
h(Dv, "pu");
u(Dv, "getHash");
function $1(n, t) {
  return n.findAll(t.filters).map(
    (e) => t.select ? t.select(e) : e.state
  );
}
h($1, "Sh");
u($1, "getResult");
var Wu;
const yz = (Wu = class {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await sl(this.host), this.context = new qs(this.host, { context: _e, subscribe: !0 });
  }
  hostUpdate() {
    var t, e;
    (t = this.context) != null && t.value && ((e = this.resolveContext) == null || e.call(this));
  }
  async trackMutationState(t, e) {
    var i, s, r;
    if (e || (await this.whenContext, e = (s = (i = this.context) == null ? void 0 : i.value) == null ? void 0 : s.queryClient), !e)
      throw new Error("No QueryClient provided");
    return (r = this.mutationCacheUnsubscribe) == null || r.call(this), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = $1(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = $1(this.mutationCache, this.options);
        (this.result !== e || Vc(this.result, e)) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    var t;
    return !this.mutationCache || !((t = this.options) != null && t.filters) ? 0 : $1(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    var t;
    (t = this.mutationCacheUnsubscribe) == null || t.call(this), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.mutationCacheUnsubscribe) == null || t.call(this);
  }
}, h(Wu, "Rp"), Wu);
u(yz, "MutationStateController");
let rg = yz;
var Du;
const mz = (Du = class {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await sl(this.host), this.context = new qs(this.host, { context: _e, subscribe: !0 });
  }
  hostUpdate() {
    var t, e;
    (t = this.context) != null && t.value && ((e = this.resolveContext) == null || e.call(this));
  }
  async trackMutation(t, e) {
    var i, s, r, a;
    if (e || (await this.whenContext, e = (s = (i = this.context) == null ? void 0 : i.value) == null ? void 0 : s.queryClient), !e)
      throw new Error("No QueryClient provided");
    return (r = this.observerUnsubscribe) == null || r.call(this), this.observer && (this.whenObserver = new Promise((o) => this.resolveObserver = o)), this.observer = new Vt(e, { ...t }), this.observerSubscribe(), (a = this.resolveObserver) == null || a.call(this, this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ?? (this.observerUnsubscribe = this.observer.subscribe(() => {
      if (this.observer) {
        const t = xy(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    })), this.host.requestUpdate());
  }
  untrackMutation() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    return (await this.whenObserver).mutate(t, e);
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this);
  }
}, h(Du, "Op"), Du);
u(mz, "MutationController");
let sn = mz;
function re(n, t, e, i) {
  const s = n.getMutationCache(), r = s.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ u((a) => a.state.variables === e, "predicate")
  });
  if (r && r.state.context) {
    const a = { ...r.state.context };
    i(a);
    const o = { ...r.state, context: a };
    r.state = o, s.notify({
      mutation: r,
      type: "updated",
      action: {
        type: "pending",
        context: r.state.context,
        variables: r.state.variables,
        isPaused: !1
      }
    });
  }
}
h(re, "Ft");
u(re, "updateMutationContext");
function cP(n, t, e) {
  const i = n.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  i && n.getMutationCache().remove(i);
}
h(cP, "Zw");
u(cP, "removeMutation");
function wz(n, t) {
  const e = n.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((i) => {
    e.remove(i);
  });
}
h(wz, "U1");
u(wz, "removeMutations");
const hP = /* @__PURE__ */ u((n, t, e = 0, i = "application/octet-stream", s, r = Date.now()) => {
  const a = n && (n instanceof URL ? n.toString() : URL.createObjectURL(n));
  return {
    id: r,
    app: { id: -1 },
    name: t,
    kind: Sy(t),
    size: e,
    media_type: i,
    embed_url: "",
    preview_format: fz(t),
    thumbnail_url: a,
    preview_url: a,
    download_url: a,
    rev: -1,
    created_by: s,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function dP(n) {
  const t = n ? n.reduce(
    (e, i) => {
      var s, r;
      const a = (s = i.context) == null ? void 0 : s.file;
      return a && (r = i.context) != null && r.status.progress && a.size ? {
        loaded: e.loaded + i.context.status.progress * a.size,
        total: e.total + a.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    loaded: t.loaded,
    total: t.total,
    percent: t.total > 0 ? t.loaded / t.total : null
  };
}
h(dP, "Yw");
u(dP, "getFileMutationsTotalProgress");
function uP(n) {
  return n ? n.some((t) => {
    var e;
    return ((e = t.context) == null ? void 0 : e.status.state) === "conflict";
  }) ? "conflict" : n.some((t) => t.status === "error") ? "error" : n.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
h(uP, "Xw");
u(uP, "getFileMutationsTotalStatus");
function gz(n) {
  return (n == null ? void 0 : n.filter((t) => {
    var e;
    return ((e = t.context) == null ? void 0 : e.status.state) === "conflict" || t.status === "error";
  })) || [];
}
h(gz, "q1");
u(gz, "getFileMutationsByConflictOrError");
function vz(n, t, e) {
  const i = n.queryClient;
  i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ u((s) => {
      var r, a;
      return /error|success/.test(s.state.status) && ((a = (r = s.state.variables) == null ? void 0 : r.blob) == null ? void 0 : a.name) === e;
    }, "predicate")
  }).forEach((s) => {
    i.getMutationCache().remove(s);
  });
}
h(vz, "N1");
u(vz, "removeSettledFileMutations");
function bz(n, t, e) {
  const i = n.queryClient, s = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ u(async ({ blob: r, replace: a = !1 }) => {
      const o = await n.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: r.id, replace: a })
      });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await o.json();
    }, "mutationFn"),
    mutationKey: s,
    onMutate: /* @__PURE__ */ u(async (r) => {
      await i.cancelQueries({ queryKey: s, exact: !0 }), Oz(n, e, r.blob.name), vz(n, e, r.blob.name);
      let a;
      try {
        a = r.blob.thumbnail_url && new URL(r.blob.thumbnail_url) || void 0;
      } catch {
      }
      const o = hP(a, r.blob.name, r.blob.size, r.blob.media_type, t);
      return {
        type: r.replace ? "replace" : "create",
        file: o,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((r, a, o) => (re(i, s, a, (l) => {
      l && (l.status.state = "ok", l.status.progress = void 0, l.status.text = void 0);
    }), i.invalidateQueries({ queryKey: s })), "onSuccess"),
    onError(r, a, o) {
      var l;
      ((l = r == null ? void 0 : r.cause) == null ? void 0 : l.status) === 409 ? re(i, s, a, (c) => {
        c && (c.status.progress = void 0, c.status.state = "conflict", c.status.text = r.message);
      }) : re(i, s, a, (c) => {
        c && (c.status.state = "error", c.status.progress = void 0, c.status.text = r.message);
      });
    }
  };
}
h(bz, "j1");
u(bz, "getCreateFileMutationOptions");
function Oz(n, t, e, i, s = "blobs") {
  const r = n.queryClient;
  r.getMutationCache().findAll({
    mutationKey: ["apps", t.id, s, i],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ u((a) => {
      var o;
      return ((o = a.state.data) == null ? void 0 : o.name) === e;
    }, "predicate")
  }).forEach((a) => {
    r.getMutationCache().remove(a);
  });
}
h(Oz, "W1");
u(Oz, "removeSuccessfulUploadBlobMutations");
async function pP(n, t, e) {
  const i = new FormData();
  i.append("blob", t);
  const s = await n.upload("/api/blobs", "POST", i, zv.Auto, (r) => {
    e && e({ progress: r });
  });
  if (!s.ok) {
    const r = await s.json();
    throw new Error(r.detail || r.title, { cause: r });
  }
  return await s.json();
}
h(pP, "Jw");
u(pP, "uploadBlob");
function $z(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async (t) => await pP(n, t.file, t.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
h($z, "Q1");
u($z, "getSimpleUploadBlobMutationOptions");
function j0(n, t, e, i, s = "blobs") {
  const r = n.queryClient, a = i ? ["apps", e, s, i] : ["apps", e, s];
  return {
    mutationFn: /* @__PURE__ */ u(async (o) => await pP(n, o.file, o.onProgress), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ u(async (o) => {
      await r.cancelQueries({ queryKey: a, exact: !0 });
      const l = hP(o.file, o.file.name, o.file.size, o.file.type, t);
      o.onProgress = ({ progress: d }) => {
        re(r, a, o, (p) => {
          p.status.state = "pending", p.status.progress = d;
        });
      };
      const c = await Dv(o.file);
      return { type: "upload", file: l, status: { state: "pending" }, sha256: c };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((o, l, c) => {
      re(r, a, l, (d) => {
        d.status.state = "ok", d.status.progress = void 0, d.status.text = void 0;
      });
    }, "onSuccess"),
    onError(o, l, c) {
      const d = o.cause;
      d && d.status === 409 ? re(r, a, l, (p) => {
        p.status.state = "conflict", p.status.progress = void 0, p.status.text = d.detail || d.title;
      }) : re(r, a, l, (p) => {
        p && (p.status.state = "error", p.status.progress = void 0, p.status.text = d.detail || d.title);
      });
    }
  };
}
h(j0, "Xu");
u(j0, "getUploadBlobMutationOptions");
const xz = Symbol.for("weavy-data-blobs"), kz = Symbol.for("weavy-context-id");
function Sz(n) {
  if (n)
    return n.match(/^[0-9]+$/) ? parseInt(n) : n;
}
h(Sz, "K1");
u(Sz, "toIntOrString");
var pU = Object.defineProperty, fU = Object.getOwnPropertyDescriptor, be = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? fU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && pU(t, e, s), s;
}, "__decorateClass$1d"), x1, k1, S1, $m, xm, km, Sm, Pm, Cm, Qm, Mm, fc, yc, Tm, Am, Rm, Em, zm, _m, Wa, hr, xs, Lm, mc, qu;
const Pz = (qu = class extends ft {
  // PROPERTY INIT
  constructor() {
    super(), F(this, x1), F(this, k1), F(this, S1), F(this, $m), F(this, xm), F(this, km), F(this, Sm), F(this, Pm), F(this, Cm), F(this, Qm), F(this, Mm), F(this, fc), F(this, yc), F(this, Tm), F(this, Am), F(this, Rm), F(this, Em), F(this, zm), F(this, _m), F(this, Wa), F(this, hr), F(this, xs), F(this, Lm), F(this, mc), this.storage = WS("localStorage"), this.contextId = Fc(), this.storageLinkHandler = (t) => {
      t.storageArea === this.storage && t.key === "wy-link" && t.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (t) => {
      t.defaultPrevented || (this.link && this.link.id === t.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = t.detail.link, this.link || this.provideStorageLink(t.detail.link));
    }, this.notificationEventHandler = (t) => {
      t.stopPropagation(), t.defaultPrevented || this.isConnected && this.checkVisibility(Dk) && this.matchesLink(t.detail.link) && t.preventDefault();
    }, L(this, xm, new Promise((t) => {
      L(this, $m, t);
    })), L(this, Sm, new Promise((t) => {
      L(this, km, t);
    })), L(this, Cm, new Promise((t) => {
      L(this, Pm, t);
    })), L(this, Mm, new Promise((t) => {
      L(this, Qm, t);
    })), L(this, yc, new Promise((t) => {
      L(this, fc, t);
    })), L(this, Am, new Promise((t) => {
      L(this, Tm, t);
    })), L(this, Em, new Promise((t) => {
      L(this, Rm, t);
    })), L(this, _m, new Promise((t) => {
      L(this, zm, t);
    })), L(this, Wa, new Cn(this)), L(this, hr, new Cn(this)), L(this, xs, /* @__PURE__ */ new Map()), L(this, Lm, new sn(this)), L(this, mc, new rg(this)), this.settings = new y3(this);
  }
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an Entity is matching the component.
   *
   * @param {EntityType} link Entity to check for match
   * @returns { boolean } True if the entity is matching the component
   */
  matchesLink(t) {
    var e, i, s, r;
    return (
      // Messenger conversation
      (e = t == null ? void 0 : t.app) != null && e.type && !this.componentType && (i = this.appTypes) != null && i.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : (
        // Normal contextual app
        !!(t && t.app && this.componentType !== nn.Unknown && (typeof this.uid == "string" && ((s = t.app) == null ? void 0 : s.uid) === this.uid || // Normal app with app uid
        typeof this.uid == "number" && ((r = t.app) == null ? void 0 : r.id) === this.uid || // Normal app with app id
        this.agent && t.app.type === this.componentType && t.agent === this.agent))
      )
    );
  }
  get link() {
    return this._link;
  }
  set link(t) {
    const e = this._link;
    !this.uid && this.componentType && this.componentType !== nn.Unknown ? this.whenApp().then(() => {
      this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
    }) : (this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e));
  }
  /**
   * Clears the link and resets the promise.
   */
  clearLink() {
    this.link && (L(this, yc, new Promise((t) => {
      L(this, fc, t);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param {LinkType} link - The entity to provide
   */
  provideStorageLink(t) {
    var e;
    (e = this.storage) == null || e.setItem("wy-link", btoa(JSON.stringify(t)));
  }
  /**
   * Reads a link from storage provides it in the .link property/context.
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const t = this.storage.getItem("wy-link");
    if (t)
      try {
        const e = JSON.parse(atob(t));
        e && (this.link = e);
      } catch (e) {
        console.error("Error parsing link", e);
      }
  }
  /**
   * Consumes a link in the storage. Make sure to consume it after it has been used.
   */
  consumeStorageLink() {
    var t;
    (t = this.storage) == null || t.removeItem("wy-link");
  }
  get agent() {
    return this._agentUid;
  }
  set agent(t) {
    this._agentUid = t || void 0;
  }
  set name(t) {
    this._initialAppName = t, this._appName = t;
  }
  get name() {
    return this._appName;
  }
  set notifications(t) {
    L(this, x1, t);
  }
  get notifications() {
    var t;
    return k(this, x1) ?? ((t = this.weavy) == null ? void 0 : t.notifications) ?? Ce.defaults.notifications;
  }
  set notificationsBadge(t) {
    L(this, k1, t);
  }
  get notificationsBadge() {
    var t;
    return k(this, k1) ?? ((t = this.weavy) == null ? void 0 : t.notificationsBadge) ?? Ce.defaults.notificationsBadge;
  }
  set reactions(t) {
    L(this, S1, t);
  }
  get reactions() {
    var t;
    return k(this, S1) ?? ((t = this.weavy) == null ? void 0 : t.reactions) ?? Ce.defaults.reactions;
  }
  async whenApp() {
    return await k(this, xm);
  }
  async whenContextDataBlobs() {
    return await k(this, Sm);
  }
  async whenContextId() {
    return await k(this, Cm);
  }
  async whenComponentFeatures() {
    return await k(this, Mm);
  }
  async whenLink() {
    return await k(this, yc);
  }
  async whenSettings() {
    return await k(this, Am);
  }
  async whenUser() {
    return await k(this, Em);
  }
  async whenWeavy() {
    return await k(this, _m);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.app && this.requestUpdate("app"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.contextId && this.requestUpdate("contextId"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), (t = this.weavy) == null || t.host.removeEventListener("wy-notification", this.notificationEventHandler, { capture: !0 });
  }
  async scheduleUpdate() {
    await sl(this), await super.scheduleUpdate();
  }
  async willUpdate(t) {
    var e, i, s, r, a, o, l, c, d, p, f, m, w, b, x, O, P, A, R, T;
    super.willUpdate(t), this.weavyContextConsumer ?? (this.weavyContextConsumer = new qs(this, { context: _e, subscribe: !0 })), (e = this.weavyContextConsumer) != null && e.value && this.weavy !== ((i = this.weavyContextConsumer) == null ? void 0 : i.value) && (this.weavy = (s = this.weavyContextConsumer) == null ? void 0 : s.value);
    const I = Object.keys(this.settings);
    if ((t.has("weavy") || I.find((W) => t.has(W))) && (this.settings = new y3(this)), t.has("weavy") && this.weavy && await k(this, hr).trackQuery(ol(this.weavy, ["user"])), (r = k(this, hr).result) != null && r.isPending || (this.user && k(this, hr).result.data && this.user.id !== k(this, hr).result.data.id && (console.warn("User mismatch, resetting"), (a = this.weavy) == null || a.reset()), this.user = (o = k(this, hr).result) == null ? void 0 : o.data), t.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof $n && (this.componentFeatures = this.componentFeatures.immutable())), (t.has("autoUid") || t.has("user") || t.has("agent")) && this.autoUid && this.user && (this.componentType && qv.has(this.componentType) && this.agent || this.componentType && !qv.has(this.componentType))) {
      const W = [this.autoUid];
      this.agent && W.push(this.agent), this.user && W.push(this.user.uid || this.user.id), this.uid = W.join("-");
    }
    const Z = this.name;
    if (t.has("componentType") || t.has("uid") || t.has("agent") || t.has("name") || t.has("weavy"))
      if (this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", Z)), this.componentType && this.uid && this.weavy) {
        const W = this.name ? { name: this.name } : void 0, V = this.agent ? [this.agent] : void 0;
        await k(this, Wa).trackQuery(
          cE(this.weavy, this.uid, this.componentType, V, W)
        );
      } else
        k(this, Wa).untrackQuery();
    if ((l = k(this, Wa).result) != null && l.isPending || (this.app = (c = k(this, Wa).result) == null ? void 0 : c.data, (d = this.app) != null && d.name && (this.app.name !== this.name || this._appName !== this.app.name) && (this._appName = this.app.name, this.requestUpdate("name", Z))), (t.has("weavy") || t.has("contextId") || t.has("user") || t.has("componentFeatures")) && this.weavy && this.contextId && this.user && (p = this.componentFeatures) != null && p.allowsFeature(_.ContextData) && (await k(this, Lm).trackMutation(
      j0(this.weavy, this.user, this.contextId, void 0, "data")
    ), await k(this, mc).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), t.has("data") || t.has("componentFeatures")) {
      const W = k(this, xs);
      if (L(this, xs, /* @__PURE__ */ new Map()), (f = this.data) == null || f.forEach((V) => {
        const Y = W.get(V);
        if (Y)
          k(this, xs).set(V, Y);
        else {
          const G = hz(V);
          G && k(this, xs).set(V, G);
        }
      }), k(this, xs) && (m = this.componentFeatures) != null && m.allowsFeature(_.ContextData)) {
        for (const X of Array.from(k(this, xs).values()))
          if (X.type === "file") {
            const st = await Dv(X.item);
            await AR(
              k(this, mc).result ?? [],
              async (tt) => {
                var Qt, vt;
                return (((Qt = tt.context) == null ? void 0 : Qt.sha256) ?? await Dv((vt = tt.variables) == null ? void 0 : vt.file)) === st;
              }
            ) || await k(this, Lm).mutate({ file: X.item });
          }
        const V = k(this, mc).result, Y = V == null ? void 0 : V.some((X) => X.status === "pending"), G = (V == null ? void 0 : V.map((X) => {
          var st;
          return (st = X.data) == null ? void 0 : st.id;
        }).filter((X) => X).reverse()) ?? [];
        Y || (this.contextDataBlobs = G);
      } else
        this.contextDataBlobs = [];
    }
    if (t.has("uid") && (this.uid || t.get("uid")) && this.uid !== t.get("uid") && this.clearLink(), (!this.link && (t.has("uid") && this.uid || t.has("app") && this.app) && this.componentType && this.componentType !== nn.Unknown || (t.has("appTypes") || t.has("agent")) && this.appTypes) && this.readStorageLink(), t.has("link") && this.link && (console.info(
      `Opening notification link in ${this.uid ?? Cz.get(this.componentType) ?? this.constructor.name}`
    ), this.consumeStorageLink()), t.has("app") && this.app) {
      const W = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(W);
    }
    t.has("app") && this.app && (t.get("app") && L(this, xm, new Promise((W) => {
      L(this, $m, W);
    })), (w = k(this, $m)) == null || w.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && L(this, Sm, new Promise((W) => {
      L(this, km, W);
    })), (b = k(this, km)) == null || b.call(this, this.contextDataBlobs)), t.has("contextId") && this.contextId && (t.get("contextId") && L(this, Cm, new Promise((W) => {
      L(this, Pm, W);
    })), (x = k(this, Pm)) == null || x.call(this, this.contextId)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && L(this, Mm, new Promise((W) => {
      L(this, Qm, W);
    })), (O = k(this, Qm)) == null || O.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && L(this, yc, new Promise((W) => {
      L(this, fc, W);
    })), (P = k(this, fc)) == null || P.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && L(this, Am, new Promise((W) => {
      L(this, Tm, W);
    })), (A = k(this, Tm)) == null || A.call(this, this.settings)), t.has("user") && this.user && (t.get("user") && L(this, Em, new Promise((W) => {
      L(this, Rm, W);
    })), (R = k(this, Rm)) == null || R.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && L(this, _m, new Promise((W) => {
      L(this, zm, W);
    })), this.weavy.host.addEventListener("wy-notification", this.notificationEventHandler, { capture: !0 }), (T = k(this, zm)) == null || T.call(this, this.weavy)), t.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
  }
}, h(qu, "Lp"), qu);
x1 = /* @__PURE__ */ new WeakMap(), k1 = /* @__PURE__ */ new WeakMap(), S1 = /* @__PURE__ */ new WeakMap(), $m = /* @__PURE__ */ new WeakMap(), xm = /* @__PURE__ */ new WeakMap(), km = /* @__PURE__ */ new WeakMap(), Sm = /* @__PURE__ */ new WeakMap(), Pm = /* @__PURE__ */ new WeakMap(), Cm = /* @__PURE__ */ new WeakMap(), Qm = /* @__PURE__ */ new WeakMap(), Mm = /* @__PURE__ */ new WeakMap(), fc = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), Tm = /* @__PURE__ */ new WeakMap(), Am = /* @__PURE__ */ new WeakMap(), Rm = /* @__PURE__ */ new WeakMap(), Em = /* @__PURE__ */ new WeakMap(), zm = /* @__PURE__ */ new WeakMap(), _m = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new WeakMap(), hr = /* @__PURE__ */ new WeakMap(), xs = /* @__PURE__ */ new WeakMap(), Lm = /* @__PURE__ */ new WeakMap(), mc = /* @__PURE__ */ new WeakMap(), u(Pz, "WeavyComponent");
let jt = Pz;
be([
  U()
], jt.prototype, "weavy", 2);
be([
  Gs({ context: nP }),
  U()
], jt.prototype, "app", 2);
be([
  Gs({ context: xz }),
  U()
], jt.prototype, "contextDataBlobs", 2);
be([
  Gs({ context: kz }),
  U()
], jt.prototype, "contextId", 2);
be([
  Gs({ context: W0 }),
  U()
], jt.prototype, "componentFeatures", 2);
be([
  Gs({ context: sz }),
  U()
], jt.prototype, "settings", 2);
be([
  Gs({ context: Z0 }),
  U()
], jt.prototype, "user", 2);
be([
  Gs({ context: oz })
], jt.prototype, "_link", 2);
be([
  $({ type: Object })
], jt.prototype, "link", 1);
be([
  U()
], jt.prototype, "componentType", 2);
be([
  U()
], jt.prototype, "appTypes", 2);
be([
  $()
], jt.prototype, "features", 2);
be([
  $({ type: String })
], jt.prototype, "agent", 1);
be([
  $({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(n) {
        return TR(n);
      }
    }
  })
], jt.prototype, "data", 2);
be([
  $()
], jt.prototype, "autoUid", 2);
be([
  $({ converter: Sz })
], jt.prototype, "uid", 2);
be([
  $({ type: String })
], jt.prototype, "name", 1);
be([
  $({ type: String })
], jt.prototype, "notifications", 1);
be([
  $({ type: String })
], jt.prototype, "notificationsBadge", 1);
be([
  $({ type: String })
], jt.prototype, "reactions", 1);
be([
  $()
], jt.prototype, "bot", 2);
const Cz = new Map(_S(sE)), yU = new Map(_S(rE)), qv = new Map(Object.entries(aE));
new Map(Object.entries(oE));
var mU = Object.defineProperty, ua = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = void 0, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(t, e, s) || s);
  return s && mU(t, e, s), s;
}, "__decorateClass$1c"), Im, P1, Zm, C1, Wm, Q1, Dm, M1, qm, T1, Vm, A1, jm, R1, Fm, E1, Vu;
const Qz = (Vu = class extends ft {
  constructor() {
    super(), F(this, Im), F(this, P1, new Promise((t) => {
      L(this, Im, t);
    })), F(this, Zm), F(this, C1, new Promise((t) => {
      L(this, Zm, t);
    })), F(this, Wm), F(this, Q1, new Promise((t) => {
      L(this, Wm, t);
    })), F(this, Dm), F(this, M1, new Promise((t) => {
      L(this, Dm, t);
    })), F(this, qm), F(this, T1, new Promise((t) => {
      L(this, qm, t);
    })), F(this, Vm), F(this, A1, new Promise((t) => {
      L(this, Vm, t);
    })), F(this, jm), F(this, R1, new Promise((t) => {
      L(this, jm, t);
    })), F(this, Fm), F(this, E1, new Promise((t) => {
      L(this, Fm, t);
    }));
  }
  async whenApp() {
    return await k(this, P1);
  }
  async whenContextDataBlobs() {
    return await k(this, C1);
  }
  async whenContextId() {
    return await k(this, Q1);
  }
  async whenComponentFeatures() {
    return await k(this, M1);
  }
  async whenLink() {
    return await k(this, T1);
  }
  async whenSettings() {
    return await k(this, A1);
  }
  async whenUser() {
    return await k(this, R1);
  }
  async whenWeavy() {
    return await k(this, E1);
  }
  willUpdate(t) {
    var e, i, s, r, a, o, l, c;
    super.willUpdate(t), t.has("app") && this.app && (t.get("app") && L(this, P1, new Promise((d) => {
      L(this, Im, d);
    })), (e = k(this, Im)) == null || e.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && L(this, C1, new Promise((d) => {
      L(this, Zm, d);
    })), (i = k(this, Zm)) == null || i.call(this, this.contextDataBlobs)), t.has("contextId") && this.contextId && (t.get("contextId") && L(this, Q1, new Promise((d) => {
      L(this, Wm, d);
    })), (s = k(this, Wm)) == null || s.call(this, this.contextId)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && L(this, M1, new Promise((d) => {
      L(this, Dm, d);
    })), (r = k(this, Dm)) == null || r.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && L(this, T1, new Promise((d) => {
      L(this, qm, d);
    })), (a = k(this, qm)) == null || a.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && L(this, A1, new Promise((d) => {
      L(this, Vm, d);
    })), (o = k(this, Vm)) == null || o.call(this, this.settings)), t.has("user") && this.user && (t.get("user") && L(this, R1, new Promise((d) => {
      L(this, jm, d);
    })), (l = k(this, jm)) == null || l.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && L(this, E1, new Promise((d) => {
      L(this, Fm, d);
    })), (c = k(this, Fm)) == null || c.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.contextId && this.requestUpdate("contextId"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
}, h(Vu, "Ip"), Vu);
Im = /* @__PURE__ */ new WeakMap(), P1 = /* @__PURE__ */ new WeakMap(), Zm = /* @__PURE__ */ new WeakMap(), C1 = /* @__PURE__ */ new WeakMap(), Wm = /* @__PURE__ */ new WeakMap(), Q1 = /* @__PURE__ */ new WeakMap(), Dm = /* @__PURE__ */ new WeakMap(), M1 = /* @__PURE__ */ new WeakMap(), qm = /* @__PURE__ */ new WeakMap(), T1 = /* @__PURE__ */ new WeakMap(), Vm = /* @__PURE__ */ new WeakMap(), A1 = /* @__PURE__ */ new WeakMap(), jm = /* @__PURE__ */ new WeakMap(), R1 = /* @__PURE__ */ new WeakMap(), Fm = /* @__PURE__ */ new WeakMap(), E1 = /* @__PURE__ */ new WeakMap(), u(Qz, "WeavySubComponent");
let Lt = Qz;
ua([
  ve({ context: nP, subscribe: !0 }),
  U()
], Lt.prototype, "app");
ua([
  ve({ context: xz, subscribe: !0 }),
  U()
], Lt.prototype, "contextDataBlobs");
ua([
  ve({ context: kz, subscribe: !0 }),
  U()
], Lt.prototype, "contextId");
ua([
  ve({ context: W0, subscribe: !0 }),
  U()
], Lt.prototype, "componentFeatures");
ua([
  ve({ context: oz, subscribe: !0 }),
  U()
], Lt.prototype, "link");
ua([
  ve({ context: sz, subscribe: !0 }),
  U()
], Lt.prototype, "settings");
ua([
  ve({ context: Z0, subscribe: !0 }),
  U()
], Lt.prototype, "user");
ua([
  ve({ context: _e, subscribe: !0 }),
  U()
], Lt.prototype, "weavy");
function Mz(n) {
  return typeof n == "string" && n ? n = eval == null ? void 0 : (0, eval)(`"use strict";(${n})`) : n = void 0, n;
}
h(Mz, "J1");
u(Mz, "indirectEvalObject");
function ag(n) {
  if (n)
    try {
      return new URL(n, window.location.toString());
    } catch {
      console.warn("Invalid url: ", n);
    }
}
h(ag, "vd");
u(ag, "toUrl");
const H = /* @__PURE__ */ u((n) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(n) && customElements.define(
      n,
      t
    );
  }) : !customElements.get(n) && customElements.define(n, t);
}, "customElement"), yt = Mt`@charset \"UTF-8\";:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, unset)}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1 * var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}.wy-appbars{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));background-color:var(--wy-component-background-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}@supports (position: sticky){.wy-appbars{position:sticky;top:0;z-index:1020}}.wy-appbars>.wy-appbar,.wy-appbars>.wy-toolbar{background-color:transparent;box-shadow:none}.wy-appbar{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));display:grid;align-items:center;justify-content:space-between;justify-items:center;height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:0 0 var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}.wy-appbar .wy-badge{align-self:center}.wy-appbar-buttons,.wy-toolbar-buttons,.wy-appbar-section{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%}.wy-appbar-buttons-first{justify-content:flex-start}.wy-appbar-buttons-last{justify-content:flex-end}.wy-toolbar-buttons-last{margin-inline-start:auto}.wy-appbar-text{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none}.wy-appbar-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-appbar-text a,.wy-appbar-text a:hover{color:inherit}.wy-appbar-text-trashed{text-decoration:line-through}.wy-toolbars-bottom{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem))) / 2);left:0;right:0;min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center}.wy-toolbar{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}.wy-toolbar-center{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}.wy-toolbar-center .wy-input{text-align:center}.wy-toolbar-text{margin-left:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-neutral-variant-50, #72777e));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5)}[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:calc(.5 * var(--wy-size, 1rem)) calc(.75 * var(--wy-size, 1rem));margin-inline:calc(-.25 * var(--wy-size, 1rem))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-color: var(--wy-on-primary, var(--wy-white, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-color: unset}[part=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-40, #006399)));text-decoration:var(--wy-link-decoration, none)}[part=wy-button-link]:hover,[part=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, unset)}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5 * var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));top:0;z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-code pre,.wy-editor .cm-content pre,.wy-content pre{text-wrap:pretty}.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content .code,.wy-content .code,.wy-editor .cm-content code[class*=language-],.wy-content code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{.wy-code code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content code[class*=language-],.wy-content code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{text-shadow:none}}.wy-code pre[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content :not(pre)>code[class*=language-],.wy-content :not(pre)>code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-neutral-99, #fcfcff))}.wy-code :not(pre)>code[class*=language-],.wy-editor .cm-content :not(pre)>code[class*=language-],.wy-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.wy-code .token.variable,.wy-editor .cm-content .token.variable,.wy-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}.wy-code .token.operator,.wy-editor .cm-content .token.operator,.wy-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}.wy-code .token.prolog,.wy-editor .cm-content .token.prolog,.wy-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}.wy-code .token.comment,.wy-editor .cm-content .token.comment,.wy-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}.wy-code .token.builtin,.wy-editor .cm-content .token.builtin,.wy-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}.wy-code .token.number,.wy-editor .cm-content .token.number,.wy-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}.wy-code .token.inserted,.wy-editor .cm-content .token.inserted,.wy-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}.wy-code .token.constant,.wy-editor .cm-content .token.constant,.wy-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}.wy-code .token.hexcode,.wy-editor .cm-content .token.hexcode,.wy-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}.wy-code .token.regex,.wy-editor .cm-content .token.regex,.wy-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}.wy-code .token.char,.wy-editor .cm-content .token.char,.wy-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}.wy-code .token.tag,.wy-editor .cm-content .token.tag,.wy-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}.wy-code .token.attr-name,.wy-editor .cm-content .token.attr-name,.wy-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}.wy-code .token.selector,.wy-editor .cm-content .token.selector,.wy-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}.wy-code .token.property,.wy-editor .cm-content .token.property,.wy-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}.wy-code .token.deleted,.wy-editor .cm-content .token.deleted,.wy-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}.wy-code .token.string,.wy-editor .cm-content .token.string,.wy-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}.wy-code .token.changed,.wy-editor .cm-content .token.changed,.wy-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}.wy-code .token.punctuation,.wy-editor .cm-content .token.punctuation,.wy-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}.wy-code .token.function,.wy-editor .cm-content .token.function,.wy-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}.wy-code .token.keyword,.wy-editor .cm-content .token.keyword,.wy-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}.wy-code .token.class-name,.wy-editor .cm-content .token.class-name,.wy-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}.wy-code .token.important,.wy-code .token.bold,.wy-editor .cm-content .token.important,.wy-content .token.important,.wy-editor .cm-content .token.bold,.wy-content .token.bold{font-weight:700}.wy-code .token.italic,.wy-editor .cm-content .token.italic,.wy-content .token.italic{font-style:italic}.wy-content{overflow-wrap:break-word;min-width:0}.wy-content:empty{display:none}.wy-content>:first-child{margin-top:0}.wy-content>:last-child{margin-bottom:0}.wy-content b,.wy-content strong{font-weight:var(--wy-font-weight-bold, 600)}.wy-content blockquote{border-left:calc(2 * var(--wy-border, 1px)) solid var(--wy-neutral-80, #c6c6c9);margin:var(--wy-size, 1rem) 0;padding:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding-left:var(--wy-size, 1rem)}.wy-content blockquote>p{margin:0}.wy-content pre,.wy-content code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-content :not(pre)>code{overflow-wrap:inherit}.wy-content pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}.wy-content h1,.wy-content h2,.wy-content h3,.wy-content h4,.wy-content h5,.wy-content h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.2));margin:0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) 0}.wy-content h1{font-size:calc(2 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h2{font-size:calc(1.8 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h3{font-size:calc(1.6 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h4{font-size:calc(1.4 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h5{font-size:calc(1.2 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h6{font-size:var(--wy-font-size, var(--wy-size, 1em))}.wy-content table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;margin:0 auto;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}.wy-content table th,.wy-content table td{padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}.wy-content table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}.wy-content table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-content table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}.wy-content table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}.wy-content table td:last-child{border-right-width:var(--wy-border, 1px)}.wy-content table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-content table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-content table>tbody{vertical-align:inherit}.wy-content table>thead{vertical-align:bottom}.wy-content img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}ol{list-style-type:decimal}ul{list-style-type:disc}li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0}ol,ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}ol>li,ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}ol>li>:first-child,ul>li>:first-child{margin-bottom:0;margin-top:0}ol>li>:last-child,ul>li>:last-child{margin-bottom:0}.wy-hashtag{color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-mention{font-weight:700}.wy-emoji-icon{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25 * var(--wy-size, 1rem))}.wy-emoji-icon-sm{width:calc(1.125 * var(--wy-size, 1rem));height:calc(1.125 * var(--wy-size, 1rem));font-size:calc(1.125 * var(--wy-size, 1rem))}.wy-empty{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-padded]{margin:16.66666667%}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width) / 2);height:calc(var(--wy-component-icon-height) / 2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));text-align:center}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-40, #3b6a1c))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-40, #3b6a1c))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-neutral-99, #fcfcff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-40, #ba1824))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-70, #afb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9185de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #afb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-text-icon]{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-title{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, 1.25em);font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.2));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-input{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));display:block;width:100%;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-input:focus{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-input::placeholder{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:1}.wy-input:disabled{opacity:38%}.wy-input::file-selector-button,.wy-input::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1 * var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1 * var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}.wy-input:hover:not(:disabled):not([readonly])::file-selector-button,.wy-input:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}.wy-input[type=file]{overflow:hidden}.wy-input[type=file]:not(:disabled):not([readonly]){cursor:pointer}.wy-input::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem)))) * 1em)}.wy-input[type=search]::-webkit-search-cancel-button{-webkit-appearance:none}.wy-input-filled{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}.wy-input-filled:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-label{display:inline-block;margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25 * var(--wy-size, 1rem))}.wy-is-invalid,.wy-is-invalid:focus{border-color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-invalid-feedback{margin-top:calc(.25 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-input-group{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}.wy-input-group-button-icon{--wy-component-background-color: transparent}.wy-input-group-input-with-overlay{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-input-group-button-icon-overlay{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}.wy-input-group-input:placeholder-shown~.wy-input-group-button-icon[type=reset]{display:none}.wy-input-group-input:not(:placeholder-shown)~.wy-input-group-button-icon[type=reset]+.wy-input-group-button-icon{display:none}.wy-item{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));position:relative;display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-decoration:none}.wy-list-item{min-height:calc(3 * var(--wy-size, 1rem))}.wy-list-item-lg{min-height:calc(4.5 * var(--wy-size, 1rem))}.wy-item-inner{display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%}.wy-item-body{width:100%;min-width:0}.wy-item-rows{display:flex;flex-direction:column;width:100%;row-gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0}.wy-item-rows:only-child{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-rows-compact{row-gap:0}.wy-item-rows-single{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-title{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-title-lg{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title-lg{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.wy-item-text{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-item-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-text .wy-icon{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-item-quote{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-item-quote:before,.wy-item-quote:after{content:'\"'}.wy-item-actions{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;margin:calc(-.25 * var(--wy-size, 1rem))}.wy-item-top{align-self:flex-start}.wy-item-actions-bottom{align-self:flex-start;margin-block:calc(-.5 * var(--wy-size, 1rem))}.wy-item-row{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-item-row .wy-item-title,.wy-item-row .wy-item-text{margin-right:auto}.wy-item-row .wy-meta{white-space:nowrap}.wy-item-right{margin-left:auto}.wy-item-hover{-webkit-user-select:none;user-select:none;cursor:pointer}.wy-item-hover:hover,.wy-item-hover:focus{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);text-decoration:none}.wy-item-hover:active{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-item-hover.wy-disabled,.wy-item-hover:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}.wy-item-hover.wy-active{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}.wy-item-trashed{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}.wy-item-trashed.wy-item-hover:hover{opacity:1}.wy-list{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-border);min-width:0}.wy-list .wy-item:not(.wy-item-hover){--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-list .wy-item:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-list .wy-item:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.wy-list-bordered{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));gap:0}.wy-list-bordered .wy-item{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-left:none;border-right:none}.wy-list-bordered .wy-item:first-child{border-top:none}.wy-list-bordered .wy-item:last-child{border-bottom:none}.wy-list-bordered .wy-item+.wy-list-bordered .wy-item{border-top-width:0}@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}.wy-messages{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}.wy-message-placeholder{opacity:.5}.wy-date-separator{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-align:center;position:sticky;top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));z-index:10}.wy-date-separator time{background:var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:inline-block}.wy-message{display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-message-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-meta{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message-bubble{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32 * var(--wy-size, 1rem),100% - 2 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-message-bubble>div{flex:1 1 100%}.wy-message-author{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-size, 1rem)) 0 0}.wy-message-content{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}.wy-message-content-row{display:flex;flex-direction:row;align-items:center;max-width:100%}.wy-message-agent{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-90, #bbf294));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-tertiary-10, #0a2100))}.wy-message-me{margin-right:0;margin-left:calc(2.5 * var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}.wy-message-me .wy-message-meta{margin:0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}.wy-message-me .wy-message-content{align-items:flex-end}.wy-message-me .wy-message-content-row{flex-direction:row-reverse}.wy-message-emoji .wy-message-bubble{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-message-emoji .wy-content .wy-emoji{width:calc(3 * var(--wy-size, 1rem));height:calc(3 * var(--wy-size, 1rem));margin:0}.wy-message-emoji.wy-message-me .wy-content{text-align:end}.wy-readby-status{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125 * var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125 * var(--wy-size, 1rem))}.wy-message-readmore{justify-self:center;text-align:center}.wy-meta{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-meta-sm{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}.wy-dialog{background:none;border:none;padding:0;margin:0}.wy-dialog[popover]{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1055}.wy-overlay-dialog{width:100%;height:100%;align-items:center;justify-content:center;overflow:visible;max-width:100%;max-height:100%}.wy-overlay-dialog[open]{display:flex}.wy-overlay-dialog:popover-open{display:flex}.wy-overlay-dialog:focus-visible{outline:none}.wy-overlay{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column}.wy-overlay.wy-modal{width:100%;height:100%;overflow:hidden;border-radius:0}@media (min-width: 768px){.wy-overlay.wy-modal-padded{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4 * var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4 * var(--wy-size, 1rem));margin-bottom:auto;width:calc(32 * var(--wy-size, 1rem));max-height:calc(32 * var(--wy-size, 1rem))}}@media (min-width: 768px){.wy-overlay.wy-modal-full{margin:0;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));max-width:calc(100% - 2 * var(--wy-size, 1rem));max-height:calc(100% - 2 * var(--wy-size, 1rem))}}.wy-overlay{opacity:0;visibility:hidden;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,transform var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}.wy-overlay.wy-open{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start;visibility:visible}.wy-overlay.wy-open.wy-transition{opacity:1;transform:none}.wy-pane{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}.wy-pane-body{display:flex;flex-direction:column;flex:1}.wy-pane-group{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-pane-background{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-pane-toolbar{display:flex;flex:1;justify-content:space-evenly;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-picker-list{background:var(--wy-component-background-color);color:var(--wy-component-color);border:none}.wy-picker-list>.wy-picker-list-item:first-child,.wy-picker-list>:first-child .wy-picker-list-item{border-top:none}.wy-picker-list>.wy-picker-list-item:last-child,.wy-picker-list>:last-child .wy-picker-list-item{border-bottom:none}.wy-picker-list-item{display:flex;align-items:center;padding:calc(.25 * var(--wy-size, 1rem)) calc(.5 * var(--wy-size, 1rem))}.wy-picker-list-item>wy-icon{margin-left:calc(.25 * var(--wy-size, 1rem));margin-right:calc(.25 * var(--wy-size, 1rem));flex:0 0 auto}.wy-picker-list-item>button{margin-block-start:auto;flex:0 0 auto}.wy-picker-list-item-title{flex-grow:1}.wy-picker-list-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-main{display:flex;height:calc(100% - var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@media (max-width: 767.98px){.wy-main{flex-direction:column}}.wy-preview{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16 * var(--wy-size, 1rem));min-height:calc(16 * var(--wy-size, 1rem));max-height:100%;max-width:100%}.wy-preview-layout{width:100%;height:100%}.wy-preview-swiper{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16 * var(--wy-size, 1rem));min-height:calc(16 * var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}.wy-preview-swiper::-webkit-scrollbar{display:none}.wy-preview-swiper-disabled{overflow-x:hidden}.wy-preview-area{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}.wy-nav-prev,.wy-nav-next{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}.wy-nav-prev{left:calc(.5 * var(--wy-size, 1rem))}.wy-nav-next{right:calc(.5 * var(--wy-size, 1rem))}.wy-document{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2 * var(--wy-size, 1rem)) calc(3.5 * var(--wy-size, 1rem));width:100%;min-height:100%;flex:1 0 auto}@media (min-width: 768px){.wy-document{padding:calc(3 * var(--wy-size, 1rem)) calc(4 * var(--wy-size, 1rem));margin:calc(2 * var(--wy-size, 1rem)) auto;border-radius:calc(.125 * var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5 * var(--wy-size, 1rem))}}.wy-content-code{align-self:flex-start;width:100%;padding:calc(2 * var(--wy-size, 1rem)) calc(3.5 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-content-iframe{border:0;display:block;width:100%;height:100%;top:0;left:0;flex:1 1 100%}.wy-content-iframe.wy-loaded{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-content-iframe.wy-loaded~.wy-content-iframe-fallback,.wy-content-iframe.wy-loaded~.wy-spinner,.wy-content-iframe.wy-loaded~wy-spinner{display:none}.wy-content-iframe.wy-loading:not(.wy-loaded){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}.wy-content-iframe.wy-loading:not(.wy-loaded):not(.wy-fallback)~.wy-content-iframe-fallback{display:none}.wy-content-iframe.wy-loading:not(.wy-loaded).wy-fallback~.wy-spinner,.wy-content-iframe.wy-loading:not(.wy-loaded).wy-fallback~wy-spinner{display:none}.wy-content-iframe~.wy-spinner,.wy-content-iframe~wy-spinner{margin:auto}.wy-content-html pre,.wy-content-html code{word-break:break-word;white-space:pre-wrap}.wy-content-image{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}.wy-content-image.wy-zoom{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}.wy-content-image img{min-width:0;min-height:0;width:100%;height:100%}.wy-content-image img:not(.wy-loading-transition):not([data-controller~=image])~.wy-spinner,.wy-content-image img:not(.wy-loading-transition):not([data-controller~=image])~wy-spinner{display:none}.wy-content-image img.wy-loading,.wy-content-image img[data-controller~=image]{transition:opacity .15s ease-out;opacity:0}.wy-content-image img.wy-loading.wy-loaded,.wy-content-image img[data-controller~=image].wy-loaded{opacity:1;transition:opacity .15s ease-out}.wy-content-image img.wy-loading.wy-loaded~img,.wy-content-image img[data-controller~=image].wy-loaded~img{transition-delay:.15s;opacity:0}.wy-content-image img.wy-loading.wy-loaded~.wy-spinner,.wy-content-image img.wy-loading.wy-loaded~wy-spinner,.wy-content-image img[data-controller~=image].wy-loaded~.wy-spinner,.wy-content-image img[data-controller~=image].wy-loaded~wy-spinner{display:none}.wy-content-image img.wy-responsive-image-thumb{position:absolute;z-index:-1}.wy-content-image img~.wy-spinner,.wy-content-image img~wy-spinner{position:absolute}.wy-content-video:not(.wy-error){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}.wy-content-video,.wy-content-audio{margin:auto}.wy-content-video.wy-loading:not(.wy-loaded),.wy-content-video[data-controller~=media]:not(.wy-loaded),.wy-content-audio.wy-loading:not(.wy-loaded),.wy-content-audio[data-controller~=media]:not(.wy-loaded){visibility:hidden}.wy-content-video.wy-loading.wy-loaded~.wy-spinner,.wy-content-video.wy-loading.wy-loaded~wy-spinner,.wy-content-video[data-controller~=media].wy-loaded~.wy-spinner,.wy-content-video[data-controller~=media].wy-loaded~wy-spinner,.wy-content-audio.wy-loading.wy-loaded~.wy-spinner,.wy-content-audio.wy-loading.wy-loaded~wy-spinner,.wy-content-audio[data-controller~=media].wy-loaded~.wy-spinner,.wy-content-audio[data-controller~=media].wy-loaded~wy-spinner{display:none}.wy-content-video:focus,.wy-content-audio:focus{outline:none}.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-content-pdf .textLayer{position:absolute;text-align:initial;top:0;right:0;bottom:0;left:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors: active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:transparent}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;top:100%;right:0;bottom:0;left:0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors: active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px * var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px * var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:transparent;border:none;top:0;right:0;bottom:0;left:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px * var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:transparent}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{-webkit-appearance:none;-moz-appearance:none;appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px * var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) #888;border-radius:calc(2px * var(--scale-factor));outline:1.5px solid rgb(255,255,74);padding:calc(6px * var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px * var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px * var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid rgb(51,51,51);margin-top:calc(2px * var(--scale-factor));padding-top:calc(2px * var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px * var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:transparent;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors: active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:transparent}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:transparent;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:transparent;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:transparent;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:transparent}.wy-content-pdf .xfaSelect{-webkit-appearance:none;-moz-appearance:none;appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors: active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors: active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid transparent}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3 * var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5 * var(--wy-size, 1rem))}.wy-content-text{word-break:break-word;white-space:pre-wrap}.wy-sheet{--wy-scrollbar-adjust-top: 0;--wy-scrollbar-adjust-bottom: 0;--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:fixed;z-index:1055;display:flex;flex-direction:column;overflow:hidden;bottom:calc(.5 * var(--wy-size, 1rem));left:calc(.5 * var(--wy-size, 1rem));right:calc(.5 * var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3 * var(--wy-size, 1rem));margin:calc(.5 * var(--wy-size, 1rem)) auto;max-width:calc(32 * var(--wy-size, 1rem));transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}.wy-sheet>.wy-appbars,.wy-sheet>.wy-appbar{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-sheet-body{overflow:hidden;padding:calc(.5 * var(--wy-size, 1rem));position:relative;min-height:calc(3 * var(--wy-size, 1rem))}.wy-sheet-body.wy-scroll-y{overflow-y:auto}.wy-sheet-no-padding{padding:0}.wy-sheet:not(.wy-show){opacity:0;transform:translateY(calc(32 * var(--wy-size, 1rem)))}.wy-sheet.wy-show{opacity:1;transform:none;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));pointer-events:auto}@starting-style{.wy-sheet.wy-show{opacity:0;transform:translateY(calc(32 * var(--wy-size, 1rem)))}}.wy-toasts{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}.wy-toasts[popover]{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1070}.wy-toasts>::slotted(*){pointer-events:auto}.wy-toast{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(4.5 * var(--wy-size, 1rem));max-width:calc(32 * var(--wy-size, 1rem))}.wy-toast.wy-fade{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}.wy-toast.wy-fade:not(.wy-show){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}.wy-toast-action{position:sticky;top:calc(4.5 * var(--wy-size, 1rem));bottom:calc(4.5 * var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-on-primary, var(--wy-white, #ffffff));padding:calc(.5 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3 * var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}.wy-toast-primary{background:var(--wy-on-primary-container, var(--wy-primary-10, #001d32));color:var(--wy-primary-container, var(--wy-primary-90, #cde5ff))}.wy-placeholder{cursor:wait;color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));background:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite}@keyframes wy-placeholder-glow{50%{opacity:.2}}.wy-meeting .wy-item-title{font-weight:700}.wy-meeting .wy-item-text{font-size:var(--wy-font-size, var(--wy-size, 1em))}.wy-meeting.wy-disabled .wy-item-title{font-weight:400}.wy-dragging:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125 * var(--wy-size, 1rem)) dashed var(--wy-primary, var(--wy-primary-40, #006399));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;top:0;left:0;bottom:0;right:0}.wy-message-editor-top{background-color:var(--wy-component-background-color);color:var(--wy-component-color)}@supports (position: sticky){.wy-message-editor-top{position:sticky;top:0;z-index:1020}}.wy-message-editor-bottom{background-color:var(--wy-component-background-color);color:var(--wy-component-color)}@supports (position: sticky){.wy-message-editor-bottom{position:sticky;bottom:0;z-index:1020}}.wy-message-form .wy-spinner{display:none}.wy-message-form.wy-uploading .wy-spinner{display:block}.wy-message-form.wy-uploading [data-icon=plus]{display:none}.wy-message-form .wy-picker-list:not(:empty){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2)}.wy-message-editor-buttons{flex:1 0 auto}.wy-message-editor-text{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-editor-mention,.wy-message-editor-link{background:#00f;color:#fff}.wy-message-editor .cm-editor,.wy-message-editor-grow:after,.wy-message-editor-grow>textarea,.wy-message-editor-textfield{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-background, var(--wy-neutral-99, #fcfcff))}.wy-message-editor .cm-editor:focus,.wy-message-editor-grow:focus:after,.wy-message-editor-grow>textarea:focus,.wy-message-editor-textfield:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor .cm-editor .cm-content,.wy-message-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5 * var(--wy-size, 1rem))}.wy-message-editor-grow{display:grid}.wy-message-editor-grow:after,.wy-message-editor-grow>textarea{grid-area:1/1/2/2}.wy-message-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-message-editor-grow>textarea{resize:none;overflow:hidden}.wy-editor .cm-scroller{font-family:unset;line-height:1.5}.wy-editor .cm-widgetBuffer{vertical-align:unset}.wy-editor .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-editor .cm-content{caret-color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e))}.wy-editor .cm-content .wy-link{text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}.wy-editor .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}.wy-editor .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-editor .cm-editor .cm-scroller{overflow:auto}.wy-editor .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-editor .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15 * var(--wy-size, 1rem))}.wy-editor .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}.wy-editor .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}.wy-editor .cm-tooltip-autocomplete ul li[aria-selected]{background:var(--wy-primary-container, var(--wy-primary-90, #cde5ff));color:unset}.wy-editor .cm-tooltip-autocomplete .cm-completionLabel{display:none}.wy-editor .cm-tooltip-autocomplete .wy-item-hover:hover,.wy-editor .cm-tooltip-autocomplete .wy-item-hover:focus{background:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}.wy-message-editor .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor .wy-is-invalid+[data-editor-target] .cm-editor,.wy-message-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-chat-conversation{overflow-anchor:none;display:flex;flex-direction:column;flex:1 0 min-content;height:100%;width:100%;min-height:0;min-width:0}.wy-truncated-text-and-icon{display:flex;align-items:center;gap:.25rem}.wy-truncated-text-and-icon>:first-child{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.wy-truncated-text-and-icon>:last-child:not(:first-child){flex:0 0 auto;white-space:nowrap}[part~=wy-filename]{font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);display:flex;flex-direction:column;justify-content:center}[part~=wy-filename] .wy-truncated-text-and-icon{justify-content:space-between}.wy-files{position:relative;display:flex;flex-direction:column;flex:1;min-height:0;container-type:inline-size}@supports (position: sticky){wy-files-appbar{position:sticky;top:0;z-index:1020}}.wy-table-files thead{text-align:left;display:none}@container (inline-size >= 576px){.wy-table-files thead{display:table-header-group}}.wy-table-files tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-table-files tr>:nth-child(2){width:100%}.wy-table-files tr>:nth-child(2) td{padding:0 var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}.wy-table-files tr>:nth-child(4){width:calc(7 * var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){.wy-table-files tr>:nth-child(4){display:table-cell}}.wy-table-files tr>:nth-child(4){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-files tr>:nth-child(5){width:calc(7.5 * var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 768px){.wy-table-files tr>:nth-child(5){display:table-cell}}.wy-table-files tr>:nth-child(5){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-files tr>:nth-child(6){width:calc(7 * var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){.wy-table-files tr>:nth-child(6){display:table-cell}}.wy-table-files tr>:nth-child(6){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-sidebar{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(18 * var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}.wy-sidebar>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(18 * var(--wy-size, 1rem))}.wy-sidebar[hidden]{display:flex!important;flex-basis:0}.wy-sidebar[hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@media (min-width: 768px){.wy-sidebar>*{min-width:calc(18 * var(--wy-size, 1rem))}.wy-sidebar .wy-sidebar-handle{display:none}}@media (max-width: 767.98px){.wy-sidebar{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}.wy-sidebar:not([hidden]){margin-top:calc(-1 * var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-sidebar:not([hidden]).wy-maximized{flex-basis:calc(100% - var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))) * .5);margin-top:calc(-50% + var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))) * 2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-sidebar:not([hidden]).wy-maximized~* .wy-nav-prev,.wy-sidebar:not([hidden]).wy-maximized~* .wy-nav-next{display:none}.wy-sidebar>*{min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))))}}.wy-sidebar-handle{width:calc(4 * var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));height:calc(1 * var(--wy-size, 1rem));border:calc(.375 * var(--wy-size, 1rem)) solid transparent;position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}.wy-table{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}.wy-table th,.wy-table td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(2.5 * var(--wy-size, 1rem))}.wy-table th:first-child,.wy-table td:first-child{padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-table th:last-child,.wy-table td:last-child{padding-right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-table>tbody{vertical-align:inherit}.wy-table>thead{vertical-align:bottom}.wy-table .wy-table-cell-icon{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));width:calc(calc(2.5 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) * 2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}.wy-table .wy-table-cell-text{width:100%}.wy-table .wy-table-cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-hover>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));color:var(--wy-component-color);cursor:pointer}.wy-table-row-trashed th,.wy-table-row-trashed td{text-decoration:line-through}.wy-table-row-trashed th:not(:last-child)>*,.wy-table-row-trashed td:not(:last-child)>*{opacity:var(--wy-opacity-disabled, 38%)}.wy-table-row-trashed th>a,.wy-table-row-trashed td>a{color:var(--wy-component-color)}.wy-table-row-trashed:hover th,.wy-table-row-trashed:hover td{opacity:1}.wy-table-no-result{text-align:center;padding:calc(1 * var(--wy-size, 1rem))}.wy-table-sort-link{display:inline-flex;align-items:center;color:var(--wy-link, var(--wy-primary-40, #006399));cursor:pointer}[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;overflow:hidden;column-gap:1px;row-gap:1px}[part~=wy-image-area]{display:block;height:100%;cursor:pointer}[part~=wy-image-content]{position:absolute;height:100%;width:100%;object-fit:contain}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-grid-more]{position:absolute;line-height:100%;color:var(--wy-white, #ffffff);top:0;left:0;bottom:0;right:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5 * var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}.wy-posts{display:flex;flex-direction:column;gap:calc(1 * var(--wy-size, 1rem))}.wy-post{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}.wy-post[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-post wy-comment-list{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-post-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-area-full-width{border-radius:0}.wy-post-body{display:flex;flex-direction:column;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-body:empty{display:none}.wy-post-footer{display:flex;align-items:center;justify-content:space-between;padding:0 calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) * .75) calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) * .75)}.wy-post-footer .wy-meta{margin-right:calc(.5 * var(--wy-size, 1rem))}.wy-post-comments:not(:empty){padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-post-dragging:after{content:attr(data-drag-title,\"Drop files here to upload.\");background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125 * var(--wy-size, 1rem)) dashed var(--wy-primary, var(--wy-primary-40, #006399));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;top:0;left:0;bottom:0;right:0}.wy-poll{flex:1 1 100%;min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-poll-form{background:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-poll-form:empty{display:none}.wy-poll-option{overflow:hidden;position:relative;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:calc(2.5 * var(--wy-size, 1rem));cursor:pointer}.wy-poll-option .wy-progress{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-5, var(--wy-surface-5-light, #dce2ea))}.wy-poll-option>:not(.wy-progress){z-index:1}.wy-embed{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;overflow:hidden}.wy-embed-photo a{display:flex}.wy-embed-photo img{width:100%;height:auto}.wy-embed-photo-sm a{padding:0 calc(1 * var(--wy-size, 1rem))}.wy-embed-photo-sm img{display:block;margin:0 auto;width:auto;max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-embed-video{position:relative;display:block;width:100%;padding:0;overflow:hidden}.wy-embed-video:before{display:block;content:\"\";padding-top:56.25%}.wy-embed-video iframe,.wy-embed-video embed,.wy-embed-video object,.wy-embed-video video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.wy-embed-caption{--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);padding:calc(.5 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));position:relative}.wy-embed-link{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-embed-link:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:1;content:\"\"}.wy-embed-title{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-embed-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-embed-preview a[target=_blank]{pointer-events:none}.wy-embed-preview .wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:none}.wy-embed-preview .wy-embed:first-child{display:block}.wy-embed-preview .wy-embed-caption{border-bottom-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-bottom-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}.wy-embed-preview .wy-embed-actions{display:flex}.wy-embed-actions{display:none;justify-content:space-between;padding:calc(.5 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem))}.wy-embed-cycle{visibility:hidden}.wy-embed-show-cycle .wy-embed-cycle{visibility:visible}.wy-post-editor{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-editor.wy-uploading .wy-icon-active-stack>:first-child{opacity:0}.wy-post-editor.wy-uploading .wy-icon-active-stack>:last-child{opacity:1}.wy-post-editor .wy-picker-list:not(:empty){margin-top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-post-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-editor-buttons{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));flex:1 0 auto}.wy-post-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-post-editor-mention,.wy-post-editor-link{background:#00f;color:#fff}.wy-post-editor .cm-editor,.wy-post-editor-grow:after,.wy-post-editor-grow>textarea,.wy-post-editor-textfield{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));caret-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-post-editor .cm-editor:focus,.wy-post-editor-grow:focus:after,.wy-post-editor-grow>textarea:focus,.wy-post-editor-textfield:focus{border-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-post-editor .cm-editor .cm-content,.wy-post-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-post-editor-grow{display:grid}.wy-post-editor-grow:after,.wy-post-editor-grow>textarea{grid-area:1/1/2/2}.wy-post-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-post-editor-grow>textarea{resize:none;overflow:hidden}.wy-post-editor .cm-editor .cm-line{padding:0}.wy-post-editor .wy-is-invalid+[data-editor-target] .cm-editor,.wy-post-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-comments{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));margin-bottom:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comments-padded{margin:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comment{--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius);background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative}.wy-comment[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-comment-body{flex:1 0 auto;z-index:1}.wy-comment-content{padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comment-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-comment-editor .wy-spinner{display:none}.wy-comment-editor.wy-uploading .wy-spinner{display:block}.wy-comment-editor.wy-uploading [data-icon=plus]{display:none}.wy-comment-editor .wy-picker-list:not(:empty){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-comment-editor.wy-comment-editor-bottom{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-comment-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(3.5 * var(--wy-size, 1rem));gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-comment-editor-buttons{flex:1 0 auto}.wy-comment-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-comment-editor-mention,.wy-comment-editor-link{background:#00f;color:#fff}.wy-comment-editor .cm-editor,.wy-comment-editor-grow:after,.wy-comment-editor-grow>textarea,.wy-comment-editor-textfield{flex:1 1 100%;max-height:calc(11.25 * var(--wy-size, 1rem));background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:calc(1.25 * var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-comment-editor .cm-editor:focus,.wy-comment-editor-grow:focus:after,.wy-comment-editor-grow>textarea:focus,.wy-comment-editor-textfield:focus{border-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-comment-editor .cm-editor .cm-content,.wy-comment-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-comment-editor-grow{display:grid}.wy-comment-editor-grow:after,.wy-comment-editor-grow>textarea{grid-area:1/1/2/2}.wy-comment-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-comment-editor-grow>textarea{resize:none;overflow:hidden}.wy-comment-editor{position:relative}.wy-comment-editor .wy-is-invalid+.cm-editor,.wy-comment-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-badge{display:inline-block;padding:.35em .65em;font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight-bold, 600);line-height:1;color:var(--wy-on-primary, var(--wy-white, #ffffff));text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-badge:empty{display:none}.wy-badge-reveal{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{.wy-badge-reveal{opacity:0}}.wy-button-badge{position:absolute;right:0;top:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5);padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) * 3 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) - var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:block;text-align:center}.wy-button-badge{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-button-badge:empty{display:none}.wy-button-dot{position:absolute;right:0;top:0;content-visibility:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:0;min-width:0;height:0}.wy-button-dot:empty{display:none}[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) transparent}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:transparent;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:transparent}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:75%;border:0 solid transparent;border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * 0)}.wy-conversations{position:relative}.wy-conversation{display:flex;position:relative}.wy-conversation .wy-item-title{font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em))}.wy-conversation.wy-unread .wy-item-title{font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation.wy-unread .wy-item-text,.wy-conversation.wy-unread .wy-meta{color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation .wy-item-text .wy-typing-show{font-weight:var(--wy-font-weight, unset)}.wy-conversation .wy-item-text .wy-typing-show{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`, At = Mt`:host{display:contents}`;
var wU = Object.defineProperty, gU = Object.getOwnPropertyDescriptor, Le = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? gU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && wU(t, e, s), s;
}, "__decorateClass$1b");
function uk(n) {
  return n != null && n !== !1;
}
h(uk, "wy");
u(uk, "acceptedValue");
const Tz = "wy-context";
var xO, ju;
let he = (xO = (ju = class extends ft {
  constructor() {
    super(), this.provider = !1, this.cloudFilePickerUrl = ke.defaults.cloudFilePickerUrl, this.disableEnvironmentImports = ke.defaults.disableEnvironmentImports, this.locale = ke.defaults.locale, this.locales = ke.defaults.locales, this.gcTime = ke.defaults.gcTime, this.notificationEvents = ke.defaults.notificationEvents, this.scrollBehavior = ke.defaults.scrollBehavior, this.staleTime = ke.defaults.staleTime, this.tokenFactory = ke.defaults.tokenFactory, this.tokenFactoryRetryDelay = ke.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = ke.defaults.tokenFactoryTimeout, this.tokenUrl = ke.defaults.tokenUrl, this.url = ke.defaults.url, this.notifications = ke.defaults.notifications, this.notificationsBadge = ke.defaults.notificationsBadge, this.reactions = ke.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ?? (this.weavy = new ke({ host: this.provider ? this : void 0 }));
  }
  /**
   * The semver version of the package.
   */
  get version() {
    return ke.version;
  }
  /**
   * The Weavy source name; package name.
   */
  get sourceName() {
    return ke.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((i) => {
        i !== "weavy" && (uk(this[i]) || uk(t.get(i))) && Object.assign(e, { [i]: this[i] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return v` <slot></slot> `;
  }
}, h(ju, "Gn"), ju), u(xO, "WyContext"), xO);
he.styles = [
  yt,
  Xi,
  At
];
Le([
  $({ attribute: !0, type: Boolean })
], he.prototype, "provider", 2);
Le([
  $({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ u((n) => ag(n), "fromAttribute")
    }
  })
], he.prototype, "cloudFilePickerUrl", 2);
Le([
  $({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ u((n) => ag(n), "fromAttribute")
    }
  }),
  $({ type: Boolean })
], he.prototype, "disableEnvironmentImports", 2);
Le([
  $({ attribute: !0 })
], he.prototype, "locale", 2);
Le([
  $({ attribute: !0, type: Array })
], he.prototype, "locales", 2);
Le([
  $({ attribute: !0, type: Number })
], he.prototype, "gcTime", 2);
Le([
  $({ type: Boolean })
], he.prototype, "notificationEvents", 2);
Le([
  $({ attribute: !0 })
], he.prototype, "scrollBehavior", 2);
Le([
  $({ attribute: !0, type: Number })
], he.prototype, "staleTime", 2);
Le([
  $({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ u((n) => Mz(n), "fromAttribute")
    }
  })
], he.prototype, "tokenFactory", 2);
Le([
  $({ attribute: !0, type: Number })
], he.prototype, "tokenFactoryRetryDelay", 2);
Le([
  $({ attribute: !0, type: Number })
], he.prototype, "tokenFactoryTimeout", 2);
Le([
  $({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ u((n) => ag(n), "fromAttribute")
    }
  })
], he.prototype, "tokenUrl", 2);
Le([
  $({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ u((n) => ag(n), "fromAttribute")
    }
  })
], he.prototype, "url", 2);
Le([
  $({ attribute: !0 })
], he.prototype, "notifications", 2);
Le([
  $({ attribute: !0 })
], he.prototype, "notificationsBadge", 2);
Le([
  $({ attribute: !0 })
], he.prototype, "reactions", 2);
Le([
  U()
], he.prototype, "weavy", 2);
he = Le([
  H(Tz)
], he);
var Um, z1, Fu;
const Az = (Fu = class {
  constructor(t, e) {
    F(this, Um), F(this, z1), L(this, Um, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return k(this, z1);
  }
  set themeColor(t) {
    L(this, z1, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || Zv(this.host) || Wv();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = XE(this._resolvedThemeColor).join(""), i = Mt`
        :host {
          ${pR(e)};
        }
      `, s = this.host.renderRoot;
      fR(s, [...this.styles, i]);
    }
  }
  hostUpdate() {
    k(this, Um) && (this.checkThemeUpdate(), L(this, Um, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = UE(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = BE(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    var t, e;
    (t = this.cssObserverDisconnect) == null || t.call(this), (e = this.metaObserverDisconnect) == null || e.call(this);
  }
}, h(Fu, "Tp"), Fu);
Um = /* @__PURE__ */ new WeakMap(), z1 = /* @__PURE__ */ new WeakMap(), u(Az, "ThemeController");
let Js = Az;
const tr = Mt`:host{font-family:var(--wy-font-family, unset)}`;
var vU = Object.defineProperty, bU = Object.getOwnPropertyDescriptor, fP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? bU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vU(t, e, s), s;
}, "__decorateClass$1a");
const Rz = "wy-component";
var kO, Uu;
let Uo = (kO = (Uu = class extends jt {
  constructor() {
    super(...arguments), this.componentType = nn.Unknown, this.componentFeatures = new $n(D0(dk)), this.theme = new Js(this, Uo.styles);
  }
  render() {
    return v`<slot></slot>`;
  }
}, h(Uu, "Yn"), Uu), u(kO, "WyComponent"), kO);
Uo.styles = [Xi, At, tr];
fP([
  $({
    converter: {
      fromAttribute(n, t) {
        return yU.get(n) ?? n;
      }
    }
  })
], Uo.prototype, "componentType", 2);
fP([
  $({
    converter: {
      fromAttribute(n, t) {
        const e = typeof n == "string" ? sP(n, dk) : dk;
        return new $n(D0(e));
      }
    }
  })
], Uo.prototype, "componentFeatures", 2);
Uo = fP([
  H(Rz)
], Uo);
const pa = Mt`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate}`, cl = Mt`.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}:host{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function Ez(n, t, e = {}, i) {
  var s, r;
  if (n) {
    if (n = JSON.parse(JSON.stringify(n)), n != null && n.pages) {
      let a = -1;
      return {
        pages: [...n.pages.map((o, l) => {
          if (a >= 0)
            return o;
          const c = o.data || [], d = c.filter(
            (p) => p.id !== t.id && !0
          );
          return e && e.by ? (a = d.findIndex((p) => {
            let f = e.by && p[e.by], m = e.by && t[e.by];
            if (e.by === "updated_at" && (f ?? (f = p.created_at), m ?? (m = t.created_at)), typeof f == "string" && typeof m == "string") {
              const w = f.localeCompare(m, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? w < 0 : w > 0;
            }
            return f && m && (e.descending ? f < m : f > m);
          }), a >= 0 ? (d.splice(a, 0, t), o.data = [...d], o.end && (o.end += 1 + d.length - c.length)) : n && l == n.pages.length - 1 && o.end === o.count ? (o.data = [...d, t], o.end && (o.end += 1 + d.length - c.length)) : o.data = [...d]) : l === 0 && (e.descending ? o.data = [t, ...d] : o.data = [...d, t], o.end && (o.end += 1 + d.length - c.length)), o;
        }) ?? []],
        pageParams: [...n.pageParams]
      };
    } else if ((s = n == null ? void 0 : n.data) != null && s.length) {
      let a = -1;
      const o = [
        ...((r = n.data) == null ? void 0 : r.filter(
          (c) => c.id !== t.id && !0
        )) || []
      ];
      let l = n.count;
      return e && e.by ? (a = o.findIndex((c) => {
        let d = c[e.by], p = t[e.by];
        if (e.by === "updated_at" && (d ?? (d = c.created_at), p ?? (p = t.created_at)), typeof d == "string" && typeof p == "string") {
          const f = d.localeCompare(p, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? f < 0 : f > 0;
        }
        return d && p && (e.descending ? d < p : d > p);
      }), a >= 0 ? o.splice(a, 0, t) : (o.push(t), l++)) : (e.descending ? o.unshift(t) : o.push(t), l++), {
        data: o,
        count: l
      };
    }
  }
  return n;
}
h(Ez, "ag");
u(Ez, "addToQueryData");
function yP(n, t, e) {
  var i, s;
  const r = t === void 0 ? () => !0 : t instanceof Function ? t : (a) => a.id === t;
  return n && (n = JSON.parse(JSON.stringify(n)), n.pages ? {
    pages: n.pages.map((a) => (a.data && (a.data = [
      ...a.data.map((o) => (r(o) && (o = { ...o }, e(o)), o))
    ]), a)) ?? [],
    pageParams: n.pageParams
  } : (i = n.data) != null && i.length ? {
    ...n,
    data: [
      ...((s = n.data) == null ? void 0 : s.map((a) => (r(a) && (a = { ...a }, e(a)), a))) || []
    ]
  } : n.data ? {
    data: [
      ...n.data.map((a) => (r(a) && (a = { ...a }, e(a)), a))
    ],
    count: n.count
  } : n);
}
h(yP, "rf");
u(yP, "updateQueryData");
function mP(n, t) {
  var e, i, s;
  if (t !== void 0) {
    const r = t instanceof Function ? t : (a) => a.id === t;
    if (n) {
      if (n = JSON.parse(JSON.stringify(n)), n.pages)
        return {
          pages: n.pages.map((a) => (a.data && (a.data = [...a.data.filter((o) => !r(o))]), a)) ?? [],
          pageParams: n.pageParams
        };
      if ((e = n.data) != null && e.length) {
        const a = (i = n.data) == null ? void 0 : i.length;
        let o = n.count;
        const l = [...((s = n.data) == null ? void 0 : s.filter((c) => !r(c))) || []];
        return a !== l.length && o--, {
          data: l,
          count: o
        };
      }
    }
  }
  return n;
}
h(mP, "nf");
u(mP, "removeQueryData");
const ta = /* @__PURE__ */ u((n, t, e, i) => n.setQueryData(t, (s) => Ez(s, e, i)), "addCacheItem"), we = /* @__PURE__ */ u((n, t, e, i) => n.setQueryData(t, (s) => yP(
  s,
  e,
  i
)), "updateCacheItem"), $t = /* @__PURE__ */ u((n, t, e, i) => {
  n.setQueriesData(t, (s) => yP(
    s,
    e,
    i
  ));
}, "updateCacheItems"), F0 = /* @__PURE__ */ u((n, t, e) => n.setQueryData(t, (i) => mP(
  i,
  e
)), "removeCacheItem"), OU = /* @__PURE__ */ u((n, t, e) => {
  n.setQueriesData(t, (i) => mP(i, e));
}, "removeCacheItems"), Vv = /* @__PURE__ */ u((n, t, e) => {
  n.setQueriesData(t, (i) => {
    const { count: s } = i;
    return { count: e(s) };
  });
}, "updateCacheItemsCount");
function pk(n, t, e, i = 1) {
  var s;
  if (!n)
    return;
  const r = n.getQueryData(t);
  (s = r == null ? void 0 : r.pages) != null && s.length && r.pages.length > 1 && n.setQueryData(
    t,
    (a) => ({
      pages: a.pages.slice(0, i),
      pageParams: a.pageParams.slice(0, i)
    }),
    e
  );
}
h(pk, "fy");
u(pk, "keepPages");
function ea(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  if (i && i.state.data) {
    const s = i.state.data.pages.flatMap((r) => r.data).filter((r) => r && r.id < 0).sort((r, a) => r && a ? r.id - a.id : 0);
    return s.length ? e ? s[s.length - 1] : s[0] : null;
  }
  return null;
}
h(ea, "lr");
u(ea, "getPendingCacheItem");
function og(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  return i && i.state.data ? i.state.data.pages.flatMap((s) => s.data).find((s) => (s == null ? void 0 : s.id) === e) : null;
}
h(og, "bd");
u(og, "getCacheItem");
function ds(n) {
  return ((n == null ? void 0 : n.pages.flatMap((t) => t.data)) || []).filter((t) => t);
}
h(ds, "ts");
u(ds, "getFlatInfiniteResultData");
function fk(n) {
  return !n || !(n != null && n.pages.some((t) => {
    var e;
    return (e = t.data) == null ? void 0 : e.length;
  }));
}
h(fk, "my");
u(fk, "isInfiniteResultDataEmpty");
function zz(n, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ u(async (i) => {
      var s;
      const r = i.pageParam, a = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + r, o = await (await n.fetch(a)).json();
      return o.data = ((s = o.data) == null ? void 0 : s.reverse()) || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((i) => {
      if (i != null && i.end && (i == null ? void 0 : i.end) < (i == null ? void 0 : i.count))
        return i.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ u((i) => ({
      // reverse scroll
      pages: [...i.pages].reverse(),
      pageParams: [...i.pageParams].reverse()
    }), "select")
  };
}
h(zz, "cg");
u(zz, "getMessagesOptions");
function _z(n, t) {
  return {
    mutationFn: /* @__PURE__ */ u(async (e) => await (await n.fetch("/api/apps/" + e.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        embed_id: e.embed_id || null,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        metadata: e.metadata || null,
        context: e.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ u((e) => {
      const i = ["messages", e.app_id], s = ea(n.queryClient, i, !1), r = {
        id: s ? s.id - 1 : -1,
        app: { id: e.app_id },
        text: e.text,
        html: e.text,
        plain: e.text,
        created_by: e.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      ta(n.queryClient, i, r);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((e) => {
      $t(
        n.queryClient,
        { queryKey: ["members", e.app.id] },
        e.created_by.id,
        (s) => {
          s.marked_id = e.id, s.marked_at = e.created_at;
        }
      );
      const i = ["messages", e.app.id];
      if (!og(n.queryClient, i, e.id)) {
        const s = ea(n.queryClient, i, !0);
        s ? we(n.queryClient, i, s.id, (r) => {
          r.id = e.id, r.app = e.app, r.text = e.text, r.html = e.html, r.embed = e.embed, r.meeting = e.meeting, r.attachments = e.attachments, r.options = e.options, r.created_at = e.created_at, r.created_by = e.created_by, r.updated_at = e.updated_at, r.updated_by = e.updated_by;
        }) : ta(n.queryClient, i, e);
      }
    }, "onSuccess")
  };
}
h(_z, "lg");
u(_z, "getAddMessageMutationOptions");
var Bu;
const Lz = (Bu = class {
  get result() {
    var t;
    return this._result && this.observer ? this.observer.trackResult(this._result) : ((t = this.observer) == null ? void 0 : t.getCurrentResult()) ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await sl(this.host), this.context = new qs(this.host, {
      context: _e,
      subscribe: !0,
      callback: /* @__PURE__ */ u((t) => {
        var e, i;
        t && ((e = this.resolveContext) == null || e.call(this, t), this.queryClient = t.queryClient, (i = this.resolveQueryClient) == null || i.call(this, t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    var i;
    (i = this.observerUnsubscribe) == null || i.call(this);
    const s = await this.whenQueryClient;
    if (!s)
      throw new Error("No QueryClient provided");
    const r = new _F(s, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    var e;
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const s = xy(this.result, this.observer.getCurrentResult());
          s !== this._result && (this._result = s, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let i;
      t ? i = this.observer.fetchOptimistic(this.observer.options) : i = (e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )) == null ? void 0 : e.promise, i == null || i.catch(() => {
      }).finally(() => {
        var s;
        (s = this.observer) == null || s.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this);
  }
}, h(Bu, "Fp"), Bu);
u(Lz, "InfiniteQueryController");
let hl = Lz;
function Iz(n) {
  for (; n; )
    if (n = n.nextElementSibling, n instanceof HTMLElement && /absolute|sticky|fixed/.test(getComputedStyle(n).position) === !1)
      return n;
  return null;
}
h(Iz, "dg");
u(Iz, "getNextPositionedChild");
function lg(n, t = !1) {
  if (ti(), n) {
    let e = getComputedStyle(n);
    const i = e.position === "absolute", s = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let r = n; r = r.parentElement || r.parentNode || r.host; )
      if (r instanceof Element && (e = getComputedStyle(r), !(i && e.position === "static") && s.test(e.overflow + e.overflowY + e.overflowX)))
        return r;
  }
  return document.scrollingElement || n;
}
h(lg, "xd");
u(lg, "getScrollParent");
function Zz(n) {
  if (n && n.isConnected) {
    const t = lg(n);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
h(Zz, "hg");
u(Zz, "hasScroll");
function Wz(n, t = 32) {
  if (n) {
    const e = lg(n);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
h(Wz, "ug");
u(Wz, "isParentAtBottom");
async function Dz(n, t = !1) {
  if (n) {
    const e = lg(n);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((i) => {
      let s = e.scrollTop;
      const r = /* @__PURE__ */ u(() => {
        t && e.scrollTop === s && (e.scrollTop = e.scrollHeight), s = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(r) : i(void 0);
      }, "scrollCheck");
      requestAnimationFrame(r);
    });
  }
}
h(Dz, "pg");
u(Dz, "scrollParentToBottom");
const $U = 0, xU = void 0;
function qz(n, t, e = !1) {
  ti(), t ?? (t = /* @__PURE__ */ u(() => Promise.reject(new Error("No scroll function defined")), "whenNext"));
  const i = e ? lg(n) : document.documentElement, s = i === document.documentElement ? document : i;
  let r = !1;
  const a = new IntersectionObserver(
    (o) => {
      o.forEach((l) => {
        if (l.isIntersecting && !r)
          if (r = !0, e && i && s instanceof HTMLElement) {
            const c = Iz(l.target) || l.target, d = i.scrollHeight, p = c.offsetTop, f = /* @__PURE__ */ u(() => {
              queueMicrotask(() => {
                if (d !== i.scrollHeight) {
                  if (c != null && c.isConnected) {
                    const m = c.offsetTop - p;
                    i.scrollTop += m;
                  }
                  requestAnimationFrame(() => r = !1);
                } else
                  queueMicrotask(() => {
                    if (d !== i.scrollHeight) {
                      if (c != null && c.isConnected) {
                        const m = c.offsetTop - p;
                        i.scrollTop += m;
                      }
                      requestAnimationFrame(() => r = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (a.takeRecords().length && c != null && c.isConnected) {
                          const m = c.offsetTop - p;
                          i.scrollTop += m;
                        }
                        requestAnimationFrame(() => r = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(f);
          } else
            t().then(() => {
              requestAnimationFrame(() => r = !1);
            });
      });
    },
    { root: s, threshold: $U, rootMargin: xU }
  );
  return a.observe(n), a;
}
h(qz, "fg");
u(qz, "createScroller");
var Xu;
const Vz = (Xu = class {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      var i;
      this.loadMoreRefElement = e, (i = this.scroller) == null || i.disconnect(), this.scroller = qz(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    var t;
    this.loadMoreRefElement && ((t = this.scroller) == null || t.observe(this.loadMoreRefElement));
  }
  hostDisconnected() {
    var t;
    (t = this.scroller) == null || t.disconnect();
  }
}, h(Xu, "Dp"), Xu);
u(Vz, "InfiniteScrollController");
let dl = Vz;
var Nu;
const jz = (Nu = class extends dl {
  constructor(t) {
    super(t, !0);
  }
}, h(Nu, "Hp"), Nu);
u(jz, "ReverseInfiniteScrollController");
let kU = jz;
const { I: SU } = vF, PU = /* @__PURE__ */ u((n) => n.strings === void 0, "f$1"), w3 = /* @__PURE__ */ u(() => document.createComment(""), "s$1"), rm = /* @__PURE__ */ u((n, t, e) => {
  var i;
  const s = n._$AA.parentNode, r = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const a = s.insertBefore(w3(), r), o = s.insertBefore(w3(), r);
    e = new SU(a, o, n, n.options);
  } else {
    const a = e._$AB.nextSibling, o = e._$AM, l = o !== n;
    if (l) {
      let c;
      (i = e._$AQ) == null || i.call(e, n), e._$AM = n, e._$AP !== void 0 && (c = n._$AU) !== o._$AU && e._$AP(c);
    }
    if (a !== r || l) {
      let c = e._$AA;
      for (; c !== a; ) {
        const d = c.nextSibling;
        s.insertBefore(c, r), c = d;
      }
    }
  }
  return e;
}, "r$1"), La = /* @__PURE__ */ u((n, t, e = n) => (n._$AI(t, e), n), "v"), CU = {}, Fz = /* @__PURE__ */ u((n, t = CU) => n._$AH = t, "m"), QU = /* @__PURE__ */ u((n) => n._$AH, "p"), SO = /* @__PURE__ */ u((n) => {
  var t;
  (t = n._$AP) == null || t.call(n, !1, !0);
  let e = n._$AA;
  const i = n._$AB.nextSibling;
  for (; e !== i; ) {
    const s = e.nextSibling;
    e.remove(), e = s;
  }
}, "M"), Py = { ATTRIBUTE: 1, CHILD: 2 }, fa = /* @__PURE__ */ u((n) => (...t) => ({ _$litDirective$: n, values: t }), "e$3");
var PO, Hu;
let ul = (PO = (Hu = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, h(Hu, "Xn"), Hu), u(PO, "i"), PO);
const aw = /* @__PURE__ */ u((n, t) => {
  var e;
  const i = n._$AN;
  if (i === void 0) return !1;
  for (const s of i) (e = s._$AO) == null || e.call(s, t, !1), aw(s, t);
  return !0;
}, "s"), jv = /* @__PURE__ */ u((n) => {
  let t, e;
  do {
    if ((t = n._$AM) === void 0) break;
    e = t._$AN, e.delete(n), n = t;
  } while ((e == null ? void 0 : e.size) === 0);
}, "o$5"), Uz = /* @__PURE__ */ u((n) => {
  for (let t; t = n._$AM; n = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(n)) break;
    e.add(n), MU(t);
  }
}, "r");
function Bz(n) {
  this._$AN !== void 0 ? (jv(this), this._$AM = n, Uz(this)) : this._$AM = n;
}
h(Bz, "xg");
u(Bz, "h$1");
function Xz(n, t = !1, e = 0) {
  const i = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0) if (t) if (Array.isArray(i)) for (let r = e; r < i.length; r++) aw(i[r], !1), jv(i[r]);
  else i != null && (aw(i, !1), jv(i));
  else aw(this, n);
}
h(Xz, "$g");
u(Xz, "n$2");
const MU = /* @__PURE__ */ u((n) => {
  n.type == Py.CHILD && (n._$AP ?? (n._$AP = Xz), n._$AQ ?? (n._$AQ = Bz));
}, "c$1");
var Yu;
const Nz = (Yu = class extends ul {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), Uz(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    var i, s;
    t !== this.isConnected && (this.isConnected = t, t ? (i = this.reconnected) == null || i.call(this) : (s = this.disconnected) == null || s.call(this)), e && (aw(this, t), jv(this));
  }
  setValue(t) {
    if (PU(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}, h(Yu, "Vp"), Yu);
u(Nz, "f");
let TU = Nz;
const wt = /* @__PURE__ */ u(() => new AU(), "e$2");
var Gu;
const Hz = (Gu = class {
}, h(Gu, "Bp"), Gu);
u(Hz, "h");
let AU = Hz;
const CO = /* @__PURE__ */ new WeakMap(), lt = fa(class extends TU {
  render(n) {
    return Q;
  }
  update(n, [t]) {
    var e;
    const i = t !== this.G;
    return i && this.G !== void 0 && this.rt(void 0), (i || this.lt !== this.ct) && (this.G = t, this.ht = (e = n.options) == null ? void 0 : e.host, this.rt(this.ct = n.element)), Q;
  }
  rt(n) {
    if (this.isConnected || (n = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = CO.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), CO.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, n), n !== void 0 && this.G.call(this.ht, n);
    } else this.G.value = n;
  }
  get lt() {
    var n, t;
    return typeof this.G == "function" ? (n = CO.get(this.ht ?? globalThis)) == null ? void 0 : n.get(this.G) : (t = this.G) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function Yz(n, t, e) {
  const i = n.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ u(async ({ optionId: s }) => {
      const r = await n.fetch(`/api/options/${s}/vote`, { method: "POST" });
      if (!r.ok) {
        const a = await r.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
      return await r.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => ($t(i, { queryKey: e }, s.parentId, (r) => {
      var a, o;
      (a = r.options) != null && a.data && (r.options.data = (o = r.options.data) == null ? void 0 : o.map((l) => {
        var c, d;
        if (l.has_voted) {
          l.has_voted = !1;
          const p = ((c = l.votes) == null ? void 0 : c.count) || 1;
          l.votes ? l.votes.count = p - 1 : l.votes = { count: p - 1 };
        } else if (!l.has_voted && l.id === s.optionId) {
          l.has_voted = !0;
          const p = ((d = l.votes) == null ? void 0 : d.count) || 0;
          l.votes ? l.votes.count = p + 1 : l.votes = { count: p + 1 };
        }
        return l;
      }));
    }), { id: s.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ u(async (s, r) => {
      const a = await (await n.fetch("/api/" + r.parentType + "/" + r.parentId)).json();
      $t(
        i,
        { queryKey: e, exact: !1 },
        r.parentId,
        (o) => Object.assign(o, a)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
h(Yz, "kg");
u(Yz, "getPollMutationOptions");
function U0(n, t, e) {
  return new Vt(n.queryClient, Yz(n, t, e));
}
h(U0, "tp");
u(U0, "getPollMutation");
function Gz(n, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ u(async () => await (await n.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
h(Gz, "_g");
u(Gz, "getVotesOptions");
const ey = /* @__PURE__ */ u((n, t) => !!(n && t && t.indexOf(n) !== -1), "hasPermission");
function Kz(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, messageId: e }) => {
      const i = e ? `/api/apps/${t}/mark?messageId=${e}` : `/api/apps/${t}/mark`;
      await n.fetch(i, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u(async (t) => {
      await n.queryClient.cancelQueries({ queryKey: ["apps", t.appId] }), await n.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["members", t.appId] }), n.queryClient.setQueryData(
        ["apps", t.appId],
        (e) => e && { ...e, is_unread: !t.messageId || t.messageId < e.last_message.id }
      ), $t(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_unread = !t.messageId || t.messageId < e.last_message.id;
        }
      ), t.userId && $t(n.queryClient, { queryKey: ["members", t.appId] }, t.userId, (e) => {
        t.messageId ? (e.marked_at = (/* @__PURE__ */ new Date()).toISOString(), e.marked_id = t.messageId) : (e.marked_at = void 0, e.marked_id = void 0);
      });
    }, "onMutate"),
    onError: /* @__PURE__ */ u((t, e) => {
      console.error(t.message), $t(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_unread = !i.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ u(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps", i.appId] }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
h(Kz, "zg");
u(Kz, "getMarkConversationMutationOptions");
function Jz(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, star: e }) => {
      await n.fetch(`/api/apps/${t}/stars`, { method: e ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      $t(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_starred = t.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ u((t, e) => {
      console.error(t.message), $t(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_starred = !e.star;
        }
      );
    }, "onError")
  };
}
h(Jz, "Mg");
u(Jz, "getStarConversationMutationOptions");
function t_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, pin: e }) => {
      await n.fetch(`/api/apps/${t}/pin`, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      $t(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_pinned = t.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ u(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(t_, "Pg");
u(t_, "getPinConversationMutationOptions");
function e_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members/${e.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      F0(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((t, e) => {
      n.queryClient.removeQueries({ queryKey: ["apps", e.appId] }), n.queryClient.removeQueries({ queryKey: ["members", e.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ u(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
h(e_, "Sg");
u(e_, "getLeaveConversationMutationOptions");
function i_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      F0(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ u(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(i_, "Ag");
u(i_, "getRemoveConversationMutationOptions");
function n_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, userId: e, access: i }) => {
      await n.fetch(`/api/apps/${t}/members/${e}`, { method: "PUT", body: JSON.stringify({ access: i }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ u(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
h(n_, "Eg");
u(n_, "getUpdateMemberMutationOptions");
function s_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members`, {
        method: "PUT",
        body: JSON.stringify(
          e.map((i) => ({ id: i, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ u(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
h(s_, "Rg");
u(s_, "getAddMembersToConversationMutationOptions");
function r_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t, name: e, blobId: i }) => await (await n.fetch(`/api/apps/${t}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: e,
        picture: i
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      const e = /* @__PURE__ */ u((i) => {
        typeof t.name == "string" && (i.name = t.name), typeof (t == null ? void 0 : t.thumbnailUrl) == "string" && (i.avatar_url = t.thumbnailUrl);
      }, "modifyAppItem");
      we(n.queryClient, ["apps", t.appId], void 0, e), $t(n.queryClient, { queryKey: ["apps", "list"], exact: !1 }, t.appId, e);
    }, "onMutate")
  };
}
h(r_, "Og");
u(r_, "getUpdateConversationMutationOptions");
function a_(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      F0(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ u(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(a_, "Lg");
u(a_, "getTrashConversationMutationOptions");
function wP(n) {
  return new Vt(n.queryClient, Kz(n));
}
h(wP, "cf");
u(wP, "getMarkConversationMutation");
function o_(n) {
  return new Vt(n.queryClient, Jz(n));
}
h(o_, "Ig");
u(o_, "getStarConversationMutation");
function l_(n) {
  return new Vt(n.queryClient, t_(n));
}
h(l_, "Tg");
u(l_, "getPinConversationMutation");
function gP(n) {
  return new Vt(n.queryClient, e_(n));
}
h(gP, "lf");
u(gP, "getLeaveConversationMutation");
function c_(n) {
  return new Vt(n.queryClient, i_(n));
}
h(c_, "Fg");
u(c_, "getRemoveConversationMutation");
function h_(n) {
  return new Vt(n.queryClient, n_(n));
}
h(h_, "Dg");
u(h_, "getUpdateMemberMutation");
function d_(n) {
  return new Vt(n.queryClient, s_(n));
}
h(d_, "Hg");
u(d_, "getAddMembersToConversationMutation");
function vP(n) {
  return new Vt(n.queryClient, r_(n));
}
h(vP, "df");
u(vP, "getUpdateConversationMutation");
function u_(n) {
  return new Vt(n.queryClient, a_(n));
}
h(u_, "Vg");
u(u_, "getTrashConversationMutation");
function p_(n, t, e = [Pt.ChatRoom, Pt.PrivateChat], i) {
  return ol(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ u(() => {
      var s;
      return (s = n == null ? void 0 : n.queryClient.getQueryData(["apps", "list", e, i])) == null ? void 0 : s.pages.flatMap((r) => r.data).find((r) => (r == null ? void 0 : r.id) === t);
    }, "initialData")
  });
}
h(p_, "Bg");
u(p_, "getConversationOptions");
function yk(n, t, e = [Pt.ChatRoom, Pt.PrivateChat], i) {
  return Ev(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ u(() => {
      var s;
      return (s = n == null ? void 0 : n.queryClient.getQueryData(["apps", "list", e, i])) == null ? void 0 : s.pages.flatMap((r) => r.data).find((r) => (r == null ? void 0 : r.id) === t);
    }, "initialData")
  });
}
h(yk, "gy");
u(yk, "getConversation");
async function f_(n, t, e, i) {
  let s;
  if (typeof t == "number")
    s = await yk(n, t, e, i);
  else if (typeof t.id == "number" && !t.type)
    s = await yk(n, t.id, e, i);
  else if (typeof t.type == "string")
    s = t;
  else
    return;
  return e.includes(s.type) ? s : void 0;
}
h(f_, "Ug");
u(f_, "resolveAppWithType");
var Ku;
const y_ = (Ku = class {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (i) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ?? (this.shadowParts = /* @__PURE__ */ new Set()), i.forEach((s) => {
        var r;
        s.part.forEach((a) => {
          var o;
          return (o = this.shadowParts) == null ? void 0 : o.add(a);
        }), (r = s.getAttribute("exportparts")) == null || r.split(", ").forEach((a) => {
          var o;
          return (o = this.shadowParts) == null ? void 0 : o.add(a);
        });
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    var e;
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), (e = this.observer) == null || e.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, u$(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const i = e.filter((s) => s.target instanceof Element).map((s) => s.target);
        this.setExportParts(i);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        var i;
        (i = this.observer) == null || i.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    u$(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
}, h(Ku, "Up"), Ku);
u(y_, "ShadowPartsController");
let nt = y_;
function Fv(n, t, e, i) {
  return {
    queryKey: ["members", t, i],
    queryFn: /* @__PURE__ */ u(async () => await (await n.fetch(`/api/apps/${t}/members${i !== void 0 ? `?member=false&agent=${!!i}` : ""}`)).json(), "queryFn"),
    ...e
  };
}
h(Fv, "mu");
u(Fv, "getMemberOptions");
function m_(n, t, e, i) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ u(async (s) => {
      const r = t(), a = s.pageParam;
      let o;
      e ? o = await n.fetch(`/api/apps/${e}/members?q=${r}${i() !== void 0 ? `&agent=${!!i()}` : ""}&member=false&system=false&skip=${a}`) : o = await n.fetch(`/api/users?q=${r}${i() !== void 0 ? `&agent=${!!i()}` : ""}&system=false&skip=${a}`);
      const l = await o.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
h(m_, "qg");
u(m_, "getInfiniteSearchMemberOptions");
const Ct = /* @__PURE__ */ u((n) => n ?? Q, "o$3"), w_ = Mt`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 var(--wy-border, 1px) 0 0 inset;position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}`, ya = Mt`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`;
var bP = /* @__PURE__ */ ((n) => (n.Active = "active", n.Away = "away", n))(bP || {}), Ju;
const g_ = (Ju = class extends ul {
  constructor(t) {
    var e;
    if (super(t), t.type !== Py.ATTRIBUTE || t.name !== "part" || ((e = t.strings) == null ? void 0 : e.length) > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    var i, s;
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((a) => a !== "")
      ));
      for (const a in e)
        e[a] && !((i = this._staticShadowParts) != null && i.has(a)) && this._previousShadowParts.add(a);
      return this.render(e);
    }
    const r = t.element.part;
    for (const a of this._previousShadowParts)
      a in e || (r.remove(a), this._previousShadowParts.delete(a));
    for (const a in e) {
      const o = !!e[a];
      o !== this._previousShadowParts.has(a) && !((s = this._staticShadowParts) != null && s.has(a)) && (o ? (r.add(a), this._previousShadowParts.add(a)) : (r.remove(a), this._previousShadowParts.delete(a)));
    }
    return Pn;
  }
}, h(Ju, "qp"), Ju);
u(g_, "ShadowPartMapDirective");
let RU = g_;
const Qe = fa(RU), Ie = Mt`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, unset)}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1 * var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, OP = Mt`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-40, #006399)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-white, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:1}[part~=wy-avatar-type]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-primary-50, var(--wy-primary-50, #1e7dba));stroke:var(--wy-on-primary, var(--wy-white, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5 * var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, v_ = Mt`[part~=wy-presence]{width:calc(.75 * var(--wy-size, 1rem));height:calc(.75 * var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38b));background-clip:content-box;padding:calc(.125 * var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-1 * var(--wy-size, 1rem))}`;
var EU = Object.defineProperty, zU = Object.getOwnPropertyDescriptor, $P = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && EU(t, e, s), s;
}, "__decorateClass$19"), QO, tp;
let iy = (QO = (tp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === bP.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return v` <span part=${Qe(t)} data-presence-id=${this.id}></span> `;
  }
}, h(tp, "Jn"), tp), u(QO, "WyPresence"), QO);
iy.styles = [
  Ie,
  v_,
  At
];
$P([
  $()
], iy.prototype, "placement", 2);
$P([
  $()
], iy.prototype, "status", 2);
iy = $P([
  H("wy-presence")
], iy);
var _U = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", LU = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", IU = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", ZU = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", WU = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", g3 = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", DU = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", b_ = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", qU = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", O_ = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", $_ = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", VU = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", MO = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", jU = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", FU = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", UU = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", BU = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", XU = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", NU = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", HU = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", YU = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", GU = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", KU = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", JU = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", tB = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", eB = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", iB = "M13,19A1,1 0 0,0 14,20H16V22H13.5C12.95,22 12,21.55 12,21C12,21.55 11.05,22 10.5,22H8V20H10A1,1 0 0,0 11,19V5A1,1 0 0,0 10,4H8V2H10.5C11.05,2 12,2.45 12,3C12,2.45 12.95,2 13.5,2H16V4H14A1,1 0 0,0 13,5V19Z", x_ = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", k_ = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", nB = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", sB = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", rB = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", aB = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", oB = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", lB = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", v3 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", b3 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", cB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", hB = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", dB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", uB = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", pB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", fB = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", yB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", mB = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", wB = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", gB = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", vB = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", bB = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", OB = "M13.5,8H12V13L16.28,15.54L17,14.33L13.5,12.25V8M13,3A9,9 0 0,0 4,12H1L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3", $B = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", xB = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", kB = "M7,10L12,15L17,10H7Z", SB = "M7,15L12,10L17,15H7Z", PB = "M19,13H5V11H19V13Z", CB = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", QB = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", mk = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", MB = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", TB = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", S_ = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", AB = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", P_ = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", RB = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", EB = "M2,21L23,12L2,3V10L17,12L2,14V21Z", zB = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", _B = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", LB = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", IB = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", ZB = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", WB = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", DB = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", qB = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", VB = "M9,3L5,7H8V14H10V7H13M16,17V10H14V17H11L15,21L19,17H16Z", jB = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", FB = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", UB = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", BB = "M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z", XB = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", NB = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", HB = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", YB = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const O3 = RB, $3 = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, GB = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, KB = {
  email: oB,
  file: lB,
  "file-upload": pB,
  "file-music": dB,
  "file-image": hB,
  "file-video": fB,
  "file-code": v3,
  "file-xml": v3,
  "file-document": b3,
  "file-word": yB,
  "file-excel": cB,
  "file-pdf": b3,
  "file-powerpoint": uB,
  "file-compressed": gB
}, x3 = {
  "account-minus": _U,
  "account-plus": LU,
  alert: IU,
  "alert-circle": ZU,
  "alert-octagon": WU,
  attachment: b_,
  back: g3,
  "backup-restore": qU,
  bell: O_,
  "bell-off": $_,
  agent: WB,
  check: MO,
  "check-all": jU,
  "check-circle-outline": UU,
  "checkbox-blank": BU,
  "checkbox-marked": XU,
  "circle-outline": NU,
  "check-circle": FU,
  close: HU,
  "close-circle": YU,
  cloud: GU,
  comment: KU,
  "comment-outline": JU,
  "content-save": tB,
  delete: x_,
  "delete-restore": nB,
  "delete-forever": k_,
  "dots-vertical": sB,
  download: rB,
  earth: aB,
  "emoticon-plus": "M 19 0 L 19 3 L 16 3 L 16 5 L 19 5 L 19 8 L 21 8 L 21 5 L 24 5 L 24 3 L 21 3 L 21 0 L 19 0 z M 12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 L 20 12 C 20 16.4 16.4 20 12 20 C 7.6 20 4 16.4 4 12 C 4 7.6 7.6 4 12 4 L 12 2 z M 8.5 8 C 7.7 8 7 8.7 7 9.5 C 7 10.3 7.7 11 8.5 11 C 9.3 11 10 10.3 10 9.5 C 10 8.7 9.3 8 8.5 8 z M 15.5 8 C 14.7 8 14 8.7 14 9.5 C 14 10.3 14.7 11 15.5 11 C 16.3 11 17 10.3 17 9.5 C 17 8.7 16.3 8 15.5 8 z M 6.9 14 C 7.7 16 9.7 17.5 12 17.5 C 14.3 17.5 16.3 16 17.1 14 L 6.9 14 z",
  "fit-screen": wB,
  "fit-width": mB,
  "help-circle": bB,
  information: $B,
  magnify: xB,
  meeting: CB,
  "menu-down": kB,
  "menu-up": SB,
  minus: PB,
  next: DU,
  "open-in-new": QB,
  pencil: mk,
  pin: MB,
  unpin: TB,
  plus: S_,
  "plus-circle-outline": AB,
  poll: VU,
  previous: g3,
  read: MO,
  restore: P_,
  unread: MO,
  send: EB,
  "server-network-off": zB,
  "shield-star": _B,
  "shield-star-outline": LB,
  sort: IB,
  star: ZB,
  unstar: DB,
  stars: eB,
  "swap-horizontal": qB,
  textbox: vB,
  "thumb-up": jB,
  "thumb-up-outline": FB,
  trashcan: UB,
  video: XB,
  "view-list-outline": NB,
  "view-module-outline": HB,
  "wifi-off": YB,
  ...KB,
  ...GB
}, k3 = {
  attach: b_,
  create: S_,
  "delete-forever": k_,
  edit: mk,
  modify: mk,
  rename: iB,
  replace: VB,
  restore: P_,
  subscribe: O_,
  trash: x_,
  unsubscribe: $_,
  upload: BB,
  version: OB
}, S3 = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function wk(n) {
  return n && n in x3 ? x3[n] : "";
}
h(wk, "Py");
u(wk, "getIconMapping");
function C_(n) {
  return n && n in $3 ? $3[n] : "";
}
h(C_, "db");
u(C_, "getSvgMapping");
function Q_(n) {
  return n && n in k3 ? k3[n] : "";
}
h(Q_, "hb");
u(Q_, "getFileActionIconMapping");
var TO, ep;
let Uv = (TO = (ep = class extends ul {
  constructor(t) {
    if (super(t), this.it = Q, t.type !== Py.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === Q || t == null) return this._t = void 0, this.it = t;
    if (t === Pn) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
}, h(ep, "ta"), ep), u(TO, "e"), TO);
Uv.directiveName = "unsafeHTML", Uv.resultType = 1;
const Bo = fa(Uv);
var ip;
const M_ = (ip = class extends Uv {
}, h(ip, "Np"), ip);
u(M_, "t");
let gk = M_;
gk.directiveName = "unsafeSVG", gk.resultType = 2;
const P3 = fa(gk), xP = Mt`[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-padded]{margin:16.66666667%}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width) / 2);height:calc(var(--wy-component-icon-height) / 2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));text-align:center}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-40, #3b6a1c))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-40, #3b6a1c))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-neutral-99, #fcfcff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-40, #ba1824))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-70, #afb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9185de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #afb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-text-icon]{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}`;
var JB = Object.defineProperty, tX = Object.getOwnPropertyDescriptor, Oe = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? tX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && JB(t, e, s), s;
}, "__decorateClass$18"), AO, np;
let ae = (AO = (np = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.color = "", this.size = 24, this.path = O3, this.inline = !1, this.first = !1, this.last = !1, this.padded = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${Kf()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = wk(this.name) || O3, this.overlayPath = wk(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && S3[this.name] || void 0, this.nativeOverlayColor = this.overlayName && S3[this.overlayName] || void 0);
  }
  render() {
    var t;
    const e = this.kind ? LS(this.kind) : this.kind, i = (t = this.ext) != null && t.startsWith(".") ? this.ext.substring(1) : this.ext, s = {
      "wy-icon": !0,
      "wy-icon-current-color": !e && !this.color,
      ["wy-kind-" + e]: !!e,
      ["wy-ext-" + i]: !!i,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-padded": this.padded,
      "wy-icon-inline": this.inline,
      "wy-icon-stack-layer": this.layer,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, r = this.size !== 24, a = this.size / 16, o = r ? `width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));` : "", l = this.svg && C_(this.svg);
    return this.overlayPath ? [
      v`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      v`
          <wy-icon-stack style="${o}">
            <svg
              part=${Qe(s)}
              viewBox="0 0 24 24"
              width="${this.size}"
              height="${this.size}"
              style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
            >
              <defs>
                <mask id="${this.uniqueId}-mask">
                  <rect class="icon-mask-bg" />
                  <rect class="icon-mask" />
                </mask>
              </defs>
              ${l ? P3(l) : a3`
          <path d="${this.path}" style="fill: ${Ct(this.nativeIconColor)}" />
        `}
              <!--rect width="24" height="24" fill="transparent" /-->
            </svg>
            <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
              <path d="${this.overlayPath}" style="fill: ${Ct(this.nativeOverlayColor)}" />
              <!--rect width="24" height="24" fill="transparent" /-->
            </svg>
          </wy-icon-stack>
        `
    ] : v`
      <svg
        part=${Qe(s)}
        style="${o}"
        viewBox="0 0 24 24"
        width="${this.size}"
        height="${this.size}"
      >
        ${l ? P3(l) : a3`
          <path d="${this.path}" style="fill: ${Ct(this.nativeIconColor)}" />
        `}
        <!--rect width="24" height="24" fill="transparent" /-->
      </svg>
    `;
  }
}, h(np, "ea"), np), u(AO, "WyIcon"), AO);
ae.styles = [
  Ie,
  xP,
  At
];
Oe([
  $()
], ae.prototype, "name", 2);
Oe([
  $()
], ae.prototype, "overlayName", 2);
Oe([
  $()
], ae.prototype, "svg", 2);
Oe([
  $()
], ae.prototype, "color", 2);
Oe([
  $({ type: Number })
], ae.prototype, "size", 2);
Oe([
  $()
], ae.prototype, "kind", 2);
Oe([
  $()
], ae.prototype, "ext", 2);
Oe([
  $({ attribute: !1 })
], ae.prototype, "path", 2);
Oe([
  $({ attribute: !1 })
], ae.prototype, "overlayPath", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "inline", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "first", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "last", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "padded", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "layer", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "state", 2);
Oe([
  $({ type: Boolean })
], ae.prototype, "active", 2);
Oe([
  U()
], ae.prototype, "nativeIconColor", 2);
Oe([
  U()
], ae.prototype, "nativeOverlayColor", 2);
ae = Oe([
  H("wy-icon")
], ae);
var RO, sp;
let vk = (RO = (sp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    return v`<slot></slot>`;
  }
}, h(sp, "ia"), sp), u(RO, "WyIconStack"), RO);
vk.styles = [Ie, xP];
vk = Oe([
  H("wy-icon-stack")
], vk);
var EO, rp;
let bk = (EO = (rp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    return v`
      <div part="wy-icon-display-icon">
        <slot></slot>
      </div>
      <div part="wy-icon-display-text">
        <slot name="text"></slot>
      </div>
      <div part="wy-icon-display-meta">
        <slot name="meta"></slot>
      </div>
    `;
  }
}, h(rp, "sa"), rp), u(EO, "WyIconDisplay"), EO);
bk.styles = [Ie, xP];
bk = Oe([
  H("wy-icon-display")
], bk);
var eX = Object.defineProperty, iX = Object.getOwnPropertyDescriptor, Ni = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eX(t, e, s), s;
}, "__decorateClass$17"), zO, ap;
let rs = (zO = (ap = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = RR(this.name));
    const i = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === bP.Active
    };
    return v`
      ${this.src ? v`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${Qe(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : v`
            <div
              part=${Qe(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? v`<wy-icon part="wy-avatar-type" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : Q}
      ${this.presence && !this.isAgent ? v`<wy-presence .status=${this.presence} id=${this.id}></wy-presence>` : Q}
    `;
  }
}, h(ap, "ra"), ap), u(zO, "WyAvatar"), zO);
rs.styles = [Ie, OP, v_];
Ni([
  $({ type: Number })
], rs.prototype, "size", 2);
Ni([
  $()
], rs.prototype, "src", 2);
Ni([
  $()
], rs.prototype, "name", 2);
Ni([
  $()
], rs.prototype, "description", 2);
Ni([
  $({ type: Boolean, reflect: !0 })
], rs.prototype, "isAgent", 2);
Ni([
  $()
], rs.prototype, "presence", 2);
rs = Ni([
  H("wy-avatar")
], rs);
var _O, op;
let Xo = (_O = (op = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.size = 32, this.uniqueId = `wy-avatar-${Kf()}`;
  }
  render() {
    if (!this.user)
      return Q;
    const t = this.size / 16, e = (this.members || []).filter((r) => {
      var a;
      return r.id !== ((a = this.user) == null ? void 0 : a.id);
    }).slice(0, 2).reverse(), i = (e == null ? void 0 : e.shift()) || this.user, s = (e == null ? void 0 : e.shift()) || (i !== this.user ? this.user : void 0);
    return [
      v`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          .avatar-mask-bg {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          .avatar-mask {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      v`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect class="avatar-mask-bg" />
              <rect class="avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      v`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${s == null ? void 0 : s.avatar_url}
          .name=${s == null ? void 0 : s.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${i.avatar_url}
          .name=${i.name}
          .isAgent=${i.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, h(op, "na"), op), u(_O, "WyAvatarGroup"), _O);
Xo.styles = [
  Ie,
  OP,
  At
];
Ni([
  $({ type: Number })
], Xo.prototype, "size", 2);
Ni([
  $({
    type: Array,
    attribute: !1
  })
], Xo.prototype, "members", 2);
Ni([
  ve({ context: Z0, subscribe: !0 }),
  U()
], Xo.prototype, "user", 2);
Xo = Ni([
  H("wy-avatar-group")
], Xo);
var LO, lp;
let Bv = (LO = (lp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    return v`
      <slot></slot>
      ${this.description ? v`
        <div part="wy-avatar-description">${this.description}</div>
          ` : Q}
      `;
  }
}, h(lp, "aa"), lp), u(LO, "WyAvatarHeader"), LO);
Bv.styles = [Ie, OP];
Ni([
  $()
], Bv.prototype, "description", 2);
Bv = Ni([
  H("wy-avatar-header")
], Bv);
const nX = Mt`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress]:not([width]),[part~=wy-progress][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress]:not([height]),[part~=wy-progress][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-padded]{margin:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-progress][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-spinner]{align-self:center;justify-self:center;margin:auto}[part~=wy-spinner-padded]{margin:calc(1 * var(--wy-size, 1rem))}[part~=wy-spinner-overlay]{position:absolute;left:0;right:0;top:0;bottom:0;margin:auto}[part~=wy-spinner-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-spinner-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-spinner-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-spinner][part~=wy-spin]{animation:wy-rotate 1.4s linear infinite}[part~=wy-spinner-circle][part~=wy-spin]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}25%{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}50%{stroke:transparent}75%{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}}`, sX = Mt`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress]:not([width]),[part~=wy-progress][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress]:not([height]),[part~=wy-progress][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-padded]{margin:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-progress][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}`;
var rX = Object.defineProperty, aX = Object.getOwnPropertyDescriptor, pl = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? aX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && rX(t, e, s), s;
}, "__decorateClass$16"), IO, cp;
let as = (IO = (cp = class extends ft {
  constructor() {
    super(...arguments), this.shadowParts = new nt(this), this.size = 24, this.noSpin = !1, this.padded = !1, this.overlay = !1, this.progress = NaN, this.reveal = !1;
  }
  render() {
    const t = this.noSpin && this.progress && 100 - this.progress || void 0;
    if (t !== void 0) {
      const e = Math.PI * 20, i = {
        "wy-progress": !0,
        "wy-primary": !0,
        "wy-progress-padded": this.padded,
        "wy-progress-reveal": this.reveal
      };
      return v`<svg
        part="${Qe(i)}"
        viewBox="0 0 24 24"
        width=${this.size}
        height=${this.size}
        transform="rotate(-90)"
      >
        <circle
          part="wy-progress-circle wy-progress-remaining"
          cx="12"
          cy="12"
          r=${10}
          stroke-linecap="butt"
          stroke-width="2"
          fill="none"
          stroke="#eee"
        ></circle>
        <circle
          part="wy-progress-circle wy-progress-done"
          cx="12"
          cy="12"
          r=${10}
          stroke-dasharray=${e}
          stroke-dashoffset=${e * t / 100}
          stroke-linecap="butt"
          stroke-width="2"
          fill="none"
          stroke="currentColor"
          path-length="200"
        ></circle>
      </svg>`;
    } else {
      const e = {
        "wy-spinner": !0,
        "wy-spin": !this.noSpin,
        "wy-spinner-overlay": this.overlay,
        "wy-spinner-padded": this.padded,
        "wy-spinner-reveal": this.reveal
      }, i = {
        "wy-spinner-circle": !0,
        "wy-spin": !this.noSpin
      };
      return v`<svg
        part="${Qe(e)}"
        width=${this.size}
        height=${this.size}
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle
          part="${Qe(i)}"
          fill="none"
          cx="12"
          cy="12"
          r="11"
          stroke-linecap="butt"
          stroke-width="2"
        />
      </svg>`;
    }
  }
}, h(cp, "oa"), cp), u(IO, "WySpinner"), IO);
as.styles = [
  Ie,
  nX,
  sX,
  At
];
pl([
  $({ type: Number })
], as.prototype, "size", 2);
pl([
  $({ type: Boolean })
], as.prototype, "noSpin", 2);
pl([
  $({ type: Boolean })
], as.prototype, "padded", 2);
pl([
  $({ type: Boolean })
], as.prototype, "overlay", 2);
pl([
  $({ type: Number })
], as.prototype, "progress", 2);
pl([
  $({ type: Boolean })
], as.prototype, "reveal", 2);
as = pl([
  H("wy-spinner")
], as);
var oX = Object.defineProperty, lX = Object.getOwnPropertyDescriptor, kP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? lX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && oX(t, e, s), s;
}, "__decorateClass$15"), ZO, hp;
let ny = (ZO = (hp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    var t, e, i, s;
    return v`
      <div class="wy-empty">
        ${this.weavy && !this.noNetwork && ((t = this.weavy) == null ? void 0 : t.network.state) === "unreachable" ? v`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${C("The server is offline, try again in a few minutes...")}</span>
                <wy-spinner slot="meta" ?hidden=${!((e = this.weavy) != null && e.network.isPending)}></wy-spinner>
              </wy-icon-display>
            ` : !this.noNetwork && ((i = this.weavy) == null ? void 0 : i.network.state) === "offline" ? v`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${C("You are currently offline.")}</span>
                <wy-spinner slot="meta" ?hidden=${!((s = this.weavy) != null && s.network.isPending)}></wy-spinner>
              </wy-icon-display>
            ` : v`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${C("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this.weavy) == null || t.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this.weavy) == null || t.removeNetworkListener(this.handleUpdate);
  }
}, h(hp, "ca"), hp), u(ZO, "WyEmpty"), ZO);
ny.styles = [
  yt,
  At
];
kP([
  ve({ context: _e, subscribe: !0 }),
  U()
], ny.prototype, "weavy", 2);
kP([
  $({ type: Boolean })
], ny.prototype, "noNetwork", 2);
ny = kP([
  H("wy-empty"),
  Ot()
], ny);
const C3 = /* @__PURE__ */ u((n, t, e) => {
  const i = /* @__PURE__ */ new Map();
  for (let s = t; s <= e; s++) i.set(n[s], s);
  return i;
}, "u"), Mi = fa(class extends ul {
  constructor(n) {
    if (super(n), n.type !== Py.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let i;
    e === void 0 ? e = t : t !== void 0 && (i = t);
    const s = [], r = [];
    let a = 0;
    for (const o of n) s[a] = i ? i(o, a) : a, r[a] = e(o, a), a++;
    return { values: r, keys: s };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, i]) {
    const s = QU(n), { values: r, keys: a } = this.dt(t, e, i);
    if (!Array.isArray(s)) return this.ut = a, r;
    const o = this.ut ?? (this.ut = []), l = [];
    let c, d, p = 0, f = s.length - 1, m = 0, w = r.length - 1;
    for (; p <= f && m <= w; ) if (s[p] === null) p++;
    else if (s[f] === null) f--;
    else if (o[p] === a[m]) l[m] = La(s[p], r[m]), p++, m++;
    else if (o[f] === a[w]) l[w] = La(s[f], r[w]), f--, w--;
    else if (o[p] === a[w]) l[w] = La(s[p], r[w]), rm(n, l[w + 1], s[p]), p++, w--;
    else if (o[f] === a[m]) l[m] = La(s[f], r[m]), rm(n, s[p], s[f]), f--, m++;
    else if (c === void 0 && (c = C3(a, m, w), d = C3(o, p, f)), c.has(o[p])) if (c.has(o[f])) {
      const b = d.get(a[m]), x = b !== void 0 ? s[b] : null;
      if (x === null) {
        const O = rm(n, s[p]);
        La(O, r[m]), l[m] = O;
      } else l[m] = La(x, r[m]), rm(n, s[p], x), s[b] = null;
      m++;
    } else SO(s[f]), f--;
    else SO(s[p]), p++;
    for (; m <= w; ) {
      const b = rm(n, l[w + 1]);
      La(b, r[m]), l[m++] = b;
    }
    for (; p <= f; ) {
      const b = s[p++];
      b !== null && SO(b);
    }
    return this.ut = a, Fz(n, l), Pn;
  }
}), _1 = fa(class extends ul {
  constructor() {
    super(...arguments), this.key = Q;
  }
  render(n, t) {
    return this.key = n, t;
  }
  update(n, [t, e]) {
    return t !== this.key && (Fz(n), this.key = t), e;
  }
});
function Vs(n) {
  n.stopPropagation();
}
h(Vs, "Cs");
u(Vs, "inputConsume");
function T_(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.value = "", n.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
h(T_, "$b");
u(T_, "inputClearOnEscape");
function Ew(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.blur(), n.target.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
}
h(Ew, "Gl");
u(Ew, "inputBlurOnEscape");
function A_(n) {
  n.key === "Enter" && n.target.blur();
}
h(A_, "Cb");
u(A_, "inputBlurOnEnter");
function R_(n) {
  n.target.value ? T_(n) : Ew(n);
}
h(R_, "kb");
u(R_, "inputClearAndBlurOnEscape");
function SP(n) {
  n.key === "Enter" && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
h(SP, "bf");
u(SP, "clickOnEnter");
function E_(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation());
}
h(E_, "_b");
u(E_, "consumeOnSpace");
function je(n) {
  SP(n), E_(n);
}
h(je, "ye");
u(je, "clickOnEnterAndConsumeOnSpace");
function gi(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
h(gi, "Fe");
u(gi, "clickOnSpace");
function B0(n) {
  SP(n), gi(n);
}
h(B0, "ap");
u(B0, "clickOnEnterAndSpace");
const Xt = fa(class extends ul {
  constructor(n) {
    var t;
    if (super(n), n.type !== Py.ATTRIBUTE || n.name !== "class" || ((t = n.strings) == null ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return " " + Object.keys(n).filter((t) => n[t]).join(" ") + " ";
  }
  update(n, [t]) {
    var e, i;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), n.strings !== void 0 && (this.nt = new Set(n.strings.join(" ").split(/\s/).filter((r) => r !== "")));
      for (const r in t) t[r] && !((e = this.nt) != null && e.has(r)) && this.st.add(r);
      return this.render(t);
    }
    const s = n.element.classList;
    for (const r of this.st) r in t || (s.remove(r), this.st.delete(r));
    for (const r in t) {
      const a = !!t[r];
      a === this.st.has(r) || (i = this.nt) != null && i.has(r) || (a ? (s.add(r), this.st.add(r)) : (s.remove(r), this.st.delete(r)));
    }
    return Pn;
  }
});
function PP(n) {
  const t = [n];
  for (; n && n.parent; )
    n = n.parent, t.push(n);
  return t;
}
h(PP, "xf");
u(PP, "getEntityChain");
function CP(n, t, e) {
  return n.type === t && (!e || n.id === e.id);
}
h(CP, "$f");
u(CP, "isEntityMatch");
function cg(n, t, e) {
  return PP(n).some((i) => i && CP(i, t, e));
}
h(cg, "$d");
u(cg, "isEntityChainMatch");
function QP(n, t, e) {
  return PP(n).find((i) => i && CP(i, t, e));
}
h(QP, "Cf");
u(QP, "getEntityChainMatch");
function MP(n, t, e, i) {
  const s = QP(n, i);
  return s && s.parent ? cg(s.parent, t, e) : !1;
}
h(MP, "kf");
u(MP, "hasEntityChildType");
async function TP(n, t, e) {
  var i, s, r;
  let a;
  if (t && (i = e.link.app) != null && i.id) {
    const l = await t.fetch(`/api/apps/${e.link.app.id}`);
    l.ok && (a = (await l.json()).metadata);
  }
  const o = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: {
        ...e.link,
        agent: AP(e)
      },
      app_type: ((s = e.link.app) == null ? void 0 : s.type) && Cz.get((r = e.link.app) == null ? void 0 : r.type) || nn.Unknown,
      source_name: a == null ? void 0 : a.source_name,
      source_url: a == null ? void 0 : a.source_url,
      source_data: a == null ? void 0 : a.source_data
    }
  });
  return n.dispatchEvent(o);
}
h(TP, "_f");
u(TP, "dispatchLinkEvent");
function AP(n) {
  var t, e;
  return (t = n.link.app) != null && t.type && qv.has((e = n.link.app) == null ? void 0 : e.type) && n.actor.is_agent ? n.actor.uid : void 0;
}
h(AP, "zf");
u(AP, "getAgentName");
function RP(n) {
  const t = n.args;
  switch (n.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, i, s] = t;
      return {
        title: C(at`${e} added ${i} to ${s}`),
        titleHtml: C(v`<strong>${e}</strong> added <em>${i}</em> to <strong>${s}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, i] = t;
      return {
        title: C(at`${e} edited ${i}`),
        titleHtml: C(v`<strong>${e}</strong> edited <em>${i}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} commented on ${i}`),
        titleHtml: C(v`<strong>${e}</strong> commented on <em>${i}</em>`),
        detail: s
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} commented on ${i}`),
        titleHtml: C(v`<strong>${e}</strong> commented on <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} replied to your post`),
        titleHtml: C(v`<strong>${e}</strong> replied to your post`),
        detail: i
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} replied to a post`),
        titleHtml: C(v`<strong>${e}</strong> replied to a post`),
        detail: i
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} mentioned you in a comment`),
        titleHtml: C(v`<strong>${e}</strong> mentioned you in a comment`),
        detail: i
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} posted in ${i}`),
        titleHtml: C(v`<strong>${e}</strong> posted in <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} mentioned you in a post`),
        titleHtml: C(v`<strong>${e}</strong> mentioned you in a post`),
        detail: i
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`New message from ${e}`),
        titleHtml: C(v`New message from <strong>${e}</strong>`),
        detail: i
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} sent a message in ${i}`),
        titleHtml: C(v`<strong>${e}</strong> sent a message in <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} mentioned you in a message`),
        titleHtml: C(v`<strong>${e}</strong> mentioned you in a message`),
        detail: i
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} edited a post`),
        titleHtml: C(v`<strong>${e}</strong> edited a post`),
        detail: i
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, i] = t;
      return {
        title: C(at`${e} liked ${i}`),
        titleHtml: C(v`<strong>${e}</strong> liked <em>${i}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, i, s] = t;
      return {
        title: C(at`${e} reacted ${i} to ${s}`),
        titleHtml: C(v`<strong>${e}</strong> reacted ${i} to <em>${s}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} liked your comment`),
        titleHtml: C(v`<strong>${e}</strong> liked your comment`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} reacted ${i} to your comment`),
        titleHtml: C(v`<strong>${e}</strong> reacted ${i} to your comment`),
        detail: s
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} liked your message`),
        titleHtml: C(v`<strong>${e}</strong> liked your message`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} reacted ${i} to your message`),
        titleHtml: C(v`<strong>${e}</strong> reacted ${i} to your message`),
        detail: s
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, i] = t;
      return {
        title: C(at`${e} liked your post`),
        titleHtml: C(v`<strong>${e}</strong> liked your post`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, i, s] = t;
      return {
        title: C(at`${e} reacted ${i} to your post`),
        titleHtml: C(v`<strong>${e}</strong> reacted ${i} to your post`),
        detail: s
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: C(at`${e} voted on your poll`),
        titleHtml: C(v`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, i] = t;
      return {
        title: C(at`${e} and ${i} voted on your poll`),
        titleHtml: C(v`<strong>${e}</strong> and <strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, i, s] = t;
      return {
        title: C(at`${e}, ${i} and ${s} voted on your poll`),
        titleHtml: C(
          v`<strong>${e}</strong>, <strong>${i}</strong> and <strong>${s}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, i] = t;
      return {
        title: C(at`${e} and ${i} others voted on your poll`),
        titleHtml: C(v`<strong>${e}</strong> and ${i} others voted on your poll`)
      };
    }
    default:
      return console.error(`Notification template not found! '${n.template}'`), { title: "", titleHtml: Q };
  }
}
h(RP, "Mf");
u(RP, "getNotificationText");
const z_ = Mt`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-neutral-variant-50, #72777e));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5)}[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:calc(.5 * var(--wy-size, 1rem)) calc(.75 * var(--wy-size, 1rem));margin-inline:calc(-.25 * var(--wy-size, 1rem))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-color: var(--wy-on-primary, var(--wy-white, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-color: unset}[part=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-40, #006399)));text-decoration:var(--wy-link-decoration, none)}[part=wy-button-link]:hover,[part=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, unset)}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5 * var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));top:0;z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}`, __ = Mt`.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) transparent}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:transparent;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:transparent}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:75%;border:0 solid transparent;border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * 0)}`;
var cX = Object.defineProperty, hX = Object.getOwnPropertyDescriptor, Rn = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? hX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && cX(t, e, s), s;
}, "__decorateClass$14"), WO, dp;
let os = (WO = (dp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return v`
      <button part=${Qe(t)} type=${Ct(this.type)} ?disabled=${this.disabled}>
        <slot></slot>
      </button>
    `;
  }
}, h(dp, "la"), dp), u(WO, "WyButton"), WO);
os.styles = [
  Ie,
  z_,
  __,
  At,
  Mt`
      :host {
        position: relative;
      }
    `
];
Rn([
  $()
], os.prototype, "type", 2);
Rn([
  $()
], os.prototype, "kind", 2);
Rn([
  $({ type: Boolean })
], os.prototype, "active", 2);
Rn([
  $()
], os.prototype, "color", 2);
Rn([
  $({ type: Boolean })
], os.prototype, "small", 2);
Rn([
  $({ type: Boolean, reflect: !0 })
], os.prototype, "disabled", 2);
os = Rn([
  H("wy-button")
], os);
var DO, up;
let No = (DO = (up = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return v`<div part=${Qe(t)}><slot></slot></div>`;
  }
}, h(up, "da"), up), u(DO, "WyButtons"), DO);
No.styles = [
  Ie,
  z_,
  __,
  At
];
Rn([
  $({ type: Boolean })
], No.prototype, "tabs", 2);
Rn([
  $({ type: String })
], No.prototype, "position", 2);
Rn([
  $({ type: Boolean })
], No.prototype, "reverse", 2);
No = Rn([
  H("wy-buttons")
], No);
var dX = Object.defineProperty, uX = Object.getOwnPropertyDescriptor, EP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? uX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && dX(t, e, s), s;
}, "__decorateClass$13"), qO, pp;
let sy = (qO = (pp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.enableSwap = !1;
  }
  createRenderRoot() {
    return this;
  }
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", { detail: { id: t } });
    return this.dispatchEvent(e);
  }
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", { detail: {} });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.embed.type === "photo" && this.embed.provider_name.toLocaleLowerCase() === "giphy", e = !this.embed.html && !t;
    return v`
      <div class="wy-embed-actions">
        ${this.enableSwap ? v`<wy-button kind="icon" @click=${() => this.dispatchSwap()}
              ><wy-icon name="swap-horizontal"></wy-icon
            ></wy-button>` : v`<wy-button class="wy-embed-cycle"></wy-button>`}

        <wy-button kind="icon" @click=${() => this.dispatchRemove(this.embed.id)}
          ><wy-icon name="close-circle"></wy-icon
        ></wy-button>
      </div>

      ${this.embed.type === "audio" ? v`<div class="wy-embed-audio"></div>` : Q}
      ${this.embed.type === "video" && this.embed.html ? v`<div class="wy-embed-video"><div>${Bo(this.embed.html)}</div></div>` : Q}
      ${this.embed.type === "rich" ? v`<div class="wy-embed-rich"></div>` : Q}
      ${this.embed.type === "photo" && this.embed.thumbnail_url ? v`
            <div
              class=${Xt({
      "wy-embed-photo": !0,
      "wy-embed-photo-sm": (this.embed.thumbnail_width || 0) < 250
    })}>
              <a href=${this.embed.original_url} target="_blank">
                <img
                  src=${this.embed.thumbnail_url}
                  width=${Ct(this.embed.thumbnail_width)}
                  height=${Ct(this.embed.thumbnail_height)}
                  alt="" />
              </a>
            </div>
          ` : Q}
      ${this.embed.type !== "audio" && this.embed.type !== "video" && this.embed.type !== "rich" && this.embed.type !== "photo" && this.embed.thumbnail_url ? v`
            <div
              class=${Xt({
      "wy-embed-photo": !0,
      "wy-embed-photo-sm": (this.embed.thumbnail_width || 0) < 250
    })}>
              <a href=${this.embed.original_url} target="_blank">
                <img
                  src=${this.embed.thumbnail_url}
                  width=${Ct(this.embed.thumbnail_width)}
                  height=${Ct(this.embed.thumbnail_height)}
                  alt="" />
              </a>
            </div>
          ` : Q}
      ${e ? v` <div class="wy-embed-caption">
            <a class="wy-embed-link" href=${this.embed.original_url} target="_blank">${this.embed.host}</a>
            ${this.embed.title ? v`<div class="wy-embed-title">${this.embed.title}</div>` : Q}
            ${this.embed.description ? v`<div class="wy-embed-description">${this.embed.description}</div>` : Q}
          </div>` : Q}
    `;
  }
}, h(pp, "ha"), pp), u(qO, "WyEmbed"), qO);
sy.styles = yt;
EP([
  $({ attribute: !1 })
], sy.prototype, "embed", 2);
EP([
  $({ type: Boolean, attribute: !1 })
], sy.prototype, "enableSwap", 2);
sy = EP([
  H("wy-embed")
], sy);
var pX = Object.defineProperty, fX = Object.getOwnPropertyDescriptor, Cy = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? fX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && pX(t, e, s), s;
}, "__decorateClass$12"), VO, fp;
let js = (VO = (fp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.name = "", this.previewUrl = "", this.url = "", this.size = 0;
  }
  render() {
    const t = this.size && this.size > 0 ? ky(this.size) : null, e = Ei(this.name), { icon: i } = An(this.name), s = Sy(this.name), r = Ks(this.provider);
    return v`
      <a href=${this.previewUrl || this.url} class="wy-item wy-list-item-lg" target="_blank" title=${this.name}>
        <wy-icon name=${i} .overlayName=${r} size="48" kind=${s} ext=${e}></wy-icon>
        <div class="wy-item-body ">
          <div class="wy-item-title">${this.name}</div>
          ${t ? v`<div class="wy-item-text" title="${t}">${t}</div>` : ""}
        </div>
      </a>
    `;
  }
}, h(fp, "ua"), fp), u(VO, "WyAttachment"), VO);
js.styles = yt;
Cy([
  $()
], js.prototype, "name", 2);
Cy([
  $()
], js.prototype, "previewUrl", 2);
Cy([
  $()
], js.prototype, "url", 2);
Cy([
  $()
], js.prototype, "provider", 2);
Cy([
  $({ type: Number })
], js.prototype, "size", 2);
js = Cy([
  H("wy-attachment")
], js);
const L_ = "important", yX = " !" + L_, zw = fa(class extends ul {
  constructor(n) {
    var t;
    if (super(n), n.type !== Py.ATTRIBUTE || n.name !== "style" || ((t = n.strings) == null ? void 0 : t.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return Object.keys(n).reduce((t, e) => {
      const i = n[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }, "");
  }
  update(n, [t]) {
    const { style: e } = n.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft) t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const s = t[i];
      if (s != null) {
        this.ft.add(i);
        const r = typeof s == "string" && s.endsWith(yX);
        i.includes("-") || r ? e.setProperty(i, r ? s.slice(0, -11) : s, r ? L_ : "") : e[i] = s;
      }
    }
    return Pn;
  }
});
function _w(n) {
  const t = n;
  t && (t.complete && t.naturalHeight !== 0 ? t.classList.contains("wy-loading") ? t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
h(_w, "Zl");
u(_w, "checkImageLoad");
function Lw(n) {
  const t = n.target;
  t.tagName === "IMG" && t.classList.contains("wy-loading") && !t.classList.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
h(Lw, "Yl");
u(Lw, "imageLoaded");
const mX = Mt`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;overflow:hidden;column-gap:1px;row-gap:1px}[part~=wy-image-area]{display:block;height:100%;cursor:pointer}[part~=wy-image-content]{position:absolute;height:100%;width:100%;object-fit:contain}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-grid-more]{position:absolute;line-height:100%;color:var(--wy-white, #ffffff);top:0;left:0;bottom:0;right:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5 * var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var wX = Object.defineProperty, gX = Object.getOwnPropertyDescriptor, zP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? gX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && wX(t, e, s), s;
}, "__decorateClass$11"), jO, yp;
let ry = (jO = (yp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.images = [], this.limit = 3;
  }
  dispatchFileOpen(t, e) {
    if (t.preventDefault(), !e.is_trashed) {
      const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(i);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return v`
      <div part="wy-image-grid">
        ${e.map((i, s) => {
      const r = i.width && i.height ? i.width / i.height : 1, a = 64, o = 2, l = r.toPrecision(5), c = (r * a).toPrecision(5) + "px", d = (100 / r).toPrecision(5) + "%", p = i.width + "px", f = i.width && i.width > 0 ? o * i.width + "px" : "none", m = this.images.length !== 2 && s === 0;
      return i.preview_url ? v`
            <a
              href="#"
              @click=${(w) => {
        !w.defaultPrevented && this.dispatchFileOpen(w, i);
      }}
              part=${Qe({
        "wy-image": !0,
        "wy-image-full-width": m
      })}
              style=${zw({
        flexBasis: c,
        flexGrow: l,
        flexShrink: l,
        width: p,
        maxWidth: f
      })}>
              <div part="wy-image-area" style=${zw({ paddingBottom: d })}>
                <img
                  part="wy-image-content"
                  src=${i.preview_url}
                  ${lt(_w)}
                  @load=${Lw}
                  alt=""
                  loading="lazy"
                  decoding="async" />
                ${s === e.length - 1 && t ? v`<span part="wy-image-grid-more">+${t}</span>` : ""}
              </div>
            </a>
          ` : Q;
    })}
      </div>
    `;
  }
}, h(yp, "pa"), yp), u(jO, "WyImageGrid"), jO);
ry.styles = [mX, At];
zP([
  $({ attribute: !1 })
], ry.prototype, "images", 2);
zP([
  $({ type: Number })
], ry.prototype, "limit", 2);
ry = zP([
  H("wy-image-grid")
], ry);
var vX = Object.defineProperty, bX = Object.getOwnPropertyDescriptor, I_ = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? bX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vX(t, e, s), s;
}, "__decorateClass$10"), FO, mp;
let Xv = (FO = (mp = class extends ft {
  constructor() {
    super(...arguments), this.files = [];
  }
  //protected exportParts = new ShadowPartsController(this);
  createRenderRoot() {
    return this;
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    return v`
      <div>
        ${this.files.map((t) => {
      const e = t.size && t.size > 0 ? ky(t.size) : null, i = Ei(t.name), { icon: s } = An(t.name), r = Sy(t.name), a = Ks(t.provider), o = `${t.name}${e ? ` • ${e}` : ""}`;
      return v`
            <wy-button
              @click=${(l) => {
        !l.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(l, t);
      }}
              kind="filled"
              small
              title=${o}
            >
              <wy-icon name=${s} .overlayName=${a} size="24" kind=${r} ext=${i}></wy-icon>
              <span>${t.name}</span>
            </wy-button>
          `;
    })}
      </div>
    `;
  }
}, h(mp, "ya"), mp), u(FO, "WyAttachmentsList"), FO);
Xv.styles = yt;
I_([
  $({ attribute: !1 })
], Xv.prototype, "files", 2);
Xv = I_([
  H("wy-annotations-list")
], Xv);
var OX = Object.defineProperty, $X = Object.getOwnPropertyDescriptor, Z_ = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? $X(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && OX(t, e, s), s;
}, "__decorateClass$$"), UO, wp;
let Iw = (UO = (wp = class extends ft {
  constructor() {
    super(...arguments), this.files = [];
  }
  //protected exportParts = new ShadowPartsController(this);
  createRenderRoot() {
    return this;
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    return v`
      <div class="wy-list wy-list-bordered">
        ${this.files.map((t) => {
      const e = t.size && t.size > 0 ? ky(t.size) : null, i = Ei(t.name), { icon: s } = An(t.name), r = Sy(t.name), a = Ks(t.provider);
      return v`
            <a
              @click=${(o) => {
        !o.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(o, t);
      }}
              class="wy-item wy-list-item"
              href="${Ct(t.download_url)}"
              title=${t.name}
            >
              <wy-icon name=${s} .overlayName=${a} size="48" kind=${r} ext=${i}></wy-icon>
              <div class="wy-item-body ">
                <div class="wy-item-title">${t.name}</div>
                ${e ? v`<div class="wy-item-text" title="${e}">${e}</div>` : ""}
              </div>
            </a>
          `;
    })}
      </div>
    `;
  }
}, h(wp, "wa"), wp), u(UO, "WyAttachmentsList"), UO);
Iw.styles = yt;
Z_([
  $({ attribute: !1 })
], Iw.prototype, "files", 2);
Iw = Z_([
  H("wy-attachments-list")
], Iw);
const Nv = Math.min, Na = Math.max, Hv = Math.round, Xg = Math.floor, ss = /* @__PURE__ */ u((n) => ({
  x: n,
  y: n
}), "createCoords"), xX = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, kX = {
  start: "end",
  end: "start"
};
function Ok(n, t, e) {
  return Na(n, Nv(t, e));
}
h(Ok, "Ey");
u(Ok, "clamp");
function hg(n, t) {
  return typeof n == "function" ? n(t) : n;
}
h(hg, "Cd");
u(hg, "evaluate");
function ia(n) {
  return n.split("-")[0];
}
h(ia, "pr");
u(ia, "getSide");
function dg(n) {
  return n.split("-")[1];
}
h(dg, "kd");
u(dg, "getAlignment");
function _P(n) {
  return n === "x" ? "y" : "x";
}
h(_P, "Of");
u(_P, "getOppositeAxis");
function LP(n) {
  return n === "y" ? "height" : "width";
}
h(LP, "Lf");
u(LP, "getAxisLength");
function As(n) {
  return ["top", "bottom"].includes(ia(n)) ? "y" : "x";
}
h(As, "bs");
u(As, "getSideAxis");
function IP(n) {
  return _P(As(n));
}
h(IP, "If");
u(IP, "getAlignmentAxis");
function W_(n, t, e) {
  e === void 0 && (e = !1);
  const i = dg(n), s = IP(n), r = LP(s);
  let a = s === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (a = Zw(a)), [a, Zw(a)];
}
h(W_, "Ub");
u(W_, "getAlignmentSides");
function D_(n) {
  const t = Zw(n);
  return [Yv(n), t, Yv(t)];
}
h(D_, "qb");
u(D_, "getExpandedPlacements");
function Yv(n) {
  return n.replace(/start|end/g, (t) => kX[t]);
}
h(Yv, "$u");
u(Yv, "getOppositeAlignmentPlacement");
function q_(n, t, e) {
  const i = ["left", "right"], s = ["right", "left"], r = ["top", "bottom"], a = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? s : i : t ? i : s;
    case "left":
    case "right":
      return t ? r : a;
    default:
      return [];
  }
}
h(q_, "Nb");
u(q_, "getSideList");
function V_(n, t, e, i) {
  const s = dg(n);
  let r = q_(ia(n), e === "start", i);
  return s && (r = r.map((a) => a + "-" + s), t && (r = r.concat(r.map(Yv)))), r;
}
h(V_, "jb");
u(V_, "getOppositeAxisPlacements");
function Zw(n) {
  return n.replace(/left|right|bottom|top/g, (t) => xX[t]);
}
h(Zw, "ed");
u(Zw, "getOppositePlacement");
function j_(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
h(j_, "Wb");
u(j_, "expandPaddingObject");
function F_(n) {
  return typeof n != "number" ? j_(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
h(F_, "Qb");
u(F_, "getPaddingObject");
function Ww(n) {
  const {
    x: t,
    y: e,
    width: i,
    height: s
  } = n;
  return {
    width: i,
    height: s,
    top: e,
    left: t,
    right: t + i,
    bottom: e + s,
    x: t,
    y: e
  };
}
h(Ww, "id");
u(Ww, "rectToClientRect");
function $k(n, t, e) {
  let {
    reference: i,
    floating: s
  } = n;
  const r = As(t), a = IP(t), o = LP(a), l = ia(t), c = r === "y", d = i.x + i.width / 2 - s.width / 2, p = i.y + i.height / 2 - s.height / 2, f = i[o] / 2 - s[o] / 2;
  let m;
  switch (l) {
    case "top":
      m = {
        x: d,
        y: i.y - s.height
      };
      break;
    case "bottom":
      m = {
        x: d,
        y: i.y + i.height
      };
      break;
    case "right":
      m = {
        x: i.x + i.width,
        y: p
      };
      break;
    case "left":
      m = {
        x: i.x - s.width,
        y: p
      };
      break;
    default:
      m = {
        x: i.x,
        y: i.y
      };
  }
  switch (dg(t)) {
    case "start":
      m[a] -= f * (e && c ? -1 : 1);
      break;
    case "end":
      m[a] += f * (e && c ? -1 : 1);
      break;
  }
  return m;
}
h($k, "Ry");
u($k, "computeCoordsFromPlacement");
const SX = /* @__PURE__ */ u(async (n, t, e) => {
  const {
    placement: i = "bottom",
    strategy: s = "absolute",
    middleware: r = [],
    platform: a
  } = e, o = r.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let c = await a.getElementRects({
    reference: n,
    floating: t,
    strategy: s
  }), {
    x: d,
    y: p
  } = $k(c, i, l), f = i, m = {}, w = 0;
  for (let b = 0; b < o.length; b++) {
    const {
      name: x,
      fn: O
    } = o[b], {
      x: P,
      y: A,
      data: R,
      reset: T
    } = await O({
      x: d,
      y: p,
      initialPlacement: i,
      placement: f,
      strategy: s,
      middlewareData: m,
      rects: c,
      platform: a,
      elements: {
        reference: n,
        floating: t
      }
    });
    d = P ?? d, p = A ?? p, m = {
      ...m,
      [x]: {
        ...m[x],
        ...R
      }
    }, T && w <= 50 && (w++, typeof T == "object" && (T.placement && (f = T.placement), T.rects && (c = T.rects === !0 ? await a.getElementRects({
      reference: n,
      floating: t,
      strategy: s
    }) : T.rects), {
      x: d,
      y: p
    } = $k(c, f, l)), b = -1);
  }
  return {
    x: d,
    y: p,
    placement: f,
    strategy: s,
    middlewareData: m
  };
}, "computePosition$1");
async function ZP(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: s,
    platform: r,
    rects: a,
    elements: o,
    strategy: l
  } = n, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: p = "floating",
    altBoundary: f = !1,
    padding: m = 0
  } = hg(t, n), w = F_(m), b = o[f ? p === "floating" ? "reference" : "floating" : p], x = Ww(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(b))) == null || e ? b : b.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(o.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: l
  })), O = p === "floating" ? {
    x: i,
    y: s,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, P = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(o.floating)), A = await (r.isElement == null ? void 0 : r.isElement(P)) ? await (r.getScale == null ? void 0 : r.getScale(P)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, R = Ww(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: O,
    offsetParent: P,
    strategy: l
  }) : O);
  return {
    top: (x.top - R.top + w.top) / A.y,
    bottom: (R.bottom - x.bottom + w.bottom) / A.y,
    left: (x.left - R.left + w.left) / A.x,
    right: (R.right - x.right + w.right) / A.x
  };
}
h(ZP, "Tf");
u(ZP, "detectOverflow");
const PX = /* @__PURE__ */ u(function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e, i;
      const {
        placement: s,
        middlewareData: r,
        rects: a,
        initialPlacement: o,
        platform: l,
        elements: c
      } = t, {
        mainAxis: d = !0,
        crossAxis: p = !0,
        fallbackPlacements: f,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: b = !0,
        ...x
      } = hg(n, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const O = ia(s), P = As(o), A = ia(o) === o, R = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), T = f || (A || !b ? [Zw(o)] : D_(o)), I = w !== "none";
      !f && I && T.push(...V_(o, b, w, R));
      const Z = [o, ...T], W = await ZP(t, x), V = [];
      let Y = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (d && V.push(W[O]), p) {
        const tt = W_(s, a, R);
        V.push(W[tt[0]], W[tt[1]]);
      }
      if (Y = [...Y, {
        placement: s,
        overflows: V
      }], !V.every((tt) => tt <= 0)) {
        var G, X;
        const tt = (((G = r.flip) == null ? void 0 : G.index) || 0) + 1, Qt = Z[tt];
        if (Qt && (!(p === "alignment" && P !== As(Qt)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        Y.every((It) => It.overflows[0] > 0 && As(It.placement) === P)))
          return {
            data: {
              index: tt,
              overflows: Y
            },
            reset: {
              placement: Qt
            }
          };
        let vt = (X = Y.filter((It) => It.overflows[0] <= 0).sort((It, Wt) => It.overflows[1] - Wt.overflows[1])[0]) == null ? void 0 : X.placement;
        if (!vt)
          switch (m) {
            case "bestFit": {
              var st;
              const It = (st = Y.filter((Wt) => {
                if (I) {
                  const Dt = As(Wt.placement);
                  return Dt === P || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Dt === "y";
                }
                return !0;
              }).map((Wt) => [Wt.placement, Wt.overflows.filter((Dt) => Dt > 0).reduce((Dt, bi) => Dt + bi, 0)]).sort((Wt, Dt) => Wt[1] - Dt[1])[0]) == null ? void 0 : st[0];
              It && (vt = It);
              break;
            }
            case "initialPlacement":
              vt = o;
              break;
          }
        if (s !== vt)
          return {
            reset: {
              placement: vt
            }
          };
      }
      return {};
    }
  };
}, "flip$1");
async function U_(n, t) {
  const {
    placement: e,
    platform: i,
    elements: s
  } = n, r = await (i.isRTL == null ? void 0 : i.isRTL(s.floating)), a = ia(e), o = dg(e), l = As(e) === "y", c = ["left", "top"].includes(a) ? -1 : 1, d = r && l ? -1 : 1, p = hg(t, n);
  let {
    mainAxis: f,
    crossAxis: m,
    alignmentAxis: w
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return o && typeof w == "number" && (m = o === "end" ? w * -1 : w), l ? {
    x: m * d,
    y: f * c
  } : {
    x: f * c,
    y: m * d
  };
}
h(U_, "Zb");
u(U_, "convertValueToCoords");
const CX = /* @__PURE__ */ u(function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      var e, i;
      const {
        x: s,
        y: r,
        placement: a,
        middlewareData: o
      } = t, l = await U_(t, n);
      return a === ((e = o.offset) == null ? void 0 : e.placement) && (i = o.arrow) != null && i.alignmentOffset ? {} : {
        x: s + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, "offset$1"), QX = /* @__PURE__ */ u(function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: s
      } = t, {
        mainAxis: r = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: /* @__PURE__ */ u((x) => {
            let {
              x: O,
              y: P
            } = x;
            return {
              x: O,
              y: P
            };
          }, "fn")
        },
        ...l
      } = hg(n, t), c = {
        x: e,
        y: i
      }, d = await ZP(t, l), p = As(ia(s)), f = _P(p);
      let m = c[f], w = c[p];
      if (r) {
        const x = f === "y" ? "top" : "left", O = f === "y" ? "bottom" : "right", P = m + d[x], A = m - d[O];
        m = Ok(P, m, A);
      }
      if (a) {
        const x = p === "y" ? "top" : "left", O = p === "y" ? "bottom" : "right", P = w + d[x], A = w - d[O];
        w = Ok(P, w, A);
      }
      const b = o.fn({
        ...t,
        [f]: m,
        [p]: w
      });
      return {
        ...b,
        data: {
          x: b.x - e,
          y: b.y - i,
          enabled: {
            [f]: r,
            [p]: a
          }
        }
      };
    }
  };
}, "shift$1");
function ug() {
  return typeof window < "u";
}
h(ug, "_d");
u(ug, "hasWindow");
function fl(n) {
  return WP(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
h(fl, "nc");
u(fl, "getNodeName");
function Qi(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
h(Qi, "qe");
u(Qi, "getWindow");
function En(n) {
  var t;
  return (t = (WP(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
h(En, "Ri");
u(En, "getDocumentElement");
function WP(n) {
  return ug() ? n instanceof Node || n instanceof Qi(n).Node : !1;
}
h(WP, "Ff");
u(WP, "isNode");
function on(n) {
  return ug() ? n instanceof Element || n instanceof Qi(n).Element : !1;
}
h(on, "di");
u(on, "isElement");
function Qn(n) {
  return ug() ? n instanceof HTMLElement || n instanceof Qi(n).HTMLElement : !1;
}
h(Qn, "Pi");
u(Qn, "isHTMLElement");
function xk(n) {
  return !ug() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Qi(n).ShadowRoot;
}
h(xk, "Oy");
u(xk, "isShadowRoot");
function Qy(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: s
  } = ln(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !["inline", "contents"].includes(s);
}
h(Qy, "dl");
u(Qy, "isOverflowElement");
function B_(n) {
  return ["table", "td", "th"].includes(fl(n));
}
h(B_, "Jb");
u(B_, "isTableElement");
function pg(n) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return n.matches(t);
    } catch {
      return !1;
    }
  });
}
h(pg, "zd");
u(pg, "isTopLayer");
function X0(n) {
  const t = N0(), e = on(n) ? ln(n) : n;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((i) => e[i] ? e[i] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((i) => (e.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (e.contain || "").includes(i));
}
h(X0, "lp");
u(X0, "isContainingBlock");
function X_(n) {
  let t = Fs(n);
  for (; Qn(t) && !Ho(t); ) {
    if (X0(t))
      return t;
    if (pg(t))
      return null;
    t = Fs(t);
  }
  return null;
}
h(X_, "t2");
u(X_, "getContainingBlock");
function N0() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
h(N0, "dp");
u(N0, "isWebKit");
function Ho(n) {
  return ["html", "body", "#document"].includes(fl(n));
}
h(Ho, "Uo");
u(Ho, "isLastTraversableNode");
function ln(n) {
  return Qi(n).getComputedStyle(n);
}
h(ln, "hi");
u(ln, "getComputedStyle$1");
function fg(n) {
  return on(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
h(fg, "Md");
u(fg, "getNodeScroll");
function Fs(n) {
  if (fl(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    xk(n) && n.host || // Fallback.
    En(n)
  );
  return xk(t) ? t.host : t;
}
h(Fs, "ks");
u(Fs, "getParentNode");
function DP(n) {
  const t = Fs(n);
  return Ho(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : Qn(t) && Qy(t) ? t : DP(t);
}
h(DP, "Df");
u(DP, "getNearestOverflowAncestor");
function ay(n, t, e) {
  var i;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const s = DP(n), r = s === ((i = n.ownerDocument) == null ? void 0 : i.body), a = Qi(s);
  if (r) {
    const o = Gv(a);
    return t.concat(a, a.visualViewport || [], Qy(s) ? s : [], o && e ? ay(o) : []);
  }
  return t.concat(s, ay(s, [], e));
}
h(ay, "zc");
u(ay, "getOverflowAncestors");
function Gv(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
h(Gv, "Cu");
u(Gv, "getFrameElement");
function qP(n) {
  const t = ln(n);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const s = Qn(n), r = s ? n.offsetWidth : e, a = s ? n.offsetHeight : i, o = Hv(e) !== r || Hv(i) !== a;
  return o && (e = r, i = a), {
    width: e,
    height: i,
    $: o
  };
}
h(qP, "Hf");
u(qP, "getCssDimensions");
function H0(n) {
  return on(n) ? n : n.contextElement;
}
h(H0, "hp");
u(H0, "unwrapElement");
function Ha(n) {
  const t = H0(n);
  if (!Qn(t))
    return ss(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: s,
    $: r
  } = qP(t);
  let a = (r ? Hv(e.width) : e.width) / i, o = (r ? Hv(e.height) : e.height) / s;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
h(Ha, "Qr");
u(Ha, "getScale");
const MX = /* @__PURE__ */ ss(0);
function VP(n) {
  const t = Qi(n);
  return !N0() || !t.visualViewport ? MX : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
h(VP, "Vf");
u(VP, "getVisualOffsets");
function N_(n, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Qi(n) ? !1 : t;
}
h(N_, "i2");
u(N_, "shouldAddVisualOffsets");
function na(n, t, e, i) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const s = n.getBoundingClientRect(), r = H0(n);
  let a = ss(1);
  t && (i ? on(i) && (a = Ha(i)) : a = Ha(n));
  const o = N_(r, e, i) ? VP(r) : ss(0);
  let l = (s.left + o.x) / a.x, c = (s.top + o.y) / a.y, d = s.width / a.x, p = s.height / a.y;
  if (r) {
    const f = Qi(r), m = i && on(i) ? Qi(i) : i;
    let w = f, b = Gv(w);
    for (; b && i && m !== w; ) {
      const x = Ha(b), O = b.getBoundingClientRect(), P = ln(b), A = O.left + (b.clientLeft + parseFloat(P.paddingLeft)) * x.x, R = O.top + (b.clientTop + parseFloat(P.paddingTop)) * x.y;
      l *= x.x, c *= x.y, d *= x.x, p *= x.y, l += A, c += R, w = Qi(b), b = Gv(w);
    }
  }
  return Ww({
    width: d,
    height: p,
    x: l,
    y: c
  });
}
h(na, "yr");
u(na, "getBoundingClientRect");
function Y0(n, t) {
  const e = fg(n).scrollLeft;
  return t ? t.left + e : na(En(n)).left + e;
}
h(Y0, "up");
u(Y0, "getWindowScrollBarX");
function jP(n, t, e) {
  e === void 0 && (e = !1);
  const i = n.getBoundingClientRect(), s = i.left + t.scrollLeft - (e ? 0 : (
    // RTL <body> scrollbar.
    Y0(n, i)
  )), r = i.top + t.scrollTop;
  return {
    x: s,
    y: r
  };
}
h(jP, "Bf");
u(jP, "getHTMLOffset");
function H_(n) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: s
  } = n;
  const r = s === "fixed", a = En(i), o = t ? pg(t.floating) : !1;
  if (i === a || o && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = ss(1);
  const d = ss(0), p = Qn(i);
  if ((p || !p && !r) && ((fl(i) !== "body" || Qy(a)) && (l = fg(i)), Qn(i))) {
    const m = na(i);
    c = Ha(i), d.x = m.x + i.clientLeft, d.y = m.y + i.clientTop;
  }
  const f = a && !p && !r ? jP(a, l, !0) : ss(0);
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + d.x + f.x,
    y: e.y * c.y - l.scrollTop * c.y + d.y + f.y
  };
}
h(H_, "s2");
u(H_, "convertOffsetParentRelativeRectToViewportRelativeRect");
function Y_(n) {
  return Array.from(n.getClientRects());
}
h(Y_, "r2");
u(Y_, "getClientRects");
function G_(n) {
  const t = En(n), e = fg(n), i = n.ownerDocument.body, s = Na(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), r = Na(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let a = -e.scrollLeft + Y0(n);
  const o = -e.scrollTop;
  return ln(i).direction === "rtl" && (a += Na(t.clientWidth, i.clientWidth) - s), {
    width: s,
    height: r,
    x: a,
    y: o
  };
}
h(G_, "n2");
u(G_, "getDocumentRect");
function K_(n, t) {
  const e = Qi(n), i = En(n), s = e.visualViewport;
  let r = i.clientWidth, a = i.clientHeight, o = 0, l = 0;
  if (s) {
    r = s.width, a = s.height;
    const c = N0();
    (!c || c && t === "fixed") && (o = s.offsetLeft, l = s.offsetTop);
  }
  return {
    width: r,
    height: a,
    x: o,
    y: l
  };
}
h(K_, "a2");
u(K_, "getViewportRect");
function J_(n, t) {
  const e = na(n, !0, t === "fixed"), i = e.top + n.clientTop, s = e.left + n.clientLeft, r = Qn(n) ? Ha(n) : ss(1), a = n.clientWidth * r.x, o = n.clientHeight * r.y, l = s * r.x, c = i * r.y;
  return {
    width: a,
    height: o,
    x: l,
    y: c
  };
}
h(J_, "o2");
u(J_, "getInnerBoundingClientRect");
function kk(n, t, e) {
  let i;
  if (t === "viewport")
    i = K_(n, e);
  else if (t === "document")
    i = G_(En(n));
  else if (on(t))
    i = J_(t, e);
  else {
    const s = VP(n);
    i = {
      x: t.x - s.x,
      y: t.y - s.y,
      width: t.width,
      height: t.height
    };
  }
  return Ww(i);
}
h(kk, "Ly");
u(kk, "getClientRectFromClippingAncestor");
function FP(n, t) {
  const e = Fs(n);
  return e === t || !on(e) || Ho(e) ? !1 : ln(e).position === "fixed" || FP(e, t);
}
h(FP, "Uf");
u(FP, "hasFixedPositionAncestor");
function tL(n, t) {
  const e = t.get(n);
  if (e)
    return e;
  let i = ay(n, [], !1).filter((o) => on(o) && fl(o) !== "body"), s = null;
  const r = ln(n).position === "fixed";
  let a = r ? Fs(n) : n;
  for (; on(a) && !Ho(a); ) {
    const o = ln(a), l = X0(a);
    !l && o.position === "fixed" && (s = null), (r ? !l && !s : !l && o.position === "static" && s && ["absolute", "fixed"].includes(s.position) || Qy(a) && !l && FP(n, a)) ? i = i.filter((c) => c !== a) : s = o, a = Fs(a);
  }
  return t.set(n, i), i;
}
h(tL, "c2");
u(tL, "getClippingElementAncestors");
function eL(n) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: s
  } = n;
  const r = [...e === "clippingAncestors" ? pg(t) ? [] : tL(t, this._c) : [].concat(e), i], a = r[0], o = r.reduce((l, c) => {
    const d = kk(t, c, s);
    return l.top = Na(d.top, l.top), l.right = Nv(d.right, l.right), l.bottom = Nv(d.bottom, l.bottom), l.left = Na(d.left, l.left), l;
  }, kk(t, a, s));
  return {
    width: o.right - o.left,
    height: o.bottom - o.top,
    x: o.left,
    y: o.top
  };
}
h(eL, "l2");
u(eL, "getClippingRect");
function iL(n) {
  const {
    width: t,
    height: e
  } = qP(n);
  return {
    width: t,
    height: e
  };
}
h(iL, "d2");
u(iL, "getDimensions");
function nL(n, t, e) {
  const i = Qn(t), s = En(t), r = e === "fixed", a = na(n, !0, r, t);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = ss(0);
  function c() {
    l.x = Y0(s);
  }
  if (h(c, "u"), u(c, "setLeftRTLScrollbarOffset"), i || !i && !r)
    if ((fl(t) !== "body" || Qy(s)) && (o = fg(t)), i) {
      const m = na(t, !0, r, t);
      l.x = m.x + t.clientLeft, l.y = m.y + t.clientTop;
    } else s && c();
  r && !i && s && c();
  const d = s && !i && !r ? jP(s, o) : ss(0), p = a.left + o.scrollLeft - l.x - d.x, f = a.top + o.scrollTop - l.y - d.y;
  return {
    x: p,
    y: f,
    width: a.width,
    height: a.height
  };
}
h(nL, "h2");
u(nL, "getRectRelativeToOffsetParent");
function L1(n) {
  return ln(n).position === "static";
}
h(L1, "Oh");
u(L1, "isStaticPositioned");
function Sk(n, t) {
  if (!Qn(n) || ln(n).position === "fixed")
    return null;
  if (t)
    return t(n);
  let e = n.offsetParent;
  return En(n) === e && (e = e.ownerDocument.body), e;
}
h(Sk, "Iy");
u(Sk, "getTrueOffsetParent");
function UP(n, t) {
  const e = Qi(n);
  if (pg(n))
    return e;
  if (!Qn(n)) {
    let s = Fs(n);
    for (; s && !Ho(s); ) {
      if (on(s) && !L1(s))
        return s;
      s = Fs(s);
    }
    return e;
  }
  let i = Sk(n, t);
  for (; i && B_(i) && L1(i); )
    i = Sk(i, t);
  return i && Ho(i) && L1(i) && !X0(i) ? e : i || X_(n) || e;
}
h(UP, "qf");
u(UP, "getOffsetParent");
const TX = /* @__PURE__ */ u(async function(n) {
  const t = this.getOffsetParent || UP, e = this.getDimensions, i = await e(n.floating);
  return {
    reference: nL(n.reference, await t(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "getElementRects");
function sL(n) {
  return ln(n).direction === "rtl";
}
h(sL, "p2");
u(sL, "isRTL");
const AX = {
  convertOffsetParentRelativeRectToViewportRelativeRect: H_,
  getDocumentElement: En,
  getClippingRect: eL,
  getOffsetParent: UP,
  getElementRects: TX,
  getClientRects: Y_,
  getDimensions: iL,
  getScale: Ha,
  isElement: on,
  isRTL: sL
};
function BP(n, t) {
  return n.x === t.x && n.y === t.y && n.width === t.width && n.height === t.height;
}
h(BP, "Nf");
u(BP, "rectsAreEqual");
function rL(n, t) {
  let e = null, i;
  const s = En(n);
  function r() {
    var o;
    clearTimeout(i), (o = e) == null || o.disconnect(), e = null;
  }
  h(r, "n"), u(r, "cleanup");
  function a(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), r();
    const c = n.getBoundingClientRect(), {
      left: d,
      top: p,
      width: f,
      height: m
    } = c;
    if (o || t(), !f || !m)
      return;
    const w = Xg(p), b = Xg(s.clientWidth - (d + f)), x = Xg(s.clientHeight - (p + m)), O = Xg(d), P = {
      rootMargin: -w + "px " + -b + "px " + -x + "px " + -O + "px",
      threshold: Na(0, Nv(1, l)) || 1
    };
    let A = !0;
    function R(T) {
      const I = T[0].intersectionRatio;
      if (I !== l) {
        if (!A)
          return a();
        I ? a(!1, I) : i = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !BP(c, n.getBoundingClientRect()) && a(), A = !1;
    }
    h(R, "R"), u(R, "handleObserve");
    try {
      e = new IntersectionObserver(R, {
        ...P,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(R, P);
    }
    e.observe(n);
  }
  return h(a, "a"), u(a, "refresh"), a(!0), r;
}
h(rL, "w2");
u(rL, "observeMove");
function XP(n, t, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: r = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, c = H0(n), d = s || r ? [...c ? ay(c) : [], ...ay(t)] : [];
  d.forEach((O) => {
    s && O.addEventListener("scroll", e, {
      passive: !0
    }), r && O.addEventListener("resize", e);
  });
  const p = c && o ? rL(c, e) : null;
  let f = -1, m = null;
  a && (m = new ResizeObserver((O) => {
    let [P] = O;
    P && P.target === c && m && (m.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var A;
      (A = m) == null || A.observe(t);
    })), e();
  }), c && !l && m.observe(c), m.observe(t));
  let w, b = l ? na(n) : null;
  l && x();
  function x() {
    const O = na(n);
    b && !BP(b, O) && e(), b = O, w = requestAnimationFrame(x);
  }
  return h(x, "z"), u(x, "frameLoop"), e(), () => {
    var O;
    d.forEach((P) => {
      s && P.removeEventListener("scroll", e), r && P.removeEventListener("resize", e);
    }), p == null || p(), (O = m) == null || O.disconnect(), m = null, l && cancelAnimationFrame(w);
  };
}
h(XP, "jf");
u(XP, "autoUpdate");
const aL = CX, oL = QX, lL = PX, cL = /* @__PURE__ */ u((n, t, e) => {
  const i = /* @__PURE__ */ new Map(), s = {
    platform: AX,
    ...e
  }, r = {
    ...s.platform,
    _c: i
  };
  return SX(n, t, {
    ...s,
    platform: r
  });
}, "computePosition");
function hL(n, t, e, i, s, r, a) {
  return new Vt(n.queryClient, {
    mutationFn: /* @__PURE__ */ u(async () => await n.fetch(`/api/${s}/${i}/reactions`, {
      method: r ? "POST" : "DELETE",
      body: JSON.stringify({ content: r })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ u(() => {
      const o = e === "apps" && s === "posts" ? [s, t] : [e, t, s];
      we(n.queryClient, o, i, (l) => {
        oy(l, r, a);
      });
    }, "onMutate")
  });
}
h(hL, "f2");
u(hL, "reactionMutation");
function dL(n, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ u(async () => await (await n.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
h(dL, "m2");
u(dL, "getReactionListOptions");
function oy(n, t, e) {
  var i;
  return !t && !((i = n.reactions) != null && i.data) || (n.reactions || (n.reactions = { count: 0, data: [] }), n.reactions.data || (n.reactions.data = []), t ? n.reactions.data = [
    ...n.reactions.data.filter((s) => {
      var r;
      return ((r = s.created_by) == null ? void 0 : r.id) !== e.id;
    }),
    { content: t, created_by: e }
  ] : n.reactions.data && (n.reactions.data = [...n.reactions.data.filter((s) => {
    var r;
    return ((r = s.created_by) == null ? void 0 : r.id) !== e.id;
  })])), n;
}
h(oy, "Mc");
u(oy, "updateReaction");
var RX = Object.defineProperty, EX = Object.getOwnPropertyDescriptor, NP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RX(t, e, s), s;
}, "__decorateClass$_"), BO, gp;
let ly = (BO = (gp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.noPadding = !1, this.show = !1, this.viewportRef = wt();
  }
  close() {
    var t, e, i;
    this.show = !1;
    try {
      (t = this.viewportRef.value) != null && t.popover ? (e = this.viewportRef.value) == null || e.hidePopover() : (i = this.viewportRef.value) == null || i.close();
    } catch {
    }
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "close") && (this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  render() {
    return v`
      <dialog class="wy-dialog" tabindex="0" ${lt(this.viewportRef)} popover="auto">
        <div class="wy-sheet ${this.show ? "wy-show" : ""}">
          <slot name="header">
            <header class="wy-appbars">
              <nav class="wy-appbar">
                <wy-button kind="icon" @click=${() => this.close()}>
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <slot name="appbar-text" class="wy-appbar-text"></slot>
                <slot name="appbar-buttons" class="wy-appbar-buttons wy-appbar-buttons-last"></slot>
              </nav>
            </header>
          </slot>
          <div class="wy-sheet-body wy-scroll-y ${this.noPadding ? "wy-sheet-no-padding" : ""}">
            <slot></slot>
          </div>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    var e, i, s, r, a, o, l;
    if (t.has("show"))
      try {
        this.show ? (e = this.viewportRef.value) != null && e.popover ? (i = this.viewportRef.value) == null || i.showPopover() : (s = this.viewportRef.value) == null || s.show() : (r = this.viewportRef.value) != null && r.popover ? (a = this.viewportRef.value) == null || a.hidePopover() : (o = this.viewportRef.value) == null || o.close();
      } catch {
      }
    t.has("show") && this.show && ((l = this.viewportRef.value) == null || l.focus());
  }
  firstUpdated(t) {
    var e;
    (e = this.viewportRef.value) == null || e.addEventListener(
      this.viewportRef.value.popover ? "toggle" : "close",
      (i) => this.handleClose(i)
    );
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, h(gp, "fa"), gp), u(BO, "WySheet"), BO);
ly.styles = [
  yt,
  At
];
NP([
  $({ type: Boolean })
], ly.prototype, "noPadding", 2);
NP([
  $({ type: Boolean })
], ly.prototype, "show", 2);
ly = NP([
  H("wy-sheet")
], ly);
const zX = Mt`[part~=wy-reaction]{font-size:calc(1.125 * var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25 * var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;padding-left:calc(.1875 * var(--wy-size, 1rem));padding-right:calc(.1875 * var(--wy-size, 1rem));gap:calc(.1875 * var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1 * var(--wy-size, 1rem));right:calc(.25 * var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.125 * var(--wy-size, 1rem));padding-right:calc(.125 * var(--wy-size, 1rem));gap:calc(.125 * var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, uL = Mt`.wy-item{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));position:relative;display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-decoration:none}.wy-list-item{min-height:calc(3 * var(--wy-size, 1rem))}.wy-list-item-lg{min-height:calc(4.5 * var(--wy-size, 1rem))}.wy-item-inner{display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%}.wy-item-body{width:100%;min-width:0}.wy-item-rows{display:flex;flex-direction:column;width:100%;row-gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0}.wy-item-rows:only-child{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-rows-compact{row-gap:0}.wy-item-rows-single{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-title{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-title-lg{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title-lg{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.wy-item-text{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-item-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-text .wy-icon{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-item-quote{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-item-quote:before,.wy-item-quote:after{content:'\"'}.wy-item-actions{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;margin:calc(-.25 * var(--wy-size, 1rem))}.wy-item-top{align-self:flex-start}.wy-item-actions-bottom{align-self:flex-start;margin-block:calc(-.5 * var(--wy-size, 1rem))}.wy-item-row{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-item-row .wy-item-title,.wy-item-row .wy-item-text{margin-right:auto}.wy-item-row .wy-meta{white-space:nowrap}.wy-item-right{margin-left:auto}.wy-item-hover{-webkit-user-select:none;user-select:none;cursor:pointer}.wy-item-hover:hover,.wy-item-hover:focus{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);text-decoration:none}.wy-item-hover:active{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-item-hover.wy-disabled,.wy-item-hover:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}.wy-item-hover.wy-active{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}.wy-item-trashed{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}.wy-item-trashed.wy-item-hover:hover{opacity:1}`, pL = Mt`.wy-emoji-icon{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25 * var(--wy-size, 1rem))}.wy-emoji-icon-sm{width:calc(1.125 * var(--wy-size, 1rem));height:calc(1.125 * var(--wy-size, 1rem));font-size:calc(1.125 * var(--wy-size, 1rem))}`;
var _X = Object.defineProperty, LX = Object.getOwnPropertyDescriptor, Ae = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? LX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && _X(t, e, s), s;
}, "__decorateClass$Z"), XO, vp;
let ge = (XO = (vp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = wt(), this.menuRef = wt(), this.reactionListQuery = new Cn(this), this._documentClickHandler = (t) => {
      var e;
      this.show && (t.preventDefault(), (e = this.menuRef.value) != null && e.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      var e;
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const i = hL(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await i.mutate(), (e = this.reactionListQuery.observer) == null || e.refetch();
    };
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  handleReactionsClick() {
    var t;
    (t = this.reactionListQuery.observer) == null || t.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    var e, i, s, r, a;
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(dL(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = (i = (e = this.reactions) == null ? void 0 : e.find((o) => {
      var l, c;
      return ((l = o.created_by) == null ? void 0 : l.id) === ((c = this.user) == null ? void 0 : c.id);
    })) == null ? void 0 : i.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = XP(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && cL(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            lL(),
            aL({ mainAxis: 0, alignmentAxis: -8 }),
            oL({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: o, y: l }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${o}px`,
            marginTop: `${l}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        (s = this.menuRef.value) == null || s.showPopover();
      } catch {
      }
    } else
      try {
        (r = this.menuRef.value) == null || r.hidePopover();
      } catch {
      }
    t.has("settings") && (a = this.settings) != null && a.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    var t, e, i, s, r, a;
    const { data: o, isPending: l } = this.reactionListQuery.result ?? {};
    if (!((t = this.emojis) != null && t.length))
      return Q;
    const c = ((e = this.emojis) == null ? void 0 : e.length) === 1 ? this.emojis[0] : "", d = [
      ...new Map((i = this.reactions) == null ? void 0 : i.map((b) => [b.content, b])).values()
    ], p = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, f = c ? v`
          ${this.reactions && ((s = this.reactions) == null ? void 0 : s.length) > 1 ? v`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span class=${Xt(p)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : Q}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === c}
              @click=${() => {
      this.handleReaction(c);
    }}
              @keydown=${je}
              @keyup=${gi}
              title=${C("React", { desc: "Button action to react" })}
            >
              <span class=${Xt(p)} title=${c}>${c}</span>
            </wy-button>
          </div>
        ` : v`
          ${d.length ? v`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${d.map((b) => v`<span class=${Xt(p)} title="">${b.content}</span>`)}
                    ${this.reactions && ((r = this.reactions) == null ? void 0 : r.length) > 1 ? v`<small part="wy-reaction-count">${this.reactions.length}</small>` : Q}
                  </div>
                </wy-button>
              ` : Q}

          <div ${lt(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(b) => this.handleClickToggle(b)}
              @keydown=${je}
              @keyup=${gi}
              title=${C("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon-plus" size=${this.small ? 18 : 20}></wy-icon>
            </wy-button>
          </div>

          <div
            ${lt(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(b) => this.handleClickToggle(b)}
            @keyup=${B0}
            ?hidden=${!this.show}
            popover=${Ct(V1() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (b) => v`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === b}
                      @click=${() => {
        this.handleReaction(b);
      }}
                    >
                      <span class="wy-emoji-icon">${b}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, m = v`
      ${this.weavy && this.showSheet ? v`
            <wy-sheet
              .show=${this.showSheet}
              @close=${() => this.showSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <span slot="appbar-text">${C("Reactions")}</span>
              <!-- <wy-spinner></wy-spinner> -->
              ${this.showSheet && o && !l ? v`
                    ${(a = o.data) == null ? void 0 : a.map(
      (b) => v` <wy-reaction-item .reaction=${b}></wy-reaction-item> `
    )}
                  ` : Q}
            </wy-sheet>
          ` : Q}
    `, w = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? v`
          <div part=${Qe(w)}>${f}</div>
          ${m}
        ` : [f, m];
  }
  firstUpdated(t) {
    var e;
    (e = this.menuRef.value) == null || e.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (i) => this.handleClose(i)
    );
  }
  disconnectedCallback() {
    var t;
    (t = this._computePositionCleanup) == null || t.call(this), super.disconnectedCallback();
  }
}, h(vp, "ma"), vp), u(XO, "WyReactions"), XO);
ge.styles = [Ie, zX, pL, At];
Ae([
  $()
], ge.prototype, "directionX", 2);
Ae([
  $()
], ge.prototype, "directionY", 2);
Ae([
  $({ type: Boolean })
], ge.prototype, "small", 2);
Ae([
  $({ attribute: !1 })
], ge.prototype, "reactions", 2);
Ae([
  $({ attribute: !1 })
], ge.prototype, "emojis", 2);
Ae([
  $({ type: String })
], ge.prototype, "parentType", 2);
Ae([
  $({ attribute: !0, type: Number })
], ge.prototype, "parentId", 2);
Ae([
  $({ attribute: !0, type: String })
], ge.prototype, "entityType", 2);
Ae([
  $({ attribute: !0, type: Number })
], ge.prototype, "entityId", 2);
Ae([
  $({ type: Boolean })
], ge.prototype, "line", 2);
Ae([
  $({ type: Boolean })
], ge.prototype, "lineReverse", 2);
Ae([
  $({ type: Boolean })
], ge.prototype, "lineBottom", 2);
Ae([
  $({ type: Boolean })
], ge.prototype, "lineBelow", 2);
Ae([
  U()
], ge.prototype, "_placement", 2);
Ae([
  U()
], ge.prototype, "reactedEmoji", 2);
Ae([
  U()
], ge.prototype, "show", 2);
Ae([
  U()
], ge.prototype, "showSheet", 2);
ge = Ae([
  H("wy-reactions"),
  Ot()
], ge);
var NO, bp;
let Dw = (NO = (bp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    var t, e, i;
    return v`
      <div class="wy-item wy-list-item">
        <wy-avatar
          .src=${(t = this.reaction.created_by) == null ? void 0 : t.avatar_url}
          .name=${(e = this.reaction.created_by) == null ? void 0 : e.name}
        ></wy-avatar>
        <div class="wy-item-body">${(i = this.reaction.created_by) == null ? void 0 : i.name}</div>
        <span class="wy-emoji-icon">${this.reaction.content}</span>
      </div>
    `;
  }
}, h(bp, "va"), bp), u(NO, "WyReactionItem"), NO);
Dw.styles = [Ie, uL, pL];
Ae([
  $({ attribute: !1 })
], Dw.prototype, "reaction", 2);
Dw = Ae([
  H("wy-reaction-item")
], Dw);
function Kv(n) {
  switch (n) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
h(Kv, "ku");
u(Kv, "getMeetingIconName");
function Jv(n) {
  switch (n) {
    case "zoom":
      return C("Zoom meeting");
    case "microsoft":
      return C("Teams meeting");
    case "google":
      return C("Google Meet");
  }
}
h(Jv, "_u");
u(Jv, "getMeetingTitle");
var IX = Object.defineProperty, ZX = Object.getOwnPropertyDescriptor, fL = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? ZX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && IX(t, e, s), s;
}, "__decorateClass$Y"), HO, Op;
let qw = (HO = (Op = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return v`
      <div class="wy-list">
        ${t ? v`<div class="wy-item wy-list-item wy-meeting wy-disabled" title="${C("Meeting ended")}">
                <wy-icon svg="${Kv(this.meeting.provider)}" size="48" ></wy-icon>                
                <div class="wy-item-body">
                  <div class="wy-item-title">${Jv(this.meeting.provider)}</div>
                  <div class="wy-item-text">${this.meeting.code}</div>
                </div> 
              </div>` : v`<a class="wy-item wy-list-item wy-meeting" href=${this.meeting.join_url} target="_blank"  title="${C("Join meeting")}">
              <wy-icon svg="${Kv(this.meeting.provider)}" size="48" color="native"></wy-icon>
              <div class="wy-item-body">
                <div class="wy-item-title">${Jv(this.meeting.provider)}</div>
                <div class="wy-item-text">${this.meeting.code}</div>                
              </div>
            </a>`}
      </div>
    `;
  }
}, h(Op, "ga"), Op), u(HO, "WyMeetingCard"), HO);
qw.styles = yt;
fL([
  $({ attribute: !1 })
], qw.prototype, "meeting", 2);
qw = fL([
  H("wy-meeting-card"),
  Ot()
], qw);
var WX = Object.defineProperty, DX = Object.getOwnPropertyDescriptor, yL = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? DX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && WX(t, e, s), s;
}, "__decorateClass$X"), YO, $p;
let Vw = (YO = ($p = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    let e = "";
    return t.length && (e = t.split(/(\n+)/).map((i) => `<div>${i.split(/(\s+)/).map((s) => `<span class="wy-placeholder">${this.escapeHTML(s)}</span>`).join(" ")}</div>`).join(" ")), v`
      <div>${Bo(e)}</div>
    `;
  }
  escapeHTML(t) {
    const e = document.createElement("div");
    return e.textContent = t, e.innerHTML;
  }
}, h($p, "ba"), $p), u(YO, "WySkeleton"), YO);
Vw.styles = yt;
yL([
  $()
], Vw.prototype, "text", 2);
Vw = yL([
  H("wy-skeleton")
], Vw);
var xp;
const mL = (xp = class {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    var e;
    (e = this.scrollObserver) == null || e.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (i) => {
        i.forEach(async (s) => {
          s.isIntersecting && !this.sleep && s.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((r) => {
            setTimeout(r, this.delay);
          }), s.target === this.prevElement && this.whenPrev && await this.whenPrev(), s.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    var i, s, r, a;
    this.prevElement && ((i = this.scrollObserver) == null || i.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && ((s = this.scrollObserver) == null || s.unobserve(this.nextElement), this.nextElement = void 0), t && ((r = this.scrollObserver) == null || r.observe(t), this.prevElement = t), e && ((a = this.scrollObserver) == null || a.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    var t;
    this.prevElement = void 0, this.nextElement = void 0, (t = this.scrollObserver) == null || t.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    var t;
    (t = this.scrollObserver) == null || t.disconnect();
  }
}, h(xp, "jp"), xp);
u(mL, "SwipeScrollController");
let qX = mL;
var dr, wc, kp;
const wL = (kp = class {
  constructor(t) {
    if (F(this, dr), F(this, wc), L(this, dr, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      L(this, wc, t);
    else
      try {
        ti(), L(this, wc, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    k(this, dr).clear();
  }
  getStorageItem(t, e) {
    var i;
    const s = (i = k(this, wc)) == null ? void 0 : i.getItem(`${t}-${e.toString()}`);
    if (s)
      return JSON.parse(s);
  }
  setStorageItem(t, e, i) {
    var s;
    const r = JSON.stringify(i);
    r && ((s = k(this, wc)) == null || s.setItem(`${t}-${e.toString()}`, r));
  }
  persistProperties(t, e, i, s) {
    const r = `${this.keyPrefix}:${s ? `${s}:` : ""}${typeof t}:${e}`;
    for (const a of i) {
      if (!k(this, dr).has(a.name)) {
        const o = this.getStorageItem(r, a.name);
        o && (a.override || !t[a.name]) && (t[a.name] = o), k(this, dr).set(a.name, o);
      }
      if (t[a.name] !== k(this, dr).get(a.name)) {
        const o = t[a.name];
        k(this, dr).set(a.name, o), this.setStorageItem(r, a.name, o);
      }
    }
  }
}, h(kp, "Wp"), kp);
dr = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), u(wL, "PersistStorageCache");
let VX = wL;
var gc, Bm, Sp;
const gL = (Sp = class {
  constructor(t) {
    F(this, gc), F(this, Bm), L(this, gc, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new VX(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return k(this, gc);
  }
  set prefixKey(t) {
    t !== k(this, gc) && (this.persistStorageCache.resetPersistPropertiesCache(), L(this, gc, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return k(this, Bm);
  }
  set cachePrefix(t) {
    t !== k(this, Bm) && (this.persistStorageCache.resetPersistPropertiesCache(), L(this, Bm, t), this.host.requestUpdate());
  }
  observe(t, e, i) {
    this.properties = t;
    const s = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== i);
    this.properties.forEach((r) => {
      s && this.initialProperties.has(r.name) ? this.host[r.name] = this.initialProperties.get(r.name) : this.initialProperties.has(r.name) || this.initialProperties.set(r.name, this.host[r.name]);
    }), e && (this.prefixKey = e), i && (this.cachePrefix = i);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix);
  }
}, h(Sp, "Qp"), Sp);
gc = /* @__PURE__ */ new WeakMap(), Bm = /* @__PURE__ */ new WeakMap(), u(gL, "PersistStateController");
let HP = gL;
var jX = Object.defineProperty, FX = Object.getOwnPropertyDescriptor, yg = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? FX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && jX(t, e, s), s;
}, "__decorateClass$W"), GO, Pp;
let sa = (GO = (Pp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.show = !0, this.maximized = !1, this.filled = !1, this.header = !1, this.viewportRef = wt();
  }
  close() {
    var t;
    (t = this.viewportRef.value) == null || t.close(), this.show = !1;
  }
  handleClose(t) {
    this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }));
  }
  willUpdate(t) {
    var e, i;
    super.willUpdate(t), t.has("show") && (this.show ? (e = this.viewportRef.value) == null || e.showModal() : (i = this.viewportRef.value) == null || i.close());
  }
  render() {
    const t = {
      "wy-open": this.show,
      "wy-modal-padded": !this.filled && !this.maximized,
      "wy-modal-full": this.maximized && !this.filled
    };
    return v`
      <dialog class="wy-dialog wy-overlay-dialog" ${lt(this.viewportRef)}>
        <div class="wy-overlay wy-transition wy-modal ${Xt(t)}">
          ${this.header ? v`
                <slot name="header">
                  <header class="wy-appbars">
                    <nav class="wy-appbar">
                      <wy-button kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
                      <slot name="appbar-text" class="wy-appbar-text"></slot>
                      <slot name="appbar-buttons" class="wy-appbar-buttons wy-appbar-buttons-last"></slot>
                    </nav>
                  </header>
                </slot>
              ` : Q}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    var e;
    t.has("show") && this.show && ((e = this.viewportRef.value) == null || e.focus());
  }
  firstUpdated(t) {
    var e;
    (e = this.viewportRef.value) == null || e.addEventListener("close", (i) => this.handleClose(i));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, h(Pp, "$a"), Pp), u(GO, "WyOverlay"), GO);
sa.styles = [
  yt,
  Xi,
  At
];
yg([
  $({ type: Boolean })
], sa.prototype, "show", 2);
yg([
  $({ type: Boolean })
], sa.prototype, "maximized", 2);
yg([
  $({ type: Boolean })
], sa.prototype, "filled", 2);
yg([
  $({ type: Boolean })
], sa.prototype, "header", 2);
sa = yg([
  H("wy-overlay")
], sa);
const G0 = Mt`.wy-dropdown{position:relative}.wy-dropdown-toggle{white-space:nowrap}.wy-dropdown-menu{width:max-content;position:absolute;z-index:1000;min-width:calc(10 * var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}.wy-dropdown-menu:not([popover]){display:block}.wy-dropdown-item{background-color:transparent;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e)));width:100%;padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}.wy-dropdown-item:hover,.wy-dropdown-item:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}.wy-dropdown-item.wy-active,.wy-dropdown-item:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}.wy-dropdown-item.wy-disabled,.wy-dropdown-item:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}.wy-dropdown-item>img,.wy-dropdown-item>wy-icon{margin-right:calc(.5 * var(--wy-size, 1rem))}.wy-dropdown-item>img,.wy-dropdown-item>img .wy-icon,.wy-dropdown-item>wy-icon,.wy-dropdown-item>wy-icon .wy-icon{color:inherit}.wy-dropdown-item:active>wy-icon,.wy-dropdown-item:active>wy-icon .wy-icon{color:inherit}.wy-dropdown-item.wy-option wy-icon{visibility:hidden}.wy-dropdown-item.wy-option.wy-selected wy-icon{visibility:visible}.wy-dropdown-divider{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}`;
var UX = Object.defineProperty, BX = Object.getOwnPropertyDescriptor, ii = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? BX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && UX(t, e, s), s;
}, "__decorateClass$V"), KO, Cp;
let Ti = (KO = (Cp = class extends ft {
  constructor() {
    super(), this.exportParts = new nt(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.noWrapper = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = wt(), this.menuRef = wt(), this._documentClickHandler = (t) => {
      var e;
      this.showMenu && (t.preventDefault(), (e = this.menuRef.value) != null && e.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    var e, i, s;
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = XP(this.buttonRef.value, this.menuRef.value, () => {
      this.buttonRef.value && this.menuRef.value && cL(this.buttonRef.value, this.menuRef.value, {
        placement: this._placement,
        strategy: this.menuRef.value.popover ? "absolute" : "fixed",
        middleware: [
          lL(),
          aL(({ placement: r }) => r.includes("top") ? 9 : 13),
          oL({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
        ]
      }).then(({ x: r, y: a }) => {
        this.menuRef.value && Object.assign(this.menuRef.value.style, {
          marginLeft: `${r}px`,
          marginTop: `${a}px`,
          top: 0,
          left: 0,
          position: this.menuRef.value.popover ? void 0 : "fixed",
          zIndex: this.menuRef.value.popover ? void 0 : 1075
        });
      });
    }) : !this.showMenu && this.computePositionCleanup && ((e = this.computePositionCleanup) == null || e.call(this), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        (i = this.menuRef.value) == null || i.showPopover();
      } catch {
      }
    } else
      try {
        (s = this.menuRef.value) == null || s.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof ae;
    return v`
      <span>
        <span
          ${lt(this.buttonRef)}
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${je}
          @keyup=${gi}
        >
          <wy-button
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button" @slotchange=${() => this.requestUpdate()}>
              <wy-icon name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${lt(this.menuRef)}
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${B0}
          class="wy-dropdown-menu"
          ?hidden=${V1() && !this.showMenu}
          popover=${Ct(V1() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    var e;
    (e = this.menuRef.value) == null || e.addEventListener(this.menuRef.value.popover ? "toggle" : "click", (i) => this.handleClose(i));
  }
  disconnectedCallback() {
    var t;
    (t = this.computePositionCleanup) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Cp, "Ca"), Cp), u(KO, "WyDropdown"), KO);
Ti.styles = [
  Ie,
  G0
];
ii([
  $()
], Ti.prototype, "directionX", 2);
ii([
  $()
], Ti.prototype, "directionY", 2);
ii([
  $()
], Ti.prototype, "icon", 2);
ii([
  $({ type: Boolean })
], Ti.prototype, "small", 2);
ii([
  $({ type: Boolean })
], Ti.prototype, "noWrapper", 2);
ii([
  $({ type: Boolean })
], Ti.prototype, "disabled", 2);
ii([
  U()
], Ti.prototype, "_placement", 2);
ii([
  U()
], Ti.prototype, "showMenu", 2);
ii([
  iP({ slot: "button" })
], Ti.prototype, "_slotButton", 2);
ii([
  U()
], Ti.prototype, "computePositionCleanup", 2);
Ti = ii([
  H("wy-dropdown")
], Ti);
var JO, Qp;
let jw = (JO = (Qp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.active = !1;
  }
  render() {
    return v`<div class="wy-dropdown-item ${Xt({ "wy-active": this.active })}" tabindex="0"
      ><slot></slot
    ></div>`;
  }
}, h(Qp, "ka"), Qp), u(JO, "WyDropdownItem"), JO);
jw.styles = [
  Ie,
  G0,
  At
];
ii([
  $({ type: Boolean })
], jw.prototype, "active", 2);
jw = ii([
  H("wy-dropdown-item")
], jw);
var t2, Mp;
let cy = (t2 = (Mp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return v`
      <div
        class="wy-dropdown-item wy-option ${Xt({ "wy-active": this.active, "wy-selected": this.selected })}"
        tabindex="0"
      >
        <slot name="icon" style=${zw(t)}><wy-icon name="check"></wy-icon></slot>
        <slot></slot>
      </div>
    `;
  }
}, h(Mp, "_a"), Mp), u(t2, "WyDropdownOption"), t2);
cy.styles = [
  Ie,
  G0,
  At
];
ii([
  $({ type: Boolean })
], cy.prototype, "active", 2);
ii([
  $({ type: Boolean })
], cy.prototype, "selected", 2);
cy = ii([
  H("wy-dropdown-option")
], cy);
var e2, Tp;
let t0 = (e2 = (Tp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    return v`<hr class="wy-dropdown-divider" />`;
  }
}, h(Tp, "za"), Tp), u(e2, "WyDropdownDivider"), e2);
t0.styles = [
  Ie,
  G0,
  At
];
t0 = ii([
  H("wy-dropdown-divider")
], t0);
var XX = Object.defineProperty, NX = Object.getOwnPropertyDescriptor, K0 = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? NX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && XX(t, e, s), s;
}, "__decorateClass$U"), i2, Ap;
let Yo = (i2 = (Ap = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    const t = this.icon, e = Ks(this.provider);
    return v`
      <wy-icon-display>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? v`
                <span>${C("No preview available :(")} </span>
                <a href=${this.src} target="_blank">${C(at`Open in ${this.provider}?`)}</a>
              ` : v`<span>${C("No preview available :(")}</span>`}
        </span>
      </wy-icon-display>
    `;
  }
}, h(Ap, "Ma"), Ap), u(i2, "WyPreviewIcon"), i2);
Yo.styles = [
  yt,
  At
];
K0([
  $()
], Yo.prototype, "src", 2);
K0([
  $()
], Yo.prototype, "icon", 2);
K0([
  $()
], Yo.prototype, "provider", 2);
Yo = K0([
  H("wy-preview-icon"),
  Ot()
], Yo);
var HX = Object.defineProperty, YX = Object.getOwnPropertyDescriptor, J0 = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HX(t, e, s), s;
}, "__decorateClass$T"), n2, Rp;
let Go = (n2 = (Rp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  render() {
    if (this.width && this.height) {
      const t = { "--width": this.width, "--height": this.height };
      return v`
        <div class="wy-content-image wy-responsive-image" style=${zw(t)}>
          <img
            class="wy-loading-transition"
            src=${this.src}
            ${lt(_w)}
            @load=${Lw}
            width=${this.width}
            height=${this.height}
            decoding="async"
            alt=${C("Preview")} />
          <wy-spinner></wy-spinner>
        </div>
      `;
    } else
      return v`
        <div class="wy-content-image wy-responsive-image wy-intrinsic-image">
          <img src=${this.src} ${lt(_w)} @load=${Lw} decoding="async" alt=${C("Preview")} />
        </div>
      `;
  }
}, h(Rp, "Pa"), Rp), u(n2, "WyPreviewImage"), n2);
Go.styles = [
  yt,
  At
];
J0([
  $()
], Go.prototype, "src", 2);
J0([
  $({ type: Number })
], Go.prototype, "width", 2);
J0([
  $({ type: Number })
], Go.prototype, "height", 2);
Go = J0([
  H("wy-preview-image"),
  Ot()
], Go);
function YP(n) {
  n.classList.contains("wy-loading") && n.classList.add("wy-loaded"), n.classList.add("wy-error"), n.outerHTML = n.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
h(YP, "tm");
u(YP, "mediaFallback");
function Pk(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && t.classList.contains("wy-loading") && t.classList.add("wy-loaded");
}
h(Pk, "Ty");
u(Pk, "mediaLoaded");
function Ck(n) {
  const t = n.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, i = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = i.toString(), e.querySelectorAll("source").length >= i && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), YP(e));
  }
}
h(Ck, "Fy");
u(Ck, "mediaError");
function Qk(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), YP(t));
}
h(Qk, "Dy");
u(Qk, "codecError");
var GX = Object.defineProperty, KX = Object.getOwnPropertyDescriptor, My = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? KX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && GX(t, e, s), s;
}, "__decorateClass$S"), s2, Ep;
let Us = (s2 = (Ep = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.format = "", this.play = !1, this.name = "";
  }
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.classList.add("wy-loading"), t.addEventListener("error", Ck, !0), t.addEventListener("loadedmetadata", Pk, !0), t.addEventListener("loadedmetadata", Qk, !0));
  }
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", Ck, !0), this.mediaElement.removeEventListener("loadedmetadata", Pk, !0), this.mediaElement.removeEventListener("loadedmetadata", Qk, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? v`
          <video ${lt((t) => this.registerLoading(t))} class="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ct(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-spinner></wy-spinner>
        ` : v`
          <audio ${lt((t) => this.registerLoading(t))} class="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ct(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, h(Ep, "Sa"), Ep), u(s2, "WyPreviewMedia"), s2);
Us.styles = [
  yt,
  At
];
My([
  $()
], Us.prototype, "format", 2);
My([
  $()
], Us.prototype, "src", 2);
My([
  $({ type: Boolean })
], Us.prototype, "play", 2);
My([
  $()
], Us.prototype, "name", 2);
My([
  $()
], Us.prototype, "mediaType", 2);
Us = My([
  H("wy-preview-media")
], Us);
var JX = Object.defineProperty, tN = Object.getOwnPropertyDescriptor, yl = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? tN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && JX(t, e, s), s;
}, "__decorateClass$R"), r2, zp;
let ls = (r2 = (zp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then(zR).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e;
    }));
  }
  render() {
    return this.loading ? v` <wy-empty><wy-spinner></wy-spinner></wy-empty> ` : this.html ? this.code ? v` <div class="wy-content-code wy-code">${Bo(this.textOrHtmlContent)}</div> ` : v`
            <div class="wy-document wy-light">
              <div class="wy-content-html">${Bo(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? v` <div class="wy-content-code">${this.textOrHtmlContent}</div> ` : v`
          <div class="wy-document wy-light">
            <pre class="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, h(zp, "Aa"), zp), u(r2, "WyPreviewText"), r2);
ls.styles = [yt, Xi, At];
yl([
  ve({ context: _e, subscribe: !0 }),
  U()
], ls.prototype, "weavy", 2);
yl([
  $()
], ls.prototype, "src", 2);
yl([
  $({ type: Boolean })
], ls.prototype, "html", 2);
yl([
  $({ type: Boolean })
], ls.prototype, "code", 2);
yl([
  U()
], ls.prototype, "textOrHtmlContent", 2);
yl([
  U()
], ls.prototype, "loading", 2);
ls = yl([
  H("wy-preview-text")
], ls);
var eN = Object.defineProperty, iN = Object.getOwnPropertyDescriptor, mg = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eN(t, e, s), s;
}, "__decorateClass$Q"), a2, _p;
let ra = (a2 = (_p = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  registerLoading(t) {
    var e;
    if ((e = this.unregisterLoading) == null || e.call(this), t) {
      this.embedElement = t, t.classList.add("wy-loading");
      const i = window.setTimeout(() => {
        t.classList.add("wy-fallback");
      }, 2500), s = /* @__PURE__ */ u((r) => {
        const a = r.target;
        a.tagName === "OBJECT" && a.classList.contains("wy-loading") && !a.classList.contains("wy-loaded") && (a.classList.add("wy-loaded"), window.clearTimeout(i));
      }, "embedLoaded");
      t.addEventListener("load", s, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", s, !0), window.clearTimeout(i), this.embedElement = void 0);
      };
    }
  }
  render() {
    return v`
      <object title=${C("Preview")} ${lt((t) => this.registerLoading(t))} class="wy-content-iframe" data=${this.src}></object>
      <wy-spinner overlay></wy-spinner>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${Ct(this.provider)}
        class="wy-content-iframe-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = this.unregisterLoading) == null || t.call(this), super.disconnectedCallback();
  }
}, h(_p, "Ea"), _p), u(a2, "WyPreviewEmbed"), a2);
ra.styles = [
  yt,
  At
];
mg([
  $()
], ra.prototype, "src", 2);
mg([
  $()
], ra.prototype, "name", 2);
mg([
  $()
], ra.prototype, "icon", 2);
mg([
  $()
], ra.prototype, "provider", 2);
ra = mg([
  H("wy-preview-embed"),
  Ot()
], ra);
function Uc(n = "", t = "", e = "", i = !1) {
  if (ti(), n) {
    const s = document.createElement("a");
    i && (/^(data:|blob:)/.test(n) ? s.download = e || "download" : n = n.includes("?d=1") || n.includes("&d=1") ? n : n.includes("?") ? n + "&d=1" : n + "?d=1"), t && (s.target = t), s.href = n, document.body.appendChild(s);
    try {
      s.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(n))
        console.error(`Could not ${i ? "download" : "open"} ${e}`);
      else
        try {
          window.open(n, t);
        } catch {
          console.error(`Could not ${i ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(s);
  }
}
h(Uc, "vc");
u(Uc, "openUrl");
function Mk(n, t) {
  return new URL(
    n,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
h(Mk, "Hy");
u(Mk, "environmentUrl");
var nN = Object.defineProperty, sN = Object.getOwnPropertyDescriptor, tb = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? sN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && nN(t, e, s), s;
}, "__decorateClass$P"), o2, Lp;
let Ko = (o2 = (Lp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = wt(), this.totalPagesRef = wt(), this.zoomLevelRef = wt(), this.viewerContainerRef = wt(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  ////////
  async open() {
    var t;
    const { pdfjsLib: e } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const i = e.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: ((t = this.CMAP_URL) == null ? void 0 : t.toString()) || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = i, i.onProgress = (s) => {
    };
    try {
      const s = await i.promise;
      this.pdfDocument = s, this.pdfViewer.setDocument(s), this.pdfLinkService.setDocument(s), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: s.fingerprints[0]
      });
    } catch (s) {
      let r = "pdfjs-loading-error";
      s instanceof e.InvalidPDFException ? r = "pdfjs-invalid-file-error" : s instanceof e.MissingPDFException ? r = "pdfjs-missing-file-error" : s instanceof e.UnexpectedResponseException && (r = "pdfjs-unexpected-response-error"), await this.l10n.get(r, void 0, void 0).then((a) => {
        this.pdfViewError(e, a, { message: s == null ? void 0 : s.message });
      });
    }
  }
  async close() {
    var t, e;
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const i = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, (t = this.pdfViewer) == null || t.setDocument(null), (e = this.pdfLinkService) == null || e.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await i;
  }
  pdfViewError(t, e, i) {
    const s = [`PDF.js v${(t == null ? void 0 : t.version) || "?"} (build: ${(t == null ? void 0 : t.build) || "?"})`];
    i && (s.push(`Message: ${i.message}`), i.stack ? s.push(`Stack: ${i.stack}`) : (i.filename && s.push(`File: ${i.filename}`), i.lineNumber && s.push(`Line: ${i.lineNumber}`))), console.error(`${e}

${s.join(`
`)}`);
  }
  ///////
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  fitToPage() {
    this.setScale("page-fit");
  }
  fitToWidth() {
    this.setScale("page-width");
  }
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), (e = this.whenPdfjsResolve) == null || e.call(this, {
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = Mk(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = Mk(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    var t, e, i, s, r, a;
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: o, pdfjsViewer: l } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new l.EventBus(), this.pdfLinkService = new l.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new l.GenericL10n((t = this.weavy) == null ? void 0 : t.locale), this.pdfViewer = new l.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: o.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), (e = this.pdfLinkService) == null || e.setViewer(this.pdfViewer), this.pdfHistory = new l.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), (i = this.pdfLinkService) == null || i.setHistory(this.pdfHistory), (s = this.pdfEventBus) == null || s.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), (r = this.pdfEventBus) == null || r.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), (a = this.pdfEventBus) == null || a.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return v`
      <div class="wy-content-pdf">
        <div class="wy-toolbars-bottom">
          <nav class="wy-toolbar wy-toolbar-center">
            <div class="wy-toolbar-buttons">
              <input
                type="text"
                class="wy-input wy-pdf-page-number"
                ${lt(this.pageNumberRef)}
                @keydown=${Ew}
                @keyup=${Vs}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span class="wy-toolbar-text">/</span>
              <span class="wy-toolbar-text" ${lt(this.totalPagesRef)}>1</span>
            </div>
            <div class="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${C("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                class="wy-input wy-pdf-zoom-level"
                ${lt(this.zoomLevelRef)}
                @keydown=${Ew}
                @keyup=${Vs}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${C("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div class="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${C("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${C("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${lt(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    var t;
    this.resizer.unobserve(this);
    try {
      this.close(), (t = this.pdfViewer) == null || t.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, h(Lp, "Ra"), Lp), u(o2, "WyPdfViewer"), o2);
Ko.styles = [
  yt,
  At
];
tb([
  ve({ context: _e, subscribe: !0 }),
  U()
], Ko.prototype, "weavy", 2);
tb([
  $()
], Ko.prototype, "src", 2);
tb([
  U()
], Ko.prototype, "pdfViewer", 2);
Ko = tb([
  H("wy-pdf-viewer"),
  Ot()
], Ko);
var rN = Object.defineProperty, aN = Object.getOwnPropertyDescriptor, GP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? aN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && rN(t, e, s), s;
}, "__decorateClass$O"), l2, Ip;
let hy = (l2 = (Ip = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.current = !1;
  }
  render() {
    const t = this.file;
    if (!t) return Q;
    const { icon: e } = An(t.name), i = Ei(t.name);
    let s = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (i === ".gif" || i === ".svg") && (s = t.download_url || "");
    const r = s, a = t.external_url, o = t.is_trashed ? "none" : t.preview_format, l = t.name, c = t.width, d = t.height, p = t.media_type, f = t.provider;
    return o === "image" ? v`<wy-preview-image
        src=${r}
        width=${Ct(c)}
        height=${Ct(d)}
      ></wy-preview-image>` : o === "pdf" ? v`<wy-pdf-viewer src=${r}></wy-pdf-viewer>` : o === "video" || o === "audio" ? v`<wy-preview-media
        format=${o}
        src=${r}
        name=${l}
        mediaType=${p}
        ?play=${this.current}
      ></wy-preview-media>` : o === "text" ? v`<wy-preview-text src=${r}></wy-preview-text>` : o === "code" ? v`<wy-preview-text src=${r} ?html=${!/^(?:blob:|data:)/.test(r)} code></wy-preview-text>` : o === "html" ? v`<wy-preview-text src=${r} html></wy-preview-text>` : o === "embed" ? v`<wy-preview-embed
        src=${r}
        name=${l}
        icon=${e}
        provider=${Ct(f)}
      ></wy-preview-embed>` : o === "none" ? a ? v`<wy-preview-icon src=${a} icon=${e} provider=${Ct(f)}></wy-preview-icon>` : v`<wy-preview-icon src=${r} icon=${e}></wy-preview-icon>` : Q;
  }
}, h(Ip, "Oa"), Ip), u(l2, "WyPreviewItem"), l2);
hy.styles = [
  yt,
  At
];
GP([
  $({ type: Object })
], hy.prototype, "file", 2);
GP([
  $({ type: Boolean })
], hy.prototype, "current", 2);
hy = GP([
  H("wy-preview-item")
], hy);
var oN = Object.defineProperty, lN = Object.getOwnPropertyDescriptor, Ty = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? lN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && oN(t, e, s), s;
}, "__decorateClass$N"), c2, Zp;
let aa = (c2 = (Zp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.noWrapper = !1, this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, i) {
    if (this.hasEventListener) {
      const s = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, s) && Object.assign(this.hasEventListener, {
        [s]: !0
      });
    }
    super.addEventListener(t, e, i);
  }
  triggerDownload() {
    this.file && Uc(this.file.download_url, "_top", this.file.name, !0);
  }
  triggerExternal() {
    this.file && Uc(this.file.external_url, "_blank", this.file.name);
  }
  triggerApplication() {
    this.file && Uc(this.file.application_url, "_top", this.file.name);
  }
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    var t;
    if (!this.file)
      return Q;
    const { icon: e } = An(this.file.name), i = this.file.id >= 1, s = this.file.provider, r = this.file.provider || "app";
    return v`
      <wy-dropdown directionX="left" ?noWrapper=${this.noWrapper} ?small=${this.small}>
        ${i && this.file.is_trashed ? v`
              ${this.hasEventListener.restore ? v`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${C("Restore")}
                    </wy-dropdown-item>
                  ` : Q}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? v` <wy-dropdown-divider></wy-dropdown-divider> ` : Q}
              ${this.hasEventListener["delete-forever"] ? v`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${C("Delete")}
                    </wy-dropdown-item>
                  ` : Q}
            ` : Q}
        ${this.file.is_trashed ? Q : v`
              ${this.file.external_url ? v`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${e}></wy-icon>
                      ${C(at`Open in ${s}`)}
                    </wy-dropdown-item>
                  ` : v`
                    ${(t = this.componentFeatures) != null && t.allowsFeature(_.WebDAV) && this.file.application_url ? v`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? LS(this.file.provider) : e}
                            ></wy-icon>
                            ${C(at`Open in ${r}`)}
                          </wy-dropdown-item>
                        ` : Q}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${C("Download")}
                    </wy-dropdown-item>
                  `}
              ${i ? v`
                    ${this.hasEventListener["edit-name"] ? v`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${C("Rename")}
                          </wy-dropdown-item>
                        ` : Q}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${C("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${C("Subscribe")}
                            </wy-dropdown-item>
                          ` : Q}
                    ${this.hasEventListener.trash ? v`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${C("Trash")}
                          </wy-dropdown-item>
                        ` : Q}
                  ` : Q}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, h(Zp, "La"), Zp), u(c2, "WyFileMenu"), c2);
Ty([
  ve({ context: W0, subscribe: !0 }),
  U()
], aa.prototype, "componentFeatures", 2);
Ty([
  $({ type: Object })
], aa.prototype, "file", 2);
Ty([
  $({ type: Boolean })
], aa.prototype, "noWrapper", 2);
Ty([
  $({ type: Boolean })
], aa.prototype, "small", 2);
Ty([
  $({ type: Object })
], aa.prototype, "hasEventListener", 2);
aa = Ty([
  H("wy-file-menu"),
  Ot()
], aa);
function vL(n, t, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ u(async (s) => {
      const r = s.pageParam, a = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + r, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
h(vL, "Q2");
u(vL, "getCommentsOptions");
function bL(n, t) {
  return {
    mutationFn: /* @__PURE__ */ u(async (e) => await (await n.fetch("/api/comments/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ u((e, i) => {
      i.id && we(n.queryClient, [i.type, i.parent_id, "comments"], i.id, (s) => {
        s.text = e.text, s.html = e.html, s.attachments = e.attachments, s.meeting = e.meeting, s.updated_at = e.updated_at, s.updated_by = e.updated_by, s.options = e.options, s.embed = e.embed;
      });
    }, "onSuccess")
  };
}
h(bL, "K2");
u(bL, "getUpdateCommentMutationOptions");
function OL(n) {
  const t = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ u(async (e) => await (await n.fetch("/api/" + e.type + "/" + e.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        embed_id: e.embed_id,
        context: e.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ u(async (e) => {
      const i = [e.type, e.parent_id, "comments"];
      await t.cancelQueries({ queryKey: i });
      const s = ea(n.queryClient, i, !1);
      if (e.user) {
        const r = {
          id: s ? s.id - 1 : -1,
          app: e.type === "apps" ? { id: e.parent_id } : { id: -1 },
          is_trashed: !1,
          text: e.text,
          html: e.text,
          plain: e.text,
          created_by: e.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        e.type === "files" ? r.parent = { type: oi.File, id: e.parent_id } : e.type === "posts" && (r.parent = { type: oi.Post, id: e.parent_id }), ta(t, i, r, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((e, i) => {
      var s, r;
      const a = [i.type, ((s = e.parent) == null ? void 0 : s.id) ?? e.app.id, "comments"];
      if (!og(n.queryClient, a, e.id)) {
        const o = ea(n.queryClient, a, !0);
        o ? we(n.queryClient, a, o.id, (l) => {
          l.id = e.id, l.app = e.app, l.text = e.text, l.html = e.html, l.embed = e.embed, l.meeting = e.meeting, l.attachments = e.attachments, l.options = e.options, l.created_at = e.created_at, l.created_by = e.created_by, l.updated_at = e.updated_at, l.updated_by = e.updated_by;
        }) : ta(n.queryClient, a, e), ((r = e.parent) == null ? void 0 : r.type) === oi.Post && we(t, ["posts", e.app.id], e.parent.id, (l) => {
          l.comments ? l.comments.count += 1 : l.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
h(OL, "G2");
u(OL, "getAddCommentMutationOptions");
function $L(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ u(async ({ id: r }) => {
      if (!(await n.fetch("/api/comments/" + r + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((r) => {
      $t(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((r, a) => {
      $t(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, r)
      ), we(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return s;
}
h($L, "Z2");
u($L, "getTrashCommentMutationOptions");
function xL(n, t, e) {
  return new Vt(n.queryClient, $L(n, t, e));
}
h(xL, "Y2");
u(xL, "getTrashCommentMutation");
function kL(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ u(async ({ id: r }) => {
      const a = await n.fetch("/api/comments/" + r + "/restore", { method: "POST" });
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((r) => {
      $t(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((r, a) => {
      $t(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, r)
      ), we(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count += 1;
      });
    }, "onSuccess")
  };
  return s;
}
h(kL, "X2");
u(kL, "getRestoreCommentMutationOptions");
function SL(n, t, e) {
  return new Vt(n.queryClient, kL(n, t, e));
}
h(SL, "J2");
u(SL, "getRestoreCommentMutation");
var cN = Object.defineProperty, hN = Object.getOwnPropertyDescriptor, PL = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? hN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && cN(t, e, s), s;
}, "__decorateClass$M"), h2, Wp;
let Fw = (h2 = (Wp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div class="wy-item">
        <div class="wy-item-body">${C("Comment was trashed.")}</div>
        <wy-button @click=${() => this.dispatchRestore()} color="variant">${C("Undo")}</wy-button>
      </div>
    `;
  }
}, h(Wp, "Ia"), Wp), u(h2, "WyCommentTrashed"), h2);
Fw.styles = yt;
PL([
  $({ type: Number })
], Fw.prototype, "commentId", 2);
Fw = PL([
  H("wy-comment-trashed"),
  Ot()
], Fw);
const dN = 1e3 * 60 * 60, d2 = dN * 24;
function Ay(n, t, e, i = 7) {
  e ?? (e = /* @__PURE__ */ new Date());
  const s = new Date(e.getFullYear(), e.getMonth(), e.getDate()), r = t.valueOf() - e.valueOf(), a = t.toDateString() === e.toDateString(), o = t.valueOf() > s.valueOf() - d2 * i && t.valueOf() < s.valueOf() + d2 * i;
  if (!a && o) {
    const l = Math.round(r / d2);
    return new Intl.RelativeTimeFormat(n, { numeric: "auto" }).format(l, "days");
  } else return a ? new Intl.DateTimeFormat(n, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(n, { dateStyle: "short" }).format(t);
}
h(Ay, "pl");
u(Ay, "relativeTime");
var uN = Object.defineProperty, pN = Object.getOwnPropertyDescriptor, eb = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? pN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && uN(t, e, s), s;
}, "__decorateClass$L"), u2, Dp;
let Jo = (u2 = (Dp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new Cn(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(Gz(this.weavy, this.option.id));
  }
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  openSheet(t) {
    var e;
    t.preventDefault(), t.stopPropagation(), (e = this.getVotesQuery.observer) == null || e.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    var t, e;
    if (!this.option || !this.option.id)
      return Q;
    const { data: i, isLoading: s } = this.getVotesQuery.result ?? {}, r = this.totalVotes > 0 ? Math.round((((t = this.option.votes) == null ? void 0 : t.count) || 0) / this.totalVotes * 100) : 0;
    return v`
      <div
        class="wy-item wy-list-item wy-poll-option"
        tabindex="0"
        @click=${() => {
      var a;
      return this.dispatchVote((a = this.option) == null ? void 0 : a.id);
    }}
        @keydown=${je}
        @keyup=${gi}
      >
        <div class="wy-progress" style="width: ${r + "%"}"></div>
        ${this.option.has_voted ? v`<wy-icon name="check-circle"></wy-icon>` : v`<wy-icon name="circle-outline"></wy-icon>`}
        <div class="wy-item-body">${this.option.text}</div>
        ${r > 0 ? v`<span
              class="wy-facepile"
              tabindex="0"
              @click=${(a) => this.openSheet(a)}
              @keydown=${je}
              @keyup=${gi}
            >
              ${r + "%"}
            </span>` : Q}
      </div>

      ${this.weavy ? v`
            <wy-sheet
              .show=${this.showSheet}
              @close=${() => this.showSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <span slot="appbar-text">${C(at`Votes on ${this.option.text}`)}</span>
              <!-- <wy-spinner></wy-spinner> -->
              ${this.showSheet && i && !s ? v`
                    ${(e = i.votes) != null && e.data ? i.votes.data.map(
      (a) => v`
                        <div class="wy-item wy-list-item">
                          <wy-avatar .size=${32} .src=${a.avatar_url} .name=${a.name}></wy-avatar>
                          <div class="wy-item-body">${a.name}</div>
                        </div>
                      `
    ) : Q}
                  ` : Q}
            </wy-sheet>
          ` : Q}
    `;
  }
}, h(Dp, "Ta"), Dp), u(u2, "WyPollOption"), u2);
Jo.styles = yt;
eb([
  $({ type: Number, attribute: !1 })
], Jo.prototype, "totalVotes", 2);
eb([
  $({ attribute: !1 })
], Jo.prototype, "option", 2);
eb([
  U()
], Jo.prototype, "showSheet", 2);
Jo = eb([
  H("wy-poll-option"),
  Ot()
], Jo);
var fN = Object.defineProperty, yN = Object.getOwnPropertyDescriptor, CL = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? yN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && fN(t, e, s), s;
}, "__decorateClass$K"), p2, qp;
let Uw = (p2 = (qp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.pollOptions = [];
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, i) => {
      var s;
      return e + (((s = i.votes) == null ? void 0 : s.count) || 0);
    }, 0);
    return v`
      <div class="wy-poll">
        ${this.pollOptions.map(
      (e) => v`<wy-poll-option
              @vote=${(i) => this.dispatchVote(i.detail.optionId)}
              .option=${e}
              .totalVotes=${t}></wy-poll-option>`
    )}
      </div>
    `;
  }
}, h(qp, "Fa"), qp), u(p2, "WyPoll"), p2);
Uw.styles = [
  yt,
  Mt`
      :host {
        display: grid;
      }
    `
];
CL([
  $({ type: Array, attribute: !1 })
], Uw.prototype, "pollOptions", 2);
Uw = CL([
  H("wy-poll")
], Uw);
var mN = Object.defineProperty, wN = Object.getOwnPropertyDescriptor, ni = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? wN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && mN(t, e, s), s;
}, "__decorateClass$J"), f2, Vp;
let Me = (f2 = (Vp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isTrashed = !1, this.text = "", this.html = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt(), this.highlight = !1;
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && cg(this.link, oi.Comment, { id: this.commentId }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    var t, e, i, s, r, a, o, l;
    const c = ((t = this.attachments) == null ? void 0 : t.filter((m) => m.kind === "image" && m.thumbnail_url)) || [], d = ((e = this.attachments) == null ? void 0 : e.filter((m) => m.kind !== "image" || !m.thumbnail_url)) || [], p = new Intl.DateTimeFormat((i = this.weavy) == null ? void 0 : i.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), f = Ay((s = this.weavy) == null ? void 0 : s.locale, new Date(this.createdAt));
    return this.commentId < 0 ? v`<div class="wy-item wy-item-sm wy-comment-header">
            <wy-avatar
              .src="${this.createdBy.avatar_url}"
              .size=${32}
              .name=${this.createdBy.name}
              .isAgent=${this.createdBy.is_agent}
            ></wy-avatar>
            <div class="wy-item-body">
              <div class="wy-item-title"><span class="wy-placeholder">${this.createdBy.name}</span></div>
              <div class="wy-item-text">
                <time class="wy-placeholder">${f}</time>
              </div>
            </div>
          </div>
          <div class="wy-comment-body">
            <div class="wy-comment-content">
              ${this.html ? v`<div class="wy-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>` : ""}
            </div>
          </div>` : v`<div class="wy-item wy-comment-header" ${lt(this.highlightRef)}>
            <wy-avatar
              .src=${this.createdBy.avatar_url}
              .size=${32}
              .name=${this.createdBy.name}
              .isAgent=${this.createdBy.is_agent}
            ></wy-avatar>
            <div class="wy-item-body">
              <div class="wy-item-title">${this.createdBy.name}</div>
              <div class="wy-item-text">
                <time datetime=${this.createdAt} title=${p}>${f}</time>
                ${this.modifiedAt ? v`<time datetime=${this.modifiedAt}> · ${C("edited")}</time>` : Q}
              </div>
            </div>

            ${this.user && this.user.id === this.createdBy.id ? v`
                  <div class="wy-item-actions wy-item-top">
                    <wy-dropdown>
                      ${this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                            <wy-icon name="pencil"></wy-icon>
                            ${C("Edit")}
                          </wy-dropdown-item>` : Q}
                      ${this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="trashcan"></wy-icon>
                            ${C("Trash")}
                          </wy-dropdown-item>` : Q}
                    </wy-dropdown>
                  </div>
                ` : Q}
          </div>
          <div class="wy-comment-body">
            <div class="wy-comment-content">
              <!-- annotations -->
              ${this.annotations && this.annotations.length ? v`<wy-annotations-list
                    class="wy-message-area"
                    .files=${this.annotations}
                    @file-open=${(m) => {
      var w;
      (w = this.previewAnnotationsRef.value) == null || w.open(m.detail.fileId);
    }}
                  ></wy-annotations-list>` : ""}

              <!-- image grid -->
              ${c && c.length ? v`<wy-image-grid
                    class="wy-comment-area"
                    .images=${c}
                    @file-open=${(m) => {
      var w;
      (w = this.previewAttachmentsRef.value) == null || w.open(m.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

              <!-- embeds -->
              ${this.embed && (r = this.componentFeatures) != null && r.allowsFeature(_.Embeds) ? v` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : Q}
              ${this.html ? v`<div class="wy-content">${Bo(this.html)}</div>` : ""}

              <!-- poll -->
              ${this.pollOptions && this.pollOptions.length > 0 ? v`
                    <wy-poll
                      .pollOptions=${this.pollOptions}
                      @vote=${(m) => this.dispatchVote(m.detail.optionId)}
                    ></wy-poll>
                  ` : Q}

              <!-- files -->
              ${d && d.length ? v`<wy-attachments-list
                    .files=${d ?? []}
                    @file-open=${(m) => {
      var w;
      (w = this.previewAttachmentsRef.value) == null || w.open(m.detail.fileId);
    }}
                  ></wy-attachments-list>` : ""}

              <!-- meeting -->
              ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}
            </div>
          </div>

          ${(a = this.componentFeatures) != null && a.allowsFeature(_.Reactions) ? v` <wy-reactions
                lineBottom
                small
                .reactions=${this.reactions}
                parentType=${this.location}
                parentId=${this.parentId}
                entityId=${this.commentId}
                entityType="comments"
              ></wy-reactions>` : Q}
          ${(o = this.annotations) != null && o.length ? v`<wy-preview
                ${lt(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview> ` : Q}
          ${(l = this.attachments) != null && l.length ? v`<wy-preview
                ${lt(this.previewAttachmentsRef)}
                .files=${[...c, ...d]}
                .isAttachment=${!0}
              ></wy-preview> ` : Q} `;
  }
  updated(t) {
    var e;
    t.has("highlight") && this.highlight && ((e = this.highlightRef.value) == null || e.scrollIntoView({ block: "nearest" }));
  }
}, h(Vp, "Da"), Vp), u(f2, "WyCommentView"), f2);
Me.styles = yt;
ni([
  $({ type: Number })
], Me.prototype, "commentId", 2);
ni([
  $({ type: Number })
], Me.prototype, "parentId", 2);
ni([
  $({ attribute: !1 })
], Me.prototype, "location", 2);
ni([
  $({ attribute: !1 })
], Me.prototype, "createdBy", 2);
ni([
  $()
], Me.prototype, "createdAt", 2);
ni([
  $()
], Me.prototype, "modifiedAt", 2);
ni([
  $({ type: Boolean })
], Me.prototype, "isTrashed", 2);
ni([
  $()
], Me.prototype, "text", 2);
ni([
  $()
], Me.prototype, "html", 2);
ni([
  $({ type: Array })
], Me.prototype, "annotations", 2);
ni([
  $({ type: Array })
], Me.prototype, "attachments", 2);
ni([
  $({ attribute: !1 })
], Me.prototype, "embed", 2);
ni([
  $({ type: Array })
], Me.prototype, "pollOptions", 2);
ni([
  $({ attribute: !1 })
], Me.prototype, "meeting", 2);
ni([
  $({ type: Array })
], Me.prototype, "reactions", 2);
ni([
  $({ type: Boolean })
], Me.prototype, "highlight", 2);
Me = ni([
  H("wy-comment-view"),
  Ot()
], Me);
var y2, Q3;
function QL() {
  if (Q3) return y2;
  Q3 = 1;
  var n = "Expected a function", t = NaN, e = "[object Symbol]", i = /^\s+|\s+$/g, s = /^[-+]0x[0-9a-f]+$/i, r = /^0b[01]+$/i, a = /^0o[0-7]+$/i, o = parseInt, l = typeof Bg == "object" && Bg && Bg.Object === Object && Bg, c = typeof self == "object" && self && self.Object === Object && self, d = l || c || Function("return this")(), p = Object.prototype, f = p.toString, m = Math.max, w = Math.min, b = /* @__PURE__ */ u(function() {
    return d.Date.now();
  }, "now");
  function x(I, Z, W) {
    var V, Y, G, X, st, tt, Qt = 0, vt = !1, It = !1, Wt = !0;
    if (typeof I != "function")
      throw new TypeError(n);
    Z = T(Z) || 0, P(W) && (vt = !!W.leading, It = "maxWait" in W, G = It ? m(T(W.maxWait) || 0, Z) : G, Wt = "trailing" in W ? !!W.trailing : Wt);
    function Dt(Nt) {
      var pn = V, ga = Y;
      return V = Y = void 0, Qt = Nt, X = I.apply(ga, pn), X;
    }
    h(Dt, "Rt"), u(Dt, "invokeFunc");
    function bi(Nt) {
      return Qt = Nt, st = setTimeout(ee, Z), vt ? Dt(Nt) : X;
    }
    h(bi, "et"), u(bi, "leadingEdge");
    function Ee(Nt) {
      var pn = Nt - tt, ga = Nt - Qt, wl = Z - pn;
      return It ? w(wl, G - ga) : wl;
    }
    h(Ee, "xt"), u(Ee, "remainingWait");
    function le(Nt) {
      var pn = Nt - tt, ga = Nt - Qt;
      return tt === void 0 || pn >= Z || pn < 0 || It && ga >= G;
    }
    h(le, "si"), u(le, "shouldInvoke");
    function ee() {
      var Nt = b();
      if (le(Nt))
        return fe(Nt);
      st = setTimeout(ee, Ee(Nt));
    }
    h(ee, "Be"), u(ee, "timerExpired");
    function fe(Nt) {
      return st = void 0, Wt && V ? Dt(Nt) : (V = Y = void 0, X);
    }
    h(fe, "Li"), u(fe, "trailingEdge");
    function Oi() {
      st !== void 0 && clearTimeout(st), Qt = 0, V = tt = Y = st = void 0;
    }
    h(Oi, "Ii"), u(Oi, "cancel");
    function _i() {
      return st === void 0 ? X : fe(b());
    }
    h(_i, "dc"), u(_i, "flush");
    function Hi() {
      var Nt = b(), pn = le(Nt);
      if (V = arguments, Y = this, tt = Nt, pn) {
        if (st === void 0)
          return bi(tt);
        if (It)
          return st = setTimeout(ee, Z), Dt(tt);
      }
      return st === void 0 && (st = setTimeout(ee, Z)), X;
    }
    return h(Hi, "fi"), u(Hi, "debounced"), Hi.cancel = Oi, Hi.flush = _i, Hi;
  }
  h(x, "z"), u(x, "debounce");
  function O(I, Z, W) {
    var V = !0, Y = !0;
    if (typeof I != "function")
      throw new TypeError(n);
    return P(W) && (V = "leading" in W ? !!W.leading : V, Y = "trailing" in W ? !!W.trailing : Y), x(I, Z, {
      leading: V,
      maxWait: Z,
      trailing: Y
    });
  }
  h(O, "_"), u(O, "throttle");
  function P(I) {
    var Z = typeof I;
    return !!I && (Z == "object" || Z == "function");
  }
  h(P, "P"), u(P, "isObject");
  function A(I) {
    return !!I && typeof I == "object";
  }
  h(A, "E"), u(A, "isObjectLike");
  function R(I) {
    return typeof I == "symbol" || A(I) && f.call(I) == e;
  }
  h(R, "q"), u(R, "isSymbol");
  function T(I) {
    if (typeof I == "number")
      return I;
    if (R(I))
      return t;
    if (P(I)) {
      var Z = typeof I.valueOf == "function" ? I.valueOf() : I;
      I = P(Z) ? Z + "" : Z;
    }
    if (typeof I != "string")
      return I === 0 ? I : +I;
    I = I.replace(i, "");
    var W = r.test(I);
    return W || a.test(I) ? o(I.slice(2), W ? 2 : 8) : s.test(I) ? t : +I;
  }
  return h(T, "R"), u(T, "toNumber"), y2 = O, y2;
}
h(QL, "l5");
u(QL, "requireLodash_throttle");
var gN = QL();
const Tk = /* @__PURE__ */ pE(gN);
function ML(n, t) {
  return new Vt(n.queryClient, {
    mutationFn: /* @__PURE__ */ u(async () => await n.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
h(ML, "h5");
u(ML, "typingMutation");
function Ak(n, t) {
  return new Vt(n.queryClient, {
    mutationFn: /* @__PURE__ */ u(async () => {
      const e = await n.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
h(Ak, "By");
u(Ak, "addMeetingMutation");
async function TL(n, t) {
  const e = await n.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const i = await e.json();
    throw new Error(i.detail || i.title, { cause: i });
  }
  return await e.json();
}
h(TL, "u5");
u(TL, "externalBlob");
function AL(n, t, e, i) {
  const s = n.queryClient, r = ["apps", e, "blobs", i];
  return {
    mutationFn: /* @__PURE__ */ u(async (a) => await TL(n, a.externalBlob), "mutationFn"),
    mutationKey: r,
    onMutate: /* @__PURE__ */ u(async (a) => (await s.cancelQueries({ queryKey: r, exact: !0 }), { type: "attach", file: hP(void 0, a.externalBlob.name, a.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((a, o, l) => {
      re(s, r, o, (c) => {
        c.status.state = "ok", c.status.progress = void 0, c.status.text = void 0;
      });
    }, "onSuccess"),
    onError(a, o, l) {
      const c = a.cause;
      c && c.status === 409 ? re(s, r, o, (d) => {
        d.status.state = "conflict", d.status.progress = void 0, d.status.text = c.detail || c.title;
      }) : re(s, r, o, (d) => {
        d && (d.status.state = "error", d.status.progress = void 0, d.status.text = c.detail || c.title);
      });
    }
  };
}
h(AL, "p5");
u(AL, "getExternalBlobMutationOptions");
function KP(n, t, e, i) {
  return new Vt(n.queryClient, AL(n, t, e, i));
}
h(KP, "sm");
u(KP, "getExternalBlobMutation");
const vN = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let vc = [], Bw = [], e0 = [], I1 = [], Ss = {};
const bN = /* @__PURE__ */ u((n, t) => n.length === t.length && n.every((e, i) => e === t[i]), "arrayEquals");
function RL() {
  return !!Object.keys(Ss).length;
}
h(RL, "f5");
u(RL, "isFetchingEmbeds");
async function EL(n, t) {
  new FormData().append("url", n);
  let e;
  try {
    const i = await t.fetch("/api/embeds", { method: "POST", body: JSON.stringify({ url: n }) });
    if (!i.ok)
      throw new Error();
    e = await i.json(), delete Ss[n], Bw = [...Bw, n];
  } catch {
    e0 = [...e0, n], delete Ss[n];
  }
  return e;
}
h(EL, "m5");
u(EL, "fetchEmbed");
const ON = /* @__PURE__ */ u(() => {
  vc = [], Bw = [], e0 = [], I1 = [], Ss = {};
}, "clearEmbeds"), M3 = /* @__PURE__ */ u((n) => {
  Bw = n;
}, "initEmbeds"), $N = /* @__PURE__ */ u((n, t, e) => {
  var i;
  let s = ((i = n.match(vN)) == null ? void 0 : i.map((r) => r)) || null;
  if (s !== null && (s = s.map((r) => r.startsWith("//") ? "http:" + r : !r.startsWith("http://") && !r.startsWith("https://") ? "http://" + r : r)), !(s === null || s.length === 0) && (s.length !== vc.length || !bN(s, vc))) {
    vc = s, s.forEach((r) => {
      !Bw.includes(r) && !e0.includes(r) && !I1.includes(r) && typeof Ss[r] > "u" && (ti(), Ss[r] = window.setTimeout(async () => {
        const a = await EL(r, e);
        a && t(a);
      }, 500));
    }), I1 = I1.filter((r) => vc.includes(r));
    for (const r in Ss)
      vc.includes(r) || (ti(), window.clearTimeout(Ss[r]), delete Ss[r]);
  }
}, "getEmbeds");
var Xm, jp;
const zL = (jp = class {
  constructor(t) {
    F(this, Xm, !1), t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return k(this, Xm);
  }
  set isDragActive(t) {
    k(this, Xm) !== t && (L(this, Xm, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    var e, i;
    t.preventDefault();
    const s = [];
    (e = t.dataTransfer) != null && e.items ? [...t.dataTransfer.items].forEach((r) => {
      if (r.kind === "file") {
        const a = r.getAsFile();
        a ? s.push(a) : console.error("Could not add file");
      }
    }) : (i = t.dataTransfer) != null && i.files && [...t.dataTransfer.files].forEach((r) => {
      s.push(r);
    }), s.length && this.dispatchUploadFiles(s), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
}, h(jp, "Kp"), jp);
Xm = /* @__PURE__ */ new WeakMap(), u(zL, "DropZoneController");
let _L = zL;
const Ji = a0() ? window.navigator.userAgent : "", LL = Ji.includes("iPad") || Ji.includes("Android") && !Ji.includes("Mobi") || !1, xN = Ji.includes("Mobi") || LL || !1, kN = !xN && !LL, T3 = Ji.includes("Windows") ? "Windows" : Ji.includes("Macintosh") ? "Mac" : Ji.includes("iPad") || Ji.includes("iPhone") || Ji.includes("iPod") ? "iOS" : Ji.includes("Android") ? "Android" : void 0;
T3 === "Android" && Ji.includes("; wv") || T3 === "iOS" && Ji.includes("Safari");
var SN = Object.defineProperty, PN = Object.getOwnPropertyDescriptor, Ry = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? PN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && SN(t, e, s), s;
}, "__decorateClass$I"), m2, Fp;
let Bs = (m2 = (Fp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.status = {
      state: "ok"
    }, this.hasHover = !0, this.isRenaming = !1;
  }
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file;
    if (!t) return Q;
    const { icon: e } = An(t.name), i = Q_(this.actionType), s = Ei(t.name), r = Ks(t.provider), a = /* @__PURE__ */ u((l) => {
      l.stopImmediatePropagation();
      const c = l.target;
      c.value && c.value !== t.name ? this.dispatchRename(t, c.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), o = /* @__PURE__ */ u((l) => {
      const c = l.target;
      l.key === "Escape" ? (l.preventDefault(), c.value = t.name, c.blur()) : l.key === "Enter" && (l.preventDefault(), c.blur());
    }, "handleRenameKey");
    return v`
      <div
        class="wy-item wy-list-item ${Xt({
      "wy-item-trashed": t.is_trashed,
      "wy-item-hover": this.hasHover && !t.is_trashed && !this.isRenaming
    })}"
        title=${t.name}>
        ${this.status.state === "error" ? v`<wy-icon name="alert-octagon" color="error" title=${Ct(this.status.text)}></wy-icon>` : this.status.state === "conflict" ? v`<wy-icon name="alert" color="yellow" title=${Ct(this.status.text)}></wy-icon>` : this.status.state === "pending" ? v`<wy-spinner ?nospin=${!!this.status.progress} .progress=${this.status.progress}></wy-spinner>` : v`<wy-icon .name=${e} .overlayName=${r} .overlayPath=${i} .size=${24} .kind=${t.kind} ext=${s}></wy-icon>`}
        <div class="wy-item-body">
          ${this.isRenaming ? v`
                <input
                  type="text"
                  maxlength="256"
                  class="wy-input"
                  .defaultValue=${t.name}
                  @blur=${a}
                  @keyup=${(l) => {
      Vs(l), o(l);
    }}
                  @click=${(l) => l.preventDefault()}
                  @focus=${V0}
                  ${lt(Zk)} />
              ` : v`
                <span title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}
                  ><slot name="title"
                    >${this.title || t.name}${this.status.text ? v`: <em>${this.status.text}</em>` : Q}</slot
                  ></span
                >
              `}
        </div>
        <div class="wy-item-actions">
          <slot name="actions">
            <wy-file-menu
              .file=${t}
              @edit-name=${(l) => this.dispatchEditName(l.detail.file)}
              @trash=${(l) => this.dispatchTrash(l.detail.file)}
              @restore=${(l) => this.dispatchRestore(l.detail.file)}
              @delete-forever=${(l) => this.dispatchDeleteForever(l.detail.file)}
              @subscribe=${(l) => this.dispatchSubscribe(l.detail.file, l.detail.subscribe)}>
            </wy-file-menu>
          </slot>
        </div>
      </div>
    `;
  }
}, h(Fp, "Va"), Fp), u(m2, "WyFileItem"), m2);
Bs.styles = yt;
Ry([
  $({ type: Object })
], Bs.prototype, "file", 2);
Ry([
  $({ type: Object })
], Bs.prototype, "status", 2);
Ry([
  $({ type: Boolean })
], Bs.prototype, "hasHover", 2);
Ry([
  $()
], Bs.prototype, "actionType", 2);
Ry([
  U()
], Bs.prototype, "isRenaming", 2);
Bs = Ry([
  H("wy-file-item")
], Bs);
const CN = Mt`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-40, #006399));--_warning-color: var(--wy-warning, var(--wy-warning-70, #afb140));--_error-color: var(--wy-error, var(--wy-error-40, #ba1824));--_track-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));display:contents;position:relative}[part~=wy-progress]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;top:0;right:0;bottom:0;left:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress][part~=wy-progress-overlay],[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{top:0;right:0;bottom:0;left:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);top:0;right:0;bottom:0;left:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var QN = Object.defineProperty, MN = Object.getOwnPropertyDescriptor, er = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? MN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && QN(t, e, s), s;
}, "__decorateClass$H"), w2, Up;
let cn = (w2 = (Up = class extends ft {
  constructor() {
    super(...arguments), this.shadowParts = new nt(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    const t = {
      transform: `scaleX(${(this.indeterminate ? 1 : this.value / this.max) * 100}%)`
    }, e = {
      "wy-indeterminate": this.indeterminate,
      "wy-progress-overlay": this.overlay,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return v`
      <div
        part="wy-progress ${Qe(e)}"
        role="progressbar"
        aria-label="${Q}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${this.indeterminate ? Q : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${zw(t)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, h(Up, "Ba"), Up), u(w2, "WyProgressLinear"), w2);
cn.styles = [Ie, CN];
er([
  $({ type: Boolean })
], cn.prototype, "padded", 2);
er([
  $({ type: Boolean })
], cn.prototype, "overlay", 2);
er([
  $({ type: Boolean })
], cn.prototype, "reveal", 2);
er([
  $({ type: Number })
], cn.prototype, "value", 2);
er([
  $({ type: Number })
], cn.prototype, "max", 2);
er([
  $({ type: Boolean })
], cn.prototype, "indeterminate", 2);
er([
  $({ type: Boolean })
], cn.prototype, "warning", 2);
er([
  $({ type: Boolean })
], cn.prototype, "error", 2);
cn = er([
  H("wy-progress-linear")
], cn);
var TN = Object.defineProperty, AN = Object.getOwnPropertyDescriptor, te = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? AN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && TN(t, e, s), s;
}, "__decorateClass$G"), g2, Bp;
let qt = (g2 = (Bp = class extends Lt {
  constructor() {
    super(), this.exportParts = new nt(this), this.storage = WS("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this.embeds = [], this.draftKey = "", this.uploadBlobMutation = new sn(
      this
    ), this.mutatingFiles = new rg(this), this.fileInputRef = wt(), this.cloudFilesRef = wt(), this.dropZone = new _L(this), this.keyMap = [], this.editorRef = wt(), this.editorInitialized = !1, this.throttledTyping = Tk(
      async () => {
        this.weavy && this.app && !qv.has(this.app.type) && await ML(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = Tk(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      var t;
      (t = this.fileInputRef.value) == null || t.click();
    }, this.openCloudFiles = () => {
      var t;
      (t = this.cloudFilesRef.value) == null || t.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), i = await Ak(this.weavy, e).mutate();
        i.auth_url || (this.meeting = i);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", Ew), this.addEventListener("keyup", Vs);
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  selectAllContent() {
    var t;
    (t = this.editor) == null || t.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  setCursorLast() {
    var t;
    (t = this.editor) == null || t.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  focusInput() {
    var t;
    (t = this.editor) == null || t.focus();
  }
  willUpdate(t) {
    var e, i;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? ((e = this.app) == null ? void 0 : e.id) ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        j0(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = KP(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const s = this.storage.getItem(this.draftKey);
        if (s) {
          const r = JSON.parse(s);
          this.text = r.text, this.embeds = r.embeds, this.meeting = r.meeting, ((i = r.pollOptions) == null ? void 0 : i.length) > 0 && (this.showPolls = !0, this.pollOptions = r.pollOptions), M3(this.embeds.map((a) => a.original_url));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], M3(this.embeds.map((s) => s.original_url))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: i,
          history: s,
          dropCursor: r,
          mentions: a,
          autocompletion: o,
          placeholder: l,
          keymap: c,
          weavyKeymap: d,
          defaultKeymap: p,
          historyKeymap: f,
          markdown: m,
          languages: w,
          EditorView: b,
          EditorState: x,
          weavyDesktopMessageKeymap: O,
          Compartment: P
        }) => {
          var A, R, T;
          this.editorInitialized = !0, this.editorRef.value && !this.editor && (this.editorRef.value.innerHTML = ""), this.editorEditable = new P(), this.editorPlaceholder = new P(), this.EditorView = b, this.placeholderExtension = l;
          const I = this.editorType === "messages" && kN && O ? [...O] : [];
          this.editorExtensions = [
            b.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on"
            }),
            s(),
            r(),
            a,
            o({
              override: (A = this.componentFeatures) != null && A.allowsFeature(_.Mentions) ? [(Z) => this.autocomplete(Z)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ u(function(Z, W) {
                    var V, Y, G, X;
                    const st = document.createElement("div");
                    st.classList.add("wy-item"), st.classList.add("wy-list-item"), st.classList.add("wy-item-hover"), (!((V = Z.item) != null && V.access) || Z.item.access === yr.None) && st.classList.add("wy-disabled");
                    const tt = document.createElement("wy-avatar");
                    tt.src = ((Y = Z.item) == null ? void 0 : Y.avatar_url) || "", tt.name = ((G = Z.item) == null ? void 0 : G.name) || "";
                    const Qt = document.createElement("div");
                    return Qt.classList.add("wy-item-body"), Qt.innerText = ((X = Z.item) == null ? void 0 : X.name) || "", st.appendChild(tt), st.appendChild(Qt), st;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            i(e, { fallback: !0 }),
            b.lineWrapping,
            c.of([...I, ...d, ...p, ...f]),
            m({ codeLanguages: w }),
            b.domEventHandlers({
              paste: /* @__PURE__ */ u((Z, W) => {
                var V, Y;
                let G = [];
                const X = ((V = Z.clipboardData) == null ? void 0 : V.items) || [];
                for (const st of X)
                  if (st.kind === "file") {
                    const tt = st.getAsFile();
                    tt && (G = [...G, tt]);
                  }
                if ((Y = this.componentFeatures) != null && Y.allowsFeature(_.Attachments) && G.length > 0) {
                  for (let st = 0; st < G.length; st++)
                    this.handleUploadFiles(G);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ u((Z, W) => {
                var V, Y;
                this.text = W.state.doc.toString(), (V = this.componentFeatures) != null && V.allowsFeature(_.Typing) && this.typing && W.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), (Y = this.componentFeatures) != null && Y.allowsFeature(_.Embeds) && W.state.doc.toString() !== "" && this.handleEmbeds(W.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of(b.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            b.updateListener.of((Z) => {
              var W;
              this.setPlaceHolderText();
              const V = Array.from(((W = this.editor) == null ? void 0 : W.state).config.compartments.keys());
              this.editorEditable = V[0], this.editorPlaceholder = V[1];
            })
          ], this.editor || (this.editor = new b({
            state: x.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), (T = (R = this.editorRef.value) == null ? void 0 : R.querySelector(".cm-editor")) == null || T.addEventListener("Weavy-SoftSubmit", this.submit.bind(this)));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
  }
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?!\]\(@)(^[^@]{0,1}|[^@]{2})@([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const i = e == null ? void 0 : e.text.substring(1), s = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${i}`)).json();
    let r = [];
    return s.data && (r = s.data.filter((a) => typeof a.name < "u").map((a) => ({
      item: a,
      label: a.name,
      apply: /* @__PURE__ */ u((o, l, c, d) => {
        const p = "[" + a.name + "](@u" + a.id.toString() + ")";
        let f = o.state.update({ changes: { from: c - 1, to: c } });
        o.dispatch(f), f = o.state.update({
          changes: { from: c - 1, to: d - 1, insert: p }
        }), o.dispatch(f);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: r,
      filter: !1
    };
  }
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  async handleUploadFiles(t, e) {
    if (t) {
      for (let i = 0; i < t.length; i++) {
        const s = { file: t[i] };
        await this.uploadBlobMutation.mutate(s), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  handleExternalBlobs(t) {
    var e;
    if (t)
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        (e = this.externalBlobMutation) == null || e.mutate({ externalBlob: s });
      }
  }
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || cP(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => {
        var i, s;
        return ((i = e.state.data) == null ? void 0 : i.id) === ((s = t.data) == null ? void 0 : s.id);
      }
    );
  }
  saveDraft() {
    var t;
    if (!this.draft || !this.storage) return;
    const e = this.mutatingFiles.result;
    let i = (t = this.editor) == null ? void 0 : t.state.doc.toString();
    if (i === void 0 && (i = this.text), (!e || !e.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((s) => s.text.trim() !== "").length === 0) && i === "")
      this.storage.removeItem(this.draftKey);
    else {
      const s = {
        meeting: this.meeting,
        text: i,
        pollOptions: this.pollOptions.filter((r) => r.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(s));
    }
  }
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  submit() {
    var t, e, i, s;
    const r = this.mutatingFiles.result, a = r == null ? void 0 : r.some((w) => w.status === "pending"), o = ((t = this.editor) == null ? void 0 : t.state.doc.toString().trim()) ?? "", l = (e = this.meeting) == null ? void 0 : e.id, c = r == null ? void 0 : r.map((w) => {
      var b;
      return (b = w.data) == null ? void 0 : b.id;
    }).filter((w) => w), d = ((i = this.attachments) == null ? void 0 : i.map((w) => w.id)) || [], p = this.pollOptions.filter((w) => w.text.trim() !== "");
    if (RL() || a || !this.contextDataBlobs || !o && !l && (c == null ? void 0 : c.length) == 0 && p.length == 0 && d.length == 0 && this.embeds.length == 0)
      return;
    const f = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, m = new CustomEvent("submit", {
      detail: { text: o, meetingId: l, blobs: c, attachments: d, pollOptions: p, embedId: (s = this.embeds[0]) == null ? void 0 : s.id, contextData: f },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(m), this.resetEditor();
  }
  resetEditor() {
    var t;
    this.clearEditor(), this.weavy && this.mutationAppId && wz(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), (t = this.storage) == null || t.removeItem(this.draftKey);
  }
  clearEditor() {
    var t;
    (t = this.editor) == null || t.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, ON();
  }
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const e = await Ak(this.weavy, t).mutate();
    e.auth_url ? this.authWindow = window.open(e.auth_url, "oauthwin", "height=640,width=480") : this.meeting = e;
  }
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  handleEmbeds(t) {
    this.weavy && $N(t, this.setEmbeds.bind(this), this.weavy);
  }
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  openPolls() {
    if (this.showPolls)
      this.showPolls = !1;
    else {
      if (this.pollOptions.length === 0) {
        const t = { id: null, text: "" };
        this.pollOptions = [...this.pollOptions, t];
      }
      this.showPolls = !0;
    }
  }
  handlePollOptionChange(t, e) {
    const i = [...this.pollOptions];
    i[e].text = t.target.value, this.pollOptions = i, this.saveDraft();
  }
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const i = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, i], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? Q : v`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return Q;
  }
  renderMiddleSlot() {
    var t, e, i, s, r, a;
    return v`
      <!-- Input -->
      <div class=${Xt({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${lt(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div class="wy-post-editor-inputs">
        <div class="wy-post-editor-buttons">
          ${(t = this.componentFeatures) != null && t.allowsFeature(_.Attachments) ? v`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${C("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${lt(this.fileInputRef)}
                  @click=${(o) => o.stopPropagation()}
                  @change=${(o) => this.handleUploadFiles(
      Array.from(o.target.files || []),
      o.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : Q}
          ${(e = this.componentFeatures) != null && e.allowsFeature(_.CloudFiles) ? v`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${C("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : Q}
          ${(i = this.componentFeatures) != null && i.allowsAnyFeature(_.Meetings, _.ZoomMeetings) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${C("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : Q}
          ${(s = this.componentFeatures) != null && s.allowsAnyFeature(_.Meetings, _.GoogleMeet) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${C("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : Q}
          ${(r = this.componentFeatures) != null && r.allowsAnyFeature(_.Meetings, _.MicrosoftTeams) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${C("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : Q}
          ${(a = this.componentFeatures) != null && a.allowsFeature(_.Polls) ? v`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${C("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : Q}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  renderBottomSlot() {
    return [this.renderLists()];
  }
  renderLists() {
    var t, e, i, s, r, a, o, l;
    const c = this.mutatingFiles.result;
    return this.disabled ? Q : v`
      <!-- polls -->
      ${(t = this.componentFeatures) != null && t.allowsFeature(_.Polls) && this.showPolls && this.pollOptions.length > 0 ? v`
            <div class="wy-poll-form">
              ${this.pollOptions.map((d, p) => v`<input
                  value=${d.text}
                  @change=${(f) => this.handlePollOptionChange(f, p)}
                  @keyup=${Vs}
                  class="wy-input"
                  type="text"
                  placeholder=${C("+ add an option")}
                  @focus=${(f) => this.handlePollOptionAdd(f, p)}
                />`)}
            </div>
          ` : Q}

      <!-- meetings -->
      ${((e = this.meeting) == null ? void 0 : e.provider) === "zoom" && (i = this.componentFeatures) != null && i.allowsAnyFeature(_.Meetings, _.ZoomMeetings) || ((s = this.meeting) == null ? void 0 : s.provider) === "google" && (r = this.componentFeatures) != null && r.allowsAnyFeature(_.Meetings, _.GoogleMeet) || ((a = this.meeting) == null ? void 0 : a.provider) === "microsoft" && (o = this.componentFeatures) != null && o.allowsAnyFeature(_.Meetings, _.MicrosoftTeams) ? v`
            <div class="wy-item wy-list-item">
              <wy-icon svg="${Kv(this.meeting.provider)}"></wy-icon>
              <div class="wy-item-body">${Jv(this.meeting.provider)}</div>
              <wy-button kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close-circle"></wy-icon>
              </wy-button>
            </div>
          ` : Q}

      <!-- blobs -->
      ${c && c.length ? Mi(
      c,
      (d) => "mutation" + d.submittedAt,
      (d) => {
        var p;
        if ((p = d.context) != null && p.file) {
          const f = d.context.file, m = {
            ...d.context.status
          };
          return v`
                  <wy-file-item
                    .file=${d.context.file}
                    .status=${m}
                    title="${R0(d.context.type)}: ${f.name + (m.text ? `: ${m.text}` : "")}"
                  >
                    <span slot="title"
                      ><strong></strong> ${f.name}
                      ${m.text ? v`: <em>${m.text}</em>` : Q}</span
                    >
                    <wy-button
                      slot="actions"
                      kind="icon"
                      @click=${() => this.handleRemoveUpload(d)}
                      title=${C("Discard", { desc: "Button action to discard" })}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                  </wy-file-item>
                `;
        }
        return Q;
      }
    ) : Q}

      <!-- attachments -->
      ${this.attachments && this.attachments.map(
      (d) => v`<wy-file-item .file=${d} title="${d.name}">
          <span slot="title">${d.name}</span>
          <wy-button
            slot="actions"
            kind="icon"
            @click=${() => this.handleRemoveAttachment(d)}
            title=${C("Remove", { desc: "Button action to remove" })}
          >
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-file-item>`
    )}

      <!-- embeds -->
      ${(l = this.componentFeatures) != null && l.allowsFeature(_.Embeds) && this.embeds.length > 0 ? v`<div class="wy-embed-preview">
            ${this.embeds.map(
      (d) => v`
                <wy-embed
                  class="wy-embed"
                  .embed=${d}
                  @embed-remove=${(p) => this.removeEmbed(p)}
                  @embed-swap=${() => this.swapEmbed()}
                  .enableSwap=${this.embeds.length > 1}
                ></wy-embed>
              `
    )}
          </div> ` : Q}
    `;
  }
  renderCloudFiles() {
    return this.disabled ? Q : v`
      <wy-cloud-files
        ${lt(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        class=${Xt({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${C("Drop files here to upload.")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, h(Bp, "Ua"), Bp), u(g2, "WyEditor"), g2);
qt.styles = yt;
te([
  $({ type: Boolean })
], qt.prototype, "disabled", 2);
te([
  $({ attribute: !1 })
], qt.prototype, "parentId", 2);
te([
  $()
], qt.prototype, "placeholder", 1);
te([
  $()
], qt.prototype, "text", 2);
te([
  $({ type: Object })
], qt.prototype, "metadata", 2);
te([
  $({ attribute: !1 })
], qt.prototype, "embed", 2);
te([
  $({ attribute: !1 })
], qt.prototype, "options", 2);
te([
  $({ attribute: !1 })
], qt.prototype, "attachments", 2);
te([
  $()
], qt.prototype, "buttonText", 2);
te([
  $({ type: Boolean })
], qt.prototype, "typing", 2);
te([
  $({ type: Boolean })
], qt.prototype, "draft", 2);
te([
  $()
], qt.prototype, "editorType", 2);
te([
  $()
], qt.prototype, "editorClass", 2);
te([
  $()
], qt.prototype, "editorLocation", 2);
te([
  U()
], qt.prototype, "meeting", 2);
te([
  U()
], qt.prototype, "editorError", 2);
te([
  U()
], qt.prototype, "showPolls", 2);
te([
  U()
], qt.prototype, "pollOptions", 2);
te([
  U()
], qt.prototype, "embeds", 2);
te([
  U()
], qt.prototype, "draftKey", 2);
te([
  U()
], qt.prototype, "mutationAppId", 2);
te([
  U()
], qt.prototype, "keyMap", 2);
te([
  U()
], qt.prototype, "editorExtensions", 2);
te([
  U()
], qt.prototype, "editor", 2);
qt = te([
  H("wy-editor"),
  Ot()
], qt);
var RN = Object.defineProperty, EN = Object.getOwnPropertyDescriptor, ir = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RN(t, e, s), s;
}, "__decorateClass$F"), v2, Xp;
let hn = (v2 = (Xp = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.location = "apps", this.text = "", this.attachments = [], this.pollOptions = [], this.updateCommentMutation = new sn(this);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  handleSubmit(t) {
    this.updateCommentMutation.mutate({
      id: this.commentId,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      bL(this.weavy, [this.location, this.parentId, "comments"])
    );
  }
  render() {
    return v`
      <nav class="wy-item">
        <div class="wy-item-body">
          <div class="wy-item-title">${C("Edit comment")}</div>
        </div>

        <wy-button @click=${() => this.dispatchEdit(!1)} kind="icon">
          <wy-icon name="close"></wy-icon>
        </wy-button>
      </nav>
      <wy-editor
        editorLocation=${this.location}
        .text=${this.text}
        .embed=${this.embed}
        .options=${this.pollOptions}
        .attachments=${this.attachments ?? []}
        .parentId=${this.commentId}
        .typing=${!1}
        .draft=${!1}
        placeholder=${C("Edit comment...")}
        buttonText=${C("Update", { desc: "Button action to update" })}
        @submit=${(t) => this.handleSubmit(t)}></wy-editor>
    `;
  }
}, h(Xp, "qa"), Xp), u(v2, "WyCommentEdit"), v2);
hn.styles = yt;
ir([
  ve({ context: _e, subscribe: !0 }),
  U()
], hn.prototype, "weavy", 2);
ir([
  $({ type: Number })
], hn.prototype, "parentId", 2);
ir([
  $({ attribute: !1 })
], hn.prototype, "location", 2);
ir([
  $({ type: Number })
], hn.prototype, "commentId", 2);
ir([
  $()
], hn.prototype, "text", 2);
ir([
  $({ type: Array })
], hn.prototype, "attachments", 2);
ir([
  $({ type: Array })
], hn.prototype, "pollOptions", 2);
ir([
  $({ attribute: !1 })
], hn.prototype, "embed", 2);
hn = ir([
  H("wy-comment-edit"),
  Ot()
], hn);
var zN = Object.defineProperty, _N = Object.getOwnPropertyDescriptor, Ze = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? _N(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && zN(t, e, s), s;
}, "__decorateClass$E"), b2, Np;
let de = (b2 = (Np = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t, parentId: this.commentId, parentType: "comments" } });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-comment-trashed
            class="wy-comment"
            commentId=${this.commentId}
            @restore=${() => {
      this.dispatchRestore();
    }}></wy-comment-trashed> ` : Q}
      ${!this.isTrashed && this.editing ? v`<wy-comment-edit
            class="wy-comment"
            .commentId=${this.commentId}
            .parentId=${this.parentId}
            .location=${this.location}
            .text=${this.text}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            .embed=${this.embed}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}></wy-comment-edit> ` : Q}
      ${!this.isTrashed && !this.editing ? v`<wy-comment-view
            class="wy-comment"
            id="comment-view-${this.commentId}"
            .commentId=${this.commentId}
            .parentId=${this.parentId}
            .location=${this.location}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isTrashed=${this.isTrashed}
            .text=${this.text}
            .html=${this.html}
            .annotations=${this.annotations}          
            .attachments=${this.attachments}
            .embed=${this.embed}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .reactions=${this.reactions}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}></wy-comment-view> ` : Q}
    `;
  }
}, h(Np, "Na"), Np), u(b2, "WyComment"), b2);
de.styles = [yt, At];
Ze([
  $({ type: Number })
], de.prototype, "commentId", 2);
Ze([
  $({ type: Number })
], de.prototype, "parentId", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "location", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "createdBy", 2);
Ze([
  $()
], de.prototype, "createdAt", 2);
Ze([
  $()
], de.prototype, "modifiedAt", 2);
Ze([
  $({ type: Boolean })
], de.prototype, "isTrashed", 2);
Ze([
  $()
], de.prototype, "html", 2);
Ze([
  $()
], de.prototype, "text", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "annotations", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "attachments", 2);
Ze([
  $({ type: Array })
], de.prototype, "pollOptions", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "meeting", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "embed", 2);
Ze([
  $({ type: Array })
], de.prototype, "reactions", 2);
Ze([
  $({ attribute: !1 })
], de.prototype, "commentCount", 2);
Ze([
  $({ type: Array })
], de.prototype, "seenBy", 2);
Ze([
  U()
], de.prototype, "editing", 2);
de = Ze([
  H("wy-comment")
], de);
var LN = Object.getOwnPropertyDescriptor, IN = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? LN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$D"), O2, Hp;
let Rk = (O2 = (Hp = class extends qt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && this.editorLocation === "files" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom");
  }
  renderTopSlot() {
    return Q;
  }
  renderMiddleSlot() {
    var t, e, i, s, r, a, o;
    return v`<div class="wy-comment-editor-inputs">
      <!-- Add -->
      ${(t = this.componentFeatures) != null && t.allowsAnyFeature(
      _.Attachments,
      _.CloudFiles,
      _.Meetings,
      _.ZoomMeetings,
      _.GoogleMeet,
      _.MicrosoftTeams,
      _.Polls
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${(e = this.componentFeatures) != null && e.allowsFeature(_.Attachments) ? v`<wy-dropdown-item @click=${this.openFileInput} title=${C("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${C("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${lt(this.fileInputRef)}
                    @click=${(l) => l.stopPropagation()}
                    @change=${(l) => this.handleUploadFiles(
      Array.from(l.target.files || []),
      l.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : Q}
            ${(i = this.componentFeatures) != null && i.allowsFeature(_.CloudFiles) ? v`<wy-dropdown-item @click=${this.openCloudFiles} title=${C("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${C("From cloud")}</span>
                </wy-dropdown-item>` : Q}
            ${(s = this.componentFeatures) != null && s.allowsAnyFeature(_.Meetings, _.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${C("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${C("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(r = this.componentFeatures) != null && r.allowsAnyFeature(_.Meetings, _.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${C("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${C("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(a = this.componentFeatures) != null && a.allowsAnyFeature(_.Meetings, _.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${C("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${C("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(o = this.componentFeatures) != null && o.allowsFeature(_.Polls) ? v`<wy-dropdown-item @click=${() => this.openPolls()} title=${C("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${C("Poll")}</span>
                </wy-dropdown-item>` : Q}
          </wy-dropdown>` : Q}

      <!-- Input -->
      <div
        class=${Xt({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${lt(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, h(Hp, "ja"), Hp), u(O2, "WyCommentEditor"), O2);
Rk = IN([
  H("wy-comment-editor"),
  Ot()
], Rk);
var ZN = Object.defineProperty, WN = Object.getOwnPropertyDescriptor, IL = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$b"), ib = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? WN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && ZN(t, e, s), s;
}, "__decorateClass$C"), ZL = /* @__PURE__ */ u((n, t, e) => t.has(n) || IL("Cannot " + e), "__accessCheck$b"), Ng = /* @__PURE__ */ u((n, t, e) => (ZL(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$b"), $2 = /* @__PURE__ */ u((n, t, e) => t.has(n) ? IL("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$b"), x2 = /* @__PURE__ */ u((n, t, e, i) => (ZL(n, t, "write to private field"), t.set(n, e), e), "__privateSet$a"), Z1, Ek, bc, k2, Yp;
let tl = (k2 = (Yp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.location = "apps", $2(this, Z1), $2(this, Ek, new Promise((t) => {
      x2(this, Z1, t);
    })), this.commentsQuery = new hl(this), this.addCommentMutation = new sn(this), this.infiniteScroll = new dl(this), this.pagerRef = wt(), $2(this, bc), this.handleRealtimeCommentCreated = () => {
      var t;
      (t = this.weavy) == null || t.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== oi.Comment || we(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          oy(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== oi.Comment || we(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          oy(e, void 0, t.actor);
        }
      );
    };
  }
  async whenParentId() {
    return await Ng(this, Ek);
  }
  async willUpdate(t) {
    var e, i, s;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((i = Ng(this, Z1)) == null || i.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(vL(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(OL(this.weavy)), this.removeCommentMutation = xL(this.weavy, this.location, this.parentId), this.restoreCommentMutation = SL(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = U0(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (s = Ng(this, bc)) == null || s.call(this);
      const r = `a${this.app.id}`;
      this.weavy.subscribe(r, "comment_created", this.handleRealtimeCommentCreated), (e = this.componentFeatures) != null && e.allowsFeature(_.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), x2(this, bc, () => {
        var a, o, l;
        (a = this.weavy) == null || a.unsubscribe(r, "comment_created", this.handleRealtimeCommentCreated), (o = this.weavy) == null || o.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), (l = this.weavy) == null || l.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), x2(this, bc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  renderComments(t) {
    return t ? Mi(
      t,
      (e) => e.id,
      (e) => {
        var i, s, r, a;
        return this.parentId ? v`<wy-comment
              id="comment-${e.id}"
              .commentId=${e.id}
              .parentId=${this.parentId}
              .location=${this.location}
              .createdBy=${e.created_by}
              .createdAt=${e.created_at}
              .modifiedAt=${e.updated_at}
              .isTrashed=${e.is_trashed}
              .html=${e.html}
              .text=${e.text}
              .annotations=${(i = e.annotations) == null ? void 0 : i.data}
              .attachments=${(s = e.attachments) == null ? void 0 : s.data}
              .embed=${e.embed}
              .meeting=${e.meeting}
              .pollOptions=${(r = e.options) == null ? void 0 : r.data}
              .reactions=${(a = e.reactions) == null ? void 0 : a.data}
              @trash=${async (o) => {
          var l;
          const c = await this.whenApp(), d = await this.whenParentId();
          (l = this.removeCommentMutation) == null || l.mutate({
            id: o.detail.id,
            appId: c.id,
            parentId: d,
            type: this.location
          });
        }}
              @restore=${async (o) => {
          var l;
          const c = await this.whenApp(), d = await this.whenParentId();
          (l = this.restoreCommentMutation) == null || l.mutate({
            id: o.detail.id,
            appId: c.id,
            parentId: d,
            type: this.location
          });
        }}
              @vote=${(o) => {
          var l;
          o.detail.parentId && o.detail.parentType && ((l = this.pollMutation) == null || l.mutate({
            optionId: o.detail.optionId,
            parentType: o.detail.parentType,
            parentId: o.detail.parentId
          }));
        }}
            ></wy-comment>` : Q;
      }
    ) : Q;
  }
  render() {
    var t;
    const { data: e, hasNextPage: i, isPending: s } = this.commentsQuery.result ?? {}, r = ds(e), a = {
      "wy-comments": !0,
      "wy-comments-padded": this.location === "files"
    };
    return v`
      ${r && r.length ? v`
            <div class=${Xt(a)}>
              ${this.renderComments(r)}
              ${i ? v`<div ${lt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            </div>
          ` : s ? v`<wy-empty noNetwork><wy-spinner padded reveal></wy-spinner></wy-empty>` : Q}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!ey(Fo.Create, (t = this.app) == null ? void 0 : t.permissions)}
        placeholder=${this.placeholder ?? C("Create a comment...")}
        buttonText=${C("Comment", { desc: "Button action to comment" })}
        @submit=${(o) => this.handleSubmit(o)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Ng(this, bc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Yp, "Wa"), Yp), u(k2, "WyCommentList"), k2);
Z1 = /* @__PURE__ */ new WeakMap();
Ek = /* @__PURE__ */ new WeakMap();
bc = /* @__PURE__ */ new WeakMap();
tl.styles = [yt, ya];
ib([
  $({ type: Number })
], tl.prototype, "parentId", 2);
ib([
  $({ attribute: !1 })
], tl.prototype, "location", 2);
ib([
  $()
], tl.prototype, "placeholder", 2);
tl = ib([
  H("wy-comment-list"),
  Ot()
], tl);
function nb(n, t) {
  return ["apps", n.id, "file", t.id, "versions"];
}
h(nb, "wp");
u(nb, "getFileVersionsKey");
function WL(n, t, e) {
  const i = n.queryClient, s = ["apps", t.id, "files"], r = nb(t, e), a = {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ u(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        if (!(await n.fetch(`/api/files/${o.id}/versions/${o.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${o.name} to version ${o.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((o) => ($t(
      i,
      { queryKey: a.mutationKey, exact: !1 },
      o.versionFile.id,
      (l) => Object.assign(l, o.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((o, l) => {
      $t(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (c) => Object.assign(c, o, { status: "ok" })
      ), re(i, a.mutationKey, l, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ u((o, l, c) => {
      c != null && c.file && $t(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (d) => Object.assign(d, c.file, { status: "error" })
      ), re(i, a.mutationKey, l, (d) => {
        d.status.state = "error", d.status.text = o.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ u(async () => {
      await i.invalidateQueries({ queryKey: r });
    }, "onSettled")
  };
  return a;
}
h(WL, "F5");
u(WL, "getFileVersionRestoreMutationOptions");
function DL(n, t, e) {
  return new Vt(n.queryClient, WL(n, t, e));
}
h(DL, "D5");
u(DL, "getFileVersionRestoreMutation");
function qL(n, t, e) {
  const i = n.queryClient, s = nb(t, e);
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ u(async ({ versionFile: r }) => {
      if (r.id >= 1 && r.rev) {
        const a = await n.fetch(`/api/files/${r.id}/versions/${r.rev}`, {
          method: "DELETE"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else {
        const a = {
          status: 400,
          title: `Could not remove ${r.name} version ${r.rev}.`
        };
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((r) => {
      we(
        i,
        s,
        /* @__PURE__ */ u((a) => a.id === r.versionFile.id && a.rev === r.versionFile.rev, "versionPredicate"),
        (a) => Object.assign(a, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((r, a) => {
      F0(i, s, /* @__PURE__ */ u((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ u((r, a) => {
      we(
        i,
        s,
        /* @__PURE__ */ u((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"),
        (o) => Object.assign(o, { status: void 0 })
      );
    }, "onError")
  };
}
h(qL, "H5");
u(qL, "getFileVersionDeleteMutationOptions");
function VL(n, t, e) {
  return new Vt(n.queryClient, qL(n, t, e));
}
h(VL, "V5");
u(VL, "getFileVersionDeleteMutation");
var DN = Object.defineProperty, qN = Object.getOwnPropertyDescriptor, JP = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? qN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && DN(t, e, s), s;
}, "__decorateClass$B"), S2, Gp;
let dy = (S2 = (Gp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.fileVersionsQuery = new Cn(this);
  }
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", { detail: { versionFile: t } });
    return this.dispatchEvent(e);
  }
  handleRevert(t) {
    var e;
    (e = this.fileVersionRestoreMutation) == null || e.mutate({ versionFile: t }), this.selectVersion(t);
  }
  handleRemove(t) {
    var e;
    (e = this.fileVersionDeleteMutation) == null || e.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  triggerDownload(t) {
    Uc(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      ol(
        this.weavy,
        nb(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = DL(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = VL(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? v`<wy-spinner overlay></wy-spinner>` : t != null && t.data ? v`
          <div class="wy-list wy-versions">
            ${Mi(
      t.data,
      (i) => i.id,
      (i, s) => {
        var r, a, o, l;
        const c = An(i.name || "").icon, d = t.data ? t.data.length - s : NaN, p = Ei(i.name), f = new Date(i.updated_at || i.created_at), m = !!this.file.external_url, w = new Intl.DateTimeFormat((r = this.weavy) == null ? void 0 : r.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(f), b = Ay((a = this.weavy) == null ? void 0 : a.locale, new Date(f));
        return m ? v`
                      <wy-empty noNetwork>
                        <span slot="title">${C("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : v`
                      <div
                        class="wy-item wy-list-item-lg wy-item-hover ${Xt({
          "wy-active": i.rev == ((o = this.activeVersion) == null ? void 0 : o.rev)
        })}"
                        tabindex="0"
                        @click=${() => this.selectVersion(i)}
                        @keydown=${je}
                        @keyup=${gi}
                      >
                        <wy-icon name=${c} size="48" kind=${i.kind} ext=${p}></wy-icon>
                        <div class="wy-item-body">
                          <div class="wy-item-title">${d}. ${i.name}</div>
                          <div class="wy-item-text">
                            <time datetime=${i.updated_at || i.created_at} title=${w}
                              >${b}</time
                            >
                            · ${(l = i.updated_by) == null ? void 0 : l.name}</div
                          >
                        </div>

                        <wy-dropdown directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(i)}>
                            <wy-icon name="download"></wy-icon>
                            ${C("Download")}
                          </wy-dropdown-item>                          

                          ${s !== 0 ? v`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(i)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(i)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${C("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : Q}
                        </wy-dropdown>
                      </div>
                    `;
      }
    )}
          </div>
        ` : Q;
  }
}, h(Gp, "Qa"), Gp), u(S2, "WyFileVersions"), S2);
dy.styles = yt;
JP([
  $({ attribute: !1 })
], dy.prototype, "file", 2);
JP([
  $({ attribute: !1 })
], dy.prototype, "activeVersion", 2);
dy = JP([
  H("wy-file-versions"),
  Ot()
], dy);
var VN = Object.defineProperty, jN = Object.getOwnPropertyDescriptor, si = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && VN(t, e, s), s;
}, "__decorateClass$A"), P2, Kp;
let Te = (P2 = (Kp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new HP(this), this.previewFileRef = wt(), this.swipeScrollRef = wt(), this.prevRef = wt(), this.nextRef = wt(), this.swipeScroller = new qX(this), this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), i = this.currentId, s = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, r = this.currentFile ? [this.currentFile] : [], a = this.isAttachment, o = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: { fileId: i, tab: s, files: r, app: t, features: e.allowedFeatures().join(" "), isAttachment: a, contextDataBlobs: o },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  close() {
    this.showOverlay = !1;
  }
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  handleVersionFile(t) {
    this.versionFile = t.detail.versionFile;
  }
  scrollToPrev() {
    var t;
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: (t = this.weavy) == null ? void 0 : t.scrollBehavior }));
  }
  scrollToNext() {
    var t;
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: (t = this.weavy) == null ? void 0 : t.scrollBehavior }));
  }
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e == null ? void 0 : e.filter((i) => i && !i.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = ds(e).filter((i) => i && !i.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.versionFile = void 0, this.currentFile = this.files.find((e, i) => this.files && e.id === this.currentId ? (i >= 1 && (this.previousFile = this.files[i - 1]), i < this.files.length - 1 && (this.nextFile = this.files[i + 1]), this.infiniteQueryResult && i >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && i <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  renderHeader(t) {
    var e, i, s, r;
    const a = {
      "wy-appbar-text-trashed": !!(t != null && t.is_trashed)
    };
    return v` <header class="wy-appbars">
      <nav class="wy-appbar">
        <wy-button kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        <div class="wy-appbar-text ${Xt(a)}">
          ${t ? v` <span>${t.name}</span> ` : Q}
        </div>
        <div class="wy-appbar-buttons wy-appbar-buttons-last">
          ${t ? v`
                ${(e = this.componentFeatures) != null && e.allowsFeature(_.Comments) && t.id >= 1 && !this.isAttachment ? v`
                      <wy-button
                        kind="icon"
                        ?active=${this.commentsOpen}
                        @click=${() => this.toggleSidebarTab("comments")}
                        title=${C("Comments")}
                      >
                        <wy-icon-stack>
                          ${(i = t.comments) != null && i.count && ((s = t.comments) == null ? void 0 : s.count) > 0 ? v`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                                <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : v`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                                <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                        </wy-icon-stack>
                      </wy-button>
                    ` : Q}
                <wy-file-menu .file=${t}>
                  ${(r = this.componentFeatures) != null && r.allowsFeature(_.Versions) && t.id >= 1 && !this.isAttachment ? v`
                        <wy-dropdown-item
                          ?active=${this.versionsOpen}
                          @click=${() => this.toggleSidebarTab("versions")}
                        >
                          <wy-icon name="backup-restore"></wy-icon>
                          ${C("Versions")}
                        </wy-dropdown-item>
                      ` : Q}
                </wy-file-menu>
              ` : Q}
        </div>
      </nav>
    </header>`;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = this.versionFile || this.currentFile, i = [this.previousFile, e, this.nextFile].filter((r) => r);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const s = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? v`
      <wy-overlay
        class="wy-dark"
        maximized
        ?filled=${this.filled}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        ${this.showOverlay ? v`<div class="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div class="wy-main">
                ${this.isAttachment ? Q : v` <aside
                        id="tab-comments"
                        class="wy-sidebar ${Xt({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav class="wy-item">
                          <div class="wy-item-body">
                            <div class="wy-item-title">${C("Comments")}</div>
                          </div>
                          <wy-button kind="icon" @click=${() => this.toggleSidebarTab("comments", !1)}>
                            <wy-icon name="close"></wy-icon>
                          </wy-button>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            class="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? C("Restore side panel") : C("Maximize side panel")}
                          ></button>
                        </nav>
                        <div class="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? v`
                                <wy-comment-list
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : Q}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        class="wy-sidebar ${Xt({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav class="wy-item">
                          <div class="wy-item-body">
                            <div class="wy-item-title">${C("Versions")}</div>
                          </div>
                          <wy-button kind="icon" @click=${() => this.toggleSidebarTab("versions", !1)}>
                            <wy-icon name="close"></wy-icon>
                          </wy-button>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            class="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? C("Restore side panel") : C("Maximize side panel")}
                          ></button>
                        </nav>
                        <div class="wy-pane wy-scroll-y">
                          <div class="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? v`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.versionFile || this.currentFile}
                                    @file-version-select=${(r) => this.handleVersionFile(r)}
                                  ></wy-file-versions>
                                ` : Q}
                          </div>
                        </div>
                      </aside>`}

                <div class="wy-preview">
                  <div ${lt(this.swipeScrollRef)} class="wy-preview-swiper ${Xt(s)}">
                    ${Mi(
      i,
      (r) => "preview-area-" + (r == null ? void 0 : r.id),
      (r) => {
        const a = r === e ? /* @__PURE__ */ u((o) => {
          o == null || o.scrollIntoView(), requestAnimationFrame(() => o == null ? void 0 : o.scrollIntoView());
        }, "currentPreviewFileCallback") : r === this.nextFile ? this.nextRef : r === this.previousFile ? this.prevRef : void 0;
        return r ? v`
                              <div
                                id="preview-${r.id}"
                                ${lt(a)}
                                class="wy-preview-area wy-scroll-y wy-scroll-x"
                              >
                                ${t ? v` <wy-spinner overlay></wy-spinner> ` : v` <wy-preview-item .file=${r} ?current=${r === e}></wy-preview-item> `}
                              </div>
                            ` : Q;
      }
    )}
                  </div>
                  ${this.currentFile ? v`
                        ${this.previousFile ? v`
                              <nav class="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : Q}
                        ${this.nextFile ? v`
                              <nav class="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : Q}
                      ` : Q}
                </div>
              </div>
            </div> ` : Q}
      </wy-overlay>
    ` : Q;
  }
  updated() {
    requestAnimationFrame(
      () => requestAnimationFrame(() => {
        var t, e;
        this.swipeScrollRef.value ? ((t = this.swipeScroller).whenPrev ?? (t.whenPrev = () => this.setPrev()), (e = this.swipeScroller).whenNext ?? (e.whenNext = () => this.setNext()), this.swipeScroller.createObserver(this.swipeScrollRef.value), this.swipeScroller.observe(this.prevRef.value, this.nextRef.value)) : this.swipeScroller.clearObserver();
      })
    );
  }
}, h(Kp, "Ka"), Kp), u(P2, "WyPreview"), P2);
Te.styles = [yt];
si([
  $({ attribute: !1 })
], Te.prototype, "files", 2);
si([
  $({ attribute: !1 })
], Te.prototype, "queryResult", 2);
si([
  $({ attribute: !1 })
], Te.prototype, "infiniteQueryResult", 2);
si([
  $({ type: Object })
], Te.prototype, "user", 2);
si([
  $({ type: Number })
], Te.prototype, "currentId", 2);
si([
  $({ type: Boolean })
], Te.prototype, "isAttachment", 2);
si([
  $({ type: Boolean })
], Te.prototype, "filled", 2);
si([
  U()
], Te.prototype, "currentFile", 2);
si([
  U()
], Te.prototype, "previousFile", 2);
si([
  U()
], Te.prototype, "nextFile", 2);
si([
  U()
], Te.prototype, "showOverlay", 2);
si([
  U()
], Te.prototype, "commentsOpen", 2);
si([
  U()
], Te.prototype, "versionsOpen", 2);
si([
  U()
], Te.prototype, "versionFile", 2);
si([
  U()
], Te.prototype, "sidePanelMaximized", 2);
si([
  U()
], Te.prototype, "disableSwipeScroll", 2);
Te = si([
  H("wy-preview"),
  Ot()
], Te);
var FN = Object.defineProperty, UN = Object.getOwnPropertyDescriptor, Re = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FN(t, e, s), s;
}, "__decorateClass$z"), C2, Jp;
let oe = (C2 = (Jp = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt();
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && cg(this.link, oi.Message, { id: this.messageId })));
  }
  render() {
    var t, e, i, s, r, a, o;
    const l = ((t = this.attachments) == null ? void 0 : t.filter((f) => f.kind === "image" && f.thumbnail_url)) || [], c = ((e = this.attachments) == null ? void 0 : e.filter((f) => f.kind !== "image" || !f.thumbnail_url)) || [], d = this.createdAt ? new Intl.DateTimeFormat((i = this.weavy) == null ? void 0 : i.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", p = this.createdAt ? new Intl.DateTimeFormat((s = this.weavy) == null ? void 0 : s.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "";
    return v`
      <div
        class=${Xt({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent })}
        part=${Qe({ "wy-highlight": this.highlight })}
        ${lt(this.highlightRef)}
      >
        ${this.me ? "" : v`
              <div class="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div class="wy-message-content">
          <div class="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? v` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${d}>${p}</time>
          </div>

          <div class="wy-message-bubble">
            ${this.messageId < 0 ? v`<wy-skeleton .text=${this.text}></wy-skeleton>` : v`
                  <!-- image grid -->
                  ${l && l.length ? v`<wy-image-grid
                        class="wy-message-area"
                        .images=${l}
                        @file-open=${(f) => {
      var m;
      (m = this.previewAttachmentsRef.value) == null || m.open(f.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- embeds -->
                  ${(r = this.componentFeatures) != null && r.allowsFeature(_.Embeds) && this.embed ? v` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : Q}

                  <!-- text -->
                  ${this.html ? v`<div class="wy-content">${Bo(this.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.annotations && this.annotations.length ? v`<wy-annotations-list
                        class="wy-message-area"
                        .files=${this.annotations}
                        @file-open=${(f) => {
      var m;
      (m = this.previewAnnotationsRef.value) == null || m.open(f.detail.fileId);
    }}
                      ></wy-annotations-list>` : ""}

                  <!-- poll -->
                  ${this.pollOptions && this.pollOptions.length ? v`
                        <wy-poll
                          .pollOptions=${this.pollOptions}
                          @vote=${(f) => this.dispatchVote(f.detail.optionId)}
                        ></wy-poll>
                      ` : Q}

                  <!-- meeting -->
                  ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}

                  <!-- files -->
                  ${c && c.length ? v`<wy-attachments-list
                        class="wy-message-area"
                        .files=${c}
                        @file-open=${(f) => {
      var m;
      (m = this.previewAttachmentsRef.value) == null || m.open(f.detail.fileId);
    }}
                      ></wy-attachments-list>` : ""}

                  <!-- reactions -->
                  ${(a = this.componentFeatures) != null && a.allowsFeature(_.Reactions) && this.conversation ? v`
                        ${_1(
      `reactions-${this.conversation.id}-${this.messageId}`,
      v`
                            <wy-reactions
                              lineBelow
                              ?lineReverse=${!this.me}
                              small
                              directionX=${this.me ? "right" : "left"}
                              .reactions=${this.reactions}
                              parentId=${this.conversation.id}
                              parentType="apps"
                              entityId=${this.messageId}
                              entityType="messages"
                            ></wy-reactions>
                          `
    )}
                      ` : Q}
                `}
          </div>
        </div>
      </div>
      ${(o = this.componentFeatures) != null && o.allowsFeature(_.Receipts) ? v`<div class="wy-readby-status">
            ${this.seenBy && this.seenBy.length ? v`
                  ${this.seenBy.map((f) => {
      var m;
      const w = f.marked_at ? new Intl.DateTimeFormat((m = this.weavy) == null ? void 0 : m.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(f.marked_at)) : "";
      return v`<wy-avatar
                      title=${C(at`Seen by ${f.name} at ${w}`)}
                      .name=${f.name}
                      .src=${f.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : Q}
          </div>` : Q}
      ${this.annotations ? _1(
      `annotation-preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${lt(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : Q}
      ${this.attachments ? _1(
      `preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${lt(this.previewAttachmentsRef)}
                .files=${[...l, ...c]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : Q}
    `;
  }
  updated(t) {
    var e;
    t.has("highlight") && this.highlight && ((e = this.highlightRef.value) == null || e.scrollIntoView({ block: "nearest" }));
  }
}, h(Jp, "Ga"), Jp), u(C2, "WyMessage"), C2);
oe.styles = yt;
Re([
  $({ attribute: !1 })
], oe.prototype, "conversation", 2);
Re([
  $({ type: Number })
], oe.prototype, "messageId", 2);
Re([
  $({ type: Boolean })
], oe.prototype, "me", 2);
Re([
  $({ type: Boolean })
], oe.prototype, "isAgent", 2);
Re([
  $({ type: Boolean })
], oe.prototype, "isPrivateChat", 2);
Re([
  $()
], oe.prototype, "name", 2);
Re([
  $()
], oe.prototype, "comment", 2);
Re([
  $()
], oe.prototype, "avatar", 2);
Re([
  $()
], oe.prototype, "createdAt", 2);
Re([
  $()
], oe.prototype, "html", 2);
Re([
  $()
], oe.prototype, "text", 2);
Re([
  $({ type: Array })
], oe.prototype, "annotations", 2);
Re([
  $({ type: Array })
], oe.prototype, "attachments", 2);
Re([
  $({ attribute: !1 })
], oe.prototype, "meeting", 2);
Re([
  $({ type: Array })
], oe.prototype, "pollOptions", 2);
Re([
  $({ attribute: !1 })
], oe.prototype, "embed", 2);
Re([
  $({ type: Array })
], oe.prototype, "reactions", 2);
Re([
  $({ type: Array })
], oe.prototype, "seenBy", 2);
Re([
  $({ type: Boolean })
], oe.prototype, "highlight", 2);
oe = Re([
  H("wy-message"),
  Ot()
], oe);
var BN = Object.defineProperty, XN = Object.getOwnPropertyDescriptor, nr = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? XN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BN(t, e, s), s;
}, "__decorateClass$y"), Q2, tf;
let dn = (Q2 = (tf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.dataUpdatedAt = NaN, this.unreadMarkerShow = !0, this.seenByShow = !1;
  }
  dispatchVote(t, e) {
    const i = new CustomEvent("vote", { detail: { optionId: t, parentId: e, parentType: "messages" } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = ds(this.infiniteMessages);
    let e;
    return v`
      <div class="wy-messages">
        <slot name="start"></slot>
        <!-- this.user ?? -->
        ${t && this.conversation && this.user ? Mi(
      t,
      (i) => i.id,
      (i, s) => {
        var r, a, o, l, c, d, p, f, m, w;
        const b = new Date(i.created_at);
        let x = v``;
        if ((e == null ? void 0 : e.toDateString()) !== b.toDateString()) {
          const A = new Intl.DateTimeFormat((r = this.weavy) == null ? void 0 : r.locale, {
            dateStyle: "short"
          }).format(b);
          e = b, x = v`<div class="wy-date-separator"><time>${A}</time></div>`;
        }
        let O = v``;
        this.unreadMarkerId && this.unreadMarkerId === i.id && (O = v`<div
                    id="unread-marker"
                    class="wy-toast wy-toast-action wy-fade ${this.unreadMarkerShow ? "wy-show" : ""}"
                    tabindex=${this.unreadMarkerShow ? 0 : -1}
                    @click=${() => {
          var A;
          let R = `#message-${this.unreadMarkerId}`;
          this.unreadMarkerPosition === "below" && (R += "~ wy-message"), (A = this.renderRoot.querySelector(R)) == null || A.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                    @keydown=${je}
                    @keyup=${gi}
                  >
                    ${C("New messages")}
                  </div>`);
        const P = ((o = (a = this.members) == null ? void 0 : a.data) == null ? void 0 : o.find((A) => A.id === i.created_by.id)) || i.created_by;
        return v`${[
          v`${x}`,
          v`${this.unreadMarkerPosition === "above" ? O : Q}`,
          _1(
            `message-${i.id}`,
            v`<wy-message
                      id="message-${i.id}"
                      .conversation=${this.conversation}
                      .messageId=${i.id}
                      .me=${P.id === ((l = this.user) == null ? void 0 : l.id)}
                      .isAgent=${P.is_agent || !1}
                      .isPrivateChat=${((c = this.conversation) == null ? void 0 : c.type) === Pt.PrivateChat || ((d = this.conversation) == null ? void 0 : d.type) === Pt.AgentChat}
                      .name=${P.name}
                      .comment=${P.comment}
                      .avatar=${P.avatar_url}
                      .createdAt=${i.created_at}
                      .text=${i.plain}
                      .html=${i.html}
                      .annotations=${(p = i.annotations) == null ? void 0 : p.data}
                      .attachments=${(f = i.attachments) == null ? void 0 : f.data}
                      .meeting=${i.meeting}
                      .pollOptions=${(m = i.options) == null ? void 0 : m.data}
                      .embed=${i.embed}
                      .reactions=${(w = i.reactions) == null ? void 0 : w.data}
                      .seenBy=${this.seenByShow && this.members && this.members.data && this.members.data.length > 0 ? this.members.data.filter((A) => {
              var R;
              return A.marked_id === i.id && A.id !== ((R = this.user) == null ? void 0 : R.id);
            }) : []}
                      @vote=${(A) => {
              A.detail.parentId && this.dispatchVote(A.detail.optionId, A.detail.parentId);
            }}
                    ></wy-message>`
          ),
          v`${this.unreadMarkerPosition === "below" ? O : Q}`
        ]}`;
      }
    ) : Q}
        <slot name="end"></slot>
      </div>
    `;
  }
}, h(tf, "Za"), tf), u(Q2, "WyMessages"), Q2);
dn.styles = [
  yt,
  At,
  Mt`
      wy-message {
        scroll-margin-block: 6rem;
      }
    `
];
nr([
  $({ attribute: !1 })
], dn.prototype, "conversation", 2);
nr([
  $({ attribute: !1 })
], dn.prototype, "infiniteMessages", 2);
nr([
  $({ type: Number })
], dn.prototype, "dataUpdatedAt", 2);
nr([
  $({ attribute: !1 })
], dn.prototype, "members", 2);
nr([
  $({ attribute: !1 })
], dn.prototype, "unreadMarkerId", 2);
nr([
  $({ attribute: !1 })
], dn.prototype, "unreadMarkerPosition", 2);
nr([
  $({ attribute: !1 })
], dn.prototype, "unreadMarkerShow", 2);
nr([
  $({ attribute: !1 })
], dn.prototype, "seenByShow", 2);
dn = nr([
  H("wy-messages"),
  Ot()
], dn);
var ef;
const jL = (ef = class {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((i, s) => {
        i.id === e.actor.id && this.typingMembers.splice(s, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    var t;
    return (t = this.weavyContext) == null ? void 0 : t.value;
  }
  get componentFeatures() {
    var t;
    return (t = this.componentFeaturesContext) == null ? void 0 : t.value;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await sl(this.host), this.weavyContext = new qs(this.host, { context: _e, subscribe: !0 }), this.componentFeaturesContext = new qs(this.host, { context: W0, subscribe: !0 });
  }
  hostUpdate() {
    var t, e, i, s, r, a;
    (t = this.weavyContext) != null && t.value && ((i = this.resolveWeavyContext) == null || i.call(this, (e = this.weavyContext) == null ? void 0 : e.value)), (s = this.componentFeaturesContext) != null && s.value && ((a = this.resolveComponentFeaturesContext) == null || a.call(this, (r = this.componentFeaturesContext) == null ? void 0 : r.value));
  }
  async registerRealtime() {
    var t, e, i;
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), (t = this.componentFeatures) != null && t.allowsFeature(_.Typing) && ((e = this.weavy) == null || e.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), (i = this.weavy) == null || i.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime() {
    var t, e;
    !this.registrationRequested && this.appId && this.userId && (await this.whenWeavyContext, (t = this.weavy) == null || t.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), (e = this.weavy) == null || e.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, s) => {
      t - i.time > this.discardTime && this.typingMembers.splice(s, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), s = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((r) => r.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(s), this.names = this.typingMembers.map((r) => r.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((i, s) => {
      i.id === t.id && this.typingMembers.splice(s, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
}, h(ef, "Gp"), ef);
u(jL, "TypingController");
let FL = jL;
const NN = Mt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}.wy-messages{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}.wy-message-placeholder{opacity:.5}.wy-date-separator{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-align:center;position:sticky;top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));z-index:10}.wy-date-separator time{background:var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:inline-block}.wy-message{display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-message-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-meta{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message-bubble{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32 * var(--wy-size, 1rem),100% - 2 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-message-bubble>div{flex:1 1 100%}.wy-message-author{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-size, 1rem)) 0 0}.wy-message-content{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}.wy-message-content-row{display:flex;flex-direction:row;align-items:center;max-width:100%}.wy-message-agent{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-90, #bbf294));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-tertiary-10, #0a2100))}.wy-message-me{margin-right:0;margin-left:calc(2.5 * var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}.wy-message-me .wy-message-meta{margin:0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}.wy-message-me .wy-message-content{align-items:flex-end}.wy-message-me .wy-message-content-row{flex-direction:row-reverse}.wy-message-emoji .wy-message-bubble{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-message-emoji .wy-content .wy-emoji{width:calc(3 * var(--wy-size, 1rem));height:calc(3 * var(--wy-size, 1rem));margin:0}.wy-message-emoji.wy-message-me .wy-content{text-align:end}.wy-readby-status{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125 * var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125 * var(--wy-size, 1rem))}.wy-message-readmore{justify-self:center;text-align:center}`, HN = Mt`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5 * var(--wy-size, 1rem));height:calc(.75 * var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var YN = Object.defineProperty, GN = Object.getOwnPropertyDescriptor, us = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? GN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && YN(t, e, s), s;
}, "__decorateClass$x"), M2, nf;
let Ui = (M2 = (nf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.typing = new FL(this), this.isPrivateChat = !1, this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: i } = this.typing;
    this.typingMembers = e, this.names = i, e.length ? this.typingTime || (this.typingTime = /* @__PURE__ */ new Date()) : this.typingTime = void 0;
  }
  render() {
    var t, e, i, s, r, a, o, l;
    const c = this.typingMembers.map(
      (w) => [...this.members ?? [], ...this.agents ?? []].find((b) => b.id === w.id)
    ).filter((w) => w), d = new Intl.ListFormat((t = this.weavy) == null ? void 0 : t.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), p = this.typingTime ? new Intl.DateTimeFormat((e = this.weavy) == null ? void 0 : e.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", f = this.typingTime ? new Intl.DateTimeFormat((i = this.weavy) == null ? void 0 : i.locale, { timeStyle: "short" }).format(this.typingTime) : "", m = v`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return c.length ? v`
          <div class=${Xt({ "wy-message": !0, "wy-message-agent": !!((s = c[0]) != null && s.is_agent) })}>
            <div class="wy-message-author">
              ${c.length > 1 ? v`
                    <wy-avatar-group
                      .size=${32}
                      .members=${c}
                      title=${d}
                    ></wy-avatar-group>
                  ` : v`
                    <wy-avatar
                      .size=${32}
                      .src=${(r = c[0]) == null ? void 0 : r.avatar_url}
                      .description=${(a = c[0]) == null ? void 0 : a.comment}
                      .name=${d}
                      .isAgent=${(o = c[0]) == null ? void 0 : o.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div class="wy-message-content">
              <div class="wy-message-meta">
                ${this.isPrivateChat ? v`
                      <time datetime=${Ct((l = this.typingTime) == null ? void 0 : l.toISOString())} title=${p}>${f}</time>
                    ` : d}
              </div>
              <div class="wy-message-bubble"> ${m} </div>
            </div>
          </div>
        ` : Q;
  }
}, h(nf, "Ya"), nf), u(M2, "WyMessageTyping"), M2);
Ui.styles = [Ie, HN, NN];
us([
  ve({ context: _e, subscribe: !0 }),
  U()
], Ui.prototype, "weavy", 2);
us([
  $({ attribute: !0, type: Number })
], Ui.prototype, "conversationId", 2);
us([
  $({ attribute: !0, type: Number })
], Ui.prototype, "userId", 2);
us([
  $({ type: Boolean })
], Ui.prototype, "isPrivateChat", 2);
us([
  $({ attribute: !1 })
], Ui.prototype, "members", 2);
us([
  $({ attribute: !1 })
], Ui.prototype, "agents", 2);
us([
  U()
], Ui.prototype, "typingMembers", 2);
us([
  U()
], Ui.prototype, "names", 2);
us([
  U()
], Ui.prototype, "typingTime", 2);
Ui = us([
  H("wy-message-typing")
], Ui);
var KN = Object.defineProperty, JN = Object.getOwnPropertyDescriptor, UL = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$a"), zn = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? JN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && KN(t, e, s), s;
}, "__decorateClass$w"), BL = /* @__PURE__ */ u((n, t, e) => t.has(n) || UL("Cannot " + e), "__accessCheck$a"), A3 = /* @__PURE__ */ u((n, t, e) => (BL(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$a"), tH = /* @__PURE__ */ u((n, t, e) => t.has(n) ? UL("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$a"), R3 = /* @__PURE__ */ u((n, t, e, i) => (BL(n, t, "write to private field"), t.set(n, e), e), "__privateSet$9"), Oc, T2, sf;
let Ai = (T2 = (sf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), this.messagesQuery = new hl(this), this.membersQuery = new Cn(this), this.agentsQuery = new Cn(this), this.addMessageMutation = new sn(this), this.infiniteScroll = new kU(this), this.pagerRef = wt(), this.bottomRef = wt(), this.editorRef = wt(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      var e;
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await ((e = this.messagesQuery.observer) == null ? void 0 : e.getCurrentQuery().promise);
      const i = t.message.app.uid ?? t.message.app.id, s = ["messages", t.message.app.id];
      let r = og(this.weavy.queryClient, s, t.message.id);
      r || (t.message.created_by.id === this.user.id && (r = ea(this.weavy.queryClient, s, !0), r && we(this.weavy.queryClient, s, r.id, (a) => {
        a.id = t.message.id, a.app = t.message.app, a.text = t.message.text, a.html = t.message.html, a.embed = t.message.embed, a.meeting = t.message.meeting, a.attachments = t.message.attachments, a.options = t.message.options, a.created_at = t.message.created_at, a.created_by = t.message.created_by, a.updated_at = t.message.updated_at, a.updated_by = t.message.updated_by;
      })), r || ta(this.weavy.queryClient, s, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", i],
        (a) => a && { ...a, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", i],
        (a) => a && { ...a, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), $t(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (a) => {
          a.marked_id = t.message.id, a.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || $t(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((i) => {
              var s;
              return ((s = i.created_by) == null ? void 0 : s.id) !== t.actor.id;
            }),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || $t(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((i) => {
            var s;
            return ((s = i.created_by) == null ? void 0 : s.id) !== t.actor.id;
          }));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || $t(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, tH(this, Oc);
  }
  isPrivateChat(t) {
    var e;
    return ((e = t ?? this.conversation) == null ? void 0 : e.type) === Pt.PrivateChat;
  }
  isChatRoom(t) {
    var e;
    return ((e = t ?? this.conversation) == null ? void 0 : e.type) === Pt.ChatRoom;
  }
  get isAtBottom() {
    return this.bottomRef.value ? Wz(this.bottomRef.value) : !0;
  }
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await q1(this.bottomRef.value), Zz(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      var e;
      pk((e = this.weavy) == null ? void 0 : e.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await Dz(this.bottomRef.value, t));
  }
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const i = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, i;
  }
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  async selectAllInEditor() {
    var t;
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, (t = this.editorRef.value) == null || t.selectAllContent());
  }
  async setCursorLastInEditor() {
    var t;
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, (t = this.editorRef.value) == null || t.setCursorLast());
  }
  focusEditor() {
    var t;
    this.editorRef.value && ((t = this.editorRef.value) == null || t.focusInput());
  }
  async setEmptyConversationTitle(t) {
    var e;
    !this.conversation || this.conversation.name || (t = ZS(t), await ((e = this.updateConversationMutation) == null ? void 0 : e.mutate({ appId: this.conversation.id, name: t })));
  }
  async markAsRead(t) {
    var e, i;
    await e9(), await Promise.race([q1(this), Wk(this, !1)]), this.isConnected && this.conversation && this.conversation.last_message && await ((i = this.markConversationMutation) == null ? void 0 : i.mutate({
      appId: this.conversation.id,
      messageId: t ?? this.conversation.last_message.id,
      userId: (e = this.user) == null ? void 0 : e.id
    }));
  }
  async willUpdate(t) {
    var e, i, s, r, a, o, l, c, d, p, f, m, w;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = vP(this.weavy), this.markConversationMutation = wP(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (w = A3(this, Oc)) == null || w.call(this);
      const b = t.get("conversationId");
      if (b && b > 0 && requestAnimationFrame(() => {
        var x;
        pk((x = this.weavy) == null ? void 0 : x.queryClient, ["messages", b], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(zz(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          _z(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(Fv(this.weavy, this.conversationId, {})), await this.agentsQuery.trackQuery(Fv(this.weavy, this.conversationId, {}, !0)), this.pollMutation = U0(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const x = `a${this.conversationId}`;
        this.weavy.subscribe(x, "message_created", this.handleRealtimeMessage), (e = this.componentFeatures) != null && e.allowsFeature(_.Reactions) && (this.weavy.subscribe(x, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(x, "reaction_removed", this.handleRealtimeReactionDeleted)), (i = this.componentFeatures) != null && i.allowsFeature(_.Receipts) && this.weavy.subscribe(x, "app_marked", this.handleRealtimeMarked).then((O) => {
          this.showReadReceipts = O;
        }), R3(this, Oc, () => {
          var O, P, A, R;
          (O = this.weavy) == null || O.unsubscribe(x, "message_created", this.handleRealtimeMessage), (P = this.weavy) == null || P.unsubscribe(x, "reaction_added", this.handleRealtimeReactionAdded), (A = this.weavy) == null || A.unsubscribe(x, "reaction_removed", this.handleRealtimeReactionDeleted), (R = this.weavy) == null || R.unsubscribe(x, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, R3(this, Oc, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery(), this.agentsQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const b = t.get("conversation");
      if ((b == null ? void 0 : b.id) !== ((s = this.conversation) == null ? void 0 : s.id) || (b == null ? void 0 : b.is_unread) !== ((r = this.conversation) == null ? void 0 : r.is_unread))
        if ((a = this.conversation) != null && a.is_unread) {
          const x = (c = (l = (o = this.membersQuery.result.data) == null ? void 0 : o.data) == null ? void 0 : l.find(
            (O) => {
              var P;
              return O.id === ((P = this.user) == null ? void 0 : P.id);
            }
          )) == null ? void 0 : c.marked_id;
          x && x < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = x, this.showNewMessages = !0), ((b == null ? void 0 : b.id) !== ((d = this.conversation) == null ? void 0 : d.id) || (b == null ? void 0 : b.last_message.id) !== ((p = this.conversation) == null ? void 0 : p.last_message.id) && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else (b == null ? void 0 : b.id) !== ((f = this.conversation) == null ? void 0 : f.id) && (this.showNewMessages = !1);
    }
    if (this.conversation && !((m = this.conversation) != null && m.name) && !fk(this.messagesQuery.result.data)) {
      const b = ds(this.messagesQuery.result.data).find((x) => x.plain);
      b && this.setEmptyConversationTitle(IS(b.plain));
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  renderConversationHeader() {
    var t, e, i;
    if (!this.header)
      return v` <!-- Top of the conversation --> `;
    const { isPending: s, hasNextPage: r } = this.messagesQuery.result ?? {};
    if (!this.conversation || s || r)
      return Q;
    const { data: a } = this.membersQuery.result ?? {}, o = this.user && this.isPrivateChat() ? ((i = (((e = (t = this.conversation) == null ? void 0 : t.members) == null ? void 0 : e.data) || []).filter((l) => {
      var c;
      return l.id !== ((c = this.user) == null ? void 0 : c.id);
    })) == null ? void 0 : i[0]) ?? this.user : null;
    return v`
      <wy-avatar-header description=${Ct(o == null ? void 0 : o.comment)}>
        ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? v` <wy-avatar-group
              .members=${a == null ? void 0 : a.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : o != null && o.avatar_url ? v`
              <wy-avatar
                src=${Ct(o == null ? void 0 : o.avatar_url)}
                name=${this.conversation.name}
                description=${Ct(o == null ? void 0 : o.comment)}
                ?isAgent=${o == null ? void 0 : o.is_agent}
                size=${96}
              ></wy-avatar>
            ` : Q}
      </wy-avatar-header>
    `;
  }
  render() {
    var t, e, i;
    const { isPending: s } = ((t = this.weavy) == null ? void 0 : t.network) ?? { isPending: !0 }, { data: r, isPending: a, hasNextPage: o } = this.messagesQuery.result ?? { isPending: s }, { data: l } = this.membersQuery.result ?? {}, { data: c } = this.agentsQuery.result ?? {};
    return v`
      ${this.renderConversationHeader()}
      ${this.conversation && r && !fk(r) ? v`
            <wy-messages
              .conversation=${this.conversation}
              .infiniteMessages=${r}
              .members=${l}
              .unreadMarkerId=${this.lastReadMessageId}
              .unreadMarkerPosition=${this.lastReadMessagePosition}
              .unreadMarkerShow=${this.showNewMessages}
              .seenByShow=${this.showReadReceipts}
              @vote=${(d) => {
      var p;
      d.detail.parentType && d.detail.parentId && ((p = this.pollMutation) == null || p.mutate({
        optionId: d.detail.optionId,
        parentType: d.detail.parentType,
        parentId: d.detail.parentId
      }));
    }}
            >
              ${o ? v`<div slot="start" ${lt(this.pagerRef)} part="wy-pager wy-pager-top"></div>` : Q}
              <wy-message-typing
                slot="end"
                .conversationId=${this.conversation.id}
                .userId=${(e = this.user) == null ? void 0 : e.id}
                .isPrivateChat=${this.isPrivateChat()}
                .members=${l == null ? void 0 : l.data}
                .agents=${c == null ? void 0 : c.data}
                @typing=${(d) => this.handleTyping(d)}
              ></wy-message-typing>
            </wy-messages>
          ` : v`
            <div class="wy-messages">
              <wy-empty class="wy-pane">
                ${a && this.conversationId || this.isCreatingConversation ? v`<wy-spinner overlay></wy-spinner>` : v` <slot name="empty">${this.conversationId ? C("Start the conversation!") : Q}</slot> `}
              </wy-empty>
            </div>
          `}
      <div ${lt(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${lt(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? C("Type a message...")}
          ?disabled=${this.conversation && !ey(Fo.Create, (i = this.conversation) == null ? void 0 : i.permissions)}
          @submit=${(d) => this.handleSubmit(d)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        var i;
        e.isIntersecting && !this.isTyping && (i = this.conversation) != null && i.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = A3(this, Oc)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, h(sf, "Xa"), sf), u(T2, "WyConversation"), T2);
Oc = /* @__PURE__ */ new WeakMap();
Ai.styles = [
  yt,
  ya,
  w_,
  Mt`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
zn([
  Gs({ context: nP }),
  $({ attribute: !1 })
], Ai.prototype, "conversation", 2);
zn([
  $({ type: Number })
], Ai.prototype, "conversationId", 2);
zn([
  $({ type: Boolean })
], Ai.prototype, "header", 2);
zn([
  $()
], Ai.prototype, "agentInstructions", 2);
zn([
  $()
], Ai.prototype, "placeholder", 2);
zn([
  U()
], Ai.prototype, "lastReadMessagePosition", 2);
zn([
  U()
], Ai.prototype, "lastReadMessageId", 2);
zn([
  U()
], Ai.prototype, "showNewMessages", 2);
zn([
  U()
], Ai.prototype, "isCreatingConversation", 2);
zn([
  U()
], Ai.prototype, "showReadReceipts", 2);
Ai = zn([
  H("wy-conversation"),
  Ot()
], Ai);
var Ye = /* @__PURE__ */ ((n) => (n.All = "", n.Activity = "activity", n.Mention = "mention", n.Reaction = "reaction", n))(Ye || {});
function XL(n, t = Ye.All, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ u(async (s) => {
      var r;
      const a = new URLSearchParams({
        skip: ((r = s.pageParam) == null ? void 0 : r.toString()) || "0",
        type: t
      }), o = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${a.toString()}`, l = await (await n.fetch(o)).json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
h(XL, "i4");
u(XL, "getNotificationsOptions");
function NL(n, t = Ye.All, e) {
  var i;
  const s = (i = n.queryClient.getQueryData(["notifications", "list", e, t])) == null ? void 0 : i.pages.flatMap((a) => a.data);
  let r;
  return s == null || s.forEach((a) => {
    r = r && a && r.id > a.id ? r : a;
  }), r;
}
h(NL, "s4");
u(NL, "getLastNotification");
function HL(n, t) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ notificationId: e }) => {
      const i = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, n.url);
      e && i.searchParams.append("id", e.toString()), await n.fetch(i, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((e) => {
      const i = [];
      return $t(
        n.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (s) => {
          i.push({ id: s.id, is_unread: s.is_unread }), s.is_unread = !1;
        }
      ), t && i.length && $t(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (s) => !!i.find((r) => r.id === s.id && s.is_unread),
        (s) => {
          s.is_unread = !1;
        }
      ), t || Vv(
        n.queryClient,
        { queryKey: ["notifications", "badge"], exact: !1 },
        () => 0
      ), Vv(
        n.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "badge", t] : ["apps", "notifications", "badge"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: i };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u(async () => {
      t && await n.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ u(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "badge"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ u((e, i, s) => {
      console.error(e.message);
    }, "onError")
  };
}
h(HL, "r4");
u(HL, "getMarkNotificationsMutationOptions");
function YL(n, t) {
  return new Vt(n.queryClient, HL(n, t));
}
h(YL, "n4");
u(YL, "getMarkNotificationsMutation");
function GL(n) {
  return {
    mutationFn: /* @__PURE__ */ u(async ({ markAsRead: t, notificationId: e }) => {
      const i = `/api/notifications/${e}/mark`;
      await n.fetch(i, { method: t ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((t) => {
      const e = /* @__PURE__ */ new Map();
      $t(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        t.notificationId,
        (i) => {
          !!i.is_unread === t.markAsRead && e.set(i.id, i), i.is_unread = !t.markAsRead;
        }
      ), e.size && (Vv(
        n.queryClient,
        { queryKey: ["notifications", "badge"], exact: !1 },
        (i) => Math.max(0, i + (t.markAsRead ? -1 : 1))
      ), e.forEach((i) => {
        i.link.app && Vv(
          n.queryClient,
          {
            queryKey: ["apps", "notifications", "badge"],
            predicate: /* @__PURE__ */ u((s) => {
              var r, a;
              return s.queryKey[3] === ((r = i.link.app) == null ? void 0 : r.id) || s.queryKey[3] === ((a = i.link.app) == null ? void 0 : a.uid);
            }, "predicate"),
            exact: !1
          },
          (s) => Math.max(0, s + (t.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ u(async (t, e) => {
      $t(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (i) => {
          i.is_unread = e.markAsRead;
        }
      ), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "badge"], exact: !1 });
    }, "onError")
  };
}
h(GL, "a4");
u(GL, "getMarkNotificationMutationOptions");
function tC(n) {
  return new Vt(n.queryClient, GL(n));
}
h(tC, "lm");
u(tC, "getMarkNotificationMutation");
function KL(n, t = Ye.All, e, i = {}) {
  const s = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), r = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${s.toString()}`;
  return ol(n, e ? ["apps", "notifications", "badge", e, t] : ["notifications", "badge", t], r, i);
}
h(KL, "o4");
u(KL, "getBadgeOptions");
var eH = Object.defineProperty, iH = Object.getOwnPropertyDescriptor, JL = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$9"), tI = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eH(t, e, s), s;
}, "__decorateClass$v"), eI = /* @__PURE__ */ u((n, t, e) => t.has(n) || JL("Cannot " + e), "__accessCheck$9"), E3 = /* @__PURE__ */ u((n, t, e) => (eI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$9"), nH = /* @__PURE__ */ u((n, t, e) => t.has(n) ? JL("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$9"), z3 = /* @__PURE__ */ u((n, t, e, i) => (eI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$8"), $c, A2, rf;
let Xw = (A2 = (rf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.typeFilter = Ye.All, this.badgeQuery = new Cn(this), this.handleRefresh = () => {
      this.badgeQuery.result.refetch();
    }, nH(this, $c);
  }
  async willUpdate(t) {
    var e, i;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.badgeQuery.trackQuery(KL(this.weavy, this.typeFilter, (e = this.app) == null ? void 0 : e.id), !0), t.has("weavy") && this.weavy && ((i = E3(this, $c)) == null || i.call(this), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), z3(this, $c, () => {
      var s, r, a;
      (s = this.weavy) == null || s.unsubscribe(null, "notification_created", this.handleRefresh), (r = this.weavy) == null || r.unsubscribe(null, "notification_updated", this.handleRefresh), (a = this.weavy) == null || a.unsubscribe(null, "notifications_marked", this.handleRefresh), z3(this, $c, void 0);
    }));
  }
  render() {
    var t;
    const { data: e, isPending: i } = this.badgeQuery.result ?? {}, s = e != null && e.count ? e.count >= 100 ? "99+" : e.count : "";
    return v`
      ${this.user && !i && e != null && e.count ? v`
          <span class="wy-badge ${((t = this.settings) == null ? void 0 : t.notificationsBadge) === "count" ? "wy-button-badge" : "wy-button-dot"}" title=${e == null ? void 0 : e.count}>${s}</span> 
        ` : Q}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = E3(this, $c)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(rf, "Ja"), rf), u(A2, "WyNotificationBadge"), A2);
$c = /* @__PURE__ */ new WeakMap();
Xw.styles = [
  yt,
  At
];
tI([
  $()
], Xw.prototype, "typeFilter", 2);
Xw = tI([
  H("wy-notification-badge"),
  Ot()
], Xw);
var sH = Object.defineProperty, rH = Object.getOwnPropertyDescriptor, iI = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? rH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && sH(t, e, s), s;
}, "__decorateClass$u"), R2, af;
let i0 = (R2 = (af = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.showNotifications = !1, this.notificationsRef = wt(), this.appSubscribeMutation = new sn(this);
  }
  handleSubscribe(t) {
    var e;
    (e = this.app) != null && e.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.appSubscribeMutation.trackMutation(GS(this.weavy, this.app));
  }
  render() {
    var t, e, i, s;
    return ((t = this.settings) == null ? void 0 : t.notifications) === "none" || !this.app ? Q : v`
      <wy-button
        kind="icon"
        ?active=${this.showNotifications}
        @click=${() => this.showNotifications = !this.showNotifications}
      >
        <wy-icon name="bell"></wy-icon>
        ${((e = this.settings) == null ? void 0 : e.notificationsBadge) !== "none" ? v` <wy-notification-badge></wy-notification-badge> ` : Q}
      </wy-button>

      <wy-sheet
        noPadding
        .show=${this.showNotifications}
        @close=${() => this.showNotifications = !1}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        <wy-dropdown slot="appbar-buttons" ?disabled=${!this.app}>
          ${(i = this.app) != null && i.is_subscribed ? v`<wy-dropdown-item @click=${() => this.handleSubscribe(!1)}>
                <wy-icon name="bell-off"></wy-icon>
                ${C("Unsubscribe")}
              </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.handleSubscribe(!0)}>
                <wy-icon name="bell"></wy-icon>
                ${C("Subscribe")}
              </wy-dropdown-item>`}
        </wy-dropdown>
        <span slot="appbar-text">${C("Notifications")}</span>
        ${this.showNotifications ? v`
              <wy-notification-list ${lt(this.notificationsRef)}>
                ${(s = this.app) != null && s.is_subscribed ? Q : v`
                      <wy-empty slot="empty">
                          <div>${C("You are not subscribed to updates yet.")}</div>
                          <wy-button color="primary" @click=${() => this.handleSubscribe(!0)}>${C("Subscribe")}</wy-button>
                      </wy-empty>
                    `}
              </wy-notification-list>
            ` : Q}
      </wy-sheet>
    `;
  }
}, h(af, "to"), af), u(R2, "WyNotificationButtonList"), R2);
iI([
  U()
], i0.prototype, "showNotifications", 2);
i0 = iI([
  H("wy-notification-button-list"),
  Ot()
], i0);
var aH = Object.defineProperty, oH = Object.getOwnPropertyDescriptor, nI = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$8"), eC = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? oH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && aH(t, e, s), s;
}, "__decorateClass$t"), lH = /* @__PURE__ */ u((n, t, e) => t.has(n) || nI("Cannot " + e), "__accessCheck$8"), n0 = /* @__PURE__ */ u((n, t, e) => (lH(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$8"), sI = /* @__PURE__ */ u((n, t, e) => t.has(n) ? nI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$8"), W1, D1, E2, of;
let s0 = (E2 = (of = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.itemType = "file", sI(this, W1, new rg(this));
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && (e = this.componentFeatures) != null && e.allowsFeature(_.ContextData) && await n0(this, W1).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    var t;
    const { result: e } = n0(this, W1), i = e == null ? void 0 : e.filter((s) => {
      var r;
      return (r = s.variables) == null ? void 0 : r.file;
    });
    return (t = this.componentFeatures) != null && t.allowsFeature(_.ContextData) && i ? Mi(
      i,
      (s) => "mutation" + s.submittedAt,
      (s) => {
        var r;
        if ((r = s.context) != null && r.file) {
          const a = s.context.file, o = {
            ...s.context.status
          }, l = a.size && a.size > 0 ? ky(a.size) : null, c = Ei(a.name), { icon: d } = An(a.name), p = Sy(a.name), f = Ks(a.provider);
          return this.itemType === "file" ? v`
                    <wy-file-item
                      @click=${(m) => {
            !m.defaultPrevented && !a.is_trashed && this.dispatchFileOpen(m, a);
          }}
                      .hasHover=${!1}
                      .file=${s.context.file}
                      .status=${o}
                      title="${R0(s.context.type)}: ${a.name + (o.text ? `: ${o.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${a.name}
                        ${o.text ? v`: <em>${o.text}</em>` : Q}</span
                      >
                      <span slot="actions"></span>
                    </wy-file-item>
                  ` : v`
                    <a
                      @click=${(m) => {
            !m.defaultPrevented && !a.is_trashed && this.dispatchFileOpen(m, a);
          }}
                      class="wy-item wy-list-item"
                      href="${Ct(a.download_url)}"
                      title=${a.name}
                    >
                      <wy-icon name=${d} .overlayName=${f} size="48" kind=${p} ext=${c}></wy-icon>
                      <div class="wy-item-body ">
                        <div class="wy-item-title">${a.name}</div>
                        ${l ? v`<div class="wy-item-text" title="${l}">${l}</div>` : ""}
                      </div>
                    </a>
                  `;
        }
        return Q;
      }
    ) : Q;
  }
}, h(of, "eo"), of), u(E2, "WyContextDataItems"), E2);
W1 = /* @__PURE__ */ new WeakMap();
s0.styles = [yt, At];
eC([
  $()
], s0.prototype, "itemType", 2);
s0 = eC([
  H("wy-context-data-items")
], s0);
var z2, lf;
let zk = (z2 = (lf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), sI(this, D1, new rg(this));
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && (e = this.componentFeatures) != null && e.allowsFeature(_.ContextData) && await n0(this, D1).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    var t;
    const { result: e, isMutating: i } = n0(this, D1), s = e == null ? void 0 : e.filter((o) => {
      var l;
      return (l = o.variables) == null ? void 0 : l.file;
    }), r = dP(s), a = uP(s);
    return (t = this.componentFeatures) != null && t.allowsFeature(_.ContextData) && e && e.length ? v`
          ${i || r.percent !== null && r.percent < 100 ? v`
                <wy-progress-linear
                  ?indeterminate=${!r.percent}
                  overlay
                  reveal
                  ?warning=${a === "error"}
                  value=${r.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : Q}
        ` : Q;
  }
}, h(lf, "io"), lf), u(z2, "WyContextDataProgress"), z2);
D1 = /* @__PURE__ */ new WeakMap();
zk.styles = [yt, At];
zk = eC([
  H("wy-context-data-progress")
], zk);
var cH = Object.defineProperty, hH = Object.getOwnPropertyDescriptor, rI = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? hH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && cH(t, e, s), s;
}, "__decorateClass$s");
const aI = "wy-chat";
var _2, cf;
let uy = (_2 = (cf = class extends jt {
  constructor() {
    super(...arguments), this.componentType = Pt.Chat, this.componentFeatures = new $n({
      // All available features as enabled/disabled by default
      [_.Attachments]: !0,
      [_.ContextData]: !0,
      [_.CloudFiles]: !0,
      [_.Embeds]: !0,
      [_.GoogleMeet]: !0,
      [_.Meetings]: !0,
      [_.Mentions]: !0,
      [_.MicrosoftTeams]: !0,
      [_.Polls]: !0,
      [_.Previews]: !0,
      [_.Reactions]: !0,
      [_.Receipts]: !1,
      [_.Typing]: !1,
      [_.ZoomMeetings]: !0
    }), this.theme = new Js(this, uy.styles);
  }
  render() {
    var t;
    return v`
      <wy-context-data-progress></wy-context-data-progress>
      <wy-buttons position="floating" reverse>
        <wy-notification-button-list></wy-notification-button-list>
      </wy-buttons>

      <wy-conversation .conversation=${this.app} .conversationId=${(t = this.app) == null ? void 0 : t.id} .placeholder=${this.placeholder}>
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, h(cf, "so"), cf), u(_2, "WyChat"), _2);
uy.styles = [yt, pa, cl, Xi, tr];
rI([
  $()
], uy.prototype, "placeholder", 2);
uy = rI([
  H(aI),
  Ot()
], uy);
var dH = Object.defineProperty, uH = Object.getOwnPropertyDescriptor, oI = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? uH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && dH(t, e, s), s;
}, "__decorateClass$r");
const lI = "wy-comments";
var L2, hf;
let py = (L2 = (hf = class extends jt {
  constructor() {
    super(...arguments), this.componentType = Pt.Comments, this.componentFeatures = new $n({
      // All available features as enabled/disabled by default
      [_.Attachments]: !0,
      [_.CloudFiles]: !0,
      [_.ContextData]: !0,
      [_.Embeds]: !0,
      [_.GoogleMeet]: !1,
      [_.Meetings]: !1,
      [_.Mentions]: !0,
      [_.MicrosoftTeams]: !1,
      [_.Polls]: !0,
      [_.Previews]: !0,
      [_.Reactions]: !0,
      [_.Typing]: !1,
      // Has no effect currently
      [_.ZoomMeetings]: !1
    }), this.theme = new Js(this, py.styles);
  }
  render() {
    var t;
    return v`
      <wy-buttons position="floating" reverse>
        <wy-notification-button-list></wy-notification-button-list>
      </wy-buttons>
      <wy-comment-list parentId=${(t = this.app) == null ? void 0 : t.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, h(hf, "ro"), hf), u(L2, "WyComments"), L2);
py.styles = [yt, pa, cl, Xi, tr];
oI([
  $()
], py.prototype, "placeholder", 2);
py = oI([
  H(lI),
  Ot()
], py);
function cI(n) {
  var t;
  if (!this.weavy || !this.app)
    return;
  const e = {
    message: n.message,
    direction: n.message.created_by.id === ((t = this.user) == null ? void 0 : t.id) ? "outbound" : "inbound"
  };
  n.message.created_by.is_agent && (e.agent = n.message.created_by.uid);
  const i = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: e
  });
  this.dispatchEvent(i);
}
h(cI, "$4");
u(cI, "handleRealtimeMessage");
const pH = Mt`.wy-list{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-border);min-width:0}.wy-list .wy-item:not(.wy-item-hover){--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-list .wy-item:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-list .wy-item:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.wy-list-bordered{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));gap:0}.wy-list-bordered .wy-item{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-left:none;border-right:none}.wy-list-bordered .wy-item:first-child{border-top:none}.wy-list-bordered .wy-item:last-child{border-bottom:none}.wy-list-bordered .wy-item+.wy-list-bordered .wy-item{border-top-width:0}`;
var fH = Object.defineProperty, yH = Object.getOwnPropertyDescriptor, iC = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? yH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && fH(t, e, s), s;
}, "__decorateClass$q");
const hI = "wy-copilot";
var I2, df;
let el = (I2 = (df = class extends jt {
  constructor() {
    super(...arguments), this.componentType = Pt.AgentChat, this.componentFeatures = new $n({
      // All available features as enabled/disabled by default
      [_.Attachments]: !1,
      [_.ContextData]: !0,
      [_.Embeds]: !0,
      [_.Mentions]: !1,
      [_.Previews]: !0,
      [_.Reactions]: !1,
      [_.Typing]: !0
    }), this.theme = new Js(this, el.styles), this.conversationRef = wt(), this.handleRealtimeMessage = cI.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    var e;
    await ((e = this.conversationRef.value) == null ? void 0 : e.setEditorText(t));
  }
  async willUpdate(t) {
    var e;
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = YS(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && ((e = this.unsubscribeToRealtime) == null || e.call(this), this.app)) {
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        var s;
        (s = this.weavy) == null || s.unsubscribe(i, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
  }
  render() {
    var t;
    return this.agent ? v`
          <wy-buttons position="floating" reverse>
            ${this.app && this.uid ? v` <wy-notification-button-list></wy-notification-button-list> ` : Q}
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${lt(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${(t = this.app) == null ? void 0 : t.id}
            .placeholder=${this.placeholder ?? C("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (e) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const i = {
        uid: `wy-copilot-${Fc()}`,
        name: ZS(IS(this.name ?? e.text)),
        members: [this.agent],
        type: vn.AgentChat
      }, s = await this.addConversationMutation.mutate(i);
      return this.app = s, await this.updateComplete, s;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (e) => {
      var i, s;
      e.target.matches(".suggestion") && (e.stopPropagation(), await this.setSuggestion(e.target.innerText), await ((i = this.conversationRef.value) == null ? void 0 : i.setCursorLastInEditor()), (s = this.conversationRef.value) == null || s.focusEditor());
    }}
              @keydown=${je}
              @keyup=${gi}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <div class="wy-list">
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </div>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>

        ` : v`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, h(df, "no"), df), u(I2, "WyCopilot"), I2);
el.styles = [pa, cl, Xi, tr, pH];
iC([
  $()
], el.prototype, "instructions", 2);
iC([
  $()
], el.prototype, "placeholder", 2);
el = iC([
  H(hI),
  Ot()
], el);
function dI(n, t, e = {}, i = {}) {
  if (!n)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...i,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ u(async (s) => {
      const r = s.pageParam, a = !!(e != null && e.trashed), o = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let l = "/api/apps/" + t + "/files?skip=" + r + "&order_by=" + o;
      return a && (l += "&trashed=null"), await (await n.fetch(l)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((s) => s.end && s.end < s.count ? s.end : null, "getNextPageParam")
  };
}
h(dI, "M4");
u(dI, "getInfiniteFileListOptions");
function uI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ u(async ({ file: s, name: r }) => {
      if (s.id >= 1) {
        const a = await n.fetch("/api/files/" + s.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: r
          })
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
        return await a.json();
      } else
        throw new Error(`Could not rename ${s.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => ($t(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { name: s.name })
    ), { type: "rename", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, s)
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { name: r.file.name })
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }, "onError")
  };
  return i;
}
h(uI, "P4");
u(uI, "getRenameFileMutationOptions");
function pI(n, t) {
  return new Vt(n.queryClient, uI(n, t));
}
h(pI, "S4");
u(pI, "getRenameFileMutation");
function fI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ u(async ({ file: s }) => {
      if (s.id >= 1) {
        if (!(await n.fetch("/api/files/" + s.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => ($t(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { is_trashed: !0 })
    ), { type: "trash", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, s)
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
h(fI, "A4");
u(fI, "getTrashFileMutationOptions");
function yI(n, t) {
  return new Vt(n.queryClient, fI(n, t));
}
h(yI, "E4");
u(yI, "getTrashFileMutation");
function mI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ u(async ({ file: s }) => {
      if (s.id >= 1) {
        const r = await n.fetch("/api/files/" + s.id + "/restore", { method: "POST" });
        if (!r.ok) {
          const a = await r.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const r = { status: 400, title: `Could not restore ${s.name}.` };
        throw new Error(r.detail || r.title, { cause: r });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => ($t(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { status: "pending" })
    ), { type: "restore", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !1, status: "ok" })
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
h(mI, "R4");
u(mI, "getRestoreFileMutationOptions");
function wI(n, t) {
  return new Vt(n.queryClient, mI(n, t));
}
h(wI, "O4");
u(wI, "getRestoreFileMutation");
function gI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ u(async ({ file: s }) => {
      if (s.id >= 1 && s.is_trashed) {
        const r = await n.fetch("/api/files/" + s.id, { method: "DELETE" });
        if (!r.ok) {
          const a = await r.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const r = { status: 400, title: `Could not delete ${s.name} forever.` };
        throw new Error(r.detail || r.title, { cause: r });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => ($t(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { status: "pending" })
    ), { type: "delete-forever", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      OU(e, { queryKey: i.mutationKey, exact: !1 }, r.file.id), re(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { status: void 0 })
      ), re(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
h(gI, "L4");
u(gI, "getDeleteForeverFileMutationOptions");
function vI(n, t) {
  return new Vt(n.queryClient, gI(n, t));
}
h(vI, "I4");
u(vI, "getDeleteForeverFileMutation");
function bI(n, t) {
  const e = n.queryClient, i = ["apps", t.id, "files"];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ u(async ({ file: s, subscribe: r }) => {
      if (s.id >= 1) {
        const a = await n.fetch(`/api/files/${s.id}/${r ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else
        throw new Error(`Could not ${r ? "subscribe" : "unsubscribe"} to ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => ($t(
      e,
      { queryKey: i, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { is_subscribed: s.subscribe, status: "pending" })
    ), {
      type: s.subscribe ? "subscribe" : "unsubscribe",
      file: s.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { status: "ok" })
      ), re(e, i, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_subscribed: r.file.is_subscribed, status: "error" })
      ), re(e, i, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }, "onError")
  };
}
h(bI, "T4");
u(bI, "getSubscribeFileMutationOptions");
function OI(n, t) {
  return new Vt(n.queryClient, bI(n, t));
}
h(OI, "F4");
u(OI, "getSubscribeFileMutation");
const mH = /* @__PURE__ */ u((n) => {
  var p;
  var t, e, i, s, r, a, o, l, c, d;
  return d = (p = class extends n {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...m) {
      super(...m), F(this, s), F(this, t, []), F(this, e), F(this, i, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return k(this, e);
    }
    set eventParent(m) {
      m != null && m.eventChildren && m.eventChildren.add(this), L(this, e, m);
    }
    get eventChildren() {
      return k(this, i);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...m) {
      const w = mt(this, s, c).call(this, m);
      if (m[3]) {
        const b = /* @__PURE__ */ u((...x) => {
          try {
            w.handler.apply(this, x);
          } catch {
            try {
              w.handler();
            } catch (O) {
              console.warn("Could not invoke one handler:", O);
            }
          }
          mt(this, s, o).call(this, w.events, w.selector, null, w.handler);
        }, "attachedHandler");
        mt(this, s, r).call(this, w.events, w.selector, b, w.handler);
      } else
        mt(this, s, r).call(this, w.events, w.selector, w.handler, w.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(m, w, b) {
      this.on(m, w, b, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...m) {
      const w = mt(this, s, c).call(this, m), b = mt(this, s, a).call(this, w.events, w.selector, w.handler);
      return mt(this, s, o).call(this, w.events, w.selector, b, w.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      k(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(m, w, ...b) {
      const x = /^(before|on|after):/.test(m), O = x ? m.split(":")[0] : "";
      m = m.replace(/^(before|on|after):/, "");
      const P = "before:" + m, A = m, R = "after:" + m;
      if (w && typeof w == "string")
        try {
          w = JSON.parse(w);
        } catch {
          console.warn("Could not parse event data", m, w);
        }
      let T;
      if (x) {
        if (O === "before" || O === "after") {
          if (k(this, e) && (T = k(this, e).triggerEvent(
            O === "before" ? P : R,
            w,
            ...b
          ), w = T || T === !1 ? T : w, w === !1) || (T = mt(this, s, l).call(this, O === "before" ? P : R, w, ...b), w = T || T === !1 ? T : w, w === !1))
            return w;
        } else if (O === "on" && (T = mt(this, s, l).call(this, A, w, ...b), w = T || T === !1 ? T : w, w === !1 || k(this, e) && (T = k(this, e).triggerEvent("on:" + A, w, ...b), w = T || T === !1 ? T : w, w === !1)))
          return w;
      } else {
        if (k(this, e) && (T = k(this, e).triggerEvent(P, w, ...b), w = T || T === !1 ? T : w, w === !1) || (T = mt(this, s, l).call(this, P, w, ...b), w = T || T === !1 ? T : w, w === !1) || (T = mt(this, s, l).call(this, A, w, ...b), w = T || T === !1 ? T : w, w === !1) || k(this, e) && (T = k(this, e).triggerEvent("on:" + A, w, ...b), w = T || T === !1 ? T : w, w === !1) || k(this, e) && (T = k(this, e).triggerEvent(R, w, ...b), w = T || T === !1 ? T : w, w === !1))
          return w;
        T = mt(this, s, l).call(this, R, w, ...b), w = T || T === !1 ? T : w;
      }
      return w;
    }
  }, h(p, "p"), p), t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakSet(), /**
  * Saves a single event handler.
  *
  * @internal
  * @function
  * @param {string} event - One or more events. Multiple events are currently not registered individually.
  * @param {string|Object} [selector] - Optional refinement selector
  * @param {function} handler - The handler function. may be wrapped for once-handlers
  * @param {function} originalHandler - The original non-wrapped event handler.
  */
  r = /* @__PURE__ */ u(function(f, m, w, b) {
    k(this, t).push({
      events: f,
      selector: m,
      handler: w,
      originalHandler: b
    });
  }, "#registerEventHandler"), /**
  * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} events - The events registered
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @param {function} handler - The registered handler
  * @param {function} [originalHandler] - The original registered handler
  */
  a = /* @__PURE__ */ u(function(f, m, w, b) {
    const x = {
      events: f,
      selector: m,
      handler: w,
      originalHandler: b || w
    }, O = k(this, t).filter((P) => Vc(x, P, !0)).pop();
    return O && O.handler;
  }, "#getEventHandler"), /**
  * Unregister an event handler. Arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} event - The events registered
  * @param {function} handler - The registered handler
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @returns {boolean} - True if any handler was removed
  */
  o = /* @__PURE__ */ u(function(f, m, w, b) {
    const x = {
      events: f,
      selector: m,
      handler: w,
      originalHandler: b
    };
    let O = !1;
    return k(this, t).forEach((P, A) => {
      Vc(x, P, !0) && (O = !0, k(this, t).splice(A, 1));
    }), O;
  }, "#unregisterEventHandler"), /**
  * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
  *
  * @example
  * weavyEvents.on("myevent", function(e, data) { ... })
  *
  * triggerHandler(this, "myevent", { key: 1 })
  *
  * @internal
  * @function
  * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
  * @param {any} data - Any data to pass to the handler
  * @param {any} ...additionalData - Any extra data
  */
  l = /* @__PURE__ */ u(function(f, m, ...w) {
    let b = !1;
    return k(this, t).forEach((x) => {
      x.events.split(" ").forEach((O) => {
        if (O = O.indexOf("on:") === 0 ? O.split("on:")[1] : O, f === O && (!x.selector || Vc(x.selector, m, !0))) {
          const P = x.handler(m, ...w);
          P ? m = P : P === !1 && (b = !0);
        }
      });
    }), b ? !1 : m;
  }, "#triggerHandler"), /**
  * Extracts and normalizes all parts of the events arguments.
  *
  * @internal
  * @function
  * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
  * @returns {Object}
  * @property {string} events - Event names with added namespace for local events.
  * @property {string|Object} selector - The optional selector.
  * @property {function} handler - The handler function
  * @
  */
  c = /* @__PURE__ */ u(function(f) {
    const m = typeof f[1] == "function" ? f[1] : f[2], w = typeof f[1] == "function" ? null : f[1];
    return { events: f[0], selector: w, handler: m };
  }, "#getEventArguments"), u(d, "WeavyEvents"), d;
}, "MixinWeavyEvents"), wH = mH(class {
});
function _k(n) {
  var t;
  let e = "";
  try {
    e = ((t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(n)) == null ? void 0 : t[1]) || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return e;
}
h(_k, "Ky");
u(_k, "extractOrigin");
var uf;
const $I = (uf = class extends wH {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = a0() ? _k(window.location.href) : "", this.timeout = 2e3, t != null && t.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      var i, s;
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            (i = e.source) == null || i.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const r = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, a = e.source ? this.contentWindowNames.get(e.source) : void 0;
              a && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: a,
                  weavyId: r || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (r) {
              console.error("could not register frame window", r);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && (s = this.contentWindowsMapByWeavyId.get(e.data.weavyId)) != null && s.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const i = t.source === window && t.origin === this.origin;
    if (e || (e = t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1), i || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const s = t.data.name;
      s && this.triggerEvent(s, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, i, s) {
    var r;
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!i || i === "true") && (i = !0), this.contentWindowsMapByWeavyId.has(i) || this.contentWindowsMapByWeavyId.set(i, /* @__PURE__ */ new Map()), (r = this.contentWindowsMapByWeavyId.get(i)) == null || r.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, i), this.contentWindowOrigins.set(t, s);
  }
  unregisterAll(t) {
    var e;
    this.contentWindowsMapByWeavyId.has(t) && ((e = this.contentWindowsMapByWeavyId.get(t)) == null || e.forEach((i, s) => {
      this.unregisterContentWindow(s, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    var i, s, r, a;
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if ((i = this.contentWindowsMapByWeavyId.get(e)) != null && i.has(t)) {
        const o = (s = this.contentWindowsMapByWeavyId.get(e)) == null ? void 0 : s.get(t);
        if (o)
          try {
            this.contentWindows.delete(o), this.contentWindowNames.delete(o), this.contentWindowWeavyIds.delete(o), this.contentWindowOrigins.delete(o);
          } catch {
          }
      }
      if ((r = this.contentWindowsMapByWeavyId.get(e)) == null || r.delete(t), ((a = this.contentWindowsMapByWeavyId.get(e)) == null ? void 0 : a.size) === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, i) {
    ti(), i === null && (i = void 0);
    const s = t === window.self, r = s ? _k(window.location.href) : this.contentWindowOrigins.get(t);
    if (s || t && r === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = Kf() + Kf());
      let a;
      await Promise.race([
        new Promise((o, l) => {
          a = window.setTimeout(() => {
            l(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((o) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(a), o(void 0);
          }), t.postMessage(e, { targetOrigin: r, transfer: i });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + r + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((i) => {
      const s = this.contentWindowOrigins.get(i);
      if (s === this.contentWindowDomain.get(i))
        try {
          i.postMessage(t, { targetOrigin: s, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(i)
          );
        }
    });
  }
  async postToFrame(t, e, i, s) {
    var r;
    if (typeof i != "object" || !i.name) {
      console.error("postToFrame() Invalid message format", i);
      return;
    }
    const a = (r = this.contentWindowsMapByWeavyId.get(e)) == null ? void 0 : r.get(t);
    if (!a)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return i.weavyId = e, await this.whenPostMessage(a, i, s);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, i) {
    if (t.source && t.data.weavyId !== void 0) {
      const s = t.source === window.self && t.origin === this.origin, r = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (i === null && (i = void 0), s || r) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: i });
        } catch (a) {
          console.error("postToSource() Could not post message back to source", a);
        }
      }
    }
  }
}, h(uf, "Zp"), uf);
u($I, "WeavyPostalParent");
let gH = $I;
var vH = Object.defineProperty, bH = Object.getOwnPropertyDescriptor, sb = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? bH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vH(t, e, s), s;
}, "__decorateClass$p"), Z2, pf;
let il = (Z2 = (pf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = wt(), this.overlayRef = wt();
  }
  open() {
    this.showOverlay = !0;
  }
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", { detail: { externalBlobs: t } });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      var i, s;
      e.source === ((s = (i = this.iframeElementRef.value) == null ? void 0 : i.contentWindow) == null ? void 0 : s.self) && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      var i, s;
      e.source === ((s = (i = this.iframeElementRef.value) == null ? void 0 : i.contentWindow) == null ? void 0 : s.self) && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      var i, s;
      e.source === ((s = (i = this.iframeElementRef.value) == null ? void 0 : i.contentWindow) == null ? void 0 : s.self) && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new gH()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    var t, e, i;
    super.disconnectedCallback(), (t = this.weavyPostal) == null || t.off("add-external-blobs", this.handleFiles), (e = this.weavyPostal) == null || e.off("request:file-browser-close", this.handleClose), (i = this.weavyPostal) == null || i.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    var t, e;
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? (t = this.iframeElementRef.value) != null && t.contentWindow && (this.weavyPostal.registerContentWindow(
      (e = this.iframeElementRef.value) == null ? void 0 : e.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    var t;
    return this.weavy ? v`
      <wy-overlay
        .show=${this.showOverlay}
        ${lt(this.overlayRef)}
        @close=${() => this.close()}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        ${this.showOverlay ? v`
              <wy-spinner overlay ?hidden=${this.iframeVisible}></wy-spinner>
              <iframe
                ${lt(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${Ct((t = this.src) == null ? void 0 : t.toString())}
                style="flex: 1 1 100%; border: 0;"
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${C("Cloud File Browser")}
              ></iframe>
            ` : Q}
      </wy-overlay>
    ` : Q;
  }
}, h(pf, "ao"), pf), u(Z2, "WyCloudFiles"), Z2);
il.styles = yt;
sb([
  U()
], il.prototype, "src", 2);
sb([
  U()
], il.prototype, "iframeVisible", 2);
sb([
  U()
], il.prototype, "showOverlay", 2);
il = sb([
  H("wy-cloud-files"),
  Ot()
], il);
var OH = Object.defineProperty, $H = Object.getOwnPropertyDescriptor, wg = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? $H(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && OH(t, e, s), s;
}, "__decorateClass$o"), W2, ff;
let oa = (W2 = (ff = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new rg(
      this
    ), this.fileInputRef = wt(), this.cloudFilesRef = wt(), this.openFileInput = () => {
      var t;
      (t = this.fileInputRef.value) == null || t.click();
    }, this.openCloudFiles = () => {
      var t;
      (t = this.cloudFilesRef.value) == null || t.open();
    };
  }
  // remove file attachment
  async handleRemoveMutation(t) {
    var e;
    const i = await this.whenWeavy(), s = await this.whenApp(), r = t.status === "error" && !((e = t.variables) != null && e.blob) ? ["apps", s.id, "blobs", void 0] : ["apps", s.id, "files"];
    cP(
      i.queryClient,
      r,
      (a) => a.state.submittedAt === t.submittedAt
    );
  }
  handleOverwriteUpload(t) {
    var e;
    const i = (e = t.variables) == null ? void 0 : e.blob;
    i && this.dispatchCreateFiles([i], !0);
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchCreateFiles(t, e = !1) {
    const i = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(i);
  }
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      { filters: { mutationKey: ["apps", this.app.id], exact: !1 } },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    var e, i, s;
    if ((e = t.context) != null && e.file) {
      const r = t.context.file, a = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (a.text = C("Replace existing file?")), v`
        <wy-file-item
          .file=${(i = t.context) == null ? void 0 : i.file}
          .status=${a}
          .actionType=${t.context.type}
          title="${R0(t.context.type)}: ${r.name}"
        >
          <span slot="title">${r.name}</span>
          ${a.text ? v`: <span slot="actions" title=${a.text}><em>${a.text}</em></span>` : Q}
          ${a.state === "conflict" && (s = t.variables) != null && s.blob ? v`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${C("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : Q}
          <wy-button
            slot="actions"
            kind="icon"
            @click=${() => this.handleRemoveMutation(t)}
            title=${C("Discard", { desc: "Button action to discard" })}
          >
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-file-item>
      `;
    }
    return Q;
  }
  render() {
    var t, e, i, s;
    const r = this.mutatingFiles.result, a = gz(r), o = r != null && r.length ? r.filter((d) => {
      var p;
      return ((p = d.context) == null ? void 0 : p.file) && !a.includes(d);
    }) : [], l = dP(r), c = uP(r);
    return v`
      <nav class="wy-toolbar">
        <div class="wy-toolbar-buttons">
          ${ey(Fo.Create, (t = this.app) == null ? void 0 : t.permissions) ? v`
                <wy-dropdown title=${C("Add files")}>
                  <span slot="button">${C("Add files")}</span>
                  <wy-icon slot="button" name="plus" last></wy-icon>
                  <wy-dropdown-item @click=${this.openFileInput} title=${C("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${C("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    data-testid="uploadFile"
                    ${lt(this.fileInputRef)}
                    @click=${(d) => d.stopPropagation()}
                    @change=${(d) => {
      this.dispatchUploadFiles(d.target.files) && (d.target.value = "");
    }}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                  ${(e = this.componentFeatures) != null && e.allowsFeature(_.CloudFiles) ? v`
                        <wy-dropdown-item @click=${this.openCloudFiles} title=${C("From cloud")}>
                          <wy-icon name="cloud"></wy-icon>
                          <span>${C("From cloud")}</span>
                        </wy-dropdown-item>
                      ` : Q}
                </wy-dropdown>
              ` : Q}
        </div>
        <div class="wy-toolbar-buttons wy-toolbar-buttons-last">
          ${r != null && r.length ? v`
                <wy-button
                  kind="icon"
                  @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                  title=${C(c === "conflict" ? "File conflict" : c === "error" ? "Upload error" : c === "pending" ? "Pending" : "All uploads finished")}
                >
                  ${c === "conflict" ? v`<wy-icon name="alert" color="yellow" title=${C("File conflict")}></wy-icon>` : c === "error" ? v`<wy-icon name="alert-octagon" color="error" title=${C("Upload error")}></wy-icon>` : c === "pending" ? v`<wy-spinner
                        ?nospin=${l !== void 0 && l.percent !== null}
                        progress=${Ct(l.percent !== null ? l.percent : void 0)}
                        title=${C("Pending")}
                      ></wy-spinner>` : v`<wy-icon name="check" title=${C("All uploads finished")}></wy-icon>`}
                </wy-button>
              ` : Q}
          ${this.app ? v` <wy-notification-button-list></wy-notification-button-list> ` : Q}

          <wy-dropdown icon="sort" title="Sort items by" directionX="left">
            <wy-dropdown-option
              ?selected=${this.order.by === "name"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
            >
              ${C("Name")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.by === "updated_at"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
            >
              ${C("Modified")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.by === "size"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
            >
              ${C("Size")}
            </wy-dropdown-option>
            <wy-dropdown-divider></wy-dropdown-divider>
            <wy-dropdown-option
              ?selected=${!this.order.descending}
              @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
            >
              ${C("Ascending")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.descending}
              @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
            >
              ${C("Descending")}
            </wy-dropdown-option>
          </wy-dropdown>

          <wy-dropdown
            icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
            title="View options"
            directionX="left"
          >
            <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
              ${C("List view")}
            </wy-dropdown-option>
            <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
              ${C("Grid view")}
            </wy-dropdown-option>
            <wy-dropdown-divider></wy-dropdown-divider>
            <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
              ${C("Hide trashed")}
            </wy-dropdown-option>
            <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
              ${C("Show trashed")}
            </wy-dropdown-option>
          </wy-dropdown>

          <wy-dropdown directionX="left" ?disabled=${!this.app}>
            ${(i = this.app) != null && i.is_subscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                  <wy-icon name="bell-off"></wy-icon>
                  ${C("Unsubscribe")}
                </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                  <wy-icon name="bell"></wy-icon>
                  ${C("Subscribe")}
                </wy-dropdown-item>`}
            ${(s = this.app) != null && s.archive_url ? v`<wy-dropdown-item
                  @click=${() => {
      var d, p, f, m;
      return Uc((d = this.app) == null ? void 0 : d.archive_url, "_top", `${(p = this.app) != null && p.uid ? this.app.uid : `${(f = this.app) == null ? void 0 : f.type}-${(m = this.app) == null ? void 0 : m.id}`}.zip`, !0);
    }}
                >
                  <wy-icon name="download"></wy-icon>
                  ${C("Download files")}
                </wy-dropdown-item>` : Q}
          </wy-dropdown>
        </div>
      </nav>

      <wy-context-data-progress></wy-context-data-progress>

      ${this.weavy ? v`
            <wy-sheet
              .show=${this.showUploadSheet}
              @close=${() => this.showUploadSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <wy-button
                kind="icon"
                slot="appbar-buttons"
                @click=${() => {
      r == null || r.forEach((d) => this.handleRemoveMutation(d));
    }}
                title=${C("Remove all", { desc: "Button action to remove all" })}
              >
                <wy-icon name="trashcan"></wy-icon>
              </wy-button>
              <span slot="appbar-text">${C("File actions")}</span>
              ${a.length ? v`
                    ${Mi(
      a,
      (d) => "mutation" + d.submittedAt,
      (d) => this.renderFileMutation(d)
    )}
                    ${o.length ? v`<hr />` : Q}
                  ` : Q}
              ${o.length ? v`
                    ${Mi(
      o,
      (d) => "mutation" + d.submittedAt,
      (d) => this.renderFileMutation(d)
    )}
                  ` : Q}
            </wy-sheet>
          ` : Q}

      <wy-cloud-files
        ${lt(this.cloudFilesRef)}
        @external-blobs=${(d) => this.dispatchExternalBlobs(d.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
}, h(ff, "oo"), ff), u(W2, "WyFilesAppbar"), W2);
oa.styles = [yt];
wg([
  $({ type: Object })
], oa.prototype, "order", 2);
wg([
  $()
], oa.prototype, "view", 2);
wg([
  $({ type: Boolean })
], oa.prototype, "showTrashed", 2);
wg([
  U()
], oa.prototype, "showUploadSheet", 2);
oa = wg([
  H("wy-files-appbar"),
  Ot()
], oa);
const xH = Mt`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, kH = Mt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius);position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));right:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));align-items:center;display:flex}[part~=wy-card-content]{flex:1 0 auto;padding-block-end:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));padding-inline-start:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));padding-inline-end:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-card-content][part~=wy-card-top]{padding-block-start:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-card-top]{border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:top center;flex:1 1 100%;max-height:calc(10 * var(--wy-size, 1rem))}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-card-image]{width:auto;height:auto}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-top-image]{object-position:50% 38%}[part~=wy-trashed]{opacity:var(--wy-opacity-disabled, 38%);text-decoration:line-through}`;
function xI(n, t, e, i, s) {
  return n && n.length ? v`
        <table class="wy-table wy-table-hover wy-table-files">
          <thead>${kI.call(this, t)}</thead>
          <tbody>
            ${Mi(
    n,
    (r) => r.id,
    (r) => SI.call(this, this.weavy, { file: r }, e, i, s)
  )}
          </tbody>
        </table>
        <slot name="end"></slot>
      ` : Q;
}
h(xI, "W4");
u(xI, "renderFileTable");
function kI(n) {
  const t = [
    { by: void 0, title: "" },
    // File icon
    { by: "name", title: C("Name") },
    { by: void 0, title: "" },
    // Comments icon
    { by: "updated_at", title: C("Modified") },
    { by: void 0, title: C("Kind") },
    { by: "size", title: C("Size") },
    { by: void 0, title: "" }
    // Menu
  ];
  return v`
    <tr>
      ${t.map((e) => {
    if (e.title) {
      const i = e.by === (n == null ? void 0 : n.by), s = /* @__PURE__ */ u((r) => {
        r.preventDefault(), e.by && this.dispatchOrder({ by: e.by, descending: i && !(n != null && n.descending) });
      }, "onHeaderClick");
      return v` <th>
            ${e.by ? v`<div
                  class="wy-table-sort-link"
                  tabindex="0"
                  @click=${s}
                  @keydown=${je}
                  @keyup=${gi}
                  >${e.title}
                  ${i && v`<wy-icon name=${n != null && n.descending ? "menu-down" : "menu-up"}></wy-icon>` || Q}</div
                >` : e.title}
          </th>`;
    } else
      return v`<th class="wy-table-cell-icon"></th>`;
  })}
    </tr>
  `;
}
h(kI, "Q4");
u(kI, "renderFileTableHeaders");
function SI(n, { file: t }, e, i, s) {
  var r;
  const a = t.size && t.size > 0 ? ky(t.size) : Q, o = t.updated_at || t.created_at, l = new Intl.DateTimeFormat(n == null ? void 0 : n.locale, { dateStyle: "full", timeStyle: "short" }).format(
    new Date(o)
  ), c = new Intl.DateTimeFormat(n == null ? void 0 : n.locale, { dateStyle: "short" }).format(new Date(o)), d = !!(e && e === t.id), { icon: p } = An(t.name), f = Ei(t.name), m = Ks(t.provider), w = /* @__PURE__ */ u((O) => {
    O.stopImmediatePropagation();
    const P = O.target;
    P.value && P.value !== t.name ? this.dispatchRename(t, P.value) : this.dispatchEditName({ id: NaN });
  }, "handleRename"), b = /* @__PURE__ */ u((O) => {
    const P = O.target;
    O.key === "Escape" ? (O.preventDefault(), P.value = t.name, P.blur()) : O.key === "Enter" && (O.preventDefault(), P.blur());
  }, "handleRenameKey"), x = !!(i && i === t.id);
  return v`
    <tr
      class=${Xt({ "wy-table-row-trashed": t.is_trashed })}
      part=${Qe({ "wy-highlight": x })}
      @click=${(O) => {
    !O.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
  }}
      ${x && s ? lt(s) : Q}
    >
      <td class="wy-table-cell-icon"
        ><wy-icon name=${p} .overlayName=${m} size="24" kind=${t.kind} ext=${f}></wy-icon
      ></td>
      <td class="wy-table-cell-text">
        ${d ? v`
              <input
                type="text"
                maxlength="256"
                class="wy-input"
                .defaultValue=${t.name}
                @blur=${w}
                @keyup=${(O) => {
    Vs(O), b(O);
  }}
                @click=${(O) => O.preventDefault()}
                @focus=${V0}
                ${lt(Zk)}
              />
            ` : v`${t.name}`}
      </td>
      <td class="wy-table-cell-icon"
        >${(r = t.comments) != null && r.count ? v`<wy-button
              kind="icon"
              @click=${(O) => {
    !O.defaultPrevented && !t.is_trashed && (O.target.blur(), this.dispatchFileOpen(t.id, "comments"), O.stopPropagation());
  }}
              title=${C(at`${t.comments.count} comments`)}
            >
              <span class="wy-badge">${t.comments.count}</span>
            </wy-button>` : Q}</td
      >
      <td><time datetime="${o}" title=${l}>${c}</time></td>
      <td>${t.kind}</td>
      <td>${a}</td>
      <td class="wy-table-cell-icon">
        <wy-file-menu
          .file=${t}
          @edit-name=${(O) => this.dispatchEditName(O.detail.file)}
          @trash=${(O) => this.dispatchTrash(O.detail.file)}
          @restore=${(O) => this.dispatchRestore(O.detail.file)}
          @delete-forever=${(O) => this.dispatchDeleteForever(O.detail.file)}
          @subscribe=${(O) => this.dispatchSubscribe(O.detail.file, O.detail.subscribe)}
        >
        </wy-file-menu>
      </td>
    </tr>
  `;
}
h(SI, "K4");
u(SI, "renderFileTableRow");
function PI(n, t, e, i) {
  var s, r;
  const a = n.size && n.size > 0 ? ky(n.size) : Q, o = n.updated_at || n.created_at, l = new Intl.DateTimeFormat((s = this.weavy) == null ? void 0 : s.locale, { dateStyle: "full", timeStyle: "short" }).format(
    new Date(o)
  ), c = !!(t && t === n.id), { icon: d } = An(n.name), p = Ei(n.name), f = Ks(n.provider), m = /* @__PURE__ */ u((O) => {
    O.stopImmediatePropagation();
    const P = O.target;
    P.value && P.value !== n.name ? this.dispatchRename(n, P.value) : this.dispatchEditName({ id: NaN });
  }, "handleRename"), w = /* @__PURE__ */ u((O) => {
    const P = O.target;
    O.key === "Escape" ? (O.preventDefault(), P.value = n.name, P.blur()) : O.key === "Enter" && (O.preventDefault(), P.blur());
  }, "handleRenameKey"), b = {
    "wy-trashed": n.is_trashed
  }, x = !!(e && e === n.id);
  return v`
    <div
      part=${Qe({
    "wy-card": !0,
    "wy-card-trashed": n.is_trashed,
    "wy-card-hover": !n.is_trashed && !c,
    "wy-highlight": x
  })}
      title="${n.name} • ${a} • ${l}"
      tabindex="0"
      @click=${(O) => {
    !O.defaultPrevented && !n.is_trashed && this.dispatchFileOpen(n.id);
  }}
      @keydown=${je}
      @keyup=${gi}
      ${x && i ? lt(i) : Q}
    >
      <div part="wy-card-actions">
        <wy-file-menu
          small
          .file=${n}
          @edit-name=${(O) => this.dispatchEditName(O.detail.file)}
          @trash=${(O) => this.dispatchTrash(O.detail.file)}
          @restore=${(O) => this.dispatchRestore(O.detail.file)}
          @delete-forever=${(O) => this.dispatchDeleteForever(O.detail.file)}
          @subscribe=${(O) => this.dispatchSubscribe(O.detail.file, O.detail.subscribe)}
        ></wy-file-menu>
      </div>
      ${!n.is_trashed && n.thumbnail_url ? v`
            <img
              part="wy-card-top wy-card-content wy-card-image ${Qe({
    "wy-card-top-image": n.kind === "image",
    ...b
  })}"
              width=${Ct(n.width)}
              height=${Ct(n.height)}
              src=${n.thumbnail_url}
              alt=${n.name}
              ${lt(_w)}
              @load=${Lw}
              loading="lazy"
              decoding="async"
            />
          ` : v`
            <div part="wy-card-top wy-card-content wy-card-icon ${Qe(b)}">
              <wy-icon name=${d} .overlayName=${f} size="96" kind=${n.kind} ext=${p}></wy-icon>
            </div>
          `}
      <div part="wy-card-content wy-filename ${Qe(b)}">
        ${c ? v`
              <input
                type="text"
                maxlength="256"
                class="wy-input"
                .defaultValue=${n.name}
                @blur=${m}
                @keyup=${(O) => {
    Vs(O), w(O);
  }}
                @click=${(O) => O.preventDefault()}
                @focus=${V0}
                ${lt(Zk)}
              />
            ` : v`<div class="wy-truncated-text-and-icon"
              ><div>${n.name}</div> ${(r = n.comments) != null && r.count ? v`<wy-button
                    small
                    kind="icon"
                    @click=${(O) => {
    !O.defaultPrevented && !n.is_trashed && (O.target.blur(), this.dispatchFileOpen(n.id, "comments"), O.stopPropagation());
  }}
                    title=${C(at`${n.comments.count} comments`)}
                  >
                    <span class="wy-badge">${n.comments.count}</span>
                  </wy-button>` : Q}</div
            >`}
      </div>
    </div>
  `;
}
h(PI, "G4");
u(PI, "renderFileCard");
var SH = Object.defineProperty, PH = Object.getOwnPropertyDescriptor, ma = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? PH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && SH(t, e, s), s;
}, "__decorateClass$n"), D2, yf;
let Mn = (D2 = (yf = class extends Lt {
  constructor() {
    super(), this.exportParts = new nt(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.isRenamingId = NaN, this.highlightId = NaN, this.highlightComment = !1, this.highlightRef = wt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  willUpdate(t) {
    var e;
    super.willUpdate(t), t.has("link") && (this.highlightId = this.link && ((e = QP(this.link, oi.File)) == null ? void 0 : e.id), this.highlightComment = this.link && this.highlightId ? MP(this.link, oi.File, { id: this.highlightId }, oi.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments");
  }
  render() {
    return this.files && this.files.length ? this.view === "grid" ? v`
          <div part="wy-grid">
            ${Mi(
      this.files,
      (t) => t.id,
      (t) => PI.call(this, t, this.isRenamingId, this.highlightId, this.highlightRef)
    )}
          </div>
          <slot name="end"></slot>
        ` : xI.call(this, this.files, this.order, this.isRenamingId, this.highlightId, this.highlightRef) : Q;
  }
  updated(t) {
    var e;
    t.has("highlightId") && this.highlightId && ((e = this.highlightRef.value) == null || e.scrollIntoView({ block: "nearest" }));
  }
}, h(yf, "co"), yf), u(D2, "WyFilesList"), D2);
Mn.styles = [yt, cl, xH, kH];
ma([
  $({ attribute: !1 })
], Mn.prototype, "files", 2);
ma([
  $({ type: Number })
], Mn.prototype, "dataUpdatedAt", 2);
ma([
  $({ attribute: !1 })
], Mn.prototype, "order", 2);
ma([
  $()
], Mn.prototype, "view", 2);
ma([
  U()
], Mn.prototype, "isRenamingId", 2);
ma([
  U()
], Mn.prototype, "highlightId", 2);
ma([
  U()
], Mn.prototype, "highlightComment", 2);
Mn = ma([
  H("wy-files-list"),
  Ot()
], Mn);
var CH = Object.defineProperty, QH = Object.getOwnPropertyDescriptor, CI = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$7"), rb = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? QH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && CH(t, e, s), s;
}, "__decorateClass$m"), QI = /* @__PURE__ */ u((n, t, e) => t.has(n) || CI("Cannot " + e), "__accessCheck$7"), _3 = /* @__PURE__ */ u((n, t, e) => (QI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$7"), MH = /* @__PURE__ */ u((n, t, e) => t.has(n) ? CI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$7"), L3 = /* @__PURE__ */ u((n, t, e, i) => (QI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$7"), xc;
const MI = "wy-files";
var q2, mf;
let la = (q2 = (mf = class extends jt {
  constructor() {
    super(), this.componentType = Pt.Files, this.componentFeatures = new $n({
      // All available features as enabled/disabled by default
      [_.Attachments]: !0,
      [_.CloudFiles]: !0,
      [_.Comments]: !0,
      [_.ContextData]: !0,
      [_.Embeds]: !0,
      [_.GoogleMeet]: !1,
      [_.Meetings]: !1,
      [_.Mentions]: !0,
      [_.MicrosoftTeams]: !1,
      [_.Polls]: !0,
      [_.Previews]: !0,
      [_.Reactions]: !0,
      [_.Typing]: !1,
      // Has no effect currently
      [_.Versions]: !0,
      [_.WebDAV]: !0,
      [_.ZoomMeetings]: !1
    }), this.theme = new Js(this, la.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.filesQuery = new hl(this), this.persistState = new HP(this), this.infiniteScroll = new dl(this), this.pagerRef = wt(), this.previewRef = wt(), this.dropZone = new _L(this), this.appSubscribeMutation = new sn(this), this.uploadBlobMutation = new sn(this), this.createFileMutation = new sn(this), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, MH(this, xc), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  // upload files
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        const s = { file: e.files[i] };
        this.uploadBlobMutation.mutate(s).then((r) => this.handleCreateFile(r));
      }
  }
  // upload files
  handleExternalBlobs(t) {
    var e;
    if (t.detail.externalBlobs)
      for (let i = 0; i < t.detail.externalBlobs.length; i++) {
        const s = t.detail.externalBlobs[i];
        (e = this.externalBlobMutation) == null || e.mutate({ externalBlob: s }).then((r) => this.handleCreateFile(r));
      }
  }
  // add uploaded files
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  handleSubscribe(t) {
    var e;
    (e = this.app) != null && e.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  async willUpdate(t) {
    var e;
    if (await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      dI(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      await this.appSubscribeMutation.trackMutation(GS(this.weavy, this.app)), await this.uploadBlobMutation.trackMutation(j0(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(bz(this.weavy, this.user, this.app)), this.externalBlobMutation = KP(this.weavy, this.user, this.app.id), this.renameFileMutation = pI(this.weavy, this.app), this.subscribeFileMutation = OI(this.weavy, this.app), this.trashFileMutation = yI(this.weavy, this.app), this.restoreFileMutation = wI(this.weavy, this.app), this.deleteForeverFileMutation = vI(this.weavy, this.app), (e = _3(this, xc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), L3(this, xc, () => {
        var s, r, a, o, l, c;
        (s = this.weavy) == null || s.unsubscribe(i, "file_created", this.handleRealtimeFileCreated), (r = this.weavy) == null || r.unsubscribe(i, "file_updated", this.handleRealtimeFileUpdated), (a = this.weavy) == null || a.unsubscribe(i, "file_trashed", this.handleRealtimeFileTrashed), (o = this.weavy) == null || o.unsubscribe(i, "file_restored", this.handleRealtimeFileRestored), (l = this.weavy) == null || l.unsubscribe(i, "file_deleted", this.handleRealtimeFileDeleted), (c = this.weavy) == null || c.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), L3(this, xc, void 0);
      });
    }
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, dataUpdatedAt: e, hasNextPage: i, isPending: s } = this.filesQuery.result, r = this.dropZone.isDragActive, a = ds(t);
    return [
      v`
        <wy-files-appbar
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(o) => this.handleBlobUpload(o)}
          @external-blobs=${(o) => this.handleExternalBlobs(o)}
          @create-files=${(o) => o.detail.blobs.forEach((l) => this.handleCreateFile(l, o.detail.replace))}
          @order=${(o) => {
        this.order = o.detail.order;
      }}
          @show-trashed=${(o) => {
        this.showTrashed = o.detail.showTrashed;
      }}
          @view=${(o) => {
        this.view = o.detail.view;
      }}
          @subscribe=${(o) => this.handleSubscribe(o.detail.subscribe)}
        >
        </wy-files-appbar>
      `,
      this.app ? v`
            <div
              class="wy-files ${Xt({ "wy-dragging": r })}"
              data-drag-title=${C("Drop files here to upload.")}
            >
              ${a.length ? v`
                    <wy-files-list
                      .view=${this.view}
                      .files=${a}
                      .dataUpdatedAt=${e}
                      .order=${this.order}
                      @file-open=${(o) => {
        var l;
        (l = this.previewRef.value) == null || l.open(o.detail.fileId, o.detail.tab);
      }}
                      @order=${(o) => {
        this.order = o.detail.order;
      }}
                      @rename=${(o) => {
        var l;
        (l = this.renameFileMutation) == null || l.mutate({ file: o.detail.file, name: o.detail.name });
      }}
                      @subscribe=${(o) => {
        var l;
        (l = this.subscribeFileMutation) == null || l.mutate({
          file: o.detail.file,
          subscribe: o.detail.subscribe
        });
      }}
                      @trash=${(o) => {
        var l;
        (l = this.trashFileMutation) == null || l.mutate({ file: o.detail.file });
      }}
                      @restore=${(o) => {
        var l;
        (l = this.restoreFileMutation) == null || l.mutate({ file: o.detail.file });
      }}
                      @delete-forever=${(o) => {
        var l;
        (l = this.deleteForeverFileMutation) == null || l.mutate({ file: o.detail.file });
      }}
                    >
                      ${i ? v`<div slot="end" ${lt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
                    </wy-files-list>
                  ` : v`
                    <wy-empty>
                      ${s ? v`<wy-spinner padded reveal></wy-spinner>` : v` <wy-icon-display>
                            <wy-icon name="file-upload"></wy-icon>
                            <span slot="text">${C("Add some files to get started!")}</span>
                          </wy-icon-display>`}
                    </wy-empty>
                  `}
            </div>
            ${t ? v` <wy-preview ${lt(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : Q}
          ` : v`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty>`
    ];
  }
  disconnectedCallback() {
    var t;
    (t = _3(this, xc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(mf, "lo"), mf), u(q2, "WyFiles"), q2);
xc = /* @__PURE__ */ new WeakMap();
la.styles = [Xi, yt, pa, tr, ya];
rb([
  $()
], la.prototype, "view", 2);
rb([
  $({ type: Object })
], la.prototype, "order", 2);
rb([
  $({ type: Boolean })
], la.prototype, "showTrashed", 2);
la = rb([
  H(MI),
  Ot()
], la);
const TH = Mt`.wy-messenger-layout{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0}wy-conversation-list{flex:0 1 50%;min-width:0;max-width:24rem;border-right:1px solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c1c7ce))}.wy-messenger-conversation{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;min-width:max(50%,16rem)}.wy-close-conversation{display:none}@container (max-width: 768px){wy-conversation-list{flex:0 1 100%;min-width:0;max-width:none;border-right:none}wy-conversation-list[conversationid]{display:none}.wy-messenger-conversation[data-conversation-id=\"\"]{display:none}.wy-close-conversation{display:contents}wy-empty{display:none}}`, AH = Mt`.wy-title{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, 1.25em);font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.2));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-input{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));display:block;width:100%;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-input:focus{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-input::placeholder{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:1}.wy-input:disabled{opacity:38%}.wy-input::file-selector-button,.wy-input::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1 * var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1 * var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}.wy-input:hover:not(:disabled):not([readonly])::file-selector-button,.wy-input:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}.wy-input[type=file]{overflow:hidden}.wy-input[type=file]:not(:disabled):not([readonly]){cursor:pointer}.wy-input::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem)))) * 1em)}.wy-input[type=search]::-webkit-search-cancel-button{-webkit-appearance:none}.wy-input-filled{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}.wy-input-filled:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-label{display:inline-block;margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25 * var(--wy-size, 1rem))}.wy-is-invalid,.wy-is-invalid:focus{border-color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-invalid-feedback{margin-top:calc(.25 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-input-group{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}.wy-input-group-button-icon{--wy-component-background-color: transparent}.wy-input-group-input-with-overlay{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-input-group-button-icon-overlay{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}.wy-input-group-input:placeholder-shown~.wy-input-group-button-icon[type=reset]{display:none}.wy-input-group-input:not(:placeholder-shown)~.wy-input-group-button-icon[type=reset]+.wy-input-group-button-icon{display:none}`;
var RH = Object.defineProperty, EH = Object.getOwnPropertyDescriptor, ab = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RH(t, e, s), s;
}, "__decorateClass$l"), V2, wf;
let fy = (V2 = (wf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.inputRef = wt(), this.compact = !1, this.query = "", this.throttledSearch = Tk(
      () => {
        var t;
        this.query = ((t = this.inputRef.value) == null ? void 0 : t.value) || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  focusInput() {
    var t;
    (t = this.inputRef.value) == null || t.focus();
  }
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return v`
      <div class="wy-input-group">
        <input
          class=${Xt(t)}
          name="text"
          .value=${this.query || ""}
          ${lt(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${R_}
          @keyup=${Vs}
          placeholder=${this.placeholder || C("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" class=${Xt(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" class=${Xt(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, h(wf, "ho"), wf), u(V2, "WySearch"), V2);
fy.styles = [AH, At];
ab([
  $()
], fy.prototype, "placeholder", 2);
ab([
  $({ type: Boolean })
], fy.prototype, "compact", 2);
ab([
  U()
], fy.prototype, "query", 2);
fy = ab([
  H("wy-search"),
  Ot()
], fy);
var zH = Object.defineProperty, _H = Object.getOwnPropertyDescriptor, wa = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? _H(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && zH(t, e, s), s;
}, "__decorateClass$k"), j2, gf;
let Tn = (j2 = (gf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new hl(this), this.searchRef = wt(), this.infiniteScroll = new dl(this), this.pagerRef = wt();
  }
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", { detail: { members: this.selected } });
    return this.dispatchEvent(t);
  }
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((i) => i.id !== t.id), this.selected = this.selected.filter((i) => i.id !== t.id));
  }
  getSelected() {
    return this.selected.length > 0 ? v`
        ${this.selected.map((t) => v`
            <div
              class="wy-item wy-list-item wy-item-hover"
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${je}
              @keyup=${je}
            >
              <wy-avatar
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <div class="wy-item-body"> ${t.name} </div>
              <wy-icon name="checkbox-marked"></wy-icon>
            </div>
          `)}
      ` : Q;
  }
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: i } = this.peopleQuery.result ?? { data: [], isPending: !0 }, s = ds(t), r = !!s.length, a = [];
    return i ? a.push(v`<wy-spinner overlay></wy-spinner>`) : r || a.push(v`<div class="wy-pane-group">
        <div class="wy-table-no-result">
          ${this.text ? C("Your search did not match any people.") : C("No more users found.")}
        </div>
      </div>`), r && a.push(
      v` ${s.filter((o) => this.selected.find((l) => l.id === o.id) === void 0).map((o) => v`<div
              class="wy-item wy-list-item wy-item-hover"
              @click=${() => this.handleSelected(o, !this.isChecked(o.id))}
              @keydown=${je}
              @keyup=${je}
            >
              <wy-avatar
                id=${o.id}
                .src=${o.avatar_url}
                .name=${o.name}
                .description=${o.comment}
                .presence=${o.presence}
                .isAgent=${o.is_agent}
                size=${32}
              ></wy-avatar>
              <div class="wy-item-body"> ${o.name} </div>
              <wy-icon name="${this.isChecked(o.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon>
            </div>`) ?? Q}`
    ), e && a.push(v`<div ${lt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), a;
  }
  render() {
    return v`<div class="wy-pane wy-scroll-y">
      <div class="wy-pane-body">
        <div class="wy-pane-group">
          <wy-search ${lt(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${C("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${C("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${C("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div class="wy-pane-body">
          ${this.getSelected()} ${this.getSearchResult()}
        </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div class="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? C("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      m_(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    var e, i, s;
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await ((i = (e = this.peopleQuery.result) == null ? void 0 : e.refetch) == null ? void 0 : i.call(e)), (s = this.searchRef.value) == null || s.focusInput());
  }
}, h(gf, "uo"), gf), u(j2, "WyUsersSearch"), j2);
Tn.styles = [
  yt,
  w_,
  ya,
  At
];
wa([
  ve({ context: _e, subscribe: !0 }),
  U()
], Tn.prototype, "weavy", 2);
wa([
  $({ attribute: !1 })
], Tn.prototype, "appId", 2);
wa([
  $({ attribute: !1 })
], Tn.prototype, "buttonTitle", 2);
wa([
  U()
], Tn.prototype, "agentFilter", 2);
wa([
  U()
], Tn.prototype, "selected", 2);
wa([
  U()
], Tn.prototype, "select", 2);
wa([
  U()
], Tn.prototype, "text", 2);
Tn = wa([
  H("wy-users-search"),
  Ot()
], Tn);
var LH = Object.defineProperty, IH = Object.getOwnPropertyDescriptor, nC = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LH(t, e, s), s;
}, "__decorateClass$j"), F2, vf;
let yy = (F2 = (vf = class extends Lt {
  constructor() {
    super(...arguments), this.uploadBlobMutation = new sn(this), this.fileInputRef = wt(), this.openFileInput = () => {
      var t;
      (t = this.fileInputRef.value) == null || t.click();
    };
  }
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const i = { file: t[0] };
      await this.uploadBlobMutation.trackMutation($z(this.weavy));
      const s = await this.uploadBlobMutation.mutate(i);
      e && (e.value = "");
      const r = new CustomEvent("blob-uploaded", { detail: { blob: s } });
      this.dispatchEvent(r);
    }
  }
  render() {
    return v` <slot
        name="placeholder"
        @click=${this.openFileInput}
        @keydown=${je}
        @keyup=${gi}
      ></slot>
      <input
        accept=${Ct(this.accept)}
        type="file"
        ${lt(this.fileInputRef)}
        @click=${(t) => t.stopPropagation()}
        @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
        hidden
      />
      <slot name="label">
        ${this.label ? v`<wy-button @click=${this.openFileInput}>${this.label}</wy-button>` : Q}
      </slot>`;
  }
}, h(vf, "po"), vf), u(F2, "WyBlobUpload"), F2);
yy.styles = [
  Mt`
      :host {
        text-align: center;
      }
      slot[name="placeholder"] {
        cursor: pointer;
      }
    `
];
nC([
  $({ attribute: !1 })
], yy.prototype, "label", 2);
nC([
  $({ attribute: !1 })
], yy.prototype, "accept", 2);
yy = nC([
  H("wy-blob-upload"),
  Ot()
], yy);
var ZH = Object.defineProperty, WH = Object.getOwnPropertyDescriptor, TI = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$6"), ml = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? WH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && ZH(t, e, s), s;
}, "__decorateClass$i"), AI = /* @__PURE__ */ u((n, t, e) => t.has(n) || TI("Cannot " + e), "__accessCheck$6"), I3 = /* @__PURE__ */ u((n, t, e) => (AI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$6"), DH = /* @__PURE__ */ u((n, t, e) => t.has(n) ? TI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$6"), Z3 = /* @__PURE__ */ u((n, t, e, i) => (AI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$6"), kc, U2, bf;
let cs = (U2 = (bf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), this.membersQuery = new Cn(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ u((i) => {
        const s = i.members.data ?? [];
        return s.forEach((r) => {
          r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
        }), i.members.data = s, i;
      }, "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], e);
    }, DH(this, kc);
  }
  isAgentChat(t) {
    var e;
    return ((e = t ?? this.conversation) == null ? void 0 : e.type) === Pt.AgentChat;
  }
  isChatRoom(t) {
    var e;
    return ((e = t ?? this.conversation) == null ? void 0 : e.type) === Pt.ChatRoom;
  }
  isPrivateChat(t) {
    var e;
    return ((e = t ?? this.conversation) == null ? void 0 : e.type) === Pt.PrivateChat;
  }
  async addMembers(t) {
    var e;
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await ((e = this.addMembersMutation) == null ? void 0 : e.mutate({ appId: this.conversationId, members: t.map((i) => i.id) })), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  async handleSaveConversationName() {
    var t;
    if (!this.weavy || !this.conversationId)
      return;
    const e = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await ((t = this.updateConversationMutation) == null ? void 0 : t.mutate({ appId: this.conversationId, name: e }));
  }
  async handleAvatarUploaded(t) {
    var e;
    !this.weavy || !this.conversationId || await ((e = this.updateConversationMutation) == null ? void 0 : e.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    }));
  }
  async clearAvatar() {
    var t;
    !this.weavy || !this.conversationId || await ((t = this.updateConversationMutation) == null ? void 0 : t.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null }));
  }
  async updateMember(t, e) {
    var i;
    !this.weavy || !this.conversationId || (await ((i = this.updateMemberMutation) == null ? void 0 : i.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    })), await this.membersQuery.result.refetch());
  }
  async leaveConversation(t) {
    var e;
    if (!(!this.weavy || !this.conversationId || !this.user)) {
      if (t && await ((e = this.leaveConversationMutation) == null ? void 0 : e.mutate({
        appId: this.conversationId,
        members: [t]
      })), !t || t === this.user.id) {
        this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0;
        const i = new CustomEvent("selected", { detail: { id: void 0 } });
        this.dispatchEvent(i);
      } else
        await this.membersQuery.result.refetch();
      await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = gP(this.weavy), this.addMembersMutation = d_(this.weavy), this.updateConversationMutation = vP(this.weavy), this.updateMemberMutation = h_(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = I3(this, kc)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          Fv(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ u(() => {
              var s, r;
              if (this.conversationId)
                return (r = (s = this.weavy) == null ? void 0 : s.queryClient.getQueryData(["apps", this.conversationId])) == null ? void 0 : r.members;
            }, "initialData")
          })
        );
        const i = `a${this.conversationId}`;
        this.weavy.subscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), Z3(this, kc, () => {
          var s, r;
          (s = this.weavy) == null || s.unsubscribe(i, "app_updated", this.handleRealtimeAppUpdated), (r = this.weavy) == null || r.unsubscribe(null, "online", this.handlePresenceChange), Z3(this, kc, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    var t, e, i, s;
    const { data: r } = this.membersQuery.result ?? {}, a = ((r == null ? void 0 : r.data) || []).filter((l) => l.access === yr.Admin).length, o = this.user && this.isPrivateChat() ? ((i = (((e = (t = this.conversation) == null ? void 0 : t.members) == null ? void 0 : e.data) || []).filter((l) => {
      var c;
      return l.id !== ((c = this.user) == null ? void 0 : c.id);
    })) == null ? void 0 : i[0]) ?? this.user : null;
    return this.conversationId ? v`
      <header class="wy-appbars">
        <nav class="wy-appbar">
          <slot class="wy-appbar-buttons wy-appbar-buttons-first" name="action"></slot>
          ${this.conversation && this.user ? v`
                <div class="wy-appbar-section">
                  ${this.conversation.type === Pt.PrivateChat ? v`<wy-presence
                        placement="text"
                        .status=${o == null ? void 0 : o.presence}
                        id=${Ct(o == null ? void 0 : o.id)}
                      ></wy-presence>` : Q}
                  <span class="wy-appbar-text">${this.conversationTitle}</span>
                </div>
              ` : v`<span></span>`}
          ${this.isChatRoom() ? v`<wy-button kind="icon" @click=${() => this.showDetails = !0} title="${C("Details")}">
                <wy-icon name="information"></wy-icon>
              </wy-button>` : Q}
        </nav>
      </header>

      <!-- details modal -->
      ${this.weavy ? v`
            <wy-overlay
              .show=${this.showDetails}
              @close=${() => {
      this.showDetails = !1;
    }}
              @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            >
              <header class="wy-appbars">
                <nav class="wy-appbar">
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showDetails = !1;
    }}
                  >
                    <wy-icon name="close"></wy-icon>
                  </wy-button>
                  <div class="wy-appbar-text">${this.conversationTitle}</div>
                </nav>
              </header>
              <div class="wy-scroll-y">
                ${this.showDetails && this.conversation && this.user ? v`
                      <wy-avatar-header>
                        ${this.isChatRoom() ? v`
                              <wy-blob-upload
                                @blob-uploaded=${(l) => this.handleAvatarUploaded(l.detail.blob)}
                                .accept=${"image/*"}
                                .label=${C("Select picture")}
                              >
                                <div slot="placeholder">
                                  ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : v`<wy-avatar-group
                                        .members=${r == null ? void 0 : r.data}
                                        title=${this.conversation.name}
                                        .size=${96}
                                      ></wy-avatar-group>`}
                                </div>
                                ${this.conversation.avatar_url ? v`<div slot="label"
                                      ><wy-button @click=${() => this.clearAvatar()}
                                        >${C("Remove picture")}</wy-button
                                      ></div
                                    >` : Q}
                              </wy-blob-upload>
                            ` : v`
                              <wy-avatar
                                src=${Ct(o == null ? void 0 : o.avatar_url)}
                                name=${Ct(o == null ? void 0 : o.name)}
                                presence=${(o == null ? void 0 : o.presence) || "away"}
                                ?isAgent=${o == null ? void 0 : o.is_agent}
                                id=${Ct(o == null ? void 0 : o.id)}
                                size=${96}
                              ></wy-avatar>
                            `}
                      </wy-avatar-header>
                      ${this.isChatRoom() ? v`
                            <div class="wy-pane-group">
                              <label class="wy-label" for="roomName">${C("Room name")}</label>

                              <input
                                id="roomName"
                                class="wy-input"
                                .value=${this.conversationTitleInput}
                                @input=${(l) => {
      this.conversationTitleInput = l.target.value;
    }}
                                @keyup=${A_}
                                @blur=${() => this.handleSaveConversationName()}
                              />

                              <div class="wy-description">
                                ${C("Changing the name of a group chat changes it for everyone.")}
                              </div>
                              <br />
                              <label class="wy-label">${C("Members")}</label>
                              ${r ? v`
                                    <div class="wy-list">
                                      ${((s = r.data) == null ? void 0 : s.map(
      (l) => {
        var c, d;
        return v`
                                          <div class="wy-item wy-list-item">
                                            <wy-avatar
                                              .src=${l.avatar_url}
                                              .name=${l.name}
                                              .description=${l.comment}
                                              .isAgent=${l.is_agent}
                                              size=${32}
                                            ></wy-avatar>
                                            <div class="wy-item-body">
                                              ${l.name}
                                              ${l.access === yr.Admin ? v` <wy-icon
                                                    size="20"
                                                    inline
                                                    name="shield-star"
                                                    title=${C("Admin")}
                                                  ></wy-icon>` : Q}
                                            </div>
                                            ${this.user && this.user.id === l.id && !ey(Fo.Admin, (c = this.conversation) == null ? void 0 : c.permissions) ? v` <wy-button
                                                  @click=${() => this.leaveConversation(l.id)}
                                                  title=${C("Leave conversation")}
                                                  kind="icon"
                                                >
                                                  <wy-icon name="close"></wy-icon>
                                                </wy-button>` : ey(Fo.Admin, (d = this.conversation) == null ? void 0 : d.permissions) ? v`<wy-dropdown>
                                                  <wy-dropdown-item @click=${() => this.leaveConversation(l.id)}>
                                                    <wy-icon name="account-minus"></wy-icon>
                                                    ${this.user && this.user.id === l.id ? C("Leave conversation") : C("Remove member")}
                                                  </wy-dropdown-item>
                                                  ${a > 1 && l.access === yr.Admin ? v`<wy-dropdown-item
                                                        @click=${() => this.updateMember(l.id, yr.Write)}
                                                      >
                                                        <wy-icon name="shield-star-outline"></wy-icon>
                                                        ${C("Remove as admin")}
                                                      </wy-dropdown-item>` : l.access !== yr.Admin ? v`<wy-dropdown-item
                                                        @click=${() => this.updateMember(l.id, yr.Admin)}
                                                      >
                                                        <wy-icon name="shield-star"></wy-icon>
                                                        ${C("Make admin")}
                                                      </wy-dropdown-item>` : Q}
                                                </wy-dropdown>` : Q}
                                          </div>
                                        `;
      }
    )) ?? Q}
                                    </div>
                                  ` : Q}
                              <wy-button
                                kind="filled"
                                color="primary"
                                @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                title=${C("Add members")}
                              >
                                ${C("Add members")}
                              </wy-button>
                            </div>
                          ` : Q}
                    ` : Q}
              </div>
            </wy-overlay>
          ` : Q}

      <!-- add members modal -->
      ${this.weavy ? v`
            <wy-overlay
              .show=${this.showAddMembers}
              @close=${() => {
      this.showAddMembers = !1;
    }}
              @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            >
              <header class="wy-appbars">
                <nav class="wy-appbar">
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showAddMembers = !1;
    }}
                  >
                    <wy-icon name="close"></wy-icon>
                  </wy-button>
                  <div class="wy-appbar-text">${C("Add members")}</div>
                </nav>
              </header>
              ${this.showAddMembers ? v`
                    <wy-users-search
                      .buttonTitle=${C("Add members")}
                      .appId=${this.conversationId}
                      @submit=${(l) => this.addMembers(l.detail.members)}
                    ></wy-users-search>
                  ` : Q}
            </wy-overlay>
          ` : Q}
    ` : Q;
  }
  disconnectedCallback() {
    var t;
    (t = I3(this, kc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(bf, "yo"), bf), u(U2, "WyConversationAppbar"), U2);
kc = /* @__PURE__ */ new WeakMap();
cs.styles = [
  yt,
  At
];
ml([
  $({ attribute: !1 })
], cs.prototype, "conversationId", 2);
ml([
  $({ attribute: !1 })
], cs.prototype, "conversation", 2);
ml([
  $({ type: Boolean })
], cs.prototype, "showDetails", 2);
ml([
  $({ type: Boolean })
], cs.prototype, "showAddMembers", 2);
ml([
  $({ type: String })
], cs.prototype, "conversationTitle", 2);
ml([
  U()
], cs.prototype, "conversationTitleInput", 2);
cs = ml([
  H("wy-conversation-appbar"),
  Ot()
], cs);
var qH = Object.defineProperty, VH = Object.getOwnPropertyDescriptor, RI = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$5"), gg = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? VH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qH(t, e, s), s;
}, "__decorateClass$h"), EI = /* @__PURE__ */ u((n, t, e) => t.has(n) || RI("Cannot " + e), "__accessCheck$5"), W3 = /* @__PURE__ */ u((n, t, e) => (EI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$5"), jH = /* @__PURE__ */ u((n, t, e) => t.has(n) ? RI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$5"), D3 = /* @__PURE__ */ u((n, t, e, i) => (EI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$5"), Sc, B2, Of;
let ca = (B2 = (Of = class extends ft {
  constructor() {
    super(...arguments), this.private = !0, this.rooms = !0, this.badgeQuery = new Cn(this), this.handleBadgeRefresh = async () => {
      this.badgeQuery.result.isRefetching || await this.badgeQuery.result.refetch();
    }, this.handleRealtimeMessage = (t) => {
      this.handleBadgeRefresh();
    }, this.handleRealtimeSeenBy = (t) => {
      this.handleBadgeRefresh();
    }, jH(this, Sc);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy) {
      const i = [];
      this.rooms && i.push(Pt.ChatRoom), this.private && i.push(Pt.PrivateChat), this.agent && i.push(Pt.AgentChat), await this.badgeQuery.trackQuery(dE(this.weavy, i, this.agent), !0), (e = W3(this, Sc)) == null || e.call(this), this.weavy.subscribe(null, "message_created", this.handleRealtimeMessage), this.weavy.subscribe(null, "app_marked", this.handleBadgeRefresh), D3(this, Sc, () => {
        var s, r;
        (s = this.weavy) == null || s.unsubscribe(null, "message_created", this.handleRealtimeMessage), (r = this.weavy) == null || r.unsubscribe(null, "app_marked", this.handleBadgeRefresh), D3(this, Sc, void 0);
      });
    }
  }
  render() {
    const { data: t, isPending: e } = this.badgeQuery.result ?? {}, i = t ? t.count : 0;
    return v`
      ${!e && i > 0 ? v` <span class="wy-badge wy-badge-danger wy-badge-reveal">${i}</span> ` : Q}
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = W3(this, Sc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Of, "wo"), Of), u(B2, "WyMessengerBadge"), B2);
Sc = /* @__PURE__ */ new WeakMap();
ca.styles = yt;
gg([
  ve({ context: _e, subscribe: !0 }),
  U()
], ca.prototype, "weavy", 2);
gg([
  $({ attribute: !1, type: Boolean })
], ca.prototype, "private", 2);
gg([
  $({ attribute: !1, type: Boolean })
], ca.prototype, "rooms", 2);
gg([
  $()
], ca.prototype, "agent", 2);
ca = gg([
  H("wy-messenger-badge")
], ca);
var FH = Object.defineProperty, UH = Object.getOwnPropertyDescriptor, vg = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FH(t, e, s), s;
}, "__decorateClass$g");
const JG = new Map(
  Object.entries({
    [vn.ChatRoom]: Pt.ChatRoom,
    [vn.PrivateChat]: Pt.PrivateChat,
    [Pt.ChatRoom]: vn.ChatRoom,
    [Pt.PrivateChat]: vn.PrivateChat
  })
);
new Map(
  Object.entries({
    [vn.AgentChat]: Pt.AgentChat,
    [Pt.AgentChat]: vn.AgentChat
  })
);
const zI = "wy-messenger", q3 = {
  // All available features as enabled/disabled by default
  [_.Attachments]: !0,
  [_.CloudFiles]: !0,
  [_.ContextData]: !0,
  [_.Embeds]: !0,
  [_.GoogleMeet]: !0,
  [_.Meetings]: !0,
  [_.Mentions]: !0,
  [_.MicrosoftTeams]: !0,
  [_.Polls]: !0,
  [_.Previews]: !0,
  [_.Reactions]: !0,
  [_.Receipts]: !0,
  [_.Typing]: !0,
  [_.ZoomMeetings]: !0
}, BH = {
  // All available features as enabled/disabled by default
  [_.Attachments]: !0,
  [_.ContextData]: !0,
  [_.Embeds]: !0,
  [_.Previews]: !0,
  [_.Reactions]: !1,
  [_.Receipts]: !0,
  [_.Typing]: !0
};
var X2, $f;
let Xs = (X2 = ($f = class extends jt {
  constructor() {
    super(...arguments), this.componentFeatures = new $n(q3), this.theme = new Js(this, Xs.styles), this.appTypes = [Pt.ChatRoom, Pt.PrivateChat], this.conversationId = null, this.conversationQuery = new Cn(this), this.persistState = new HP(this), this.conversationNewRef = wt(), this.conversationListRef = wt(), this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 });
  }
  get agent() {
    return super.agent;
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.appTypes = [Pt.AgentChat], this.componentFeatures = new $n(
      BH,
      this.componentFeatures.allowedFeatures()
    )) : (this.appTypes = [Pt.ChatRoom, Pt.PrivateChat], this.componentFeatures = new $n(
      q3,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  /**
   * Checks if a conversation belongs to Messenger.
   *
   * @deprecated
   * @param conversation {AppRef | AppType | number} - The conversation or id to check if it belongs to Messenger.
   * @returns Promise<Boolean>
   */
  async conversationBelongsToMessenger(t) {
    return console.warn("conversationBelongsToMessenger() is deprecated. Compare app to to .appTypes instead."), this.weavy ? !!await f_(this.weavy, t, this.appTypes, this.agent) : !1;
  }
  /**
   * Creates a new conversation. 
   * 
   * - When no members are specified, the user selector is shown.
   * - When in agent mode, a conversation is created instantly.
   * 
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid to bypass user selection dialog.
   */
  async createConversation(t) {
    var e;
    await ((e = this.conversationNewRef.value) == null ? void 0 : e.create(t));
  }
  /**
   * Set the active conversation.
   *
   * @deprecated
   * @param id {number} - The id of the conversation to select.
   */
  selectConversation(t) {
    return console.warn("selectConversation() is deprecated. Set .conversationId instead."), this.conversationId = t, !0;
  }
  /**
   * Deselects any active conversation.
   * @deprecated
   */
  clearConversation() {
    console.warn("clearConversation() is deprecated. Set .conversationId to null instead."), this.conversationId = null;
  }
  async willUpdate(t) {
    var e, i;
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${(e = this.user) == null ? void 0 : e.id}`
    ), t.has("link") && (i = this.link) != null && i.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(p_(this.weavy, this.conversationId, this.appTypes)) : this.conversationQuery.untrackQuery());
  }
  render() {
    var t, e, i;
    const { isPending: s } = ((t = this.weavy) == null ? void 0 : t.network) ?? { isPending: !0 }, { data: r } = this.conversationQuery.result ?? {}, a = ((i = (e = this.conversationListRef.value) == null ? void 0 : e.conversationsQuery.result.data) == null ? void 0 : i.pages[0].count) || 0;
    return v`
      <div class="wy-messenger-layout">
        <wy-conversation-list
          ${lt(this.conversationListRef)}
          .conversationTypes=${this.appTypes}
          .agent=${this.agent}
          conversationId=${Ct(this.conversationId !== null ? this.conversationId : void 0)}
          @selected=${(o) => this.conversationId = o.detail.id}
        >
          <wy-conversation-new
            slot="actions"
            .agent=${this.agent}
            @selected=${(o) => this.conversationId = o.detail.id}
            ${lt(this.conversationNewRef)}
            >
            <slot name="conversation-new"></slot>
          </wy-conversation-new>
          <slot name="actions" slot="actions"></slot>
        </wy-conversation-list>

        <div
          class="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null ? this.conversationId : ""}
        >
          <wy-conversation-appbar
            .conversationId=${this.conversationId || void 0}
            .conversation=${r}
            @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            @selected=${(o) => this.conversationId = o.detail.id}
            ?hidden=${!this.conversationId}
          >
            <span slot="action" class="wy-close-conversation">
              <wy-button kind="icon" @click=${() => this.conversationId = null}>
                <wy-icon name="back"></wy-icon>
              </wy-button>
              <wy-messenger-badge slot="badge" .agent=${this.agent}></wy-messenger-badge>
            </span>
          </wy-conversation-appbar>

          ${this.conversationId ? v`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${r}
                .placeholder=${this.placeholder ?? (this.agent ? C("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : a ? v`<wy-empty noNetwork>${C("Select a conversation")}</wy-empty>` : Q}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, h($f, "fo"), $f), u(X2, "WyMessenger"), X2);
Xs.styles = [Xi, yt, TH, pa, tr];
vg([
  U()
], Xs.prototype, "appTypes", 2);
vg([
  $({ type: String })
], Xs.prototype, "agent", 1);
vg([
  $()
], Xs.prototype, "placeholder", 2);
vg([
  $({ type: Number })
], Xs.prototype, "conversationId", 2);
Xs = vg([
  H(zI),
  Ot()
], Xs);
const XH = Mt`.wy-meta{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-meta-sm{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}`, NH = Mt`.wy-notification.wy-read{opacity:var(--wy-opacity-muted, 60%);--wy-component-color: var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}`;
var HH = Object.defineProperty, YH = Object.getOwnPropertyDescriptor, bg = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HH(t, e, s), s;
}, "__decorateClass$f"), N2, xf;
let ha = (N2 = (xf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.selected = !1, this.standalone = !1;
  }
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const i = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(i);
    }
    return !0;
  }
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await TP(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    var t, e;
    const i = this.notification.created_at ? new Intl.DateTimeFormat((t = this.weavy) == null ? void 0 : t.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", s = this.notification.created_at ? Ay((e = this.weavy) == null ? void 0 : e.locale, new Date(this.notification.created_at)) : "", r = this.notification.actor, { title: a, titleHtml: o, detail: l } = RP(this.notification), c = this.standalone ? Q : v`
          <div class="wy-item-actions wy-item-right">
            <wy-button
              kind="icon-inline"
              @click=${(p) => this.dispatchMark(p, !!this.notification.is_unread) && this.dispatchClose()}
              title=${this.notification.is_unread ? C("Mark as read") : C("Mark as unread")}
            >
              <wy-icon
                name=${this.notification.is_unread ? "read" : "unread"}
                color=${this.notification.is_unread ? "" : "secondary"}
              ></wy-icon>
            </wy-button>
          </div>
        `, d = this.standalone ? Q : v`
          <time class="wy-meta" datetime=${this.notification.created_at.toString()} title=${i}>
            ${s}
          </time>
        `;
    return v`
      <div
        class=${Xt({
      "wy-item wy-list-item-lg wy-item-hover wy-notification": !0,
      "wy-unread": !this.standalone && !!this.notification.is_unread,
      "wy-read": !this.standalone && !this.notification.is_unread,
      "wy-active": !this.standalone && this.selected
    })}
        tabindex="0"
        @click=${(p) => this.handleClick(p)}
        @keydown=${je}
        @keyup=${gi}
      >
        <div class="wy-item-inner">
          <wy-avatar
            class="wy-item-top"
            src=${Ct(r == null ? void 0 : r.avatar_url)}
            name=${Ct(r == null ? void 0 : r.name)}
            description=${Ct(r == null ? void 0 : r.comment)}
            presence=${(r == null ? void 0 : r.presence) || "away"}
            ?isAgent=${r == null ? void 0 : r.is_agent}
            id=${Ct(r == null ? void 0 : r.id)}
            size=${48}
          ></wy-avatar>

          <div class="wy-item-rows wy-item-rows-compact">
            <div class="wy-item-row">
              <div class="wy-item-title-lg" title=${a + (l ? `: "${l}"` : "")}>
                ${o}${l ? v`: <q class="wy-item-quote">${l}</q> ` : Q}
              </div>
            </div>
            <div class="wy-item-row"> ${d} ${c} </div>
          </div>

          ${this.standalone ? v`
                <wy-button
                  kind="icon"
                  @click=${(p) => this.dispatchMark(p, !!this.notification.is_unread) && this.dispatchClose()}
                >
                  <wy-icon name="close"></wy-icon>
                </wy-button>
              ` : Q}
        </div>
      </div>
    `;
  }
}, h(xf, "mo"), xf), u(N2, "WyNotificationListItem"), N2);
ha.styles = [Ie, uL, XH, NH];
bg([
  $({ type: Number })
], ha.prototype, "notificationId", 2);
bg([
  $({ type: Boolean, reflect: !0 })
], ha.prototype, "selected", 2);
bg([
  $({ type: Boolean })
], ha.prototype, "standalone", 2);
bg([
  $({ attribute: !1 })
], ha.prototype, "notification", 2);
ha = bg([
  H("wy-notification-list-item"),
  Ot()
], ha);
var GH = Object.defineProperty, KH = Object.getOwnPropertyDescriptor, _I = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$4"), sC = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? KH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && GH(t, e, s), s;
}, "__decorateClass$e"), LI = /* @__PURE__ */ u((n, t, e) => t.has(n) || _I("Cannot " + e), "__accessCheck$4"), V3 = /* @__PURE__ */ u((n, t, e) => (LI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$4"), JH = /* @__PURE__ */ u((n, t, e) => t.has(n) ? _I("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$4"), j3 = /* @__PURE__ */ u((n, t, e, i) => (LI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$4"), Pc, H2, kf;
let my = (H2 = (kf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.typeFilter = Ye.All, this.notificationsQuery = new hl(this), this.infiniteScroll = new dl(this), this.pagerRef = wt(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), we(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const i = e.actor;
        i.presence = t.indexOf(i.id) != -1 ? "active" : "away", e.actor = i;
      }));
    }, JH(this, Pc);
  }
  async markAllAsRead() {
    var t, e, i;
    const s = await this.whenWeavy(), r = (e = NL(s, Ye.All, (t = this.app) == null ? void 0 : t.id)) == null ? void 0 : e.id;
    await ((i = this.markNotificationsMutation) == null ? void 0 : i.mutate({ notificationId: r }));
  }
  async handleMark(t, e) {
    var i;
    await ((i = this.markNotificationMutation) == null ? void 0 : i.mutate({ markAsRead: t, notificationId: e }));
  }
  handleSelect(t) {
    this.notificationId = t.id;
  }
  async willUpdate(t) {
    var e, i, s;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(XL(this.weavy, this.typeFilter, (e = this.app) == null ? void 0 : e.id)), (t.has("weavy") || t.has("app")) && this.weavy && (this.markNotificationsMutation = YL(this.weavy, (i = this.app) == null ? void 0 : i.id)), t.has("weavy") && this.weavy && (this.markNotificationMutation = tC(this.weavy), (s = V3(this, Pc)) == null || s.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), j3(this, Pc, () => {
      var r, a, o, l;
      (r = this.weavy) == null || r.unsubscribe(null, "online", this.handlePresenceChange), (a = this.weavy) == null || a.unsubscribe(null, "notification_created", this.handleRefresh), (o = this.weavy) == null || o.unsubscribe(null, "notification_updated", this.handleRefresh), (l = this.weavy) == null || l.unsubscribe(null, "notifications_marked", this.handleRefresh), j3(this, Pc, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  renderNotifications(t, e) {
    if (e) {
      const i = ds(e);
      return Mi(
        i,
        (s) => s == null ? void 0 : s.id,
        (s) => [
          v`<wy-notification-list-item
              notificationId=${s.id}
              .notification=${s}
              .selected=${this.notificationId == s.id}
              @select=${(r) => this.handleSelect(s)}
              @mark=${(r) => this.handleMark(r.detail.markAsRead, r.detail.notificationId)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return Q;
  }
  render() {
    var t;
    const { data: e, hasNextPage: i, isPending: s } = this.notificationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <div class="wy-pane-toolbar">
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === Ye.All}
                  @click=${() => this.typeFilter = Ye.All}
                  kind="tab"
                  small
                >
                  ${C("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ye.Activity}
                  @click=${() => this.typeFilter = Ye.Activity}
                  kind="tab"
                  small
                >
                  ${C("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ye.Mention}
                  @click=${() => this.typeFilter = Ye.Mention}
                  kind="tab"
                  small
                >
                  ${C("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ye.Reaction}
                  @click=${() => this.typeFilter = Ye.Reaction}
                  kind="tab"
                  small
                >
                  ${C("Reactions")}
                </wy-button>
              </wy-buttons>
              <wy-button
                slot="buttons"
                kind="icon"
                @click=${() => this.markAllAsRead()}
                title=${C("Mark all as read")}
              >
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              <slot name="buttons"></slot>
            </div>

            <div class="wy-notifications">
              ${!s && this.user && e ? (t = e.pages[0]) != null && t.count ? this.renderNotifications(this.user, e) : v`
                      <div class="wy-pane-body">
                        <div class="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${C("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-spinner padded></wy-spinner></wy-empty>`}
              ${i ? v`<div ${lt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            </div>
          ` : v`<wy-empty class="wy-pane"><wy-spinner overlay></wy-spinner></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = V3(this, Pc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(kf, "vo"), kf), u(H2, "WyNotificationList"), H2);
Pc = /* @__PURE__ */ new WeakMap();
my.styles = [
  yt,
  ya,
  Mt`
      :host {
        position: relative;
      }
    `
];
sC([
  $({ type: Number })
], my.prototype, "notificationId", 2);
sC([
  $()
], my.prototype, "typeFilter", 2);
my = sC([
  H("wy-notification-list"),
  Ot()
], my);
var tY = Object.getOwnPropertyDescriptor, eY = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? tY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$d");
const II = "wy-notifications";
var Y2, Sf;
let Nw = (Y2 = (Sf = class extends jt {
  constructor() {
    super(...arguments), this.componentType = nn.Unknown, this.theme = new Js(this, Nw.styles), this.notificationsRef = wt();
  }
  /**
   * Mark all events as read.
   */
  async markAllAsRead() {
    var t;
    await ((t = this.notificationsRef.value) == null ? void 0 : t.markAllAsRead());
  }
  render() {
    return v`
      ${this.user ? v` <wy-notification-list ${lt(this.notificationsRef)}></wy-notification-list> ` : v`
            <wy-empty>
              <wy-spinner padded reveal></wy-spinner>
            </wy-empty>
          `}
    `;
  }
}, h(Sf, "go"), Sf), u(Y2, "WyNotifications"), Y2);
Nw.styles = [Xi, yt, pa, cl, tr];
Nw = eY([
  H(II),
  Ot()
], Nw);
var iY = Object.defineProperty, nY = Object.getOwnPropertyDescriptor, Og = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? nY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && iY(t, e, s), s;
}, "__decorateClass$c"), G2, Pf;
let Hw = (G2 = (Pf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.show = !1, this.viewportRef = wt();
  }
  close() {
    var t;
    this.show = !1;
    try {
      (t = this.viewportRef.value) == null || t.hidePopover();
    } catch {
    }
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.show = !1, this.dispatchEvent(new CustomEvent("hide")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  render() {
    return v`
      <div class="wy-toasts" tabindex="0" ${lt(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    var e, i, s;
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? (e = this.viewportRef.value) == null || e.showPopover() : (i = this.viewportRef.value) == null || i.hidePopover();
      } catch {
      }
    t.has("show") && this.show && ((s = this.viewportRef.value) == null || s.focus());
  }
  firstUpdated(t) {
    var e, i;
    (e = this.viewportRef.value) == null || e.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (s) => {
      this.handleClose(s);
    }), this.show && ((i = this.viewportRef.value) == null || i.showPopover());
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, h(Pf, "bo"), Pf), u(G2, "WyToasts"), G2);
Hw.styles = [
  yt,
  At
];
Og([
  $({ type: Boolean })
], Hw.prototype, "show", 2);
Hw = Og([
  H("wy-toasts")
], Hw);
var K2, Cf;
let Ns = (K2 = (Cf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.toastRef = wt(), this.show = !1, this.duration = Ns.defaultDuration;
  }
  hide() {
    this.show = !1;
  }
  async close(t = !1) {
    this.show = !1, await new Promise((e) => requestAnimationFrame(e)), this.toastRef.value && await q1(this.toastRef.value, !1), this.dispatchEvent(new CustomEvent("closed", { detail: { silent: t } })), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }));
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return v`
      <div
        ${lt(this.toastRef)}
        class="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${B0}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, h(Cf, "xo"), Cf), u(K2, "WyToast"), K2);
Ns.styles = [
  yt,
  At
];
Ns.defaultDuration = 5e4;
Og([
  U()
], Ns.prototype, "show", 2);
Og([
  $({ type: Number })
], Ns.prototype, "duration", 2);
Ns = Og([
  H("wy-toast")
], Ns);
var sY = Object.defineProperty, rY = Object.getOwnPropertyDescriptor, ZI = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$3"), Ey = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? rY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && sY(t, e, s), s;
}, "__decorateClass$b"), WI = /* @__PURE__ */ u((n, t, e) => t.has(n) || ZI("Cannot " + e), "__accessCheck$3"), F3 = /* @__PURE__ */ u((n, t, e) => (WI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$3"), aY = /* @__PURE__ */ u((n, t, e) => t.has(n) ? ZI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$3"), U3 = /* @__PURE__ */ u((n, t, e, i) => (WI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$3"), Cc;
const DI = "wy-notification-toasts";
var J2, Qf;
let hs = (J2 = (Qf = class extends jt {
  constructor() {
    super(...arguments), this.componentType = nn.Unknown, this.theme = new Js(this, hs.styles), this.typeFilter = Ye.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = Ns.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      var e;
      if (this.typeFilter === Ye.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: i, detail: s } = RP(t.notification), r = {
            ...t.notification,
            title: i,
            detail: s,
            lang: (e = this.weavy) == null ? void 0 : e.locale
          };
          r.link.agent = AP(r);
          const a = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: r
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission()) && this.dispatchEvent(a) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(r));
        }
    }, aY(this, Cc);
  }
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((s) => s.id === t.id);
      i !== -1 ? (e.splice(i, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((s) => s.id === t.id);
      i !== -1 && (e.splice(i, 1, t), this._notifications = e);
    }
  }
  removeNotification(t) {
    const e = [...this._notifications], i = e.findIndex((s) => s.id === t);
    i !== -1 && (e.splice(i, 1), this._notifications = e);
  }
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), i = t.actor, s = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: i.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      s.onclick = async () => {
        await this.handleMark(!0, t.id), await TP(this, this.weavy, t);
      }, s.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, s];
    }
  }
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], i = e.findIndex(
      (s) => s.tag === `wy-${t}`
    );
    return i ? (e.splice(i, 1), this._nativeNotifications = e, !0) : !1;
  }
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (i) => i.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  clearNotifications() {
    this._notifications = [];
  }
  async handleMark(t, e) {
    var i;
    await ((i = this.markNotificationMutation) == null ? void 0 : i.mutate({ markAsRead: t, notificationId: e }));
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = tC(this.weavy), (e = F3(this, Cc)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), U3(this, Cc, () => {
      var i, s;
      (i = this.weavy) == null || i.unsubscribe(null, "notification_created", this.handleEvent), (s = this.weavy) == null || s.unsubscribe(null, "notification_updated", this.handleEvent), U3(this, Cc, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return v`
      ${this.user && this.appearance === "internal" ? v`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${Mi(
      this._notifications,
      (t) => t.id,
      (t) => v`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.handleMark(!0, t.id), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : Q}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = F3(this, Cc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Qf, "$o"), Qf), u(J2, "WyNotificationToasts"), J2);
Cc = /* @__PURE__ */ new WeakMap();
hs.styles = [Xi, At, tr];
Ey([
  $()
], hs.prototype, "typeFilter", 2);
Ey([
  $()
], hs.prototype, "appearance", 2);
Ey([
  $({ type: Boolean })
], hs.prototype, "requestUserPermission", 2);
Ey([
  $({ type: Number })
], hs.prototype, "duration", 2);
Ey([
  U()
], hs.prototype, "_notifications", 2);
hs = Ey([
  H(DI),
  Ot()
], hs);
function qI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ u(async ({ id: s }) => {
      if (!(await n.fetch("/api/posts/" + s + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, s)
      );
    }, "onSuccess")
  };
  return i;
}
h(qI, "Tx");
u(qI, "getTrashPostMutationOptions");
function VI(n, t) {
  return new Vt(n.queryClient, qI(n, t));
}
h(VI, "Fx");
u(VI, "getTrashPostMutation");
function jI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ u(async ({ id: s }) => {
      const r = await n.fetch("/api/posts/" + s + "/restore", { method: "POST" });
      if (!r.ok) {
        const a = await r.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return i;
}
h(jI, "Dx");
u(jI, "getRestorePostMutationOptions");
function FI(n, t) {
  return new Vt(n.queryClient, jI(n, t));
}
h(FI, "Hx");
u(FI, "getRestorePostMutation");
function UI(n, t) {
  const e = n.queryClient, i = ["posts", t.id];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ u(async ({ id: s, subscribe: r }) => {
      const a = await n.fetch(
        `/api/posts/${s}/${r ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
      return await a.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ u((s) => {
      $t(
        e,
        { queryKey: i, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_subscribed: s.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((s, r) => {
      $t(
        e,
        { queryKey: i, exact: !1 },
        r.id,
        (a) => Object.assign(a, s)
      );
    }, "onSuccess")
  };
}
h(UI, "Vx");
u(UI, "getSubscribePostMutationOptions");
function BI(n, t) {
  return new Vt(n.queryClient, UI(n, t));
}
h(BI, "Bx");
u(BI, "getSubscribePostMutation");
function XI(n, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ u(async (e) => {
      const i = e.pageParam, s = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + i, r = await (await n.fetch(s)).json();
      return r.data = r.data || [], r;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ u((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
h(XI, "Ux");
u(XI, "getPostsOptions");
function NI(n, t) {
  return {
    mutationFn: /* @__PURE__ */ u(async (e) => await (await n.fetch("/api/posts/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ u((e) => {
      we(n.queryClient, ["posts", e.app_id], e.id, (i) => {
        i.text = e.text, i.html = e.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((e, i) => {
      i.id && we(n.queryClient, ["posts", i.app_id], i.id, (s) => {
        s.text = e.text, s.html = e.html, s.attachments = e.attachments, s.embed = e.embed, s.meeting = e.meeting, s.updated_at = e.updated_at, s.updated_by = e.updated_by, s.options = e.options;
      });
    }, "onSuccess")
  };
}
h(NI, "qx");
u(NI, "getUpdatePostMutationOptions");
function HI(n, t) {
  const e = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ u(async (i) => await (await n.fetch("/api/apps/" + i.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ text: s.text })),
        embed_id: i.embed_id,
        context: i.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ u(async (i) => {
      const s = ["posts", i.app_id];
      await e.cancelQueries({ queryKey: s });
      const r = ea(n.queryClient, s, !1);
      if (i.user) {
        const a = {
          id: r ? r.id - 1 : -1,
          app: { id: i.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: i.text,
          html: i.text,
          plain: i.text,
          created_by: i.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        ta(e, ["posts", i.app_id], a, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ u((i) => {
      const s = ["posts", i.app.id];
      if (!og(n.queryClient, s, i.id)) {
        const r = ea(n.queryClient, s, !0);
        r ? we(n.queryClient, s, r.id, (a) => {
          a.id = i.id, a.app = i.app, a.text = i.text, a.html = i.html, a.embed = i.embed, a.meeting = i.meeting, a.attachments = i.attachments, a.options = i.options, a.created_at = i.created_at, a.created_by = i.created_by, a.updated_at = i.updated_at, a.updated_by = i.updated_by;
        }) : ta(n.queryClient, s, i);
      }
    }, "onSuccess")
  };
}
h(HI, "Nx");
u(HI, "getAddPostMutationOptions");
var oY = Object.defineProperty, lY = Object.getOwnPropertyDescriptor, YI = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? lY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && oY(t, e, s), s;
}, "__decorateClass$a"), t$, Mf;
let Yw = (t$ = (Mf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: {} });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div class="wy-item">
        <div class="wy-item-body">${C("Post was trashed.")}</div>
        <wy-button @click=${() => this.dispatchRestore()} color="variant">${C("Undo")}</wy-button>
      </div>
    `;
  }
}, h(Mf, "Co"), Mf), u(t$, "WyPostTrashed"), t$);
Yw.styles = yt;
YI([
  $({ type: Number })
], Yw.prototype, "postId", 2);
Yw = YI([
  H("wy-post-trashed"),
  Ot()
], Yw);
var cY = Object.defineProperty, hY = Object.getOwnPropertyDescriptor, $e = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? hY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && cY(t, e, s), s;
}, "__decorateClass$9"), e$, Tf;
let se = (e$ = (Tf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.showComments = !1, this.loadComments = !1, this.highlight = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt();
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && cg(this.link, oi.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && MP(this.link, oi.Post, { id: this.postId }, oi.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    var t, e, i, s, r, a, o, l, c;
    const d = (t = this.attachments) == null ? void 0 : t.filter((b) => b.kind === "image" && b.thumbnail_url), p = (e = this.attachments) == null ? void 0 : e.filter((b) => b.kind !== "image" || !b.thumbnail_url), f = new Intl.DateTimeFormat((i = this.weavy) == null ? void 0 : i.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), m = Ay((s = this.weavy) == null ? void 0 : s.locale, new Date(this.createdAt)), w = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "";
    return this.postId < 0 ? v`<div class="wy-post">
          <div class="wy-item">
            <wy-avatar
              .src="${this.createdBy.avatar_url}"
              .isAgent=${this.createdBy.is_agent}
              .size=${48}
              .name=${this.createdBy.name}
            ></wy-avatar>
            <div class="wy-item-rows">
              <div class="wy-item-row">
                <div class="wy-item-title"><span class="wy-placeholder">${this.createdBy.name}</span></div>
              </div>
              <div class="wy-item-row">
                <div class="wy-item-text">
                  <time class="wy-placeholder">${m}</time>
                </div>
              </div>
            </div>
          </div>
          <div class="wy-post-body">
            <div class="wy-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
          </div>
        </div>` : v`
          <div class="wy-post" part=${Qe({ "wy-highlight": this.highlight && !this.isCommentLinked })} ${lt(
      this.highlightRef
    )}>
            <div class="wy-item">
              <wy-avatar .src="${this.createdBy.avatar_url}" .isAgent=${this.createdBy.is_agent} .size=${48} .name=${this.createdBy.name}></wy-avatar>
              <div class="wy-item-rows">
                <div class="wy-item-row">
                  <div class="wy-item-title">${this.createdBy.name}</div>
                </div>
                <div class="wy-item-row">
                  <div class="wy-item-text">
                    <time datetime=${this.createdAt} title=${f}>${m}</time>
                    ${this.modifiedAt ? v`<time datetime="${this.modifiedAt}" title=${w}> · ${C("edited")}</time>` : Q}
                  </div>
                  </div>
                </div>

                <div class="wy-item-actions wy-item-top">
                  <wy-dropdown>
                    ${this.isSubscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                            <wy-icon name="bell-off"></wy-icon>
                            ${C("Unsubscribe")}
                          </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                            <wy-icon name="bell"></wy-icon>
                            ${C("Subscribe")}
                          </wy-dropdown-item>`}
                    ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                            <wy-icon name="pencil"></wy-icon>
                            ${C("Edit")}
                          </wy-dropdown-item>` : Q}
                    ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="trashcan"></wy-icon>
                            ${C("Trash")}
                          </wy-dropdown-item>` : Q}
                  </wy-dropdown>
                </div>
              </div>
              <!-- image grid -->
              ${d && d.length ? v`<wy-image-grid
                      class="wy-post-area-full-width"
                      .images=${d}
                      @file-open=${(b) => {
      var x;
      (x = this.previewAttachmentsRef.value) == null || x.open(b.detail.fileId);
    }}
                    ></wy-image-grid>` : ""}

              <!-- embeds -->
              ${(r = this.componentFeatures) != null && r.allowsFeature(_.Embeds) && this.embed ? v` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : Q}

              <div class="wy-post-body">
                ${this.html ? v`<div class="wy-content">${Bo(this.html)}</div>` : ""}

                <!-- annotations -->
                  ${this.annotations && this.annotations.length ? v`<wy-annotations-list
                          class="wy-message-area"
                          .files=${this.annotations}
                          @file-open=${(b) => {
      var x;
      (x = this.previewAnnotationsRef.value) == null || x.open(b.detail.fileId);
    }}
                        ></wy-annotations-list>` : ""}

                <!-- poll -->
                ${this.pollOptions && this.pollOptions.length > 0 ? v`
                        <wy-poll
                          .pollOptions=${this.pollOptions}
                          @vote=${(b) => this.dispatchVote(b.detail.optionId)}
                        ></wy-poll>
                      ` : Q}

                <!-- files -->
                ${p && p.length ? v`<wy-attachments-list
                        .files=${p ?? []}
                        @file-open=${(b) => {
      var x;
      (x = this.previewAttachmentsRef.value) == null || x.open(b.detail.fileId);
    }}
                      ></wy-attachments-list>` : ""}

                <!-- meeting -->
                ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}
              </div>

              <div class="wy-post-footer">
                <div>
                  <!-- comment count -->
                  ${(a = this.componentFeatures) != null && a.allowsFeature(_.Comments) ? v` <wy-button
                          small
                          kind="inline"
                          ?active=${this.showComments}
                          class="wy-meta"
                          color="inherit"
                          @click=${(b) => this.handleCommentsClick(b)}
                        >
                          ${this.commentCount !== 1 ? C(at`${this.commentCount} comments`) : C("1 comment")}
                        </wy-button>` : Q}
                </div>
                ${(o = this.componentFeatures) != null && o.allowsFeature(_.Reactions) && this.app ? v`
                        <wy-reactions
                          line
                          small
                          .reactions=${this.reactions}
                          parentId=${this.app.id}
                          parentType="apps"
                          entityId=${this.postId}
                          entityType="posts"
                        ></wy-reactions>
                      ` : Q}
              </div>

              <!-- comments -->
              ${this.loadComments ? v`
                      <div class="wy-post-comments" ?hidden=${!this.showComments}>
                        <wy-comment-list .parentId=${this.postId} .location=${"posts"}></wy-comment-list>
                      </div>
                    ` : Q}
            </div>
          
            ${(l = this.annotations) != null && l.length ? v`<wy-preview
                    ${lt(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : Q}
            ${(c = this.attachments) != null && c.length ? v`<wy-preview
                    ${lt(this.previewAttachmentsRef)}
                    .files=${[...d, ...p]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : Q}
           
          </div>
        `;
  }
  updated(t) {
    var e;
    t.has("highlight") && this.highlight && ((e = this.highlightRef.value) == null || e.scrollIntoView({ block: "nearest" }));
  }
}, h(Tf, "ko"), Tf), u(e$, "WyPostView"), e$);
se.styles = [yt, At];
$e([
  $({ type: Number })
], se.prototype, "postId", 2);
$e([
  $({ attribute: !1 })
], se.prototype, "createdBy", 2);
$e([
  $()
], se.prototype, "createdAt", 2);
$e([
  $()
], se.prototype, "modifiedAt", 2);
$e([
  $({ type: Boolean })
], se.prototype, "isSubscribed", 2);
$e([
  $({ type: Boolean })
], se.prototype, "isTrashed", 2);
$e([
  $()
], se.prototype, "html", 2);
$e([
  $()
], se.prototype, "text", 2);
$e([
  $({ type: Array })
], se.prototype, "annotations", 2);
$e([
  $({ type: Array })
], se.prototype, "attachments", 2);
$e([
  $({ type: Array })
], se.prototype, "pollOptions", 2);
$e([
  $({ attribute: !1 })
], se.prototype, "meeting", 2);
$e([
  $({ attribute: !1 })
], se.prototype, "embed", 2);
$e([
  $({ type: Array })
], se.prototype, "reactions", 2);
$e([
  $({ attribute: !1 })
], se.prototype, "commentCount", 2);
$e([
  $({ type: Array })
], se.prototype, "seenBy", 2);
$e([
  U()
], se.prototype, "showComments", 2);
$e([
  U()
], se.prototype, "loadComments", 2);
$e([
  $({ type: Boolean })
], se.prototype, "highlight", 2);
$e([
  U()
], se.prototype, "isCommentLinked", 2);
se = $e([
  H("wy-post-view"),
  Ot()
], se);
var dY = Object.defineProperty, uY = Object.getOwnPropertyDescriptor, vi = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? uY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && dY(t, e, s), s;
}, "__decorateClass$8"), i$, Af;
let Ue = (i$ = (Af = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new sn(this);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(NI(this.weavy, ["posts", this.app.id]));
  }
  render() {
    return v`
      <nav class="wy-item">
        <div class="wy-item-body">
          <div class="wy-item-title">${C("Edit post")}</div>
        </div>

        <wy-button kind="icon" @click=${() => this.dispatchEdit(!1)}>
          <wy-icon name="close"></wy-icon>
        </wy-button>
      </nav>
      <wy-editor
        editorLocation="apps"
        .text=${this.text}
        .embed=${this.embed}
        .options=${this.pollOptions}
        .attachments=${this.attachments ?? []}
        .parentId=${this.postId}
        .typing=${!1}
        .draft=${!1}
        placeholder=${C("Edit post...")}
        buttonText=${C("Update", { desc: "Button action to update" })}
        @submit=${(t) => this.handleSubmit(t)}></wy-editor>
    `;
  }
}, h(Af, "_o"), Af), u(i$, "WyPostEdit"), i$);
Ue.styles = yt;
vi([
  $({ type: Number })
], Ue.prototype, "postId", 2);
vi([
  $({ type: Boolean })
], Ue.prototype, "temp", 2);
vi([
  $({ attribute: !1 })
], Ue.prototype, "createdBy", 2);
vi([
  $()
], Ue.prototype, "createdAt", 2);
vi([
  $()
], Ue.prototype, "modifiedAt", 2);
vi([
  $({ type: Boolean })
], Ue.prototype, "isSubscribed", 2);
vi([
  $({ type: Boolean })
], Ue.prototype, "isTrashed", 2);
vi([
  $()
], Ue.prototype, "text", 2);
vi([
  $({ type: Array })
], Ue.prototype, "attachments", 2);
vi([
  $({ type: Array })
], Ue.prototype, "pollOptions", 2);
vi([
  $({ attribute: !1 })
], Ue.prototype, "meeting", 2);
vi([
  $({ attribute: !1 })
], Ue.prototype, "embed", 2);
vi([
  $({ type: Array })
], Ue.prototype, "reactions", 2);
vi([
  $({ type: Array })
], Ue.prototype, "seenBy", 2);
Ue = vi([
  H("wy-post-edit"),
  Ot()
], Ue);
var pY = Object.defineProperty, fY = Object.getOwnPropertyDescriptor, We = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? fY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && pY(t, e, s), s;
}, "__decorateClass$7"), n$, Rf;
let ue = (n$ = (Rf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t, parentId: this.postId, parentType: "posts" } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { id: this.postId, subscribe: t } });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-post-trashed
            class="wy-post"
            postId=${this.postId}
            @restore=${() => {
      this.dispatchRestore();
    }}></wy-post-trashed> ` : Q}
      ${!this.isTrashed && this.editing ? v`<wy-post-edit
            class="wy-post"
            .postId=${this.postId}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}></wy-post-edit> ` : Q}
      ${!this.isTrashed && !this.editing ? v`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}></wy-post-view> ` : Q}
    `;
  }
}, h(Rf, "zo"), Rf), u(n$, "WyPost"), n$);
ue.styles = yt;
We([
  $({ type: Number })
], ue.prototype, "postId", 2);
We([
  $({ attribute: !1 })
], ue.prototype, "createdBy", 2);
We([
  $()
], ue.prototype, "createdAt", 2);
We([
  $()
], ue.prototype, "modifiedAt", 2);
We([
  $({ type: Boolean })
], ue.prototype, "isSubscribed", 2);
We([
  $({ type: Boolean })
], ue.prototype, "isTrashed", 2);
We([
  $()
], ue.prototype, "html", 2);
We([
  $()
], ue.prototype, "text", 2);
We([
  $()
], ue.prototype, "plain", 2);
We([
  $({ attribute: !1 })
], ue.prototype, "annotations", 2);
We([
  $({ attribute: !1 })
], ue.prototype, "attachments", 2);
We([
  $({ type: Array })
], ue.prototype, "pollOptions", 2);
We([
  $({ attribute: !1 })
], ue.prototype, "meeting", 2);
We([
  $({ attribute: !1 })
], ue.prototype, "embed", 2);
We([
  $({ type: Array })
], ue.prototype, "reactions", 2);
We([
  $({ attribute: !1 })
], ue.prototype, "commentCount", 2);
We([
  $({ type: Array })
], ue.prototype, "seenBy", 2);
We([
  U()
], ue.prototype, "editing", 2);
ue = We([
  H("wy-post")
], ue);
var yY = Object.defineProperty, mY = Object.getOwnPropertyDescriptor, GI = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$2"), KI = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? mY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && yY(t, e, s), s;
}, "__decorateClass$6"), JI = /* @__PURE__ */ u((n, t, e) => t.has(n) || GI("Cannot " + e), "__accessCheck$2"), B3 = /* @__PURE__ */ u((n, t, e) => (JI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$2"), wY = /* @__PURE__ */ u((n, t, e) => t.has(n) ? GI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$2"), X3 = /* @__PURE__ */ u((n, t, e, i) => (JI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$2"), Qc, s$, Ef;
let r0 = (s$ = (Ef = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.postsQuery = new hl(this), this.infiniteScroll = new dl(this), this.pagerRef = wt(), this.addPostMutation = new sn(this), this.handleRealtimePostCreated = async (t) => {
      var e;
      const i = await this.whenWeavy(), s = await this.whenApp(), r = await this.whenUser();
      t.post.app.id !== s.id || ((e = t.post.created_by) == null ? void 0 : e.id) === r.id || (t.post.created_by = t.actor, ta(i.queryClient, ["posts", s.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), s = await this.whenUser();
      t.actor.id === s.id || !t.comment.parent || (we(e.queryClient, ["posts", i.id], t.comment.parent.id, (r) => {
        r.comments ? r.comments.count += 1 : r.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === oi.Post && we(e.queryClient, ["posts", i.id], t.entity.id, (s) => {
        oy(s, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === oi.Post && we(e.queryClient, ["posts", i.id], t.entity.id, (s) => {
        oy(s, void 0, t.actor);
      });
    }, wY(this, Qc);
  }
  async handleSubmit(t) {
    const e = await this.whenApp(), i = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: i,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e, i, s, r, a, o;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && ((e = this.app) == null ? void 0 : e.id) !== ((i = t.get("app")) == null ? void 0 : i.id) && await this.postsQuery.trackInfiniteQuery(XI(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && ((s = this.app) == null ? void 0 : s.id) !== ((r = t.get("app")) == null ? void 0 : r.id)) {
      await this.addPostMutation.trackMutation(HI(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = BI(this.weavy, this.app), this.removePostMutation = VI(this.weavy, this.app), this.restorePostMutation = FI(this.weavy, this.app), this.pollMutation = U0(this.weavy, this.app.id, ["posts", this.app.id]), (o = B3(this, Qc)) == null || o.call(this);
      const l = `a${this.app.id}`;
      this.weavy.subscribe(l, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(l, "comment_created", this.handleRealtimeCommentCreated), (a = this.componentFeatures) != null && a.allowsFeature(_.Reactions) && (this.weavy.subscribe(l, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(l, "reaction_removed", this.handleRealtimeReactionDeleted)), X3(this, Qc, () => {
        var c, d, p, f;
        (c = this.weavy) == null || c.unsubscribe(l, "post_created", this.handleRealtimePostCreated), (d = this.weavy) == null || d.unsubscribe(l, "comment_created", this.handleRealtimeCommentCreated), (p = this.weavy) == null || p.unsubscribe(l, "reaction_added", this.handleRealtimeReactionAdded), (f = this.weavy) == null || f.unsubscribe(l, "reaction_removed", this.handleRealtimeReactionDeleted), X3(this, Qc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    var t;
    const { data: e, isPending: i, hasNextPage: s } = this.postsQuery.result ?? {}, r = ds(e);
    return v`
      <div class="wy-posts">
        <div class="wy-post">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!ey(Fo.Create, (t = this.app) == null ? void 0 : t.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? C("Create a post...")}
            buttonText=${C("Post")}
            @submit=${(a) => this.handleSubmit(a)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${i ? v`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty> ` : v`
              ${r ? Mi(
      r,
      (a) => a.id,
      (a) => {
        var o, l, c, d, p;
        return v`<wy-post
                        id="post-${a.id}"
                        .postId=${a.id}
                        .createdBy=${a.created_by}
                        .createdAt=${a.created_at}
                        .modifiedAt=${a.updated_at}
                        .isSubscribed=${a.is_subscribed}
                        .isTrashed=${a.is_trashed}
                        .html=${a.html}
                        .text=${a.text}
                        .plain=${a.plain}
                        .annotations=${(o = a.annotations) == null ? void 0 : o.data}
                        .attachments=${(l = a.attachments) == null ? void 0 : l.data}
                        .meeting=${a.meeting}
                        .pollOptions=${(c = a.options) == null ? void 0 : c.data}
                        .embed=${a.embed}
                        .reactions=${(d = a.reactions) == null ? void 0 : d.data}
                        .commentCount=${((p = a.comments) == null ? void 0 : p.count) || 0}
                        @subscribe=${(f) => {
          var m;
          (m = this.subscribePostMutation) == null || m.mutate({
            id: f.detail.id,
            subscribe: f.detail.subscribe
          });
        }}
                        @trash=${(f) => {
          var m;
          (m = this.removePostMutation) == null || m.mutate({ id: f.detail.id });
        }}
                        @restore=${(f) => {
          var m;
          (m = this.restorePostMutation) == null || m.mutate({ id: f.detail.id });
        }}
                        @vote=${(f) => {
          var m;
          f.detail.parentType && f.detail.parentId && ((m = this.pollMutation) == null || m.mutate({
            optionId: f.detail.optionId,
            parentType: f.detail.parentType,
            parentId: f.detail.parentId
          }));
        }}
                      ></wy-post>`;
      }
    ) : v`<wy-empty></wy-empty>`}
              ${s ? v`<div ${lt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = B3(this, Qc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Ef, "Mo"), Ef), u(s$, "WyPostList"), s$);
Qc = /* @__PURE__ */ new WeakMap();
r0.styles = [yt, ya];
KI([
  $()
], r0.prototype, "placeholder", 2);
r0 = KI([
  H("wy-post-list"),
  Ot()
], r0);
var gY = Object.defineProperty, vY = Object.getOwnPropertyDescriptor, tZ = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? vY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && gY(t, e, s), s;
}, "__decorateClass$5");
const eZ = "wy-posts";
var r$, zf;
let wy = (r$ = (zf = class extends jt {
  constructor() {
    super(...arguments), this.componentType = Pt.Posts, this.componentFeatures = new $n({
      // All available features as enabled/disabled by default
      [_.Attachments]: !0,
      [_.CloudFiles]: !0,
      [_.Comments]: !0,
      [_.ContextData]: !0,
      [_.Embeds]: !0,
      [_.GoogleMeet]: !1,
      [_.Meetings]: !1,
      [_.Mentions]: !0,
      [_.MicrosoftTeams]: !1,
      [_.Polls]: !0,
      [_.Previews]: !0,
      [_.Reactions]: !0,
      [_.Typing]: !1,
      // Has no effect currently
      [_.ZoomMeetings]: !1
    }), this.theme = new Js(this, wy.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse>
        <wy-notification-button-list></wy-notification-button-list>
      </wy-buttons>

      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>

      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, h(zf, "Po"), zf), u(r$, "WyPosts"), r$);
wy.styles = [
  Xi,
  yt,
  pa,
  cl,
  tr,
  ya
];
tZ([
  $()
], wy.prototype, "placeholder", 2);
wy = tZ([
  H(eZ),
  Ot()
], wy);
var bY = Object.defineProperty, OY = Object.getOwnPropertyDescriptor, ob = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? OY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && bY(t, e, s), s;
}, "__decorateClass$4"), a$, _f;
let gy = (a$ = (_f = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.typing = new FL(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    var t;
    const { names: e, ellipsis: i } = this.typing;
    let s;
    if (e.length === 1) {
      const r = e[0];
      s = C(at`${r} is typing${i}`, { desc: "A is typing..." });
    } else if (e.length > 1) {
      const r = new Intl.ListFormat((t = this.weavy) == null ? void 0 : t.locale, { style: "long", type: "conjunction" }).format(
        e
      );
      s = C(at`${r} are typing${i}`, {
        desc: "A, B and C are typing..."
      });
    }
    return s ? v`<span>${s}</span>` : v`<slot></slot>`;
  }
}, h(_f, "So"), _f), u(a$, "WyTyping"), a$);
ob([
  ve({ context: _e, subscribe: !0 }),
  U()
], gy.prototype, "weavy", 2);
ob([
  $({ attribute: !0, type: Number })
], gy.prototype, "appId", 2);
ob([
  $({ attribute: !0, type: Number })
], gy.prototype, "userId", 2);
gy = ob([
  H("wy-typing"),
  Ot()
], gy);
const $Y = Mt`.wy-conversations{position:relative}.wy-conversation{display:flex;position:relative}.wy-conversation .wy-item-title{font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em))}.wy-conversation.wy-unread .wy-item-title{font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation.wy-unread .wy-item-text,.wy-conversation.wy-unread .wy-meta{color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation .wy-item-text .wy-typing-show{font-weight:var(--wy-font-weight, unset)}.wy-conversation .wy-item-text .wy-typing-show{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`, xY = Mt`.wy-pane{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}.wy-pane-body{display:flex;flex-direction:column;flex:1}.wy-pane-group{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-pane-background{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-pane-toolbar{display:flex;flex:1;justify-content:space-evenly;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`;
var kY = Object.defineProperty, SY = Object.getOwnPropertyDescriptor, iZ = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError$1"), zi = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? SY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && kY(t, e, s), s;
}, "__decorateClass$3"), nZ = /* @__PURE__ */ u((n, t, e) => t.has(n) || iZ("Cannot " + e), "__accessCheck$1"), N3 = /* @__PURE__ */ u((n, t, e) => (nZ(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$1"), PY = /* @__PURE__ */ u((n, t, e) => t.has(n) ? iZ("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$1"), H3 = /* @__PURE__ */ u((n, t, e, i) => (nZ(n, t, "write to private field"), t.set(n, e), e), "__privateSet$1"), Mc, o$, Lf;
let ei = (o$ = (Lf = class extends ft {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = Pt.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (we(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        var i;
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== ((i = this.user) == null ? void 0 : i.id);
      }), $t(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          var i;
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== ((i = this.user) == null ? void 0 : i.id);
        }
      ));
    }, this.handleConversationUpdated = () => {
      var t;
      (t = this.weavy) == null || t.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      var e;
      this.user && t.actor.id === this.user.id && ((e = this.weavy) == null || e.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 }));
    }, PY(this, Mc);
  }
  dispatchSelected(t) {
    if (t.preventDefault(), !this.conversationId)
      return;
    const e = new CustomEvent("selected", { detail: { id: this.conversationId } });
    return this.dispatchEvent(e);
  }
  handleStar(t, e) {
    if (!this.conversationId)
      return;
    const i = new CustomEvent("star", {
      detail: { id: this.conversationId, star: e }
    });
    return this.dispatchEvent(i);
  }
  handlePin(t, e) {
    if (!this.conversationId)
      return;
    const i = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: e }
    });
    return this.dispatchEvent(i);
  }
  dispatchMarked(t) {
    var e;
    if (!this.conversationId)
      return;
    const i = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? (e = this.lastMessage) == null ? void 0 : e.id : null }
    });
    return this.dispatchEvent(i);
  }
  handleLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  handleRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  handleTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = N3(this, Mc)) == null || e.call(this);
      const i = `a${this.conversationId}`;
      this.weavy.subscribe(i, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(i, "member_added", this.handleConversationUpdated), this.weavy.subscribe(i, "message_created", this.handleMessageCreated), this.weavy.subscribe(i, "app_marked", this.handleConversationMarked), H3(this, Mc, () => {
        var s, r, a, o;
        (s = this.weavy) == null || s.unsubscribe(i, "app_updated", this.handleConversationUpdated), (r = this.weavy) == null || r.unsubscribe(i, "member_added", this.handleConversationUpdated), (a = this.weavy) == null || a.unsubscribe(i, "message_created", this.handleMessageCreated), (o = this.weavy) == null || o.unsubscribe(i, "app_marked", this.handleConversationMarked), H3(this, Mc, void 0);
      });
    }
  }
  render() {
    var t, e, i, s, r, a, o, l, c, d, p, f, m, w, b, x, O;
    const P = (t = this.lastMessage) != null && t.created_at ? new Intl.DateTimeFormat((e = this.weavy) == null ? void 0 : e.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", A = (i = this.lastMessage) != null && i.created_at ? Ay((s = this.weavy) == null ? void 0 : s.locale, new Date(this.lastMessage.created_at)) : "", R = this.type === Pt.PrivateChat && this.user ? ((a = (((r = this.members) == null ? void 0 : r.data) || []).filter((T) => {
      var I;
      return T.id !== ((I = this.user) == null ? void 0 : I.id);
    })) == null ? void 0 : a[0]) ?? this.user : null;
    return v`
      <div
        class=${Xt({
      "wy-item wy-list-item-lg wy-item-hover wy-conversation": !0,
      "wy-unread": this.unread,
      "wy-active": this.selected
    })}
        tabindex="0"
        @click=${(T) => this.dispatchSelected(T)}
        @keydown=${je}
        @keyup=${gi}
      >
        ${this.type !== Pt.AgentChat ? this.avatarUrl ? v`<wy-avatar .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == Pt.ChatRoom ? v` <wy-avatar-group .members=${(o = this.members) == null ? void 0 : o.data} title=${this.name} .size=${48}></wy-avatar-group>` : v`
                <wy-avatar
                  src=${Ct(R == null ? void 0 : R.avatar_url)}
                  name=${Ct(R == null ? void 0 : R.name)}
                  description=${Ct(R == null ? void 0 : R.comment)}
                  presence=${(R == null ? void 0 : R.presence) || "away"}
                  ?isAgent=${R == null ? void 0 : R.is_agent}
                  id=${Ct(R == null ? void 0 : R.id)}
                  size=${48}
                ></wy-avatar>
              ` : Q}

        <div class="wy-item-rows">
          <div class="wy-item-row">
            <div class="wy-item-title">${this.name || ((l = this.lastMessage) == null ? void 0 : l.plain) || C("Untitled conversation")}</div>
            ${this.lastMessage ? v`<time class="wy-meta" datetime=${this.lastMessage.created_at.toString()} title=${P}
                  >${A}</time
                >` : Q}
          </div>
          <div class="wy-item-row">
            <div class="wy-item-text">
              ${this.user ? v`
                    <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                      ${this.lastMessage ? v`
                            ${this.user.id === this.lastMessage.created_by.id ? v`${C("You")}: ` : Q}
                            ${this.members.count > 2 && this.user.id !== ((c = this.lastMessage) == null ? void 0 : c.created_by.id) ? v`${(d = this.lastMessage) == null ? void 0 : d.created_by.name}: ` : Q}
                          ` : Q}
                      ${(p = this.lastMessage) != null && p.text ? v`<span>${this.lastMessage.plain}</span>` : Q}
                      ${!((f = this.lastMessage) != null && f.text) && (((w = (m = this.lastMessage) == null ? void 0 : m.attachments) == null ? void 0 : w.count) || 0) > 0 ? v`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : Q}
                      ${!((b = this.lastMessage) != null && b.text) && (O = (x = this.lastMessage) == null ? void 0 : x.meeting) != null && O.id ? v`<wy-icon kind="text-icon" name="video"></wy-icon>` : Q}
                      ${this.lastMessage ? Q : v`&nbsp;`}
                    </wy-typing>
                  ` : Q}
            </div>

            <div class="wy-item-actions wy-item-actions-bottom">
              ${this.starred ? v`<wy-button
                    kind="icon"
                    @click=${(T) => {
      T.stopPropagation(), this.handleStar(T, !1);
    }}
                  >
                    <wy-icon name="star" size=${24} color="yellow"></wy-icon>
                  </wy-button>` : Q}
              ${this.pinned ? v`<wy-button
                    kind="icon"
                    @click=${(T) => {
      T.stopPropagation(), this.handlePin(T, !1);
    }}
                  >
                    <wy-icon name="pin" size=${24} color=""></wy-icon>
                  </wy-button>` : Q}

              <wy-dropdown directionX="left">
                <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
                  <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
                  ${this.unread ? C("Mark as read") : C("Mark as unread")}
                </wy-dropdown-item>
                <wy-dropdown-item @click=${(T) => this.handlePin(T, !this.pinned)}>
                  <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
                  ${this.pinned ? C("Unpin") : C("Pin")}
                </wy-dropdown-item>
                <wy-dropdown-item @click=${(T) => this.handleStar(T, !this.starred)}>
                  <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
                  ${this.starred ? C("Unstar") : C("Star")}
                </wy-dropdown-item>
                ${this.type === Pt.PrivateChat ? v`<wy-dropdown-item @click=${() => this.handleRemoveConversation()}>
                      <wy-icon name="trashcan"></wy-icon>
                      ${C("Delete")}
                    </wy-dropdown-item>` : Q}
                ${this.type === Pt.ChatRoom ? v`<wy-dropdown-item @click=${() => this.handleLeaveConversation()}>
                      <wy-icon name="account-minus"></wy-icon>
                      ${C("Leave")}
                    </wy-dropdown-item>` : Q}
                ${this.type === Pt.AgentChat ? v`
                      <wy-dropdown-item @click=${() => this.handleTrashConversation()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${C("Delete")}
                      </wy-dropdown-item>
                    ` : Q}
              </wy-dropdown>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = N3(this, Mc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Lf, "Ao"), Lf), u(o$, "WyConversationListItem"), o$);
Mc = /* @__PURE__ */ new WeakMap();
ei.styles = yt;
zi([
  ve({ context: _e, subscribe: !0 }),
  U()
], ei.prototype, "weavy", 2);
zi([
  $({ attribute: !0, type: Number })
], ei.prototype, "conversationId", 2);
zi([
  $({ attribute: !0, type: Boolean })
], ei.prototype, "unread", 2);
zi([
  $({ attribute: !0 })
], ei.prototype, "avatarUrl", 2);
zi([
  $({ attribute: !0, type: Boolean })
], ei.prototype, "hideAvatar", 2);
zi([
  $({ attribute: !0 })
], ei.prototype, "name", 2);
zi([
  $({ attribute: !0, type: String, reflect: !0 })
], ei.prototype, "type", 2);
zi([
  $({ attribute: !0, type: Boolean, reflect: !0 })
], ei.prototype, "selected", 2);
zi([
  $({ attribute: !0, type: Boolean, reflect: !0 })
], ei.prototype, "starred", 2);
zi([
  $({ attribute: !0, type: Boolean, reflect: !0 })
], ei.prototype, "pinned", 2);
zi([
  $({ attribute: !1 })
], ei.prototype, "members", 2);
zi([
  $({ attribute: !1 })
], ei.prototype, "lastMessage", 2);
zi([
  ve({ context: Z0, subscribe: !0 }),
  U()
], ei.prototype, "user", 2);
ei = zi([
  H("wy-conversation-list-item"),
  Ot()
], ei);
var CY = Object.defineProperty, QY = Object.getOwnPropertyDescriptor, lb = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? QY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && CY(t, e, s), s;
}, "__decorateClass$2"), l$, If;
let nl = (l$ = (If = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.show = !1;
  }
  async create(t) {
    this.agent && await this.submit(), t ? await this.submit(t) : this.open();
  }
  open() {
    this.show = !0;
  }
  close() {
    this.show = !1;
  }
  async submit(t = []) {
    var e;
    const i = this.agent ? { members: [this.agent], type: vn.AgentChat } : { members: t, type: t.length === 1 ? vn.PrivateChat : vn.ChatRoom };
    this.close();
    const s = await ((e = this.addConversationMutation) == null ? void 0 : e.mutate(i)), r = new CustomEvent("selected", { detail: { id: s == null ? void 0 : s.id } });
    return this.dispatchEvent(r);
  }
  updated(t) {
    t.has("weavy") && this.weavy && (this.addConversationMutation = YS(this.weavy));
  }
  render() {
    return v`
      ${this.slotElements.length ? Q : v`
        <wy-button part="wy-conversation-new-button" kind="icon" @click=${() => this.create()}>
          <wy-icon name="plus"></wy-icon>
        </wy-button>
      `}
      <slot></slot>

      ${!this.agent && this.weavy ? v`<wy-overlay
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
            @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
          >
            <header class="wy-appbars">
              <nav class="wy-appbar">
                <wy-button kind="icon" @click=${() => this.close()}>
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div class="wy-appbar-text">${C("New conversation")}</div>
              </nav>
            </header>
            ${this.show ? v` <wy-users-search @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}></wy-users-search> ` : Q}
          </wy-overlay>` : Q}
    `;
  }
}, h(If, "Eo"), If), u(l$, "WyConversationNew"), l$);
nl.styles = [yt, At];
lb([
  $()
], nl.prototype, "agent", 2);
lb([
  U()
], nl.prototype, "show", 2);
lb([
  iP({ flatten: !0 })
], nl.prototype, "slotElements", 2);
nl = lb([
  H("wy-conversation-new"),
  Ot()
], nl);
var MY = Object.defineProperty, TY = Object.getOwnPropertyDescriptor, sZ = /* @__PURE__ */ u((n) => {
  throw TypeError(n);
}, "__typeError"), $g = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? TY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && MY(t, e, s), s;
}, "__decorateClass$1"), rZ = /* @__PURE__ */ u((n, t, e) => t.has(n) || sZ("Cannot " + e), "__accessCheck"), Y3 = /* @__PURE__ */ u((n, t, e) => (rZ(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet"), AY = /* @__PURE__ */ u((n, t, e) => t.has(n) ? sZ("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd"), G3 = /* @__PURE__ */ u((n, t, e, i) => (rZ(n, t, "write to private field"), t.set(n, e), e), "__privateSet"), Tc, c$, Zf;
let da = (c$ = (Zf = class extends Lt {
  constructor() {
    super(...arguments), this.exportParts = new nt(this), this.conversationTypes = [Pt.ChatRoom, Pt.PrivateChat], this.searchText = "", this.conversationsQuery = new hl(this), this.infiniteScroll = new dl(this), this.pagerRef = wt(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ u((i) => {
        const s = i.members.data ?? [];
        s.forEach((r) => {
          r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
        }), i.members.data = s;
      }, "updateMembersInApps");
      $t(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, AY(this, Tc);
  }
  dispatchSelected(t) {
    this.conversationId = t;
    const e = new CustomEvent("selected", { detail: { id: t } });
    return this.dispatchEvent(e);
  }
  async handleMark(t, e) {
    var i, s;
    await ((s = this.markConversationMutation) == null ? void 0 : s.mutate({ appId: t, messageId: e, userId: (i = this.user) == null ? void 0 : i.id }));
  }
  async handleStar(t, e) {
    var i;
    await ((i = this.starConversationMutation) == null ? void 0 : i.mutate({ appId: t, star: e }));
  }
  async handlePin(t, e) {
    var i;
    await ((i = this.pinConversationMutation) == null ? void 0 : i.mutate({ appId: t, pin: e }));
  }
  async handleLeaveConversation(t) {
    var e;
    this.conversationId === t && this.dispatchSelected(void 0);
    const i = await this.whenUser();
    await ((e = this.leaveConversationMutation) == null ? void 0 : e.mutate({ appId: t, members: [i.id] })), this.conversationsQuery.result.refetch();
  }
  async handleRemoveConversation(t) {
    var e;
    this.conversationId === t && this.dispatchSelected(void 0), await ((e = this.removeConversationMutation) == null ? void 0 : e.mutate({ appId: t })), this.conversationsQuery.result.refetch();
  }
  async handleTrashConversation(t) {
    var e;
    this.conversationId === t && this.dispatchSelected(void 0), await ((e = this.trashConversationMutation) == null ? void 0 : e.mutate({ appId: t })), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      uE(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = wP(this.weavy), this.starConversationMutation = o_(this.weavy), this.pinConversationMutation = l_(this.weavy), this.leaveConversationMutation = gP(this.weavy), this.removeConversationMutation = c_(this.weavy), this.trashConversationMutation = u_(this.weavy), (e = Y3(this, Tc)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), G3(this, Tc, () => {
      var i, s, r, a;
      (i = this.weavy) == null || i.unsubscribe(null, "app_created", this.handleRefresh), (s = this.weavy) == null || s.unsubscribe(null, "message_created", this.handleRefresh), (r = this.weavy) == null || r.unsubscribe(null, "member_added", this.handleRefresh), (a = this.weavy) == null || a.unsubscribe(null, "online", this.handlePresenceChange), G3(this, Tc, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    var e, i;
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await ((i = (e = this.conversationsQuery.result).refetch) == null ? void 0 : i.call(e));
  }
  renderConversations(t, e) {
    if (e) {
      const i = ds(e);
      return Mi(
        i,
        (s) => s == null ? void 0 : s.id,
        (s) => [
          v`<wy-conversation-list-item
              .conversationId=${s == null ? void 0 : s.id}
              .avatarUrl=${s == null ? void 0 : s.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${s.name}
              .lastMessage=${s.last_message}
              .members=${s.members}
              .unread=${s.is_unread}
              .starred=${s.is_starred}
              .pinned=${s.is_pinned}
              .type=${s.type}
              .selected=${this.conversationId == s.id}
              @selected=${(r) => this.dispatchSelected(r.detail.id)}
              @mark=${(r) => this.handleMark(r.detail.id, r.detail.messageId)}
              @star=${(r) => this.handleStar(r.detail.id, r.detail.star)}
              @pin=${(r) => this.handlePin(r.detail.id, r.detail.pin)}
              @leave=${(r) => this.handleLeaveConversation(r.detail.id)}
              @remove=${(r) => this.handleRemoveConversation(r.detail.id)}
              @trash=${(r) => this.handleTrashConversation(r.detail.id)}
            ></wy-conversation-list-item>`
        ]
      );
    }
    return Q;
  }
  render() {
    var t;
    const { data: e, isPending: i, hasNextPage: s } = this.conversationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <wy-buttons position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
              ${this.agent ? Q : v`
                    <wy-search
                      compact
                      placeholder=${C("Search for conversations...")}
                      @search=${(r) => this.searchText = r.detail.query}
                    ></wy-search>
                  `}
              <slot name="actions"></slot>
            </wy-buttons>

            <div class="wy-conversations">
              ${!i && this.user && e ? (t = e.pages[0]) != null && t.count || this.searchText ? this.renderConversations(this.user, e) : v`
                      <div class="wy-pane-body">
                        <div class="wy-pane-group">
                          <wy-empty noNetwork>${C("Create a conversation to get started.")}</wy-empty>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-spinner padded></wy-spinner></wy-empty>`}
              ${s ? v`<div ${lt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            </div>
          ` : v`<wy-empty class="wy-pane"><wy-spinner overlay></wy-spinner></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Y3(this, Tc)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Zf, "Ro"), Zf), u(c$, "WeavyConversationList"), c$);
Tc = /* @__PURE__ */ new WeakMap();
da.styles = [
  $Y,
  xY,
  pa,
  cl,
  ya
];
$g([
  $({ type: Number })
], da.prototype, "conversationId", 2);
$g([
  $({ type: Array })
], da.prototype, "conversationTypes", 2);
$g([
  $()
], da.prototype, "agent", 2);
$g([
  U()
], da.prototype, "searchText", 2);
da = $g([
  H("wy-conversation-list"),
  Ot()
], da);
var RY = Object.getOwnPropertyDescriptor, EY = /* @__PURE__ */ u((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? RY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass"), h$, Wf;
let Lk = (h$ = (Wf = class extends qt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  renderMiddleSlot() {
    var t, e, i, s, r, a, o;
    return v` <div class="wy-message-editor-inputs">
      <!-- Add -->
      ${(t = this.componentFeatures) != null && t.allowsAnyFeature(
      _.Attachments,
      _.CloudFiles,
      _.Polls,
      _.Meetings,
      _.ZoomMeetings,
      _.GoogleMeet,
      _.MicrosoftTeams
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${(e = this.componentFeatures) != null && e.allowsFeature(_.Attachments) ? v`
                  <wy-dropdown-item @click=${this.openFileInput} title=${C("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${C("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${lt(this.fileInputRef)}
                    @click=${(l) => l.stopPropagation()}
                    @change=${(l) => this.handleUploadFiles(
      Array.from(l.target.files || []),
      l.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : Q}
            ${(i = this.componentFeatures) != null && i.allowsFeature(_.CloudFiles) ? v`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${C("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${C("From cloud")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(s = this.componentFeatures) != null && s.allowsFeature(_.Polls) ? v`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${C("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${C("Poll")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(r = this.componentFeatures) != null && r.allowsAnyFeature(_.Meetings, _.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${C("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${C("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(a = this.componentFeatures) != null && a.allowsAnyFeature(_.Meetings, _.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${C("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${C("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${(o = this.componentFeatures) != null && o.allowsAnyFeature(_.Meetings, _.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${C("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${C("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : Q}
          </wy-dropdown>` : Q}

      <!-- Input -->
      <div class="wy-message-editor-text" ${lt(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${C("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  renderBottomSlot() {
    return Q;
  }
}, h(Wf, "Oo"), Wf), u(h$, "WyMessageEditor"), h$);
Lk = EY([
  H("wy-message-editor"),
  Ot()
], Lk);
const ot = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAttachment() {
    return js;
  },
  get WyAttachmentsList() {
    return Iw;
  },
  get WyAvatar() {
    return rs;
  },
  get WyAvatarGroup() {
    return Xo;
  },
  get WyBlobUpload() {
    return yy;
  },
  get WyButton() {
    return os;
  },
  get WyButtons() {
    return No;
  },
  get WyCloudFiles() {
    return il;
  },
  get WyComment() {
    return de;
  },
  get WyCommentEdit() {
    return hn;
  },
  get WyCommentEditor() {
    return Rk;
  },
  get WyCommentList() {
    return tl;
  },
  get WyCommentTrashed() {
    return Fw;
  },
  get WyCommentView() {
    return Me;
  },
  get WyConversation() {
    return Ai;
  },
  get WyConversationAppbar() {
    return cs;
  },
  get WyConversationList() {
    return da;
  },
  get WyConversationListItem() {
    return ei;
  },
  get WyConversationNew() {
    return nl;
  },
  get WyDropdown() {
    return Ti;
  },
  get WyDropdownDivider() {
    return t0;
  },
  get WyDropdownItem() {
    return jw;
  },
  get WyDropdownOption() {
    return cy;
  },
  get WyEditor() {
    return qt;
  },
  get WyEmbed() {
    return sy;
  },
  get WyEmpty() {
    return ny;
  },
  get WyFileItem() {
    return Bs;
  },
  get WyFileMenu() {
    return aa;
  },
  get WyFileVersions() {
    return dy;
  },
  get WyFilesAppbar() {
    return oa;
  },
  get WyFilesList() {
    return Mn;
  },
  get WyIcon() {
    return ae;
  },
  get WyImageGrid() {
    return ry;
  },
  get WyMeetingCard() {
    return qw;
  },
  get WyMessage() {
    return oe;
  },
  get WyMessageEditor() {
    return Lk;
  },
  get WyMessageTyping() {
    return Ui;
  },
  get WyMessages() {
    return dn;
  },
  get WyMessengerBadge() {
    return ca;
  },
  get WyNotificationBadge() {
    return Xw;
  },
  get WyNotificationButtonList() {
    return i0;
  },
  get WyNotificationList() {
    return my;
  },
  get WyNotificationListItem() {
    return ha;
  },
  get WyOverlay() {
    return sa;
  },
  get WyPdfViewer() {
    return Ko;
  },
  get WyPoll() {
    return Uw;
  },
  get WyPollOption() {
    return Jo;
  },
  get WyPost() {
    return ue;
  },
  get WyPostEdit() {
    return Ue;
  },
  get WyPostTrashed() {
    return Yw;
  },
  get WyPostView() {
    return se;
  },
  get WyPresence() {
    return iy;
  },
  get WyPreview() {
    return Te;
  },
  get WyPreviewEmbed() {
    return ra;
  },
  get WyPreviewIcon() {
    return Yo;
  },
  get WyPreviewImage() {
    return Go;
  },
  get WyPreviewItem() {
    return hy;
  },
  get WyPreviewMedia() {
    return Us;
  },
  get WyPreviewText() {
    return ls;
  },
  get WyProgressLinear() {
    return cn;
  },
  get WyReactionItem() {
    return Dw;
  },
  get WyReactions() {
    return ge;
  },
  get WySheet() {
    return ly;
  },
  get WySkeleton() {
    return Vw;
  },
  get WySpinner() {
    return as;
  },
  get WyToast() {
    return Ns;
  },
  get WyToasts() {
    return Hw;
  },
  get WyTyping() {
    return gy;
  },
  get WyUsersSearch() {
    return Tn;
  }
}, Symbol.toStringTag, { value: "Module" }));
Ce.version = "1.0.0";
Ce.sourceName = "@weavy/uikit-react";
const zY = OZ(null);
function tK(n, t = []) {
  var o, l, c, d, p;
  const [e, i] = EC(), s = {
    ...n,
    cloudFilePickerUrl: (o = n.cloudFilePickerUrl) == null ? void 0 : o.toString(),
    locales: zC(() => n.locales, [(l = n.locales) == null ? void 0 : l.length]),
    tokenUrl: (c = n.tokenUrl) == null ? void 0 : c.toString(),
    tokenFactory: zC(
      () => n.tokenFactory,
      [(d = n.tokenFactory) == null ? void 0 : d.toString(), ...t]
    ),
    url: (p = n.url) == null ? void 0 : p.toString()
  }, [r, a] = EC(s);
  return d$(() => {
    if (!e) {
      const m = (Di == null ? void 0 : Di.value) ?? new ke(s);
      i(m);
    }
  }, []), d$(() => {
    if (e && !e.isDestroyed) {
      const f = {};
      Object.entries(s).forEach(([m, w]) => {
        w !== r[m] && Object.assign(f, { [m]: w });
      }), Object.keys(f).length && (a(s), Object.assign(e, f));
    }
  }, [s]), e;
}
h(tK, "useWeavy");
const aZ = Promise.resolve(), rC = class rC {
  constructor(t, e) {
    this.o = [], this.t = !0, this.i = !1, this.l = t, this.h = e, this.u = new Promise((i, s) => {
      this.p = i;
    });
  }
  addController(t) {
    this.o.push(t);
  }
  removeController(t) {
    var e;
    (e = this.o) == null || e.splice(this.o.indexOf(t) >>> 0, 1);
  }
  requestUpdate() {
    this.t || (this.t = !0, aZ.then(() => this.h(++this.l)));
  }
  get updateComplete() {
    return this.u;
  }
  m() {
    this.i = !0, this.o.forEach((t) => {
      var e;
      return (e = t.hostConnected) == null ? void 0 : e.call(t);
    });
  }
  _() {
    this.i = !1, this.o.forEach((t) => {
      var e;
      return (e = t.hostDisconnected) == null ? void 0 : e.call(t);
    });
  }
  v() {
    this.o.forEach((t) => {
      var e;
      return (e = t.hostUpdate) == null ? void 0 : e.call(t);
    });
  }
  C() {
    this.t = !1;
    const t = this.p;
    this.u = new Promise((e, i) => {
      this.p = e;
    }), this.o.forEach((e) => {
      var i;
      return (i = e.hostUpdated) == null ? void 0 : i.call(e);
    }), t(this.t);
  }
};
h(rC, "s");
let Ik = rC;
const _Y = /* @__PURE__ */ h((n, t) => {
  const { useState: e, useLayoutEffect: i } = n, [s, r] = e(0);
  let a = !1;
  const [o] = e(() => {
    const l = new Ik(s, r), c = t(l);
    return l.M = c, l.m(), a = !0, aZ.then(() => {
      a && l._();
    }), l;
  });
  return o.t = !0, i(() => (a = !1, o.i || o.m(), () => o._()), []), i(() => o.C()), o.v(), o.M;
}, "e$1");
function LY(n, t) {
  var r;
  const i = ((/* @__PURE__ */ h((a) => !!a && a.current !== void 0, "isRef"))(n) ? n.current : n) || void 0, s = _Y(
    J,
    (a) => new oU(a, t ?? _e, i)
  );
  return d$(() => {
    i && (s.ref = i);
  }, [s, i]), (r = s.context) == null ? void 0 : r.value;
}
h(LY, "useWeavyContext");
var IY = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.agents = "agents", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(IY || {});
const ZY = /* @__PURE__ */ new Set(["children", "localName", "ref", "style", "className"]), K3 = /* @__PURE__ */ new WeakMap(), J3 = /* @__PURE__ */ h((n, t, e, i, s) => {
  const r = s == null ? void 0 : s[t];
  r === void 0 ? (n[t] = e, e == null && t in HTMLElement.prototype && n.removeAttribute(t)) : e !== i && ((a, o, l) => {
    let c = K3.get(a);
    c === void 0 && K3.set(a, c = /* @__PURE__ */ new Map());
    let d = c.get(o);
    l !== void 0 ? d === void 0 ? (c.set(o, d = { handleEvent: l }), a.addEventListener(o, d)) : d.handleEvent = l : d !== void 0 && (c.delete(o), a.removeEventListener(o, d));
  })(n, r, e);
}, "t"), et = /* @__PURE__ */ h(({ react: n, tagName: t, elementClass: e, events: i, displayName: s }) => {
  const r = new Set(Object.keys(i ?? {})), a = n.forwardRef((o, l) => {
    const c = n.useRef(/* @__PURE__ */ new Map()), d = n.useRef(null), p = {}, f = {};
    for (const [m, w] of Object.entries(o)) ZY.has(m) ? p[m === "className" ? "class" : m] = w : r.has(m) || m in e.prototype ? f[m] = w : p[m] = w;
    return n.useLayoutEffect(() => {
      if (d.current === null) return;
      const m = /* @__PURE__ */ new Map();
      for (const w in f) J3(d.current, w, o[w], c.current.get(w), i), c.current.delete(w), m.set(w, o[w]);
      for (const [w, b] of c.current) J3(d.current, w, void 0, b, i);
      c.current = m;
    }), n.useLayoutEffect(() => {
      var m;
      (m = d.current) == null || m.removeAttribute("defer-hydration");
    }, []), p.suppressHydrationWarning = !0, n.createElement(t, { ...p, ref: n.useCallback((m) => {
      d.current = m, typeof l == "function" ? l(m) : l !== null && (l.current = m);
    }, [l]) });
  });
  return a.displayName = s ?? e.name, a;
}, "o"), eK = et({
  react: J,
  tagName: aI,
  elementClass: uy,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), iK = et({
  react: J,
  tagName: lI,
  elementClass: py,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), nK = et({
  react: J,
  tagName: Rz,
  elementClass: Uo,
  events: {
    onWyApp: "wy-app"
  }
}), WY = et({
  react: J,
  tagName: Tz,
  elementClass: he,
  events: {
    onWyNotifications: "wy-notifications"
  }
});
function sK({
  children: n,
  ...t
}) {
  const e = $Z(null), i = LY(e.current);
  return /* @__PURE__ */ J.createElement(WY, { ref: e, ...t }, /* @__PURE__ */ J.createElement(zY.Provider, { value: i ?? null }, n));
}
h(sK, "WyContext");
const rK = et({
  react: J,
  tagName: hI,
  elementClass: el,
  events: {
    onWyApp: "wy-app",
    onWyMessage: "wy-message",
    onWyPreviewOpen: "wy-preview-open"
  }
}), aK = et({
  react: J,
  tagName: MI,
  elementClass: la,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), oK = et({
  react: J,
  tagName: zI,
  elementClass: Xs,
  events: {
    onWyPreviewOpen: "wy-preview-open"
  }
}), lK = et({
  react: J,
  tagName: II,
  elementClass: Nw,
  events: {
    onWyApp: "wy-app",
    onWyLink: "wy-link"
  }
}), cK = et({
  react: J,
  tagName: DI,
  elementClass: hs,
  events: {
    onWyApp: "wy-app",
    onWyLink: "wy-link",
    onWyNotification: "wy-notification"
  }
}), hK = et({
  react: J,
  tagName: eZ,
  elementClass: wy,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), DY = et({
  react: J,
  tagName: "wy-attachment",
  elementClass: ot.WyAttachment
}), qY = et({
  react: J,
  tagName: "wy-attachments-list",
  elementClass: ot.WyAttachmentsList,
  events: {
    onFileOpen: "file-open"
  }
}), VY = et({
  react: J,
  tagName: "wy-avatar",
  elementClass: ot.WyAvatar
}), jY = et({
  react: J,
  tagName: "wy-blob-upload",
  elementClass: ot.WyBlobUpload
}), FY = et({
  react: J,
  tagName: "wy-button",
  elementClass: ot.WyButton
}), UY = et({
  react: J,
  tagName: "wy-buttons",
  elementClass: ot.WyButtons
}), BY = et({
  react: J,
  tagName: "wy-cloud-files",
  elementClass: ot.WyCloudFiles,
  events: {
    onExternalBlobs: "external-blobs",
    onReleaseFocus: "release-focus"
  }
}), XY = et({
  react: J,
  tagName: "wy-comment-list",
  elementClass: ot.WyCommentList
}), NY = et({
  react: J,
  tagName: "wy-comment",
  elementClass: ot.WyComment,
  events: {
    onVote: "vote",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore"
  }
}), HY = et({
  react: J,
  tagName: "wy-comment-view",
  elementClass: ot.WyCommentView,
  events: {
    onVote: "vote",
    onTrash: "trash",
    onEdit: "edit"
  }
}), YY = et({
  react: J,
  tagName: "wy-comment-edit",
  elementClass: ot.WyCommentEdit,
  events: {
    onEdit: "edit"
  }
}), GY = et({
  react: J,
  tagName: "wy-comment-editor",
  elementClass: ot.WyCommentEditor,
  events: {
    onSubmit: "submit"
  }
}), KY = et({
  react: J,
  tagName: "wy-comment-trashed",
  elementClass: ot.WyCommentTrashed,
  events: {
    onRestore: "restore"
  }
}), JY = et({
  react: J,
  tagName: "wy-conversation",
  elementClass: ot.WyConversation,
  events: {
    onReleaseFocus: "release-focus"
  }
}), tG = et({
  react: J,
  tagName: "wy-conversation-appbar",
  elementClass: ot.WyConversationAppbar,
  events: {
    onReleaseFocus: "release-focus"
  }
}), eG = et({
  react: J,
  tagName: "wy-conversation-new",
  elementClass: ot.WyConversationNew,
  events: {
    onReleaseFocus: "release-focus"
  }
}), iG = et({
  react: J,
  tagName: "wy-conversation-list",
  elementClass: ot.WyConversationList,
  events: {
    onConversationSelected: "conversation-selected"
  }
}), nG = et({
  react: J,
  tagName: "wy-conversation-list-item",
  elementClass: ot.WyConversationListItem,
  events: {
    onRefetch: "refetch",
    onSelected: "selected",
    onStar: "star",
    onPin: "pin",
    onMark: "mark",
    onLeave: "leave"
  }
}), sG = et({
  react: J,
  tagName: "wy-dropdown",
  elementClass: ot.WyDropdown
}), rG = et({
  react: J,
  tagName: "wy-dropdown-item",
  elementClass: ot.WyDropdownItem
}), aG = et({
  react: J,
  tagName: "wy-dropdown-option",
  elementClass: ot.WyDropdownOption
}), oG = et({
  react: J,
  tagName: "wy-dropdown-divider",
  elementClass: ot.WyDropdownDivider
}), lG = et({
  react: J,
  tagName: "wy-editor",
  elementClass: ot.WyEditor,
  events: {
    onSubmit: "submit"
  }
}), cG = et({
  react: J,
  tagName: "wy-embed",
  elementClass: ot.WyEmbed,
  events: {
    onEmbedRemove: "embed-remove",
    onEmbedSwap: "embed-swap"
  }
}), hG = et({
  react: J,
  tagName: "wy-empty",
  elementClass: ot.WyEmpty
}), dG = et({
  react: J,
  tagName: "wy-file-item",
  elementClass: ot.WyFileItem,
  events: {
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), uG = et({
  react: J,
  tagName: "wy-file-menu",
  elementClass: ot.WyFileMenu,
  events: {
    onEditName: "edit-name",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), pG = et({
  react: J,
  tagName: "wy-file-versions",
  elementClass: ot.WyFileVersions,
  events: {
    onFileVersionSelect: "file-version-select"
  }
}), fG = et({
  react: J,
  tagName: "wy-files-appbar",
  elementClass: ot.WyFilesAppbar,
  events: {
    onReleaseFocus: "release-focus",
    onUploadFiles: "upload-files",
    onExternalBlobs: "external-blobs",
    onCreateFiles: "create-files",
    onOrder: "order",
    onView: "view",
    onShowTrashed: "show-trashed",
    onSubscribe: "subscribe"
  }
}), yG = et({
  react: J,
  tagName: "wy-files-list",
  elementClass: ot.WyFilesList,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), mG = et({
  react: J,
  tagName: "wy-icon",
  elementClass: ot.WyIcon
}), wG = et({
  react: J,
  tagName: "wy-image-grid",
  elementClass: ot.WyImageGrid,
  events: {
    onFileOpen: "file-open"
  }
}), gG = et({
  react: J,
  tagName: "wy-meeting-card",
  elementClass: ot.WyMeetingCard
}), vG = et({
  react: J,
  tagName: "wy-message",
  elementClass: ot.WyMessage
}), bG = et({
  react: J,
  tagName: "wy-messages",
  elementClass: ot.WyMessages,
  events: {
    onScrollToBottom: "scroll-to-bottom"
  }
}), OG = et({
  react: J,
  tagName: "wy-message-editor",
  elementClass: ot.WyMessageEditor,
  events: {
    onSubmit: "submit"
  }
}), $G = et({
  react: J,
  tagName: "wy-message-typing",
  elementClass: ot.WyMessageTyping
}), xG = et({
  react: J,
  tagName: "wy-messenger-badge",
  elementClass: ot.WyMessengerBadge
}), kG = et({
  react: J,
  tagName: "wy-notification-badge",
  elementClass: ot.WyNotificationBadge
}), SG = et({
  react: J,
  tagName: "wy-notification-button-list",
  elementClass: ot.WyNotificationButtonList
}), PG = et({
  react: J,
  tagName: "wy-notification-list",
  elementClass: ot.WyNotificationList
}), CG = et({
  react: J,
  tagName: "wy-notification-list-item",
  elementClass: ot.WyNotificationListItem
}), QG = et({
  react: J,
  tagName: "wy-overlay",
  elementClass: ot.WyOverlay,
  events: {
    onReleaseFocus: "release-focus",
    onClose: "close"
  }
}), MG = et({
  react: J,
  tagName: "wy-pdf-viewer",
  elementClass: ot.WyPdfViewer
}), TG = et({
  react: J,
  tagName: "wy-poll",
  elementClass: ot.WyPoll,
  events: {
    onReleaseFocus: "release-focus",
    onVote: "vote"
  }
}), AG = et({
  react: J,
  tagName: "wy-poll-option",
  elementClass: ot.WyPollOption,
  events: {
    onReleaseFocus: "release-focus",
    onVote: "vote"
  }
}), RG = et({
  react: J,
  tagName: "wy-post",
  elementClass: ot.WyPost,
  events: {
    onVote: "vote",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore"
  }
}), EG = et({
  react: J,
  tagName: "wy-post-view",
  elementClass: ot.WyPostView,
  events: {
    onVote: "vote",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onEdit: "edit"
  }
}), zG = et({
  react: J,
  tagName: "wy-post-edit",
  elementClass: ot.WyPostEdit,
  events: {
    onEdit: "edit"
  }
}), _G = et({
  react: J,
  tagName: "wy-post-trashed",
  elementClass: ot.WyPostTrashed,
  events: {
    onRestore: "restore"
  }
}), LG = et({
  react: J,
  tagName: "wy-presence",
  elementClass: ot.WyPresence
}), IG = et({
  react: J,
  tagName: "wy-preview",
  elementClass: ot.WyPreview,
  events: {
    onReleaseFocus: "release-focus",
    onWyPreviewOpen: "wy-preview-open",
    onWyPreviewClose: "wy-preview-close"
  }
}), ZG = et({
  react: J,
  tagName: "wy-preview-item",
  elementClass: ot.WyPreviewItem
}), WG = et({
  react: J,
  tagName: "wy-preview-embed",
  elementClass: ot.WyPreviewEmbed
}), DG = et({
  react: J,
  tagName: "wy-preview-icon",
  elementClass: ot.WyPreviewIcon
}), qG = et({
  react: J,
  tagName: "wy-preview-image",
  elementClass: ot.WyPreviewImage
}), VG = et({
  react: J,
  tagName: "wy-preview-media",
  elementClass: ot.WyPreviewMedia
}), jG = et({
  react: J,
  tagName: "wy-preview-text",
  elementClass: ot.WyPreviewText
}), FG = et({
  react: J,
  tagName: "wy-reactions",
  elementClass: ot.WyReactions,
  events: {
    onReleaseFocus: "release-focus"
  }
}), UG = et({
  react: J,
  tagName: "wy-reaction-item",
  elementClass: ot.WyReactionItem
}), BG = et({
  react: J,
  tagName: "wy-sheet",
  elementClass: ot.WySheet,
  events: {
    onReleaseFocus: "release-focus",
    onClose: "close"
  }
}), XG = et({
  react: J,
  tagName: "wy-skeleton",
  elementClass: ot.WySkeleton
}), NG = et({
  react: J,
  tagName: "wy-spinner",
  elementClass: ot.WySpinner
}), HG = et({
  react: J,
  tagName: "wy-typing",
  elementClass: ot.WyTyping
}), YG = et({
  react: J,
  tagName: "wy-users-search",
  elementClass: ot.WyUsersSearch,
  events: {
    onSubmit: "submit"
  }
}), dK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WyAttachment: DY,
  WyAttachmentsList: qY,
  WyAvatar: VY,
  WyBlobUpload: jY,
  WyButton: FY,
  WyButtons: UY,
  WyCloudFiles: BY,
  WyComment: NY,
  WyCommentEdit: YY,
  WyCommentEditor: GY,
  WyCommentList: XY,
  WyCommentTrashed: KY,
  WyCommentView: HY,
  WyConversation: JY,
  WyConversationAppbar: tG,
  WyConversationList: iG,
  WyConversationListItem: nG,
  WyConversationNew: eG,
  WyDropdown: sG,
  WyDropdownDivider: oG,
  WyDropdownItem: rG,
  WyDropdownOption: aG,
  WyEditor: lG,
  WyEmbed: cG,
  WyEmpty: hG,
  WyFileItem: dG,
  WyFileMenu: uG,
  WyFileVersions: pG,
  WyFilesAppbar: fG,
  WyFilesList: yG,
  WyIcon: mG,
  WyImageGrid: wG,
  WyMeetingCard: gG,
  WyMessage: vG,
  WyMessageEditor: OG,
  WyMessageTyping: $G,
  WyMessages: bG,
  WyMessengerBadge: xG,
  WyNotificationBadge: kG,
  WyNotificationButtonList: SG,
  WyNotificationList: PG,
  WyNotificationListitem: CG,
  WyOverlay: QG,
  WyPdfViewer: MG,
  WyPoll: TG,
  WyPollOption: AG,
  WyPost: RG,
  WyPostEdit: zG,
  WyPostTrashed: _G,
  WyPostView: EG,
  WyPresence: LG,
  WyPreview: IG,
  WyPreviewEmbed: WG,
  WyPreviewIcon: DG,
  WyPreviewImage: qG,
  WyPreviewItem: ZG,
  WyPreviewMedia: VG,
  WyPreviewText: jG,
  WyReactionItem: UG,
  WyReactions: FG,
  WySheet: BG,
  WySkeleton: XG,
  WySpinner: NG,
  WyTyping: HG,
  WyUsersSearch: YG
}, Symbol.toStringTag, { value: "Module" }));
export {
  Cz as AppTypeGuids,
  yU as AppTypeStrings,
  IY as Feature,
  JG as MessengerTypes,
  ke as Weavy,
  dK as WeavyComponents,
  zY as WeavyContext,
  eK as WyChat,
  iK as WyComments,
  nK as WyComponent,
  sK as WyContext,
  rK as WyCopilot,
  aK as WyFiles,
  oK as WyMessenger,
  cK as WyNotificationToasts,
  lK as WyNotifications,
  hK as WyPosts,
  tK as useWeavy,
  LY as useWeavyContext
};
